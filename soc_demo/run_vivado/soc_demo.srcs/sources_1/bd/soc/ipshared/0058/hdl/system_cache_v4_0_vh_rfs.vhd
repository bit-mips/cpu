-------------------------------------------------------------------------------
-- system_cache_pkg -  package
-------------------------------------------------------------------------------
--
-- (c) Copyright 2001-2017 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        system_cache_pkg.vhd
-- Version:         v1.00a
-- Description:     A package with type definition and help functions for
--                  different implementations of the MicroBlaze family
--
-------------------------------------------------------------------------------
-- Structure:   
--              system_cache_pkg.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
-- History:
--  rikardw         2011-05-30      -- First version
--  stefana         2012-12-14      -- Removed legacy families
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "*_clk"
--      reset signals:                          "rst", "*_rst", "reset"
--      generics:                               All uppercase, starting with: "C_"
--      constants:                              All uppercase, not starting with: "C_"
--      state machine next state:               "*_next_state"
--      state machine current state:            "*_curr_state"
--      pipelined signals:                      "*_d#"
--      counter signals:                        "*_cnt_*" , "*_counter_*", "*_count_*"
--      internal version of output port:        "*_i"
--      ports:                                  Names begin with uppercase
--      component instantiations:               "<ENTITY>_I#|<FUNC>" , "<ENTITY>_I"
--
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


package system_cache_pkg is

  -----------------------------------------------------------------------------
  -- Common Constants & Types
  -----------------------------------------------------------------------------
  
  -- FPGA architectures
  type TARGET_FAMILY_TYPE is (ARTIX7,
                              KINTEX7,
                              VIRTEX7,
                              ZYNQ,
                              VIRTEXU,
                              KINTEXU,
                              ZYNQUPLUS,
                              VIRTEXUPLUS,
                              KINTEXUPLUS,
                              SPARTAN7,
                              RTL
                             );
  
  -- FPGA resources.
  type TARGET_PROPERTY_TYPE is (LATCH_AS_LOGIC, DUAL_DFF, BRAM_WITH_BYTE_ENABLE, BRAM_XPM,
                                BRAM_36K, BRAM_16K_WE, DSP, DSP48_V4, DSP48_A, DSP48_E);
  
  -- Create a Boolean array type
  type boolean_array is array (natural range <>) of boolean;

  -- Create an integer array type
  type integer_array is array (natural range <>) of integer;

  
  -----------------------------------------------------------------------------
  -- Common Functions
  -----------------------------------------------------------------------------
  
  -- Log2 function returns the number of bits required to encode x choices
  function log2(x : natural) return integer;
  
  -- Convert to std_logic.
  function int_to_std(v : integer) return std_logic;
  function int_to_std(v, n : integer) return std_logic_vector;
  
  -- Convert boolean choice to std_logic
  function b2s (val : boolean) return std_logic;
  
  -- Convert std_logic choice to boolean
  function s2b (val : std_logic) return boolean;
  
  -- Convert boolean choice to integer
  function b2i (val : boolean) return integer;
  
  -- Convert integer choice to boolean
  function i2b (val : integer) return boolean;
  
  -- Convert integer choice to std_logic
  function i2s (val : integer) return std_logic;
  
  -- Convert std_logic choice to integer
  function s2i (val : std_logic) return integer;
  
  -- Convert to std_logic.
  function to_int(v : std_logic_vector) return integer;
  
  -- Handle vector.
  function fit_vec(v : std_logic_vector; w : integer) return std_logic_vector;
  
  -- Select integer/std_logic/std_logic_vector.
  function sel(s : boolean; x,y : integer) return integer;
  function sel(s : boolean; x,y : std_logic) return std_logic;
  function sel(s : boolean; x,y : std_logic_vector) return std_logic_vector;
  function max_of(x,y : integer) return integer;
  function min_of(x,y : integer) return integer;
  function is_on(x: integer) return integer;
  function is_off(x: integer) return integer;
  
  -- Logic functions.
  function reduce_or(x : std_logic_vector) return std_logic;
  function reduce_and(x : std_logic_vector) return std_logic;
  function reduce_xor(x : std_logic_vector) return std_logic;
  function reduce_or_except(x : std_logic_vector; y : integer) return std_logic;
  function reduce_and_except(x : std_logic_vector; y : integer) return std_logic;
  function reduce_xor_except(x : std_logic_vector; y : integer) return std_logic;
  
  function rev_vec(x : std_logic_vector) return std_logic_vector;
  
  -- Create a resolved boolean
  function resolve_boolean(values : in boolean_array ) return boolean;

  -- Resolved boolean type
  subtype rboolean is resolve_boolean boolean;

  -- Or two integer booleans
  function intbool_or(constant a : integer; constant b : integer ) return integer;

  -- Create a resolved integer
  function resolve_integer(values : in integer_array ) return integer;

  -- Resolved integer type
  subtype rinteger is resolve_integer integer;

  -- moved from microblaze.vhd for GTi
  function LowerCase_Char(char : character) return character;
  function LowerCase_String (s : string) return string;
  function Equal_String( str1, str2 : STRING ) RETURN BOOLEAN;
  function String_To_Family (S : string; Select_RTL : boolean) return TARGET_FAMILY_TYPE;

  -- Get the maximum number of inputs to a LUT.
  function Family_To_LUT_Size(Family : TARGET_FAMILY_TYPE) return integer;

  function Has_Target(Family : TARGET_FAMILY_TYPE; TARGET_PROP : TARGET_PROPERTY_TYPE) return boolean;
  
  function is_slv_coherent(c : integer) return integer;
  function is_slv_coherent(c : integer) return boolean;

  function is_mst_coherent(c : integer) return integer;
  function is_mst_coherent(c : integer) return boolean;

  function has_ex_mon(e : integer) return boolean;
  
  function get_block(x : std_logic_vector; constant va, nb : integer) return integer;
  
  function has_debug(e : boolean) return string;
  
  
  -----------------------------------------------------------------------------
  -- System Cache Specific Constants
  -----------------------------------------------------------------------------
  
  -- 0   - v2.00a
  -- 1   - v3.0
  -- 2   - v2.00b
  -- 3   - v3.1
  -- 4   - v4.0
  constant C_SYSTEM_CACHE_VERSION       : natural :=  4;
  
  -- ----------------------------------------
  -- Static System Cache Constants
  
  constant C_MAX_NUM_PORT_WIDTH         : natural :=   5;
  constant C_MAX_NUM_PORTS              : natural :=   2 ** C_MAX_NUM_PORT_WIDTH;
  constant C_MAX_OPTIMIZED_PORTS        : natural :=  16;
  constant C_MAX_GENERIC_PORTS          : natural :=  16;
  constant C_MAX_PORTS                  : natural :=   C_MAX_OPTIMIZED_PORTS + C_MAX_GENERIC_PORTS;
  constant C_MAX_CACHE_LINE_LENGTH      : natural :=  32;
  constant C_MAX_WAYS                   : natural :=   8;
  constant C_MAX_WAYS_BITS              : natural :=   3;
  constant C_MAX_DEBUG_WIDTH            : natural := 768;
  
  
  -- ----------------------------------------
  -- System Cache Range Constants
  
  subtype C_PORT_NUM_POS                is natural range C_MAX_NUM_PORT_WIDTH - 1 downto 0;
  subtype C_MAX_PORTS_POS               is natural range C_MAX_NUM_PORTS - 1 downto 0;
  subtype C_MAX_WAYS_POS                is natural range C_MAX_WAYS - 1 downto 0;
  subtype C_MAX_WAYS_NUM_POS            is natural range C_MAX_WAYS_BITS - 1 downto 0;
  subtype C_MAX_DEBUG_POS               is natural range C_MAX_DEBUG_WIDTH - 1 downto 0;
  
  
  -- ----------------------------------------
  -- System Cache Derived Types
  
  subtype PORT_NUM_TYPE                 is std_logic_vector(C_PORT_NUM_POS);
  subtype MAX_PORTS_TYPE                is std_logic_vector(C_MAX_PORTS_POS);
  subtype MAX_WAYS_TYPE                 is std_logic_vector(C_MAX_WAYS_POS);
  subtype MAX_WAYS_NUM_TYPE             is std_logic_vector(C_MAX_WAYS_NUM_POS);
  subtype MAX_DEBUG_TYPE                is std_logic_vector(C_MAX_DEBUG_POS);
  
  type MAX_DEBUG_VECTOR_TYPE            is array(natural range <>) of MAX_DEBUG_TYPE;
  
  
  -- ----------------------------------------
  -- Static AXI Constants
  
  constant C_MAX_ID_WIDTH               : natural :=  32;
  constant C_MAX_ADDR_WIDTH             : natural :=  64;
  constant C_MAX_ASID_WIDTH             : natural :=  16;
  constant C_MAX_WORD_ADDR_WIDTH        : natural :=   7; -- 2 + Log2(C_MAX_CACHE_LINE_LENGTH);
  constant C_MAX_DATA_WIDTH             : natural := 512;
  constant C_MAX_RRESP_WIDTH            : natural :=   4;
  constant C_ACE_RRESP_WIDTH            : natural :=   4;
  constant C_AXI_RRESP_WIDTH            : natural :=   2;
  constant C_WMID_WIDTH                 : natural :=   8;
  constant C_BRESP_WIDTH                : natural :=   2;
  constant C_AXI_LENGTH_WIDTH           : natural :=   8;
  
  
  -- ----------------------------------------
  -- AXI Range Constants
  
  subtype C_AXI_ID_POS                  is natural range C_MAX_ID_WIDTH - 1 downto 0;
  subtype C_AXI_ADDR_POS                is natural range C_MAX_ADDR_WIDTH - 1 downto 0;
  subtype C_AXI_WORD_ADDR_POS           is natural range C_MAX_WORD_ADDR_WIDTH - 1 downto 0;
  subtype C_AXI_BE_POS                  is natural range C_MAX_DATA_WIDTH / 8 - 1 downto 0;
  subtype C_AXI_DATA_POS                is natural range C_MAX_DATA_WIDTH - 1 downto 0;
  subtype C_AXI_LENGTH_POS              is natural range 8 - 1 downto 0;
  subtype C_AXI_SIZE_POS                is natural range 3 - 1 downto 0;
  subtype C_AXI_BURST_POS               is natural range 2 - 1 downto 0;
  subtype C_AXI_CACHE_POS               is natural range 4 - 1 downto 0;
  subtype C_AXI_PROT_POS                is natural range 3 - 1 downto 0;
  subtype C_AXI_QOS_POS                 is natural range 4 - 1 downto 0;
  subtype C_AXI_BRESP_POS               is natural range C_BRESP_WIDTH     - 1 downto 0;
  subtype C_AXI_RRESP_POS               is natural range C_MAX_RRESP_WIDTH - 1 downto 0;
  subtype C_AXI_SHORT_RRESP_POS         is natural range 2 - 1 downto 0;
  subtype C_AXI_ACSNOOP_POS             is natural range 4 - 1 downto 0;
  subtype C_AXI_AWSNOOP_POS             is natural range 3 - 1 downto 0;
  subtype C_AXI_ARSNOOP_POS             is natural range 4 - 1 downto 0;
  subtype C_AXI_SNOOP_POS               is natural range 4 - 1 downto 0;
  subtype C_AXI_BARRIER_POS             is natural range 2 - 1 downto 0;
  subtype C_AXI_DOMAIN_POS              is natural range 2 - 1 downto 0;
  subtype C_AXI_CRRESP_POS              is natural range 5 - 1 downto 0;
  subtype C_AXI_ASID_POS                is natural range C_MAX_ASID_WIDTH - 1 downto 0;
  subtype C_AXI_WMID_POS                is natural range C_WMID_WIDTH - 1 downto 0;
  
  subtype C_AXI_LENGTH_CARRY_POS        is natural range 8 downto 0;
  
  
  -- ----------------------------------------
  -- Bit fields
  
  subtype  C_DVM_ASID_MSB_POS           is natural range 39 downto 32;
  subtype  C_DVM_VMID_POS               is natural range 31 downto 24;
  subtype  C_DVM_ASID_POS               is natural range 23 downto 16;
  constant C_DVM_NEED_COMPLETE_POS      :  natural              := 15;
  subtype  C_DVM_MESSAGE_POS            is natural range 14 downto 12;
  subtype  C_DVM_OS_POS                 is natural range 11 downto 10;
  subtype  C_DVM_SECURE_POS             is natural range  9 downto  8;
  constant C_DVM_RESERVED1_POS          :  natural              :=  7;
  constant C_DVM_USE_VMID_POS           :  natural              :=  6;
  constant C_DVM_USE_ASID_POS           :  natural              :=  5;
  subtype  C_DVM_RESERVED0_POS          is natural range  4 downto  1;
  constant C_DVM_MORE_POS               :  natural              :=  0;
  
  subtype  C_DVM_PHY_PA11_04_POS        is natural range 11 downto  4;
  subtype  C_DVM_PHY_PA31_12_POS        is natural range 31 downto 12;
  subtype  C_DVM_PHY_PA39_32_POS        is natural range 39 downto 32;
  subtype  C_DVM_PHY_PA43_40_POS        is natural range 43 downto 40;
  subtype  C_DVM_PHY_PA47_44_POS        is natural range 47 downto 44;
  subtype  C_DVM_PHY_VA19_12_POS        is natural range 19 downto 12;
  subtype  C_DVM_PHY_VA27_20_POS        is natural range 27 downto 20;
  
  subtype  C_DVM_VIR_VA11_04_POS        is natural range 11 downto  4;
  subtype  C_DVM_VIR_VA31_12_POS        is natural range 31 downto 12;
  subtype  C_DVM_VIR_VA39_32_POS        is natural range 39 downto 32;
  subtype  C_DVM_VIR_VA44_41_POS        is natural range 43 downto 40;
  constant C_DVM_VIR_VA40_POS           :  natural              :=  3;
  subtype  C_DVM_VIR_VA48_45_POS        is natural range 43 downto 40;
  subtype  C_DVM_VIR_VA52_49_POS        is natural range 47 downto 44;
  subtype  C_DVM_VIR_VA56_53_POS        is natural range 47 downto 44;
  
  constant C_RRESP_ISSHARED_POS         :  natural              :=  3;
  constant C_RRESP_PASSDIRTY_POS        :  natural              :=  2;
  constant C_RRESP_ERROR_POS            :  natural              :=  1;
  constant C_RRESP_EXOKAY_POS           :  natural              :=  0;
  
  constant C_CRRESP_WASUNIQUE_POS       :  natural              :=  4;
  constant C_CRRESP_ISSHARED_POS        :  natural              :=  3;
  constant C_CRRESP_PASSDIRTY_POS       :  natural              :=  2;
  constant C_CRRESP_ERROR_POS           :  natural              :=  1;
  constant C_CRRESP_DATATRANSFER_POS    :  natural              :=  0;
  
  
  -- ----------------------------------------
  -- AXI Derived Types
  
  subtype AXI_ID_TYPE                   is std_logic_vector(C_AXI_ID_POS);
  subtype AXI_ADDR_TYPE                 is std_logic_vector(C_AXI_ADDR_POS);
  subtype AXI_WORD_ADDR_TYPE            is std_logic_vector(C_AXI_WORD_ADDR_POS);
  subtype AXI_BE_TYPE                   is std_logic_vector(C_AXI_BE_POS);
  subtype AXI_DATA_TYPE                 is std_logic_vector(C_AXI_DATA_POS);
  subtype AXI_LENGTH_TYPE               is std_logic_vector(C_AXI_LENGTH_POS);
  subtype AXI_SIZE_TYPE                 is std_logic_vector(C_AXI_SIZE_POS);
  subtype AXI_BURST_TYPE                is std_logic_vector(C_AXI_BURST_POS);
  subtype AXI_CACHE_TYPE                is std_logic_vector(C_AXI_CACHE_POS);
  subtype AXI_PROT_TYPE                 is std_logic_vector(C_AXI_PROT_POS);
  subtype AXI_QOS_TYPE                  is std_logic_vector(C_AXI_QOS_POS);
  subtype AXI_BRESP_TYPE                is std_logic_vector(C_AXI_BRESP_POS);
  subtype AXI_RRESP_TYPE                is std_logic_vector(C_AXI_RRESP_POS);
  subtype AXI_SHORT_RRESP_TYPE          is std_logic_vector(C_AXI_SHORT_RRESP_POS);
  subtype AXI_ACSNOOP_TYPE              is std_logic_vector(C_AXI_ACSNOOP_POS);
  subtype AXI_AWSNOOP_TYPE              is std_logic_vector(C_AXI_AWSNOOP_POS);
  subtype AXI_ARSNOOP_TYPE              is std_logic_vector(C_AXI_ARSNOOP_POS);
  subtype AXI_SNOOP_TYPE                is std_logic_vector(C_AXI_SNOOP_POS);
  subtype AXI_BARRIER_TYPE              is std_logic_vector(C_AXI_BARRIER_POS);
  subtype AXI_DOMAIN_TYPE               is std_logic_vector(C_AXI_DOMAIN_POS);
  subtype AXI_CRRESP_TYPE               is std_logic_vector(C_AXI_CRRESP_POS);
  subtype AXI_ASID_TYPE                 is std_logic_vector(C_AXI_ASID_POS);
  subtype AXI_WMID_TYPE                 is std_logic_vector(C_AXI_WMID_POS);
  
  subtype DVM_VMID_TYPE                 is std_logic_vector(C_DVM_VMID_POS);
  subtype DVM_ASID_TYPE                 is std_logic_vector(C_DVM_ASID_POS);
  subtype DVM_MESSAGE_TYPE              is std_logic_vector(C_DVM_MESSAGE_POS);
  subtype DVM_OS_TYPE                   is std_logic_vector(C_DVM_OS_POS);
  subtype DVM_SECURE_TYPE               is std_logic_vector(C_DVM_SECURE_POS);
  
  subtype AXI_LENGTH_CARRY_TYPE         is std_logic_vector(C_AXI_LENGTH_CARRY_POS);
  
  type AXI_SNOOP_VECTOR_TYPE            is array(natural range <>) of AXI_SNOOP_TYPE;
  type AXI_CRRESP_VECTOR_TYPE           is array(natural range <>) of AXI_CRRESP_TYPE;
  type AXI_DATA_VECTOR_TYPE             is array(natural range <>) of AXI_DATA_TYPE;
  
  
  -- ----------------------------------------
  -- Statistic Constant & Types 
  
  constant C_RD_LATENCY_WIDTH           : natural := 2;
  constant C_WR_LATENCY_WIDTH           : natural := 3;
  
  subtype C_RD_LATENCY_POS              is natural range C_RD_LATENCY_WIDTH - 1 downto 0;
  subtype C_WR_LATENCY_POS              is natural range C_WR_LATENCY_WIDTH - 1 downto 0;
  
  subtype RD_LATENCY_TYPE               is std_logic_vector(C_RD_LATENCY_POS);
  subtype WR_LATENCY_TYPE               is std_logic_vector(C_WR_LATENCY_POS);
  
  constant C_CTRL_CONF_WIDTH            : natural := 1;
  subtype C_CTRL_CONF_POS               is natural range C_CTRL_CONF_WIDTH - 1 downto 0;
  subtype CTRL_CONF_TYPE                is std_logic_vector(C_CTRL_CONF_POS);
  
  
  -- ----------------------------------------
  -- AXI Port Information
  
  type COMMON_PORT_TYPE is record
    Valid             : std_logic;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Kind              : std_logic;
    Exclusive         : std_logic;
    Allocate          : std_logic;
    Other_Allocate    : std_logic;
    Modifiable        : std_logic;
    Bufferable        : std_logic;
    Prot              : AXI_PROT_TYPE;
    Barrier           : AXI_BARRIER_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Size              : AXI_SIZE_TYPE;
    ID                : AXI_ID_TYPE;
  end record COMMON_PORT_TYPE;
  
  type WRITE_PORT_TYPE is record
    Valid             : std_logic;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Kind              : std_logic;
    Exclusive         : std_logic;
    Allocate          : std_logic;
    Other_Allocate    : std_logic;
    Modifiable        : std_logic;
    Bufferable        : std_logic;
    Prot              : AXI_PROT_TYPE;
    Snoop             : AXI_AWSNOOP_TYPE;
    Barrier           : AXI_BARRIER_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Size              : AXI_SIZE_TYPE;
    ID                : AXI_ID_TYPE;
  end record WRITE_PORT_TYPE;
  
  type READ_PORT_TYPE is record
    Valid             : std_logic;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Kind              : std_logic;
    Exclusive         : std_logic;
    Allocate          : std_logic;
    Other_Allocate    : std_logic;
    Modifiable        : std_logic;
    Bufferable        : std_logic;
    Prot              : AXI_PROT_TYPE;
    Snoop             : AXI_ARSNOOP_TYPE;
    Barrier           : AXI_BARRIER_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Size              : AXI_SIZE_TYPE;
    ID                : AXI_ID_TYPE;
  end record READ_PORT_TYPE;
  
  type WAY_LINE_TAG_TYPE is record
    Valid             : std_logic;
    Unique            : std_logic;
    Dirty             : std_logic;
    Locked            : std_logic;
    Reused            : std_logic;
    Secure            : std_logic;
    Addr              : AXI_ADDR_TYPE;
  end record WAY_LINE_TAG_TYPE;
    
  type READ_HIT_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_VECTOR_TYPE(C_MAX_WAYS_POS);
    RRESP             : AXI_RRESP_TYPE;
    Way               : MAX_WAYS_NUM_TYPE;
  end record READ_HIT_TYPE;
  
  type READ_MISS_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_TYPE;
    RRESP             : AXI_RRESP_TYPE;
  end record READ_MISS_TYPE;
  
  type DATA_PORT_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    BE                : AXI_BE_TYPE;
    Data              : AXI_DATA_TYPE;
  end record DATA_PORT_TYPE;
  
  type READ_SOURCE_TYPE is record
    Valid             : std_logic;
    Hit               : std_logic;
    Snoop             : std_logic;
    Lx_Allocate       : std_logic;
  end record READ_SOURCE_TYPE;
  
  type STAT_RI_TYPE is record
    Almost_Full       : std_logic;
    Full              : std_logic;
  end record STAT_RI_TYPE;
  
  type STAT_RD_TYPE is record
    Hit_Pop           : std_logic;
    Hit_Almost_Full   : std_logic;
    Hit_Full          : std_logic;
    Hit_Fit           : std_logic;
    Miss_Full         : std_logic;
  end record STAT_RD_TYPE;

  type SNOOP_FETCH_TYPE is record
    Valid             : std_logic;
    Myself            : std_logic;
    Wr                : std_logic;
    Sync              : std_logic;
    Addr              : AXI_ADDR_TYPE;
  end record SNOOP_FETCH_TYPE;
  
  type SNOOP_REQ_TYPE is record
    Valid             : std_logic;
    Myself            : std_logic;
    Wr                : std_logic;
    Always            : std_logic;
    Update_Filter     : std_logic;
    Want              : std_logic;
    Complete          : std_logic;
    Barrier           : std_logic;
    Init_Cmd          : std_logic;
    Complete_Target   : MAX_PORTS_TYPE;
    Addr              : AXI_ADDR_TYPE;
    Snoop             : AXI_SNOOP_TYPE;
  end record SNOOP_REQ_TYPE;
    
  type SNOOP_ACT_TYPE is record
    Valid             : std_logic;
    Myself            : std_logic;
    Waiting_4_Pipe    : std_logic;
    Wr                : std_logic;
    Always            : std_logic;
    AnyDVM            : std_logic;
    Addr              : AXI_ADDR_TYPE;
    Prot              : AXI_PROT_TYPE;
    Snoop             : AXI_SNOOP_TYPE;
  end record SNOOP_ACT_TYPE;
    
  type SNOOP_ACT_TAG_TYPE is record
    Valid             : std_logic;
    Unique            : std_logic;
    Dirty             : std_logic;
    Secure            : std_logic;
  end record SNOOP_ACT_TAG_TYPE;
    
  type SNOOP_ACT_ACK_TYPE is record
    Done              : std_logic;
    Use_External      : std_logic;
    Write_Blocking    : std_logic;
  end record SNOOP_ACT_ACK_TYPE;
    
  type SNOOP_TAG_TYPE is record
    Valid             : std_logic;
    Unique            : std_logic;
    Dirty             : std_logic;
    Secure            : std_logic;
  end record SNOOP_TAG_TYPE;
    
  type SNOOP_CRRESP_TYPE is record
    Valid             : std_logic;
    CRRESP            : AXI_CRRESP_TYPE;
  end record SNOOP_CRRESP_TYPE;
  
  type SNOOP_DATA_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_TYPE;
  end record SNOOP_DATA_TYPE;
  
  type READ_COMPLETE_TYPE is record
    Valid             : std_logic;
    Ex_Rack           : std_logic;
  end record READ_COMPLETE_TYPE;
  
  type READ_SNOOP_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_TYPE;
    RRESP             : AXI_RRESP_TYPE;
  end record READ_SNOOP_TYPE;
  
  type WRITE_PORTS_TYPE                 is array(natural range <>) of WRITE_PORT_TYPE;
  type READ_PORTS_TYPE                  is array(natural range <>) of READ_PORT_TYPE;
    
  type SET_LINE_TAG_TYPE                is array(natural range <>) of WAY_LINE_TAG_TYPE;
  type WAY_LINE_TAG_BLOCKS_TYPE         is array(natural range <>) of WAY_LINE_TAG_TYPE;
    
  type READ_HIT_PORTS_TYPE              is array(natural range <>) of READ_HIT_TYPE;
  type READ_HIT_BLOCKS_TYPE             is array(natural range <>) of READ_HIT_TYPE;
  type READ_HIT_BLOCKS_PORTS_TYPE       is array(natural range <>, natural range <>) of READ_HIT_TYPE;
    
  type READ_MISS_PORTS_TYPE             is array(natural range <>) of READ_MISS_TYPE;
  type READ_MISS_BLOCKS_TYPE            is array(natural range <>) of READ_MISS_TYPE;
  type READ_MISS_BLOCKS_PORTS_TYPE      is array(natural range <>, natural range <>) of READ_MISS_TYPE;
    
  type DATA_PORTS_TYPE                  is array(natural range <>) of DATA_PORT_TYPE;
  type DATA_BLOCKS_TYPE                 is array(natural range <>) of DATA_PORT_TYPE;
  type DATA_BLOCKS_PORTS_TYPE           is array(natural range <>, natural range <>) of DATA_PORT_TYPE;
    
  type READ_SOURCE_PORTS_TYPE           is array(natural range <>) of READ_SOURCE_TYPE;
  type READ_SOURCE_BLOCKS_TYPE          is array(natural range <>) of READ_SOURCE_TYPE;
  type READ_SOURCE_BLOCKS_PORTS_TYPE    is array(natural range <>, natural range <>) of READ_SOURCE_TYPE;
    
  type STAT_RI_PORTS_TYPE               is array(natural range <>) of STAT_RI_TYPE;
  type STAT_RI_BLOCKS_TYPE              is array(natural range <>) of STAT_RI_TYPE;
  type STAT_RI_BLOCKS_PORTS_TYPE        is array(natural range <>, natural range <>) of STAT_RI_TYPE;
    
  type STAT_RD_PORTS_TYPE               is array(natural range <>) of STAT_RD_TYPE;
  type STAT_RD_BLOCKS_TYPE              is array(natural range <>) of STAT_RD_TYPE;
  type STAT_RD_BLOCKS_PORTS_TYPE        is array(natural range <>, natural range <>) of STAT_RD_TYPE;
    
  type SNOOP_FETCH_PORTS_TYPE           is array(natural range <>) of SNOOP_FETCH_TYPE;
  type SNOOP_FETCH_BLOCKS_TYPE          is array(natural range <>) of SNOOP_FETCH_TYPE;
  type SNOOP_FETCH_BLOCKS_PORTS_TYPE    is array(natural range <>, natural range <>) of SNOOP_FETCH_TYPE;
    
  type SNOOP_REQ_PORTS_TYPE             is array(natural range <>) of SNOOP_REQ_TYPE;
  type SNOOP_REQ_BLOCKS_TYPE            is array(natural range <>) of SNOOP_REQ_TYPE;
  type SNOOP_REQ_BLOCKS_PORTS_TYPE      is array(natural range <>, natural range <>) of SNOOP_REQ_TYPE;
      
  type SNOOP_ACT_PORTS_TYPE             is array(natural range <>) of SNOOP_ACT_TYPE;
  type SNOOP_ACT_BLOCKS_TYPE            is array(natural range <>) of SNOOP_ACT_TYPE;
  type SNOOP_ACT_BLOCKS_PORTS_TYPE      is array(natural range <>, natural range <>) of SNOOP_ACT_TYPE;
    
  type SNOOP_ACT_TAG_PORTS_TYPE         is array(natural range <>) of SNOOP_ACT_TAG_TYPE;
  type SNOOP_ACT_TAG_BLOCKS_TYPE        is array(natural range <>) of SNOOP_ACT_TAG_TYPE;
  type SNOOP_ACT_TAG_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of SNOOP_ACT_TAG_TYPE;
  
  type SNOOP_ACT_ACK_PORTS_TYPE         is array(natural range <>) of SNOOP_ACT_ACK_TYPE;
  type SNOOP_ACT_ACK_BLOCKS_TYPE        is array(natural range <>) of SNOOP_ACT_ACK_TYPE;
  type SNOOP_ACT_ACK_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of SNOOP_ACT_ACK_TYPE;
  
  type SNOOP_TAG_PORTS_TYPE             is array(natural range <>) of SNOOP_TAG_TYPE;
  type SNOOP_TAG_BLOCKS_TYPE            is array(natural range <>) of SNOOP_TAG_TYPE;
  type SNOOP_TAG_BLOCKS_PORTS_TYPE      is array(natural range <>, natural range <>) of SNOOP_TAG_TYPE;
  
  type SNOOP_CRRESP_PORTS_TYPE          is array(natural range <>) of SNOOP_CRRESP_TYPE;
  type SNOOP_CRRESP_BLOCKS_TYPE         is array(natural range <>) of SNOOP_CRRESP_TYPE;
  type SNOOP_CRRESP_BLOCKS_PORTS_TYPE   is array(natural range <>, natural range <>) of SNOOP_CRRESP_TYPE;

  type SNOOP_DATA_PORTS_TYPE            is array(natural range <>) of SNOOP_DATA_TYPE;
  type SNOOP_DATA_BLOCKS_TYPE           is array(natural range <>) of SNOOP_DATA_TYPE;
  type SNOOP_DATA_BLOCKS_PORTS_TYPE     is array(natural range <>, natural range <>) of SNOOP_DATA_TYPE;

  type READ_COMPLETE_PORTS_TYPE         is array(natural range <>) of READ_COMPLETE_TYPE;
  type READ_COMPLETE_BLOCKS_TYPE        is array(natural range <>) of READ_COMPLETE_TYPE;
  type READ_COMPLETE_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of READ_COMPLETE_TYPE;

  type READ_SNOOP_PORTS_TYPE            is array(natural range <>) of READ_SNOOP_TYPE;
  type READ_SNOOP_BLOCKS_TYPE           is array(natural range <>) of READ_SNOOP_TYPE;
  type READ_SNOOP_BLOCKS_PORTS_TYPE     is array(natural range <>, natural range <>) of READ_SNOOP_TYPE;
  
  
  -- ----------------------------------------
  -- Port Arbitration
  
  type ARBITRATION_TYPE is record
    Valid             : std_logic;
    Wr                : std_logic;
    Port_Num          : PORT_NUM_TYPE;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Kind              : std_logic;
    Exclusive         : std_logic;
    Allocate          : std_logic;
    Bufferable        : std_logic;
    Evict             : std_logic;
    Ignore_Data       : std_logic;
    Force_Hit         : std_logic;
    Internal_Cmd      : std_logic;
    Early             : std_logic;
    Keep              : std_logic;
    Prot              : AXI_PROT_TYPE;
    Snoop             : AXI_SNOOP_TYPE;
    Barrier           : AXI_BARRIER_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Size              : AXI_SIZE_TYPE;
    ID                : AXI_ID_TYPE;
  end record ARBITRATION_TYPE;
  
  
  constant C_ARB_TYPE_LEN  : natural:= 1 + 1 + PORT_NUM_TYPE'length + AXI_ADDR_TYPE'length + AXI_LENGTH_TYPE'length + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + AXI_PROT_TYPE'length + AXI_SNOOP_TYPE'length + AXI_BARRIER_TYPE'length + AXI_DOMAIN_TYPE'length + AXI_SIZE_TYPE'length;
  
  
  function To_StdVec(from : ARBITRATION_TYPE) return std_logic_vector;
  
  type ARBITRATION_BLOCKS_TYPE        is array(natural range <>) of ARBITRATION_TYPE;
  
  
  -- ----------------------------------------
  -- Access Information
  
  type ACCESS_TYPE is record
    Port_Num          : PORT_NUM_TYPE;
    Allocate          : std_logic;
    Bufferable        : std_logic;
    Exclusive         : std_logic;
    Evict             : std_logic;
    SnoopResponse     : std_logic;
    KillHit           : std_logic;
    Kind              : std_logic;
    Wr                : std_logic;
    PassDirty         : std_logic;
    IsShared          : std_logic;
    Lx_Allocate       : std_logic;
    Ignore_Data       : std_logic;
    Force_Hit         : std_logic;
    Internal_Cmd      : std_logic;
    Early             : std_logic;
    Keep              : std_logic;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Size              : AXI_SIZE_TYPE;
    Prot              : AXI_PROT_TYPE;
    Snoop             : AXI_SNOOP_TYPE;
    Barrier           : AXI_BARRIER_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Addr_Use          : AXI_WORD_ADDR_TYPE;
    Addr_Stp          : AXI_WORD_ADDR_TYPE;
    ID                : AXI_ID_TYPE;
  end record ACCESS_TYPE;
  
  
  constant C_ACC_TYPE_LEN   : natural:= PORT_NUM_TYPE'length + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +AXI_ADDR_TYPE'length + AXI_LENGTH_TYPE'length + AXI_SIZE_TYPE'length;
  
  
  function To_StdVec(from : ACCESS_TYPE) return std_logic_vector;
  
  type ACCESS_BLOCKS_TYPE             is array(natural range <>) of ACCESS_TYPE;
  
  
  -- ----------------------------------------
  -- Update Information
  
  type READ_REQ_TYPE is record
    Valid             : std_logic;
    Exclusive         : std_logic;
    Kind              : std_logic;
    Port_Num          : PORT_NUM_TYPE;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Size              : AXI_SIZE_TYPE;
    Snoop             : AXI_ARSNOOP_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Prot              : AXI_PROT_TYPE;
  end record READ_REQ_TYPE;
  
  type WRITE_REQ_TYPE is record
    Valid             : std_logic;
    Internal          : std_logic;
    Exclusive         : std_logic;
    Kind              : std_logic;
    Line_Only         : std_logic;
    Stall_Snoop       : std_logic;
    Cancelled         : std_logic;
    Port_Num          : PORT_NUM_TYPE;
    Addr              : AXI_ADDR_TYPE;
    Len               : AXI_LENGTH_TYPE;
    Size              : AXI_SIZE_TYPE;
    Snoop             : AXI_AWSNOOP_TYPE;
    Domain            : AXI_DOMAIN_TYPE;
    Prot              : AXI_PROT_TYPE;
  end record WRITE_REQ_TYPE;
    
  type READ_REQ_PORTS_TYPE            is array(natural range <>) of READ_REQ_TYPE;
  type READ_REQ_BLOCKS_TYPE           is array(natural range <>) of READ_REQ_TYPE;
  type WRITE_REQ_PORTS_TYPE           is array(natural range <>) of WRITE_REQ_TYPE;
  type WRITE_REQ_BLOCKS_TYPE          is array(natural range <>) of WRITE_REQ_TYPE;
    
  -- ----------------------------------------
  -- Backend Information
  
  type READ_RESP_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_TYPE;
    RRESP             : AXI_RRESP_TYPE;
  end record READ_RESP_TYPE;
  
  type WRITE_CONF_TYPE is record
    Port_Num          : PORT_NUM_TYPE;
    Internal          : std_logic;
    Addr              : AXI_ADDR_TYPE;
  end record WRITE_CONF_TYPE;
    
  type WRITE_RESP_TYPE is record
    Valid             : std_logic;
    BRESP             : AXI_BRESP_TYPE;
  end record WRITE_RESP_TYPE;
    
  type WRITE_EARLY_TYPE is record
    Valid             : std_logic;
    Early             : std_logic;
    Barrier           : std_logic;
  end record WRITE_EARLY_TYPE;
    
  type READ_RESP_PORTS_TYPE           is array(natural range <>) of READ_RESP_TYPE;
  type READ_RESP_BLOCKS_TYPE          is array(natural range <>) of READ_RESP_TYPE;
  type WRITE_CONF_BLOCKS_TYPE         is array(natural range <>) of WRITE_CONF_TYPE;
  type WRITE_RESP_PORTS_TYPE          is array(natural range <>) of WRITE_RESP_TYPE;
  type WRITE_RESP_BLOCKS_TYPE         is array(natural range <>) of WRITE_RESP_TYPE;
  type WRITE_RESP_BLOCKS_PORTS_TYPE   is array(natural range <>, natural range <>) of WRITE_RESP_TYPE;
  type WRITE_EARLY_PORTS_TYPE         is array(natural range <>) of WRITE_EARLY_TYPE;
  type WRITE_EARLY_BLOCKS_TYPE        is array(natural range <>) of WRITE_EARLY_TYPE;
  type WRITE_EARLY_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of WRITE_EARLY_TYPE;
    
  
  -- ----------------------------------------
  -- Master Snoop Information
  
  type MST_SNOOP_REQ_TYPE is record
    Valid             : std_logic;
    First             : std_logic;
    Lookup            : std_logic;
    Update            : std_logic;
    Get               : std_logic;
    Keep              : std_logic;
    Clean             : std_logic;
    Kill              : std_logic;
    Sync              : std_logic;
    Complete          : std_logic;
    Addr              : AXI_ADDR_TYPE;
    ASID              : AXI_ASID_TYPE;
    VMID              : AXI_WMID_TYPE;
    Prot              : AXI_PROT_TYPE;
  end record MST_SNOOP_REQ_TYPE;
  
  type MST_SNOOP_ACK_TYPE is record
    Valid             : std_logic;
    Secure            : std_logic;
    Unique            : std_logic;
    Dirty             : std_logic;
    Locked            : std_logic;
    Reused            : std_logic;
    Way               : C_MAX_WAYS_POS;
    Addr              : AXI_ADDR_TYPE;
  end record MST_SNOOP_ACK_TYPE;
  type MST_SNOOP_ACK_VECTOR_TYPE         is array(natural range <>) of MST_SNOOP_ACK_TYPE;
  
  -- Create a resolved type.
  function RESOLVE_MST_SNOOP_ACK(values : in MST_SNOOP_ACK_VECTOR_TYPE ) return MST_SNOOP_ACK_TYPE;
  subtype RMST_SNOOP_ACK_TYPE is RESOLVE_MST_SNOOP_ACK  MST_SNOOP_ACK_TYPE;
  
  type MST_SNOOP_HAZ_TYPE is record
    Valid             : std_logic;
    Hazard            : std_logic;
    MadeUnique        : std_logic;
    MadeDirty         : std_logic;
    Extracted         : std_logic;
  end record MST_SNOOP_HAZ_TYPE;
  type MST_SNOOP_HAZ_VECTOR_TYPE         is array(natural range <>) of MST_SNOOP_HAZ_TYPE;
  
  -- Create a resolved type.
  function RESOLVE_MST_SNOOP_HAZ(values : in MST_SNOOP_HAZ_VECTOR_TYPE ) return MST_SNOOP_HAZ_TYPE;
  subtype RMST_SNOOP_HAZ_TYPE is RESOLVE_MST_SNOOP_HAZ  MST_SNOOP_HAZ_TYPE;
  
  type MST_SNOOP_ADDR_TYPE is record
    Valid             : std_logic;
    Way               : C_MAX_WAYS_POS;
    Addr              : AXI_ADDR_TYPE;
  end record MST_SNOOP_ADDR_TYPE;
  type  MST_SNOOP_ADDR_VECTOR_TYPE       is array(natural range <>) of MST_SNOOP_ADDR_TYPE;
  
  -- Create a resolved type.
  function RESOLVE_MST_SNOOP_ADDR(values : in MST_SNOOP_ADDR_VECTOR_TYPE ) return MST_SNOOP_ADDR_TYPE;
  subtype RMST_SNOOP_ADDR_TYPE is RESOLVE_MST_SNOOP_ADDR  MST_SNOOP_ADDR_TYPE;
  
  type MST_SNOOP_DATA_TYPE is record
    Valid             : std_logic;
    Last              : std_logic;
    Data              : AXI_DATA_TYPE;
  end record MST_SNOOP_DATA_TYPE;
  
  type INTERNAL_DVM_TYPE is record
    Valid             : std_logic;
    Addr_1st          : AXI_ADDR_TYPE;
    Addr_2nd          : AXI_ADDR_TYPE;
  end record INTERNAL_DVM_TYPE;
  
  type INTERNAL_BAR_TYPE is record
    Valid             : std_logic;
    Synchronizing     : std_logic;
    Addr              : AXI_ADDR_TYPE;
  end record INTERNAL_BAR_TYPE;
    
  type MST_SNOOP_REQ_PORTS_TYPE          is array(natural range <>) of MST_SNOOP_REQ_TYPE;
  type MST_SNOOP_REQ_BLOCKS_TYPE         is array(natural range <>) of MST_SNOOP_REQ_TYPE;
  type MST_SNOOP_REQ_BLOCKS_PORTS_TYPE   is array(natural range <>, natural range <>) of MST_SNOOP_REQ_TYPE;
  
  type MST_SNOOP_ACK_PORTS_TYPE          is array(natural range <>) of MST_SNOOP_ACK_TYPE;
  type MST_SNOOP_ACK_BLOCKS_TYPE         is array(natural range <>) of MST_SNOOP_ACK_TYPE;
  type MST_SNOOP_ACK_BLOCKS_PORTS_TYPE   is array(natural range <>, natural range <>) of MST_SNOOP_ACK_TYPE;
  
  type MST_SNOOP_HAZ_PORTS_TYPE          is array(natural range <>) of MST_SNOOP_HAZ_TYPE;
  type MST_SNOOP_HAZ_BLOCKS_TYPE         is array(natural range <>) of MST_SNOOP_HAZ_TYPE;
  type MST_SNOOP_HAZ_BLOCKS_PORTS_TYPE   is array(natural range <>, natural range <>) of MST_SNOOP_HAZ_TYPE;
  
  type MST_SNOOP_ADDR_PORTS_TYPE         is array(natural range <>) of MST_SNOOP_ADDR_TYPE;
  type MST_SNOOP_ADDR_BLOCKS_TYPE        is array(natural range <>) of RMST_SNOOP_ADDR_TYPE;
  type MST_SNOOP_ADDR_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of MST_SNOOP_ADDR_TYPE;
  
  type MST_SNOOP_DATA_PORTS_TYPE         is array(natural range <>) of MST_SNOOP_DATA_TYPE;
  type MST_SNOOP_DATA_BLOCKS_TYPE        is array(natural range <>) of MST_SNOOP_DATA_TYPE;
  type MST_SNOOP_DATA_BLOCKS_PORTS_TYPE  is array(natural range <>, natural range <>) of MST_SNOOP_DATA_TYPE;
  type MST_SNOOP_DATA_VECTOR_TYPE        is array(natural range <>) of MST_SNOOP_DATA_TYPE;
  
  type INTERNAL_DVM_PORTS_TYPE           is array(natural range <>) of INTERNAL_DVM_TYPE;
  type INTERNAL_DVM_BLOCKS_TYPE          is array(natural range <>) of INTERNAL_DVM_TYPE;
  type INTERNAL_DVM_BLOCKS_PORTS_TYPE    is array(natural range <>, natural range <>) of INTERNAL_DVM_TYPE;
  type INTERNAL_DVM_VECTOR_TYPE          is array(natural range <>) of INTERNAL_DVM_TYPE;
  
  type INTERNAL_BAR_PORTS_TYPE           is array(natural range <>) of INTERNAL_BAR_TYPE;
  type INTERNAL_BAR_BLOCKS_TYPE          is array(natural range <>) of INTERNAL_BAR_TYPE;
  type INTERNAL_BAR_BLOCKS_PORTS_TYPE    is array(natural range <>, natural range <>) of INTERNAL_BAR_TYPE;
  type INTERNAL_BAR_VECTOR_TYPE          is array(natural range <>) of INTERNAL_BAR_TYPE;
  
  
  -- ----------------------------------------
  -- Statistics Information
  
  constant C_MAX_STAT_WIDTH             : natural := 64;
  subtype C_STAT_POS                    is natural range C_MAX_STAT_WIDTH - 1 downto 0;
  subtype STAT_TYPE                     is std_logic_vector(C_STAT_POS);
  
  constant C_MAX_STAT_CONF_WIDTH        : natural := 64;
  subtype C_STAT_CONF_POS               is natural range C_MAX_STAT_CONF_WIDTH - 1 downto 0;
  subtype STAT_CONF_TYPE                is std_logic_vector(C_STAT_CONF_POS);
  
  constant C_STAT_MIN_HI                : natural := C_MAX_STAT_WIDTH - 1;
  constant C_STAT_MIN_LO                : natural := C_MAX_STAT_WIDTH - 16;
  subtype C_STAT_MIN_POS                is natural range C_STAT_MIN_HI downto C_STAT_MIN_LO;
  subtype STAT_MIN_TYPE                 is std_logic_vector(C_STAT_MIN_POS);
  constant C_STAT_MAX_HI                : natural := C_MAX_STAT_WIDTH -16 - 1;
  constant C_STAT_MAX_LO                : natural := C_MAX_STAT_WIDTH - 32;
  subtype C_STAT_MAX_POS                is natural range C_STAT_MAX_HI downto C_STAT_MAX_LO;
  subtype STAT_MAX_TYPE                 is std_logic_vector(C_STAT_MAX_POS);
  constant C_STAT_FULL_POS              : natural := 1;
  constant C_STAT_OVERFLOW_POS          : natural := 0;
  
  type STAT_POINT_TYPE is record
    Events            : STAT_TYPE;
    Min_Max_Status    : STAT_TYPE;
    Sum               : STAT_TYPE;
    Sum_2             : STAT_TYPE;
  end record STAT_POINT_TYPE;
  
  type STAT_FIFO_TYPE is record
    Empty_Cycles      : STAT_TYPE;
    Index_Updates     : STAT_TYPE;
    Index_Max         : STAT_TYPE;
    Index_Sum         : STAT_TYPE;
  end record STAT_FIFO_TYPE;
  
  type STAT_VECTOR_TYPE                 is array(natural range <>) of STAT_TYPE;
  type STAT_POINT_VECTOR_TYPE           is array(natural range <>) of STAT_POINT_TYPE;
  type STAT_POINT_MATRIX_TYPE           is array(natural range <>, natural range <>) of STAT_POINT_TYPE;
  type STAT_FIFO_VECTOR_TYPE            is array(natural range <>) of STAT_FIFO_TYPE;
  type STAT_FIFO_MATRIX_TYPE            is array(natural range <>, natural range <>) of STAT_FIFO_TYPE;
  type STAT_CONF_VECTOR_TYPE            is array(natural range <>) of STAT_CONF_TYPE;
  
  
  constant C_STAT_POINT_TYPE_LEN        : natural:= 4 * C_MAX_STAT_WIDTH;
  constant C_STAT_FIFO_TYPE_LEN         : natural:= 4 * C_MAX_STAT_WIDTH;
  
  
  function To_StdVec(from : STAT_POINT_TYPE) return std_logic_vector;
  function To_StdVec(from : STAT_FIFO_TYPE) return std_logic_vector;
  
  function Stat_Get_Register(from : STAT_VECTOR_TYPE; 
                             idx  : natural) return STAT_TYPE;
  function Stat_Point_Get_Register(from : STAT_POINT_TYPE; 
                                   idx  : natural range 0 to 7) return STAT_TYPE;
  function Stat_FIFO_Get_Register(from : STAT_FIFO_TYPE; 
                                  idx  : natural range 0 to 7) return STAT_TYPE;
  function Stat_Conf_Get_Register(from : STAT_CONF_VECTOR_TYPE; 
                                  idx  : natural) return STAT_TYPE;
  function Stat_Conf_Get_Register(from : STAT_CONF_TYPE) return STAT_TYPE;
                                  
  function Stat_Conf_Set_Register(from : std_logic_vector; 
                                  w    : natural) return STAT_CONF_TYPE;
  
  function Stat_Get_Register_32bit(from : STAT_VECTOR_TYPE; 
                                   idx  : natural;
                                   word : natural range 0 to 1) return std_logic_vector;
  function Stat_Get_Register_64bit(from : STAT_VECTOR_TYPE; 
                                   idx  : natural) return std_logic_vector;
  function Stat_Point_Get_Register_32bit(from : STAT_POINT_TYPE; 
                                         idx  : natural range 0 to 7;
                                         word : natural range 0 to 1) return std_logic_vector;
  function Stat_Point_Get_Register_64bit(from : STAT_POINT_TYPE; 
                                         idx  : natural range 0 to 7) return std_logic_vector;
  function Stat_FIFO_Get_Register_32bit(from  : STAT_FIFO_TYPE; 
                                        idx   : natural range 0 to 7;
                                        word  : natural range 0 to 1) return std_logic_vector;
  function Stat_FIFO_Get_Register_64bit(from  : STAT_FIFO_TYPE; 
                                        idx   : natural range 0 to 7) return std_logic_vector;
  
  
  -- ----------------------------------------
  -- Null Records
  
  constant C_NULL_COMMON_PORT         : COMMON_PORT_TYPE  := (Valid=>'0', Addr=>(others=>'0'),  Len=>(others=>'0'), 
                                                              Kind=>'0', Exclusive=>'0', Allocate=>'0', Modifiable=>'0',
                                                              Other_Allocate=>'0', Bufferable=>'0', Prot=>(others=>'0'), 
                                                              Barrier=>(others=>'0'), Domain=>(others=>'0'), 
                                                              Size=>(others=>'0'), ID=>(others=>'0'));
  
  constant C_NULL_WRITE_PORT          : WRITE_PORT_TYPE   := (Valid=>'0', Addr=>(others=>'0'),  Len=>(others=>'0'), 
                                                              Kind=>'0', Exclusive=>'0', Allocate=>'0', Modifiable=>'0',
                                                              Other_Allocate=>'0', Bufferable=>'0', Prot=>(others=>'0'), 
                                                              Snoop=>(others=>'0'), Barrier=>(others=>'0'), 
                                                              Domain=>(others=>'0'), Size=>(others=>'0'), 
                                                              ID=>(others=>'0'));
  
  constant C_NULL_READ_PORT           : READ_PORT_TYPE    := (Valid=>'0', Addr=>(others=>'0'),  Len=>(others=>'0'), 
                                                              Kind=>'0', Exclusive=>'0', Allocate=>'0', Modifiable=>'0',
                                                              Other_Allocate=>'0', Bufferable=>'0', Prot=>(others=>'0'), 
                                                              Snoop=>(others=>'0'), Barrier=>(others=>'0'), 
                                                              Domain=>(others=>'0'), Size=>(others=>'0'), 
                                                              ID=>(others=>'0'));
  
  constant C_NULL_WRITE_EARLY         : WRITE_EARLY_TYPE  := (Valid=>'0', Early=>'0', Barrier=>'0');
  
  constant C_NULL_SNOOP_FETCH         : SNOOP_FETCH_TYPE  := (Valid=>'0', Myself=>'0', Wr=>'0', Sync=>'0',  
                                                              Addr=>(others=>'0'));
  
  constant C_NULL_SNOOP_REQ           : SNOOP_REQ_TYPE    := (Valid=>'0', Myself=>'0', Wr=>'0', Always=>'0', 
                                                              Update_Filter=>'0', Want=>'0', Complete=>'0', 
                                                              Barrier=>'0', Init_Cmd=>'0', 
                                                              Complete_Target=>(others=>'0'), 
                                                              Addr=>(others=>'0'), Snoop=>(others=>'0'));
    
  constant C_NULL_SNOOP_ACT           : SNOOP_ACT_TYPE    := (Valid=>'0', Myself=>'0', Waiting_4_Pipe=>'0', Wr=>'0', 
                                                              Always=>'0', AnyDVM=>'0', Prot=>(others=>'0'), 
                                                              Addr=>(others=>'0'), Snoop=>(others=>'0'));
    
  constant C_NULL_SNOOP_ACT_TAG       : SNOOP_ACT_TAG_TYPE:= (Valid=>'0', Unique=>'0', Dirty=>'0', Secure=>'0');
    
  constant C_NULL_SNOOP_ACT_ACK       : SNOOP_ACT_ACK_TYPE:= (Done=>'0', Use_External=>'0', Write_Blocking=>'0');
    
  constant C_NULL_SNOOP_TAG           : SNOOP_TAG_TYPE    := (Valid=>'0', Unique=>'0', Dirty=>'0', Secure=>'0');
    
  constant C_NULL_SNOOP_CRRESP        : SNOOP_CRRESP_TYPE := (Valid=>'0', CRRESP=>(others=>'0'));
  
  constant C_NULL_SNOOP_DATA          : SNOOP_DATA_TYPE   := (Valid=>'0', Last=>'0', Data=>(others=>'0'));
  
  constant C_NULL_READ_COMPLETE       : READ_COMPLETE_TYPE:= (Valid=>'0', Ex_Rack=>'0');
  
  constant C_NULL_READ_SNOOP          : READ_SNOOP_TYPE   := (Valid=>'0', Last=>'0', 
                                                              Data=>(others=>'0'), RRESP=>(others=>'0'));
  
  
  
  constant C_NULL_WAY_LINE_TAG        : WAY_LINE_TAG_TYPE := (Valid=>'0', Reused=>'0', Dirty=>'0', Unique=>'0', 
                                                              Locked=>'0', Secure=>'0', Addr=>(others=>'0'));
  
  constant C_NULL_ARBITRATION         : ARBITRATION_TYPE  := (Valid=>'0', Wr=>'0', Port_Num=>(others=>'0'), 
                                                              Addr=>(others=>'0'),  Len=>(others=>'0'), 
                                                              Kind=>'0', Exclusive=>'0', Allocate=>'0', 
                                                              Bufferable=>'0', Evict=>'0', Ignore_Data=>'0', 
                                                              Force_Hit=>'0', Internal_Cmd=>'0', Prot=>(others=>'0'), 
                                                              Snoop=>(others=>'0'), Barrier=>(others=>'0'), 
                                                              Domain=>(others=>'0'), Size=>(others=>'0'), 
                                                              ID=>(others=>'0'), Early=>'0', Keep=>'0');
  
  constant C_NULL_ACCESS              : ACCESS_TYPE       := (Port_Num=>(others=>'0'), Allocate=>'0', Bufferable=>'0', 
                                                              Exclusive=>'0', Evict=>'0', SnoopResponse=>'0', 
                                                              KillHit=>'0', Kind=>'0', Wr=>'0',  
                                                              PassDirty=>'0', IsShared=>'0', Lx_Allocate=>'0', 
                                                              Ignore_Data=>'0', Force_Hit=>'0', Internal_Cmd=>'0', 
                                                              Addr=>(others=>'0'), Len=>(others=>'0'), 
                                                              Size=>(others=>'0'), Prot=>(others=>'0'), 
                                                              Addr_Use=>(others=>'0'), Addr_Stp=>(others=>'0'), 
                                                              ID=>(others=>'0'), Barrier=>(others=>'0'), 
                                                              Snoop=>(others=>'0'), Domain=>(others=>'0'), 
                                                              Early=>'0', Keep=>'0');
  
  constant C_NULL_MST_SNOOP_REQ       : MST_SNOOP_REQ_TYPE:= (Valid=>'0', First=>'0', Lookup=>'0', Update=>'0', Get=>'0', 
                                                              Keep=>'0', Clean=>'0', Kill=>'0', Sync=>'0', 
                                                              Complete=>'0', Addr=>(others=>'0'), ASID=>(others=>'0'), 
                                                              VMID=>(others=>'0'), Prot=>(others=>'0'));
  
  constant C_NULL_MST_SNOOP_ACK       : MST_SNOOP_ACK_TYPE:= (Valid=>'0', Unique=>'0', Dirty=>'0', Way=>0, Locked=>'0', 
                                                              Secure=>'0', Reused=>'0', Addr=>(others=>'0'));
  
  constant C_NULL_MST_SNOOP_HAZ       : MST_SNOOP_HAZ_TYPE:= (Valid=>'0', Hazard=>'0', MadeUnique=>'0', MadeDirty=>'0', 
                                                              Extracted=>'0');
  
  constant C_NULL_MST_SNOOP_ADDR      : MST_SNOOP_ADDR_TYPE:= (Valid=>'0', Way=>0, Addr=>(others=>'0'));
  
  constant C_NULL_MST_SNOOP_DATA      : MST_SNOOP_DATA_TYPE:= (Valid=>'0', Last=>'0', Data=>(others=>'0'));
  
  constant C_NULL_STAT_POINT          : STAT_POINT_TYPE   := (Events=>(others=>'0'), Min_Max_Status=>(others=>'0'), 
                                                              Sum=>(others=>'0'), Sum_2=>(others=>'0'));
  
  constant C_NULL_STAT_FIFO           : STAT_FIFO_TYPE    := (Empty_Cycles=>(others=>'0'), Index_Updates=>(others=>'0'), 
                                                              Index_Max=>(others=>'0'), Index_Sum=>(others=>'0'));
  
  
  -- ----------------------------------------
  -- AXI NULL
  
  constant NULL_AXI_ADDR                : AXI_ADDR_TYPE   := (others=>'0');
  constant NULL_AXI_LENGTH              : AXI_LENGTH_TYPE := (others=>'0');
  constant NULL_AXI_SIZE                : AXI_SIZE_TYPE   := (others=>'0');
  constant NULL_AXI_BURST               : AXI_BURST_TYPE  := (others=>'0');
  constant NULL_AXI_CACHE               : AXI_CACHE_TYPE  := (others=>'0');
  constant NULL_AXI_PROT                : AXI_PROT_TYPE   := "010";         -- Normal and non-secure Data access only
  constant NULL_AXI_QOS                 : AXI_QOS_TYPE    := (others=>'0');
  constant NULL_AXI_BRESP               : AXI_BRESP_TYPE  := (others=>'0');
  constant NULL_AXI_RRESP               : AXI_RRESP_TYPE  := (others=>'0');
  constant NULL_AXI_ACSNOOP             : AXI_ACSNOOP_TYPE:= (others=>'0');
  constant NULL_AXI_AWSNOOP             : AXI_AWSNOOP_TYPE:= (others=>'0');
  constant NULL_AXI_ARSNOOP             : AXI_ARSNOOP_TYPE:= (others=>'0');
  constant NULL_AXI_SNOOP               : AXI_SNOOP_TYPE  := (others=>'0');
  constant NULL_AXI_BARRIER             : AXI_BARRIER_TYPE:= (others=>'0');
  constant NULL_AXI_DOMAIN              : AXI_DOMAIN_TYPE := (others=>'0');
  constant NULL_AXI_CRRESP              : AXI_CRRESP_TYPE := (others=>'0');
  
  
  -- ----------------------------------------
  -- AXI Constants
  
  -- http://en.wikipedia.org/wiki/Number_prefix
  constant C_BYTE_SIZE                  : AXI_SIZE_TYPE := "000";
  constant C_HALF_WORD_SIZE             : AXI_SIZE_TYPE := "001";
  constant C_WORD_SIZE                  : AXI_SIZE_TYPE := "010";
  constant C_DOUBLE_WORD_SIZE           : AXI_SIZE_TYPE := "011";
  constant C_QUAD_WORD_SIZE             : AXI_SIZE_TYPE := "100";
  constant C_OCTA_WORD_SIZE             : AXI_SIZE_TYPE := "101";
  constant C_HEXADECA_WORD_SIZE         : AXI_SIZE_TYPE := "110";
  constant C_TRIACONTADI_WORD_SIZE      : AXI_SIZE_TYPE := "111";
  
  constant C_BYTE_STEP_SIZE             : natural :=   1;
  constant C_HALF_WORD_STEP_SIZE        : natural :=   2;
  constant C_WORD_STEP_SIZE             : natural :=   4;
  constant C_DOUBLE_WORD_STEP_SIZE      : natural :=   8;
  constant C_QUAD_WORD_STEP_SIZE        : natural :=  16;
  constant C_OCTA_WORD_STEP_SIZE        : natural :=  32;
  constant C_HEXADECA_WORD_STEP_SIZE    : natural :=  64;
  constant C_TRIACONTADI_WORD_STEP_SIZE : natural := 128;
  
  constant C_BYTE_WIDTH                 : natural := 8 * C_BYTE_STEP_SIZE;
  constant C_HALF_WORD_WIDTH            : natural := 8 * C_HALF_WORD_STEP_SIZE;
  constant C_WORD_WIDTH                 : natural := 8 * C_WORD_STEP_SIZE;
  constant C_DOUBLE_WORD_WIDTH          : natural := 8 * C_DOUBLE_WORD_STEP_SIZE;
  constant C_QUAD_WORD_WIDTH            : natural := 8 * C_QUAD_WORD_STEP_SIZE;
  constant C_OCTA_WORD_WIDTH            : natural := 8 * C_OCTA_WORD_STEP_SIZE;
  constant C_HEXADECA_WORD_WIDTH        : natural := 8 * C_HEXADECA_WORD_STEP_SIZE;
  constant C_TRIACONTADI_WORD_WIDTH     : natural := 8 * C_TRIACONTADI_WORD_STEP_SIZE;
  
  constant C_BRESP_OKAY                 : AXI_BRESP_TYPE  := std_logic_vector(to_unsigned(0, C_BRESP_WIDTH));
  constant C_BRESP_EXOKAY               : AXI_BRESP_TYPE  := std_logic_vector(to_unsigned(1, C_BRESP_WIDTH));
  constant C_BRESP_SLVERR               : AXI_BRESP_TYPE  := std_logic_vector(to_unsigned(2, C_BRESP_WIDTH));
  constant C_BRESP_DECERR               : AXI_BRESP_TYPE  := std_logic_vector(to_unsigned(3, C_BRESP_WIDTH));
  constant C_RRESP_OKAY                 : AXI_RRESP_TYPE  := std_logic_vector(to_unsigned(0, C_MAX_RRESP_WIDTH));
  constant C_RRESP_EXOKAY               : AXI_RRESP_TYPE  := std_logic_vector(to_unsigned(1, C_MAX_RRESP_WIDTH));
  constant C_RRESP_SLVERR               : AXI_RRESP_TYPE  := std_logic_vector(to_unsigned(2, C_MAX_RRESP_WIDTH));
  constant C_RRESP_DECERR               : AXI_RRESP_TYPE  := std_logic_vector(to_unsigned(3, C_MAX_RRESP_WIDTH));
  
  constant C_LOCK_NORMAL                : std_logic := '0';
  constant C_LOCK_EXCLUSIVE             : std_logic := '1';

  constant C_AR_FIX                     : std_logic_vector(1 downto 0) := "00";
  constant C_AR_INCR                    : std_logic_vector(1 downto 0) := "01";
  constant C_AR_WRAP                    : std_logic_vector(1 downto 0) := "10";
  constant C_AR_RESERVED                : std_logic_vector(1 downto 0) := "11";
  constant C_AW_FIX                     : std_logic_vector(1 downto 0) := "00";
  constant C_AW_INCR                    : std_logic_vector(1 downto 0) := "01";
  constant C_AW_WRAP                    : std_logic_vector(1 downto 0) := "10";
  constant C_AW_RESERVED                : std_logic_vector(1 downto 0) := "11";
  constant C_KIND_WRAP                  : std_logic                    := '1';
  constant C_KIND_INCR                  : std_logic                    := '0';
  
  constant C_ARCACHE_BUFFERABLE_POS     : natural := 0;
  constant C_ARCACHE_MODIFIABLE_POS     : natural := 1;
  constant C_ARCACHE_READ_ALLOCATE_POS  : natural := 2;
  constant C_ARCACHE_OTHER_ALLOCATE_POS : natural := 3;
  constant C_AWCACHE_BUFFERABLE_POS     : natural := 0;
  constant C_AWCACHE_MODIFIABLE_POS     : natural := 1;
  constant C_AWCACHE_OTHER_ALLOCATE_POS : natural := 2;
  constant C_AWCACHE_WRITE_ALLOCATE_POS : natural := 3;
  
  -- ARCACHE[3:0] AWCACHE[3:0]  Memory type
  -- 0000         0000          Device Non-bufferable
  -- 0001         0001          Device Bufferable
  -- 0010         0010          Normal Non-cacheable Non-bufferable
  -- 0011         0011          Normal Non-cacheable Bufferable
  --
  -- 1010         0110          Write-through No-allocate
  -- 1110 (0110)  0110          Write-through Read-allocate
  -- 1010         1110 (1010)   Write-through Write-allocate
  -- 1110         1110          Write-through Read and Write-allocate
  --
  -- 1011         0111          Write-back No-allocate
  -- 1111 (0111)  0111          Write-back Read-allocate
  -- 1011         1111 (1011)   Write-back Write-allocate
  -- 1111         1111          Write-back Read and Write-allocate  
  
  constant C_PROT_PRIVELEDGED_POS       : natural := 0;
  constant C_PROT_SECURE_POS            : natural := 1;
  constant C_PROT_DATA_POS              : natural := 2;
  
  
  -- ----------------------------------------
  -- ACE Constants
  
  constant C_DOMAIN_NON_SHAREABLE       : AXI_DOMAIN_TYPE:= "00";
  constant C_DOMAIN_INNER_SHAREABLE     : AXI_DOMAIN_TYPE:= "01";
  constant C_DOMAIN_OUTER_SHAREABLE     : AXI_DOMAIN_TYPE:= "10";
  constant C_DOMAIN_SYSTEM_SHAREABLE    : AXI_DOMAIN_TYPE:= "11";
  
  constant C_BAR_NORMAL_RESPECTING      : AXI_BARRIER_TYPE:= "00";
  constant C_BAR_MEMORY_BARRIER         : AXI_BARRIER_TYPE:= "01";
  constant C_BAR_NORMAL_IGNORING        : AXI_BARRIER_TYPE:= "10";
  constant C_BAR_SYNCHRONIZATION        : AXI_BARRIER_TYPE:= "11";
  
  constant C_ARSNOOP_ReadNoSnoop        : AXI_ARSNOOP_TYPE:= "0000";
  constant C_ARSNOOP_ReadOnce           : AXI_ARSNOOP_TYPE:= "0000";
  constant C_ARSNOOP_ReadShared         : AXI_ARSNOOP_TYPE:= "0001";
  constant C_ARSNOOP_ReadClean          : AXI_ARSNOOP_TYPE:= "0010";
  constant C_ARSNOOP_ReadNotSharedDirty : AXI_ARSNOOP_TYPE:= "0011";
  constant C_ARSNOOP_ReadUnique         : AXI_ARSNOOP_TYPE:= "0111";
  constant C_ARSNOOP_CleanUnique        : AXI_ARSNOOP_TYPE:= "1011";
  constant C_ARSNOOP_MakeUnique         : AXI_ARSNOOP_TYPE:= "1100";
  constant C_ARSNOOP_CleanShared        : AXI_ARSNOOP_TYPE:= "1000";
  constant C_ARSNOOP_CleanInvalid       : AXI_ARSNOOP_TYPE:= "1001";
  constant C_ARSNOOP_MakeInvalid        : AXI_ARSNOOP_TYPE:= "1101";
  constant C_ARSNOOP_DVMComplete        : AXI_ARSNOOP_TYPE:= "1110";
  constant C_ARSNOOP_DVMMessage         : AXI_ARSNOOP_TYPE:= "1111";
  constant C_ARSNOOP_Barrier            : AXI_ARSNOOP_TYPE:= "0000";
  
  constant C_AWSNOOP_WriteNoSnoop       : AXI_AWSNOOP_TYPE:= "000";
  constant C_AWSNOOP_WriteUnique        : AXI_AWSNOOP_TYPE:= "000";
  constant C_AWSNOOP_WriteLineUnique    : AXI_AWSNOOP_TYPE:= "001";
  constant C_AWSNOOP_WriteClean         : AXI_AWSNOOP_TYPE:= "010";
  constant C_AWSNOOP_WriteBack          : AXI_AWSNOOP_TYPE:= "011";
  constant C_AWSNOOP_Evict              : AXI_AWSNOOP_TYPE:= "100";
  constant C_AWSNOOP_WriteEvict         : AXI_AWSNOOP_TYPE:= "101";
  constant C_AWSNOOP_Barrier            : AXI_AWSNOOP_TYPE:= "000";
    
  constant C_ACSNOOP_ReadOnce           : AXI_ACSNOOP_TYPE:= "0000";
  constant C_ACSNOOP_ReadShared         : AXI_ACSNOOP_TYPE:= "0001";
  constant C_ACSNOOP_ReadClean          : AXI_ACSNOOP_TYPE:= "0010";
  constant C_ACSNOOP_ReadNotSharedDirty : AXI_ACSNOOP_TYPE:= "0011";
  constant C_ACSNOOP_ReadUnique         : AXI_ACSNOOP_TYPE:= "0111";
  constant C_ACSNOOP_CleanShared        : AXI_ACSNOOP_TYPE:= "1000";
  constant C_ACSNOOP_CleanInvalid       : AXI_ACSNOOP_TYPE:= "1001";
  constant C_ACSNOOP_MakeInvalid        : AXI_ACSNOOP_TYPE:= "1101";
  constant C_ACSNOOP_DVMComplete        : AXI_ACSNOOP_TYPE:= "1110";
  constant C_ACSNOOP_DVMMessage         : AXI_ACSNOOP_TYPE:= "1111";
  
  constant C_DVM_MSG_TLB_INVALIDATE     : DVM_MESSAGE_TYPE := "000";
  constant C_DVM_MSG_BP_INVALIDATE      : DVM_MESSAGE_TYPE := "001";
  constant C_DVM_MSG_PH_INSTR_INVAL     : DVM_MESSAGE_TYPE := "010";
  constant C_DVM_MSG_VIR_INSTR_INVAL    : DVM_MESSAGE_TYPE := "011";
  constant C_DVM_MSG_SYNC               : DVM_MESSAGE_TYPE := "100";
  constant C_DVM_MSG_HINT               : DVM_MESSAGE_TYPE := "110";
  
  constant C_DVM_OS_BOTH                : DVM_OS_TYPE      := "00";
  constant C_DVM_OS_RESERVED            : DVM_OS_TYPE      := "01";
  constant C_DVM_OS_GUEST               : DVM_OS_TYPE      := "10";
  constant C_DVM_OS_HYPERVISOR          : DVM_OS_TYPE      := "11";
  
  constant C_DVM_SECURE_BOTH            : DVM_SECURE_TYPE  := "00";
  constant C_DVM_SECURE_RESERVED        : DVM_SECURE_TYPE  := "01";
  constant C_DVM_SECURE_SECURE_ONLY     : DVM_SECURE_TYPE  := "10";
  constant C_DVM_SECURE_NONSECURE_ONLY  : DVM_SECURE_TYPE  := "11";
  
  
  -- ----------------------------------------
  -- Statistics Constants
  
  constant C_STAT_ADDR_OPT_CATEGORY         : natural :=  0;  -- 000
  constant C_STAT_ADDR_GEN_CATEGORY         : natural :=  1;  -- 020
  constant C_STAT_ADDR_ARB_CATEGORY         : natural :=  2;  -- 040
  constant C_STAT_ADDR_ACS_CATEGORY         : natural :=  3;  -- 060
  constant C_STAT_ADDR_LU_CATEGORY          : natural :=  4;  -- 080
  constant C_STAT_ADDR_UD_CATEGORY          : natural :=  5;  -- 0A0
  constant C_STAT_ADDR_BE_CATEGORY          : natural :=  6;  -- 0C0
  constant C_STAT_ADDR_CTRL_CATEGORY        : natural :=  7;  -- 0E0
  
  
  constant C_STAT_ADDR_OPT_RD_SEGMENTS      : natural :=  0;  -- 000
  constant C_STAT_ADDR_OPT_WR_SEGMENTS      : natural :=  1;  -- 020
  constant C_STAT_ADDR_OPT_RIP              : natural :=  2;  -- 040
  constant C_STAT_ADDR_OPT_R                : natural :=  3;  -- 060
  constant C_STAT_ADDR_OPT_BIP              : natural :=  4;  -- 080
  constant C_STAT_ADDR_OPT_BP               : natural :=  5;  -- 0A0
  constant C_STAT_ADDR_OPT_WIP              : natural :=  6;  -- 0C0
  constant C_STAT_ADDR_OPT_W                : natural :=  7;  -- 0E0
  constant C_STAT_ADDR_OPT_READ_BLOCK       : natural :=  8;  -- 100
  constant C_STAT_ADDR_OPT_WRITE_HIT        : natural :=  9;  -- 120
  constant C_STAT_ADDR_OPT_WRITE_MISS       : natural := 10;  -- 140
  constant C_STAT_ADDR_OPT_WRITE_MISS_DIRTY : natural := 11;  -- 160
  constant C_STAT_ADDR_OPT_READ_HIT         : natural := 12;  -- 180
  constant C_STAT_ADDR_OPT_READ_MISS        : natural := 13;  -- 1A0
  constant C_STAT_ADDR_OPT_READ_MISS_DIRTY  : natural := 14;  -- 1C0
  constant C_STAT_ADDR_OPT_LOCKED_WRITE_HIT : natural := 15;  -- 1E0
  constant C_STAT_ADDR_OPT_LOCKED_READ_HIT  : natural := 16;  -- 200
  constant C_STAT_ADDR_OPT_FIRST_WRITE_HIT  : natural := 17;  -- 220
  constant C_STAT_ADDR_OPT_RD_LATENCY       : natural := 18;  -- 240
  constant C_STAT_ADDR_OPT_WR_LATENCY       : natural := 19;  -- 260
  constant C_STAT_ADDR_OPT_RD_LAT_CONF      : natural := 20;  -- 280
  constant C_STAT_ADDR_OPT_WR_LAT_CONF      : natural := 21;  -- 2A0
  
  
  constant C_STAT_ADDR_GEN_RD_SEGMENTS      : natural :=  0;  -- 000
  constant C_STAT_ADDR_GEN_WR_SEGMENTS      : natural :=  1;  -- 020
  constant C_STAT_ADDR_GEN_RIP              : natural :=  2;  -- 040
  constant C_STAT_ADDR_GEN_R                : natural :=  3;  -- 060
  constant C_STAT_ADDR_GEN_BIP              : natural :=  4;  -- 080
  constant C_STAT_ADDR_GEN_BP               : natural :=  5;  -- 0A0
  constant C_STAT_ADDR_GEN_WIP              : natural :=  6;  -- 0C0
  constant C_STAT_ADDR_GEN_W                : natural :=  7;  -- 0E0
  constant C_STAT_ADDR_GEN_READ_BLOCK       : natural :=  8;  -- 100
  constant C_STAT_ADDR_GEN_WRITE_HIT        : natural :=  9;  -- 120
  constant C_STAT_ADDR_GEN_WRITE_MISS       : natural := 10;  -- 140
  constant C_STAT_ADDR_GEN_WRITE_MISS_DIRTY : natural := 11;  -- 160
  constant C_STAT_ADDR_GEN_READ_HIT         : natural := 12;  -- 180
  constant C_STAT_ADDR_GEN_READ_MISS        : natural := 13;  -- 1A0
  constant C_STAT_ADDR_GEN_READ_MISS_DIRTY  : natural := 14;  -- 1C0
  constant C_STAT_ADDR_GEN_LOCKED_WRITE_HIT : natural := 15;  -- 1E0
  constant C_STAT_ADDR_GEN_LOCKED_READ_HIT  : natural := 16;  -- 200
  constant C_STAT_ADDR_GEN_FIRST_WRITE_HIT  : natural := 17;  -- 220
  constant C_STAT_ADDR_GEN_RD_LATENCY       : natural := 18;  -- 240
  constant C_STAT_ADDR_GEN_WR_LATENCY       : natural := 19;  -- 260
  constant C_STAT_ADDR_GEN_RD_LAT_CONF      : natural := 20;  -- 280
  constant C_STAT_ADDR_GEN_WR_LAT_CONF      : natural := 21;  -- 2A0
  
  
  constant C_STAT_ADDR_ARB_VALID            : natural :=  0;  -- 000
  constant C_STAT_ADDR_ARB_CON_ACCESS       : natural :=  1;  -- 020
  
  
  constant C_STAT_ADDR_ACS_VALID            : natural :=  0;  -- 000
  constant C_STAT_ADDR_ACS_STALL            : natural :=  1;  -- 020
  constant C_STAT_ADDR_ACS_FETCH_STALL      : natural :=  2;  -- 040
  constant C_STAT_ADDR_ACS_REQ_STALL        : natural :=  3;  -- 060
  constant C_STAT_ADDR_ACS_ACT_STALL        : natural :=  4;  -- 080
  
  
  constant C_STAT_ADDR_LU_STALL             : natural :=  0;  -- 000
  constant C_STAT_ADDR_LU_FETCH_STALL       : natural :=  1;  -- 020
  constant C_STAT_ADDR_LU_MEM_STALL         : natural :=  2;  -- 040
  constant C_STAT_ADDR_LU_DATA_STALL        : natural :=  3;  -- 060
  constant C_STAT_ADDR_LU_DATA_HIT_STALL    : natural :=  4;  -- 080
  constant C_STAT_ADDR_LU_DATA_MISS_STALL   : natural :=  5;  -- 0A0
  
  
  constant C_STAT_ADDR_UD_STALL             : natural :=  0;  -- 000
  constant C_STAT_ADDR_UD_TAG_FREE          : natural :=  1;  -- 020
  constant C_STAT_ADDR_UD_DATA_FREE         : natural :=  2;  -- 040
  constant C_STAT_ADDR_UD_RI                : natural :=  3;  -- 060
  constant C_STAT_ADDR_UD_R                 : natural :=  4;  -- 080
  constant C_STAT_ADDR_UD_E                 : natural :=  5;  -- 0A0
  constant C_STAT_ADDR_UD_BS                : natural :=  6;  -- 0C0
  constant C_STAT_ADDR_UD_WM                : natural :=  7;  -- 0E0
  constant C_STAT_ADDR_UD_WMA               : natural :=  8;  -- 100
  
  
  constant C_STAT_ADDR_BE_AW                : natural :=  0;  -- 000
  constant C_STAT_ADDR_BE_W                 : natural :=  1;  -- 020
  constant C_STAT_ADDR_BE_AR                : natural :=  2;  -- 040
  constant C_STAT_ADDR_BE_AR_SEARCH_DEPTH   : natural :=  3;  -- 060
  constant C_STAT_ADDR_BE_AR_STALL          : natural :=  4;  -- 080
  constant C_STAT_ADDR_BE_AR_PROTECT_STALL  : natural :=  5;  -- 0A0
  constant C_STAT_ADDR_BE_RD_LATENCY        : natural :=  6;  -- 0C0
  constant C_STAT_ADDR_BE_WR_LATENCY        : natural :=  7;  -- 0E0
  constant C_STAT_ADDR_BE_RD_LAT_CONF       : natural :=  8;  -- 100
  constant C_STAT_ADDR_BE_WR_LAT_CONF       : natural :=  9;  -- 120
  
  
  constant C_STAT_ADDR_CTRL_RESET           : natural :=  0;  -- 000
  constant C_STAT_ADDR_CTRL_ENABLE          : natural :=  1;  -- 008
  constant C_STAT_ADDR_CTRL_CLEAN           : natural :=  2;  -- 010
  constant C_STAT_ADDR_CTRL_FLUSH           : natural :=  3;  -- 018
  constant C_STAT_ADDR_CTRL0_VERSION        : natural :=  4;  -- 020
  constant C_STAT_ADDR_CTRL1_VERSION        : natural :=  5;  -- 028
  constant C_STAT_ADDR_CTRL_DVM0            : natural :=  6;  -- 030
  constant C_STAT_ADDR_CTRL_DVM1            : natural :=  7;  -- 038
  constant C_STAT_ADDR_CTRL_BAR0            : natural :=  8;  -- 040
  constant C_STAT_ADDR_CTRL_BAR1            : natural :=  9;  -- 048
  constant C_STAT_ADDR_CTRL_SECURE_CLEAN    : natural := 10;  -- 050
  constant C_STAT_ADDR_CTRL_SECURE_FLUSH    : natural := 11;  -- 058
  constant C_STAT_ADDR_CTRL_SECURE_DVM0     : natural := 12;  -- 060
  constant C_STAT_ADDR_CTRL_SECURE_DVM1     : natural := 13;  -- 068
  constant C_STAT_ADDR_CTRL_SECURE_BAR0     : natural := 14;  -- 070
  constant C_STAT_ADDR_CTRL_SECURE_BAR1     : natural := 15;  -- 078
  
  
  -- Settings for read latency measurements
  -- 0: read latency  AR     -> RVALID ack
  -- 1: read latency  AR ack -> RVALID ack
  -- 2: read latency  AR     -> RLAST ack
  -- 3: read latency  AR ack -> RLAST ack
  
  -- Settings for write latency measurements
  -- 0: write latency AW     -> WVALID ack
  -- 1: write latency AW ack -> WVALID ack
  -- 2: write latency AW     -> WLAST ack
  -- 3: write latency AW ack -> WLAST ack
  -- 4: write latency AW     -> B ack
  -- 5: write latency AW ack -> B ack
  
  constant C_STAT_RD_LATENCY_VALID          : RD_LATENCY_TYPE := std_logic_vector(to_unsigned(0, C_RD_LATENCY_WIDTH));
  constant C_STAT_RD_LATENCY_ACK_VALID      : RD_LATENCY_TYPE := std_logic_vector(to_unsigned(1, C_RD_LATENCY_WIDTH));
  constant C_STAT_RD_LATENCY_LAST           : RD_LATENCY_TYPE := std_logic_vector(to_unsigned(2, C_RD_LATENCY_WIDTH));
  constant C_STAT_RD_LATENCY_ACK_LAST       : RD_LATENCY_TYPE := std_logic_vector(to_unsigned(3, C_RD_LATENCY_WIDTH));
  
  constant C_STAT_WR_LATENCY_VALID          : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(0, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_ACK_VALID      : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(1, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_LAST           : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(2, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_ACK_LAST       : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(3, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_BRESP          : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(4, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_ACK_BRESP      : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(5, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_RESEVED1       : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(6, C_WR_LATENCY_WIDTH));
  constant C_STAT_WR_LATENCY_RESEVED2       : WR_LATENCY_TYPE := std_logic_vector(to_unsigned(7, C_WR_LATENCY_WIDTH));
  
  constant C_STAT_DEFAULT_RD_LAT_CONF       : RD_LATENCY_TYPE :=  std_logic_vector(to_unsigned(0, C_RD_LATENCY_WIDTH));
  constant C_STAT_DEFAULT_WR_LAT_CONF       : WR_LATENCY_TYPE :=  std_logic_vector(to_unsigned(4, C_WR_LATENCY_WIDTH));
  
  constant C_STAT_POINT_EVENTS              : natural := 0;
  constant C_STAT_POINT_MIN_MAX_STATUS      : natural := 1;
  constant C_STAT_POINT_SUM                 : natural := 2;
  constant C_STAT_POINT_SUM_2               : natural := 3;
                                      
  constant C_STAT_FIFO_EMPTY_CYCLES         : natural := 0;
  constant C_STAT_FIFO_INDEX_UPDATES        : natural := 1;
  constant C_STAT_FIFO_INDEX_MAX            : natural := 2;
  constant C_STAT_FIFO_INDEX_SUM            : natural := 3;
  
  constant C_CTRL_CONF_ENABLE               : natural := 0;
  constant C_STAT_DEFAULT_CTRL_CONF         : CTRL_CONF_TYPE :=  std_logic_vector(to_unsigned(1, C_CTRL_CONF_WIDTH));
  
  
  -----------------------------------------------------------------------------
  -- System Cache Specific Functions
  -----------------------------------------------------------------------------
  
  -- Translate port vector to natural.
  function get_port_num(signal x : std_logic_vector(4 downto 0); constant y : natural) return natural;
  function get_way(signal x : std_logic_vector(C_MAX_WAYS_BITS - 1 downto 0); constant y : natural) return natural;
  
  -- Getnumber of common address bits.
  function Addr_Bits (x, y : std_logic_vector(0 to 63);
                      z    : natural) return natural;

  
end package system_cache_pkg;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

package body system_cache_pkg is

  -----------------------------------------------------------------------------
  -- Common Functions
  -----------------------------------------------------------------------------
  
  function conv_index (I : integer) return integer is
  begin
    case I is
      when 0 => return 0;
      when 1 => return 2;
      when 2 => return 8;
      when 3 => return 10;
      when 4 => return 16;
      when 5 => return 18;
      when 6 => return 24;
      when 7 => return 26;
      when 8 => return 1;
      when 9 => return 3;
      when 10 => return 9;
      when 11 => return 11;
      when 12 => return 17;
      when 13 => return 19;
      when 14 => return 25;
      when 15 => return 27;
      when 16 => return 4;
      when 17 => return 6;
      when 18 => return 12;
      when 19 => return 14;
      when 20 => return 20;
      when 21 => return 22;
      when 22 => return 28;
      when 23 => return 30;
      when 24 => return 5;
      when 25 => return 7;
      when 26 => return 13;
      when 27 => return 15;
      when 28 => return 21;
      when 29 => return 23;
      when 30 => return 29;
      when 31 => return 31;
      when others => return -1;
    end case;
  end function conv_index;


  -- log2 function returns the number of bits required to encode x choices
  function log2(x : natural) return integer is
    variable i  : integer := 0;   
  begin 
    if x = 0 then return 0;
    else
      while 2**i < x loop
        i := i+1;
      end loop;
      return i;
    end if;
  end function log2;

  function int_to_std(v : integer) return std_logic is
  begin
    if v /= 0 then 
      return '1';
    end if;
    
    return '0';
  end function int_to_std;
  
  function int_to_std(v, n : integer) return std_logic_vector is
  begin
    return std_logic_vector(to_unsigned(v, n));
  end function int_to_std;
  
  -- Convert boolean choice to std_logic
  function b2s (val : boolean) return std_logic is
  begin  -- function b2s
    if (val) then
      return '1';
    else
      return '0';
    end if;
  end function b2s;
  
  -- Convert std_logic choice to boolean
  function s2b (val : std_logic) return boolean is
  begin  -- function s2b
    if (val = '1') then
      return true;
    else
      return false;
    end if;
  end function s2b;
  
  -- Convert boolean choice to integer
  function b2i (val : boolean) return integer is
  begin  -- function b2i
    if (val) then
      return 1;
    else
      return 0;
    end if;
  end function b2i;
  
  -- Convert integer choice to boolean
  function i2b (val : integer) return boolean is
  begin  -- function i2b
    if (val /= 0) then
      return true;
    else
      return false;
    end if;
  end function i2b;
  
  -- Convert integer choice to std_logic
  function i2s (val : integer) return std_logic is
  begin  -- function i2s
    if (val /= 0) then
      return '1';
    else
      return '0';
    end if;
  end function i2s;
  
  -- Convert std_logic choice to integer
  function s2i (val : std_logic) return integer is
  begin  -- function s2i
    if (val = '1') then
      return 1;
    else
      return 0;
    end if;
  end function s2i;
  
  -- Convert to integer.
  function to_int(v : std_logic_vector) return integer is
  begin
    return to_integer(unsigned(v));
  end function to_int;
  
  
  function fit_vec(v : std_logic_vector; w : integer) return std_logic_vector is
    variable tmp    : std_logic_vector(w-1 downto 0) := (others=>'0');
  begin
    if v'ascending then
      tmp(min_of(v'right - v'left,  w - 1) downto 0) := v(v'right - min_of(v'right - v'left, w - 1)     to v'right);
    else
      tmp(min_of(v'left - v'right,  w - 1) downto 0) := v(v'right + min_of(v'left - v'right, w - 1) downto v'right);
    end if;
    
    return tmp;
  end function fit_vec;
  
  function sel(s : boolean; x,y : integer) return integer is
  begin
    if s then 
      return x;
    end if;
    
    return y;
  end function sel;
  
  function sel(s : boolean; x,y : std_logic) return std_logic is
  begin
    if s then 
      return x;
    end if;
    
    return y;
  end function sel;
  
  function sel(s : boolean; x,y : std_logic_vector) return std_logic_vector is
  begin
    if s then 
      return x;
    end if;
    
    return y;
  end function sel;
  
  function max_of(x,y : integer) return integer is
  begin
    if x > y then 
      return x;
    end if;
    
    return y;
  end function max_of;
  
  function min_of(x,y : integer) return integer is
  begin
    if x < y then 
      return x;
    end if;
    
    return y;
  end function min_of;
  
  function is_on(x : integer) return integer is
  begin
    if x > 0 then 
      return 1;
    end if;
    
    return 0;
  end function is_on;

  function is_off(x : integer) return integer is
  begin
    if x > 0 then 
      return 0;
    end if;
    
    return 1;
  end function is_off;

  
  
  function reduce_or(x : std_logic_vector) return std_logic is
    variable r : std_logic := '0';
  begin
    for i in x'range loop
      r := r or x(i);
    end loop;
    
    return r;
  end function reduce_or;
  
  
  function reduce_and(x : std_logic_vector) return std_logic is
    variable r : std_logic := '1';
  begin
    for i in x'range loop
      r := r and x(i);
    end loop;
    
    return r;
  end function reduce_and;
  
  
  function reduce_xor(x : std_logic_vector) return std_logic is
    variable r : std_logic := '0';
  begin
    for i in x'range loop
      r := r xor x(i);
    end loop;
    
    return r;
  end function reduce_xor;
  
  
  function reduce_or_except(x : std_logic_vector; y : integer) return std_logic is
    variable r : std_logic := '0';
  begin
    for i in x'range loop
      if( i /= y ) then
        r := r or x(i);
      end if;
    end loop;
    
    return r;
  end function reduce_or_except;
  
  
  function reduce_and_except(x : std_logic_vector; y : integer) return std_logic is
    variable r : std_logic := '1';
  begin
    for i in x'range loop
      if( i /= y ) then
        r := r and x(i);
      end if;
    end loop;
    
    return r;
  end function reduce_and_except;
  
  
  function reduce_xor_except(x : std_logic_vector; y : integer) return std_logic is
    variable r : std_logic := '0';
  begin
    for i in x'range loop
      if( i /= y ) then
        r := r xor x(i);
      end if;
    end loop;
    
    return r;
  end function reduce_xor_except;
  
  
  function rev_vec(x : std_logic_vector) return std_logic_vector is
    variable r : std_logic_vector(x'reverse_range) := (others=>'0');
  begin
    for i in x'range loop
      r(i) := x(i);
    end loop;
    
    return r;
  end function rev_vec;
  
  
  
  
  
  
  -- Function for resolved boolean
  -- If any boolean in the array is false, then the result is false
  function resolve_boolean( values : in boolean_array ) return boolean is
    variable result: boolean := TRUE;
  begin
    if (values'length = 1) then
       result := values(values'low);
    else
       for I in values'range loop
          if values(I) = FALSE then
             result := FALSE;
          end if;
       end loop;
    end if;
    return result;
  end function resolve_boolean; 

  -- Function to or two integer booleans
  function intbool_or( constant a : integer; constant b : integer) return integer is
    variable result : integer := 0;
  begin
    if a /= 0 then
       result := 1;
    end if;
    if b /= 0 then
       result := 1;
    end if;
    return result;
  end function intbool_or;

  -- Function for resolved integer
  -- The result is the bitwise "or" of the integers
  function resolve_integer( values : in integer_array ) return integer is
    variable result   : integer := 0;
    variable result_s : signed(31 downto 0) := (others => '0');
    variable value_s  : signed(31 downto 0);
  begin
    if (values'length = 1) then
      result := values(values'low);
    else
      for I in values'range loop
        if values(I) < -2147483647 then
          value_s := X"80000000";
        elsif values(I) < 0 then
          value_s := '1' & to_signed((2147483647 + values(I)) + 1, 31);
        else
          value_s := '0' & to_signed(values(I), 31);
        end if;
        result_s := result_s or value_s;
      end loop;
      result := to_integer(result_s);
    end if;
    return result;
  end function resolve_integer;

  function LowerCase_Char(char : character) return character is
  begin
    -- If char is not an upper case letter then return char
    if char < 'A' or char > 'Z' then
      return char;
    end if;
    -- Otherwise map char to its corresponding lower case character and
    -- return that
    case char is
      when 'A'    => return 'a'; when 'B' => return 'b'; when 'C' => return 'c'; when 'D' => return 'd';
      when 'E'    => return 'e'; when 'F' => return 'f'; when 'G' => return 'g'; when 'H' => return 'h';
      when 'I'    => return 'i'; when 'J' => return 'j'; when 'K' => return 'k'; when 'L' => return 'l';
      when 'M'    => return 'm'; when 'N' => return 'n'; when 'O' => return 'o'; when 'P' => return 'p';
      when 'Q'    => return 'q'; when 'R' => return 'r'; when 'S' => return 's'; when 'T' => return 't';
      when 'U'    => return 'u'; when 'V' => return 'v'; when 'W' => return 'w'; when 'X' => return 'x';
      when 'Y'    => return 'y'; when 'Z' => return 'z';
      when others => return char;
    end case;
  end LowerCase_Char;

  function LowerCase_String (s : string) return string is
    variable res : string(s'range);
  begin  -- function LowerCase_String
    for I in s'range loop
      res(I) := LowerCase_Char(s(I));
    end loop;  -- I
    return res;
  end function LowerCase_String;

  -- Returns true if case insensitive string comparison determines that
  -- str1 and str2 are equal
  function Equal_String( str1, str2 : STRING ) RETURN BOOLEAN IS
    CONSTANT len1 : INTEGER := str1'length;
    CONSTANT len2 : INTEGER := str2'length;
    VARIABLE equal : BOOLEAN := TRUE;
  BEGIN
    IF NOT (len1=len2) THEN
      equal := FALSE;
    ELSE
      FOR i IN str1'range LOOP
        IF NOT (LowerCase_Char(str1(i)) = LowerCase_Char(str2(i))) THEN
          equal := FALSE;
        END IF;
      END LOOP;
    END IF;

    RETURN equal;
  END Equal_String;

  function String_To_Family (S : string; Select_RTL : boolean) return TARGET_FAMILY_TYPE is
  begin  -- function String_To_Family
    if ((Select_RTL) or Equal_String(S, "rtl")) then
      return RTL;
    elsif Equal_String(S, "virtex7") or Equal_String(S, "qvirtex7") then
      return VIRTEX7;
    elsif Equal_String(S, "kintex7")  or Equal_String(S, "kintex7l")  or
          Equal_String(S, "qkintex7") or Equal_String(S, "qkintex7l") then
      return KINTEX7;
    elsif Equal_String(S, "artix7")  or Equal_String(S, "artix7l")  or Equal_String(S, "aartix7") or
          Equal_String(S, "qartix7") or Equal_String(S, "qartix7l") then
      return ARTIX7;
    elsif Equal_String(S, "zynq")  or Equal_String(S, "azynq") or Equal_String(S, "qzynq") then
      return ZYNQ;
    elsif Equal_String(S, "virtexu") or Equal_String(S, "qvirtexu") then
      return VIRTEXU;
    elsif Equal_String(S, "kintexu")  or Equal_String(S, "kintexul")  or
          Equal_String(S, "qkintexu") or Equal_String(S, "qkintexul") then
      return KINTEXU;
    elsif Equal_String(S, "zynquplus") or Equal_String(S, "zynquplusRFSOC") then
      return ZYNQUPLUS;
    elsif Equal_String(S, "virtexuplus") or Equal_String(S, "virtexuplusHBM") then
      return VIRTEXUPLUS;
    elsif Equal_String(S, "kintexuplus") then
      return KINTEXUPLUS;
    elsif Equal_String(S, "spartan7") then
      return SPARTAN7;
    else
      assert (false) report "No known target family" severity failure;
      return RTL;
    end if;
  end function String_To_Family;

  function Family_To_LUT_Size(Family : TARGET_FAMILY_TYPE) return integer is
  begin  -- function String_To_Family
    return 6;
  end function Family_To_LUT_Size;

  function Has_Target(Family : TARGET_FAMILY_TYPE; TARGET_PROP : TARGET_PROPERTY_TYPE) return boolean is
  begin
    case TARGET_PROP is
      when LATCH_AS_LOGIC        => return (Family = VIRTEX7)    or
                                           (Family = KINTEX7)    or (Family = ARTIX7)      or (Family = ZYNQ)        or
                                           (Family = VIRTEXU)    or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7);

      when DUAL_DFF              => return (Family = VIRTEX7)    or
                                           (Family = KINTEX7)    or (Family = ARTIX7)      or (Family = ZYNQ)        or
                                           (Family = VIRTEXU)    or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7);

      when BRAM_WITH_BYTE_ENABLE => return (Family = VIRTEX7)    or (Family = KINTEX7)     or (Family = ARTIX7)      or
                                           (Family = ZYNQ)       or (Family = VIRTEXU)     or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7);

      when BRAM_XPM              => return false;

      when BRAM_36k              => return (Family = VIRTEX7)    or
                                           (Family = KINTEX7)    or (Family = ARTIX7)      or (Family = ZYNQ)        or
                                           (Family = VIRTEXU)    or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7)   or (Family = RTL);

      when BRAM_16K_WE           => return false;
      when DSP                   => return (Family = VIRTEX7)    or
                                           (Family = KINTEX7)    or (Family = ARTIX7)      or (Family = ZYNQ)        or
                                           (Family = VIRTEXU)    or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7);
      when DSP48_V4              => return false;
      when DSP48_A               => return false;
      when DSP48_E               => return (Family = VIRTEX7)    or
                                           (Family = KINTEX7)    or (Family = ARTIX7)      or (Family = ZYNQ)        or
                                           (Family = VIRTEXU)    or (Family = KINTEXU)     or
                                           (Family = ZYNQUPLUS)  or (Family = VIRTEXUPLUS) or (Family = KINTEXUPLUS) or
                                           (Family = SPARTAN7);

      when others                => return false;
    end case;
  end function Has_Target;
  
  
  function RESOLVE_MST_SNOOP_ACK(values : in MST_SNOOP_ACK_VECTOR_TYPE ) return MST_SNOOP_ACK_TYPE is
  begin
    return values(values'low);
  end function RESOLVE_MST_SNOOP_ACK; 
  
  function RESOLVE_MST_SNOOP_HAZ(values : in MST_SNOOP_HAZ_VECTOR_TYPE ) return MST_SNOOP_HAZ_TYPE is
  begin
    return values(values'low);
  end function RESOLVE_MST_SNOOP_HAZ; 
  
  function RESOLVE_MST_SNOOP_ADDR(values : in MST_SNOOP_ADDR_VECTOR_TYPE ) return MST_SNOOP_ADDR_TYPE is
  begin
    return values(values'low);
  end function RESOLVE_MST_SNOOP_ADDR; 
  
  
  -----------------------------------------------------------------------------
  -- System Cache Specific Functions
  -----------------------------------------------------------------------------
  
  -- Translate port vector to natural.
  function get_port_num(signal x : std_logic_vector(4 downto 0); constant y : natural) return natural is
    constant z : natural:= log2(y);
    variable r : natural range 0 to y;
  begin 
    if( y = 1 ) then
      return 0;
    else
      r := to_integer(unsigned(x(z-1 downto 0)));
      
-- pragma xilinx_rtl_off
      if( r >= y ) then
        r := 0;
      end if;
-- pragma xilinx_rtl_on
      
      return r;
    end if;
  end function get_port_num;
  
  function get_way(signal x : std_logic_vector(C_MAX_WAYS_BITS - 1 downto 0); constant y : natural) return natural is
    constant z : natural:= log2(y);
  begin 
    if( y = 1 ) then
      return 0;
    else
      return to_integer(unsigned(x(z-1 downto 0)));
    end if;
  end function get_way;
  
  
  -- Getnumber of common address bits.
  function Addr_Bits (x, y : std_logic_vector(0 to 63);
                      z    : natural) return natural is
    variable addr_xor : std_logic_vector(0 to 63);
  begin
    addr_xor := x xor y;
    if addr_xor(0) = '1' then
      return 1;
    end if;
    for i in 0 to 63 loop
      if addr_xor(i) = '1' then return i;
      end if;
    end loop;
    
    return 32;
  end function Addr_Bits;
  
  
  function To_StdVec(from : ARBITRATION_TYPE) return std_logic_vector is
  begin
    return from.Size &  from.Domain &  from.Barrier & from.Snoop & from.Prot & from.Ignore_Data & from.Evict & 
           from.Bufferable &  from.Allocate &  from.Exclusive & from.Kind &  from.Len &  from.Addr &  
           from.Port_Num &  from.Wr & from.Valid;
  end function To_StdVec;
  
  
  function To_StdVec(from : ACCESS_TYPE) return std_logic_vector is
  begin
    return from.Size &  from.Len &  from.Addr & from.Wr &  from.Kind &  
           from.Evict &  from.Exclusive & from.Allocate & from.Port_Num;
  end function To_StdVec;
  
  
  function To_StdVec(from : STAT_POINT_TYPE) return std_logic_vector is
  begin
    return from.Sum_2 &  from.Sum & from.Min_Max_Status & from.Events;
  end function To_StdVec;
  
  function To_StdVec(from : STAT_FIFO_TYPE) return std_logic_vector is
  begin
    return from.Index_Sum &  from.Index_Max & from.Index_Updates & from.Empty_Cycles;
  end function To_StdVec;
  
  
  function Stat_Get_Register(from : STAT_VECTOR_TYPE; 
                             idx  : natural) return STAT_TYPE is
  begin
    return from(idx);
  end function Stat_Get_Register;
                             
                             
  function Stat_Point_Get_Register(from : STAT_POINT_TYPE; 
                                   idx : natural range 0 to 7) return STAT_TYPE is
  begin
    case idx is
      when C_STAT_POINT_EVENTS =>
        return from.Events;
      when C_STAT_POINT_MIN_MAX_STATUS =>
        return from.Min_Max_Status;
      when C_STAT_POINT_SUM =>
        return from.Sum;
      when others =>
        return from.Sum_2;
    end case;
  end function Stat_Point_Get_Register;
  
  
  function Stat_FIFO_Get_Register(from : STAT_FIFO_TYPE; 
                                  idx : natural range 0 to 7) return STAT_TYPE is
  begin
    case idx is
      when C_STAT_FIFO_EMPTY_CYCLES =>
        return from.Empty_Cycles;
      when C_STAT_FIFO_INDEX_UPDATES =>
        return from.Index_Updates;
      when C_STAT_FIFO_INDEX_MAX =>
        return from.Index_Max;
      when others =>
        return from.Index_Sum;
    end case;
  end function Stat_FIFO_Get_Register;
  
  
  function Stat_Conf_Get_Register(from : STAT_CONF_VECTOR_TYPE; 
                                  idx  : natural) return STAT_TYPE is
  begin
    return Stat_Conf_Get_Register(from(idx));
  end function Stat_Conf_Get_Register;
  
  
  function Stat_Conf_Get_Register(from : STAT_CONF_TYPE) return STAT_TYPE is
    variable tmp : STAT_TYPE:= (others=>'0');
  begin
    tmp := (others=>'0');
    tmp(min_of(C_MAX_STAT_WIDTH, C_MAX_STAT_CONF_WIDTH) - 1 downto 0) := 
                            from(min_of(C_MAX_STAT_WIDTH, C_MAX_STAT_CONF_WIDTH) - 1 downto 0);
    return tmp;
  end function Stat_Conf_Get_Register;
  
  function Stat_Conf_Set_Register(from : std_logic_vector; 
                                  w    : natural) return STAT_CONF_TYPE is
    variable tmp : STAT_CONF_TYPE:= (others=>'0');
  begin
    tmp := (others=>'0');
    tmp(min_of(w, C_MAX_STAT_CONF_WIDTH) - 1 downto 0) := from(min_of(w, C_MAX_STAT_CONF_WIDTH) - 1 downto 0);
    return tmp;
  end function Stat_Conf_Set_Register;

  
  function Stat_Get_Register_32bit(from : STAT_VECTOR_TYPE; 
                                   idx  : natural;
                                   word : natural range 0 to 1) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_Get_Register(from, idx);
    
    if( word = 0 ) then
      return tmp(31 downto  0);
    else
      return tmp(63 downto 32);
    end if;
  end function Stat_Get_Register_32bit;
  
  function Stat_Get_Register_64bit(from : STAT_VECTOR_TYPE; 
                                   idx  : natural) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_Get_Register(from, idx);
    
    return tmp;
  end function Stat_Get_Register_64bit;
  
  
  function Stat_Point_Get_Register_32bit(from : STAT_POINT_TYPE; 
                                         idx  : natural range 0 to 7;
                                         word : natural range 0 to 1) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_Point_Get_Register(from, idx);
    
    if( word = 0 ) then
      return tmp(31 downto  0);
    else
      return tmp(63 downto 32);
    end if;
  end function Stat_Point_Get_Register_32bit;
  
  function Stat_Point_Get_Register_64bit(from : STAT_POINT_TYPE; 
                                         idx  : natural range 0 to 7) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_Point_Get_Register(from, idx);
    
    return tmp;
  end function Stat_Point_Get_Register_64bit;
  
  
  function Stat_FIFO_Get_Register_32bit(from  : STAT_FIFO_TYPE; 
                                        idx   : natural range 0 to 7;
                                        word  : natural range 0 to 1) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_FIFO_Get_Register(from, idx);
    
    if( word = 0 ) then
      return tmp(31 downto  0);
    else
      return tmp(63 downto 32);
    end if;
  end function Stat_FIFO_Get_Register_32bit;
  
  function Stat_FIFO_Get_Register_64bit(from  : STAT_FIFO_TYPE; 
                                        idx   : natural range 0 to 7) return std_logic_vector is
    variable tmp : std_logic_vector(63 downto 0):= (others=>'0');
  begin
    tmp(C_MAX_STAT_WIDTH - 1 downto 0) := Stat_FIFO_Get_Register(from, idx);
    
    return tmp;
  end function Stat_FIFO_Get_Register_64bit;
  
  
  function is_slv_coherent(c : integer) return integer is
  begin
    if ( c = 1 ) then
      return 1;
    else
      return 0;
    end if;
  end function is_slv_coherent;
  function is_slv_coherent(c : integer) return boolean is
  begin
    return ( is_slv_coherent(c) = 1 );
  end function is_slv_coherent;
  
  
  function is_mst_coherent(c : integer) return integer is
  begin
    if ( c > 1 ) then
      return 1;
    else
      return 0;
    end if;
  end function is_mst_coherent;

  function is_mst_coherent(c : integer) return boolean is
  begin
    return ( is_mst_coherent(c) = 1 );
  end function is_mst_coherent;

  function has_ex_mon(e : integer) return boolean is
  begin
    return ( e = 1 );
  end function has_ex_mon;
  
  function get_block(x : std_logic_vector; constant va, nb : integer) return integer is
    variable lx : std_logic_vector(C_MAX_ADDR_WIDTH - va - 1 downto C_MAX_ADDR_WIDTH - va - Log2(nb));
    variable i  : integer;
  begin
    lx    := x(lx'range);
    
    return ( to_int(lx) mod nb );
  end function get_block;
  
  function has_debug(e : boolean) return string is
  begin  -- function LowerCase_String
    if( e ) then
      return "TRUE";
    end if;
    
    return "FALSE";
  end function has_debug;

end package body system_cache_pkg;








library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


package system_cache_queue_pkg is

  -----------------------------------------------------------------------------
  -- System Cache Queue Specific Constants
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Types for Queue.
  
  constant C_QUEUE_LENGTH             : integer:= 16;
  constant C_QUEUE_LENGTH_BITS        : integer:= log2(C_QUEUE_LENGTH);
  subtype QUEUE_ADDR_POS              is natural range C_QUEUE_LENGTH - 1 downto 0;
  subtype QUEUE_ADDR_TYPE             is std_logic_vector(C_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_QUEUE_ALMOST_EMPTY       : QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(0, 
                                                                                        C_QUEUE_LENGTH_BITS));
  constant C_QUEUE_EMPTY              : QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 1, 
                                                                                        C_QUEUE_LENGTH_BITS));
  constant C_QUEUE_ALMOST_FULL        : QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 3, 
                                                                                        C_QUEUE_LENGTH_BITS));
  constant C_QUEUE_FULL               : QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 2, 
                                                                                        C_QUEUE_LENGTH_BITS));
  
  constant C_BIG_QUEUE_LENGTH         : integer:= 32;
  constant C_BIG_QUEUE_LENGTH_BITS    : integer:= log2(C_BIG_QUEUE_LENGTH);
  subtype BIG_QUEUE_ADDR_POS          is natural range C_BIG_QUEUE_LENGTH - 1 downto 0;
  subtype BIG_QUEUE_ADDR_TYPE         is std_logic_vector(C_BIG_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_BIG_QUEUE_ALMOST_EMPTY   : BIG_QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(0, 
                                                                                            C_BIG_QUEUE_LENGTH_BITS));
  constant C_BIG_QUEUE_EMPTY          : BIG_QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 1, 
                                                                                            C_BIG_QUEUE_LENGTH_BITS));
  constant C_BIG_QUEUE_ALMOST_FULL    : BIG_QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 3, 
                                                                                            C_BIG_QUEUE_LENGTH_BITS));
  constant C_BIG_QUEUE_FULL           : BIG_QUEUE_ADDR_TYPE := std_logic_vector(to_unsigned(C_QUEUE_LENGTH - 2, 
                                                                                            C_BIG_QUEUE_LENGTH_BITS));

  
end package system_cache_queue_pkg;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

package body system_cache_queue_pkg is

end package body system_cache_queue_pkg;


-------------------------------------------------------------------------------
-- sc_primitives.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        srl_fifo_counter.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              srl_fifo_counter.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_and_di is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE
    );
  port (
    Carry_IN  : in  std_logic;
    A         : in  std_logic;
    DI        : in  std_logic;
    Carry_OUT : out std_logic);
end entity carry_and_di;


architecture IMP of carry_and_di is
  signal carry_out_i : std_logic;
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate
  begin
    MUXCY_I : MUXCY_L
      port map (
        DI => DI,
        CI => Carry_IN,
        S  => A,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate
    signal a_loc    : std_logic;
    attribute KEEP  : string;
    attribute KEEP  of a_loc  : signal is "true";
  begin
    a_loc <= A;
    MUXCY_I : MUXCY_L
      port map (
        DI => DI,
        CI => Carry_IN,
        S  => a_loc,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= Carry_IN when A = '1' else DI;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_and is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE
    );
  port (
    Carry_IN  : in  std_logic;
    A         : in  std_logic;
    Carry_OUT : out std_logic);
end entity carry_and;


architecture IMP of carry_and is
  signal carry_out_i : std_logic;
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate
  begin
    MUXCY_I : MUXCY_L
      port map (
        DI => '0',
        CI => Carry_IN,
        S  => A,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate
    signal a_loc    : std_logic;
    attribute KEEP  : string;
    attribute KEEP  of a_loc  : signal is "true";
  begin
    a_loc <= A;
    MUXCY_I : MUXCY_L
      port map (
        DI => '0',
        CI => Carry_IN,
        S  => a_loc,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= Carry_IN when A = '1' else '0';
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_and_n is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE
    );
  port (
    Carry_IN  : in  std_logic;
    A_N       : in  std_logic;
    Carry_OUT : out std_logic);
end entity carry_and_n;


architecture IMP of carry_and_n is
  signal carry_out_i : std_logic;
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate
    signal A : std_logic;
  begin
    A <= not A_N;
    MUXCY_I : MUXCY_L
      port map (
        DI => '0',
        CI => Carry_IN,
        S  => A,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate
    signal A : std_logic;
    attribute KEEP  : string;
    attribute KEEP  of A  : signal is "true";
  begin
    A <= not A_N;
    MUXCY_I : MUXCY_L
      port map (
        DI => '0',
        CI => Carry_IN,
        S  => A,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= Carry_IN when A_N = '0' else '0';
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_or is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE
  );
  port (
    Carry_IN  : in  std_logic;
    A         : in  std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_or;


architecture IMP of carry_or is
  signal carry_out_i : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate
    signal A_N : std_logic;
  begin
    A_N <= not A;
    MUXCY_I : MUXCY_L
      port map (
        DI => '1',
        CI => Carry_IN,
        S  => A_N,
        LO => carry_out_i);
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate
    signal A_N : std_logic;
    attribute KEEP  : string;
    attribute KEEP  of A_N  : signal is "true";
  begin
    A_N <= not A;
    MUXCY_I : MUXCY_L
      port map (
        DI => '1',
        CI => Carry_IN,
        S  => A_N,
        LO => carry_out_i);
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= '1' when A = '1' else Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_or_n is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE
  );
  port (
    Carry_IN  : in  std_logic;
    A_N       : in  std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_or_n;


architecture IMP of carry_or_n is
  signal carry_out_i : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate
  begin
    MUXCY_I : MUXCY_L
      port map (
        DI => '1',
        CI => Carry_IN,
        S  => A_N,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate
    signal a_loc    : std_logic;
    attribute KEEP  : string;
    attribute KEEP  of a_loc  : signal is "true";
  begin
    a_loc <= A_N;
    MUXCY_I : MUXCY_L
      port map (
        DI => '1',
        CI => Carry_IN,
        S  => a_loc,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= '1' when A_N = '0' else Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_vec_or is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_INPUTS  : natural;
    C_SIZE    : natural
  );
  port (
    Carry_IN  : in  std_logic;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_OUT : out std_logic
  );
end entity carry_vec_or;


architecture IMP of carry_vec_or is

  component carry_or is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_or;

  constant C_INPUTS_PER_BIT : integer := C_INPUTS;
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  

begin  -- architecture IMP

  assign_sigs : process (A_Vec) is
  begin  -- process assign_sigs
    A                     <= (others => '0');
    A(C_SIZE-1 downto 0)  <= A_Vec;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '0';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I or A(C_BITS_PER_LUT * I + J);
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_or
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_vec_and_n is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_INPUTS  : natural;
    C_SIZE    : natural
  );
  port (
    Carry_IN  : in  std_logic;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_OUT : out std_logic
  );
end entity carry_vec_and_n;


architecture IMP of carry_vec_and_n is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

  constant C_INPUTS_PER_BIT : integer := C_INPUTS;
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  

begin  -- architecture IMP

  assign_sigs : process (A_Vec) is
  begin  -- process assign_sigs
    A                     <= (others => '0');
    A(C_SIZE-1 downto 0)  <= A_Vec;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I and not A(C_BITS_PER_LUT * I + J);
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_latch_and is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_NUM_PAD : natural := 0;
    C_INV_C   : boolean
  );
  port (
    Carry_IN  : in  std_logic;
    A         : in  std_logic;
    O         : out std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_latch_and;


architecture IMP of carry_latch_and is
  signal carry_out_i  : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL) generate
    signal carry_pad   : std_logic_vector(C_NUM_PAD downto 0);
    signal carry_value : std_logic;
    signal A_N         : std_logic;
  begin
    carry_pad(0)  <= Carry_IN;
    
    The_Pad : for I in 0 to C_NUM_PAD - 1 generate
    begin
      MUXCY_Inst: MUXCY_L
        port map (
          DI => '0',                          -- [in  std_logic]
          CI => carry_pad(I),                 -- [in  std_logic]
          S  => '1',                          -- [in  std_logic]
          LO => carry_pad(I+1)                -- [out std_logic]
        );
    end generate The_Pad;
    
    Using_Inv : if (C_INV_C) generate
      signal carry_point : std_logic;
    begin
      Using_Pad : if ( C_NUM_PAD > 0 ) generate
      begin
        carry_point   <= carry_pad(carry_pad'left - 1);
        Carry_OUT     <= carry_pad(carry_pad'left);
      end generate Using_Pad;
      No_Pad : if ( C_NUM_PAD = 0 ) generate
      begin
        MUXCY_Inst1: MUXCY_L
          port map (
            DI => '0',                          -- [in  std_logic]
            CI => Carry_IN,                     -- [in  std_logic]
            S  => '1',                          -- [in  std_logic]
            LO => carry_out_i                   -- [out std_logic]
          );
          
        carry_point   <= Carry_IN;
        Carry_OUT     <= carry_out_i;
      end generate No_Pad;
      
      XORCY_Inst1: XORCY
        port map (
          LI => '1',                          -- [in  std_logic]
          CI => carry_point,                  -- [in  std_logic]
          O  => carry_value                   -- [out std_logic]
        );
      
    end generate Using_Inv;
    No_Inv : if (not C_INV_C) generate
    begin
      carry_value   <= carry_pad(carry_pad'left);
      Carry_OUT     <= carry_pad(carry_pad'left);
    end generate No_Inv;
    
    A_N <= not A;
    
    AND2B1L_Inst1 : AND2B1L
      port map (
        O   => O,                           -- [out std_logic]
        DI  => carry_value,                 -- [in  std_logic]
        SRI => A_N                          -- [in  std_logic]
      );
  
  end generate Using_FPGA;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    O         <= (     Carry_IN ) and A when not C_INV_C else 
                 ( not Carry_IN ) and A;
    Carry_OUT <=       Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_latch_and_n is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_NUM_PAD : natural := 0;
    C_INV_C   : boolean
  );
  port (
    Carry_IN  : in  std_logic;
    A_N       : in  std_logic;
    O         : out std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_latch_and_n;


architecture IMP of carry_latch_and_n is
  signal carry_out_i : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL) generate
    signal carry_pad   : std_logic_vector(C_NUM_PAD downto 0);
    signal carry_value : std_logic;
  begin
    carry_pad(0)  <= Carry_IN;
    
    The_Pad : for I in 0 to C_NUM_PAD - 1 generate
    begin
      MUXCY_Inst: MUXCY_L
        port map (
          DI => '0',                          -- [in  std_logic]
          CI => carry_pad(I),                 -- [in  std_logic]
          S  => '1',                          -- [in  std_logic]
          LO => carry_pad(I+1)                -- [out std_logic]
        );
    end generate The_Pad;
    
    Using_Inv : if (C_INV_C) generate
      signal carry_point : std_logic;
    begin
      Using_Pad : if ( C_NUM_PAD > 0 ) generate
      begin
        carry_point   <= carry_pad(carry_pad'left - 1);
        Carry_OUT     <= carry_pad(carry_pad'left);
      end generate Using_Pad;
      No_Pad : if ( C_NUM_PAD = 0 ) generate
      begin
        MUXCY_Inst1: MUXCY_L
          port map (
            DI => '0',                          -- [in  std_logic]
            CI => Carry_IN,                     -- [in  std_logic]
            S  => '1',                          -- [in  std_logic]
            LO => carry_out_i                   -- [out std_logic]
          );
          
        carry_point   <= Carry_IN;
        Carry_OUT     <= carry_out_i;
      end generate No_Pad;
      
      XORCY_Inst1: XORCY
        port map (
          LI => '1',                          -- [in  std_logic]
          CI => carry_point,                  -- [in  std_logic]
          O  => carry_value                   -- [out std_logic]
        );
      
    end generate Using_Inv;
    No_Inv : if (not C_INV_C) generate
    begin
      carry_value   <= carry_pad(carry_pad'left);
      Carry_OUT     <= carry_pad(carry_pad'left);
    end generate No_Inv;
        
    AND2B1L_Inst1 : AND2B1L
      port map (
        O   => O,                           -- [out std_logic]
        DI  => carry_value,                 -- [in  std_logic]
        SRI => A_N                          -- [in  std_logic]
      );
  
  end generate Using_FPGA;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    O         <= (     Carry_IN ) and not A_N when not C_INV_C else 
                 ( not Carry_IN ) and not A_N;
    Carry_OUT <=       Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_latch_or is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_NUM_PAD : natural := 0;
    C_INV_C   : boolean
  );
  port (
    Carry_IN  : in  std_logic;
    A         : in  std_logic;
    O         : out std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_latch_or;


architecture IMP of carry_latch_or is
  signal carry_out_i : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL) generate
    signal carry_pad   : std_logic_vector(C_NUM_PAD downto 0);
    signal carry_value : std_logic;
  begin
    carry_pad(0)  <= Carry_IN;
    
    The_Pad : for I in 0 to C_NUM_PAD - 1 generate
    begin
      MUXCY_Inst: MUXCY_L
        port map (
          DI => '0',                          -- [in  std_logic]
          CI => carry_pad(I),                 -- [in  std_logic]
          S  => '1',                          -- [in  std_logic]
          LO => carry_pad(I+1)                -- [out std_logic]
        );
    end generate The_Pad;
    
    Using_Inv : if (C_INV_C) generate
      signal carry_point : std_logic;
    begin
      Using_Pad : if ( C_NUM_PAD > 0 ) generate
      begin
        carry_point   <= carry_pad(carry_pad'left - 1);
        Carry_OUT     <= carry_pad(carry_pad'left);
      end generate Using_Pad;
      No_Pad : if ( C_NUM_PAD = 0 ) generate
      begin
        MUXCY_Inst1: MUXCY_L
          port map (
            DI => '0',                          -- [in  std_logic]
            CI => Carry_IN,                     -- [in  std_logic]
            S  => '1',                          -- [in  std_logic]
            LO => carry_out_i                   -- [out std_logic]
          );
          
        carry_point   <= Carry_IN;
        Carry_OUT     <= carry_out_i;
      end generate No_Pad;
      
      XORCY_Inst1: XORCY
        port map (
          LI => '1',                          -- [in  std_logic]
          CI => carry_point,                  -- [in  std_logic]
          O  => carry_value                   -- [out std_logic]
        );
      
    end generate Using_Inv;
    No_Inv : if (not C_INV_C) generate
    begin
      carry_value   <= carry_pad(carry_pad'left);
      Carry_OUT     <= carry_pad(carry_pad'left);
    end generate No_Inv;
        
    OR2L_Inst1: OR2L
      port map (
        O   => O,                           -- [out std_logic]
        DI  => carry_value,                 -- [in  std_logic]
        SRI => A                            -- [in  std_logic]
      );
  
  end generate Using_FPGA;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    O         <= (     Carry_IN ) or A when not C_INV_C else 
                 ( not Carry_IN ) or A;
    Carry_OUT <=       Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_latch_or_n is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_NUM_PAD : natural := 0;
    C_INV_C   : boolean
  );
  port (
    Carry_IN  : in  std_logic;
    A_N       : in  std_logic;
    O         : out std_logic;
    Carry_OUT : out std_logic
  );
end entity carry_latch_or_n;


architecture IMP of carry_latch_or_n is
  signal carry_out_i : std_logic;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL) generate
    signal carry_pad   : std_logic_vector(C_NUM_PAD downto 0);
    signal carry_value : std_logic;
    signal A           : std_logic;
  begin
    carry_pad(0)  <= Carry_IN;
    
    The_Pad : for I in 0 to C_NUM_PAD - 1 generate
    begin
      MUXCY_Inst: MUXCY_L
        port map (
          DI => '0',                          -- [in  std_logic]
          CI => carry_pad(I),                 -- [in  std_logic]
          S  => '1',                          -- [in  std_logic]
          LO => carry_pad(I+1)                -- [out std_logic]
        );
    end generate The_Pad;
    
    Using_Inv : if (C_INV_C) generate
      signal carry_point : std_logic;
    begin
      Using_Pad : if ( C_NUM_PAD > 0 ) generate
      begin
        carry_point   <= carry_pad(carry_pad'left - 1);
        Carry_OUT     <= carry_pad(carry_pad'left);
      end generate Using_Pad;
      No_Pad : if ( C_NUM_PAD = 0 ) generate
      begin
        MUXCY_Inst1: MUXCY_L
          port map (
            DI => '0',                          -- [in  std_logic]
            CI => Carry_IN,                     -- [in  std_logic]
            S  => '1',                          -- [in  std_logic]
            LO => carry_out_i                   -- [out std_logic]
          );
          
        carry_point   <= Carry_IN;
        Carry_OUT     <= carry_out_i;
      end generate No_Pad;
      
      XORCY_Inst1: XORCY
        port map (
          LI => '1',                          -- [in  std_logic]
          CI => carry_point,                  -- [in  std_logic]
          O  => carry_value                   -- [out std_logic]
        );
      
    end generate Using_Inv;
    No_Inv : if (not C_INV_C) generate
    begin
      carry_value   <= carry_pad(carry_pad'left);
      Carry_OUT     <= carry_pad(carry_pad'left);
    end generate No_Inv;
    
    A <= not A_N;
    
    OR2L_Inst1: OR2L
      port map (
        O   => O,                           -- [out std_logic]
        DI  => carry_value,                 -- [in  std_logic]
        SRI => A                            -- [in  std_logic]
      );
  
  end generate Using_FPGA;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    O         <= (     Carry_IN ) or not A_N when not C_INV_C else 
                 ( not Carry_IN ) or not A_N;
    Carry_OUT <=       Carry_IN;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_piperun_step is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE
    );
  port (
    Carry_IN  : in  std_logic;
    Need      : in  std_logic;
    Stall     : in  std_logic;
    Done      : in  std_logic;
    Carry_OUT : out std_logic);
end entity carry_piperun_step;


architecture IMP of carry_piperun_step is
  signal carry_out_i : std_logic;
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL) generate
    signal S      : std_logic;
  begin
    S <= ( not Need ) or ( Need and Done ) or ( Need and not Stall );
    MUXCY_I : MUXCY_L
      port map (
        DI => '0',
        CI => Carry_IN,
        S  => S,
        LO => carry_out_i);    
    Carry_OUT <= carry_out_i;
  end generate Using_FPGA;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= Carry_IN when ( Need               ) = '0' else 
                 Carry_IN when ( Need and     Done  ) = '1' else 
                 Carry_IN when ( Need and not Stall ) = '1' else '0';
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_compare is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_SIZE    : natural
  );
  port (
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    B_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_In  : in  std_logic;
    Carry_Out : out std_logic
  );
end entity carry_compare;


architecture IMP of carry_compare is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

  constant C_INPUTS_PER_BIT : integer := 2;
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  

begin  -- architecture IMP

  assign_sigs : process (A_Vec, B_Vec) is
  begin  -- process assign_sigs
    A                   <= (others => '1');
    A(C_SIZE-1 downto 0)  <= A_Vec;
    B                   <= (others => '1');
    B(C_SIZE-1 downto 0)  <= B_Vec;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A, B)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I and ( ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_prio_mux is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    REVERSE   : boolean;
    C_IS_COLD : std_logic;
    C_SIZE    : natural
  );
  port (
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    M_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_In  : in  std_logic;
    Carry_Out : out std_logic
  );
end entity carry_prio_mux;


architecture IMP of carry_prio_mux is

  constant C_INPUTS_PER_BIT : integer := 2;
  constant C_BITS_PER_LUT   : integer := ((Family_To_LUT_Size(C_TARGET)-1) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal data   : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal A_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
  begin

    assign_sigs : process (A_Vec, M_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      M                     <= (others => C_IS_COLD);
      M(C_SIZE-1 downto 0)  <= M_Vec;
    end process assign_sigs;
  
    assign_order : process (A, M) is
    begin  -- process assign_order
      A_I <= A;
      M_I <= M;
      
      if( REVERSE ) then 
        for i in 0 to C_SIZE - 1 loop
          A_I(A_I'left - i) <= A(A'right + i);
          M_I(M_I'left - i) <= M(M'right + i);
        end loop; 
      end if;
    end process assign_order;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A_I, M_I)
        variable sel_I   : std_logic;
        variable data_I  : std_logic;
      begin
        sel_I   := '1';
        data_I  := A_I(C_BITS_PER_LUT * I);
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          if( M_I(C_BITS_PER_LUT * I + J) = not C_IS_COLD ) then
            data_I  := A_I(C_BITS_PER_LUT * I + J);
          end if;
          sel_I  := sel_I and ( ( C_IS_COLD xnor M_I(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I)  <= sel_I;
        data(I) <= data_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => data(I),
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal data   : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal A_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
    attribute KEEP  : string;
    attribute KEEP  of sel  : signal is "true";
    attribute KEEP  of data : signal is "true";
  begin

    assign_sigs : process (A_Vec, M_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      M                     <= (others => C_IS_COLD);
      M(C_SIZE-1 downto 0)  <= M_Vec;
    end process assign_sigs;
  
    assign_order : process (A, M) is
    begin  -- process assign_order
      A_I <= A;
      M_I <= M;
      
      if( REVERSE ) then 
        for i in 0 to C_SIZE - 1 loop
          A_I(A_I'left - i) <= A(A'right + i);
          M_I(M_I'left - i) <= M(M'right + i);
        end loop; 
      end if;
    end process assign_order;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A_I, M_I)
        variable sel_I   : std_logic;
        variable data_I  : std_logic;
      begin
        sel_I   := '1';
        data_I  := A_I(C_BITS_PER_LUT * I);
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          if( M_I(C_BITS_PER_LUT * I + J) = not C_IS_COLD ) then
            data_I  := A_I(C_BITS_PER_LUT * I + J);
          end if;
          sel_I  := sel_I and ( ( C_IS_COLD xnor M_I(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I)  <= sel_I;
        data(I) <= data_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => data(I),
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Find_Highest_Prio: process(A_Vec, M_Vec)
    begin
      -- Default assignment.
      Carry_OUT  <= Carry_IN;
      
      -- Find highest prio that is selected.
      if( REVERSE ) then 
        for i in C_SIZE - 1 to 0 loop
          if( M_Vec(i) = not C_IS_COLD ) then
            Carry_OUT <= A_Vec(i);
          end if;
        end loop; 
      else
        for i in 0 downto C_SIZE - 1 loop
          if( M_Vec(i) = not C_IS_COLD ) then
            Carry_OUT <= A_Vec(i);
          end if;
        end loop; 
      end if;
    end process Find_Highest_Prio;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_prio_mux_enable is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    REVERSE   : boolean;
    C_IS_COLD : std_logic;
    C_SIZE    : natural
  );
  port (
    Carry_In  : in  std_logic;
    Enable    : in  std_logic;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    M_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_Out : out std_logic
  );
end entity carry_prio_mux_enable;


architecture IMP of carry_prio_mux_enable is

  constant C_INPUTS_PER_BIT : integer := 2;
  constant C_BITS_PER_LUT   : integer := ((Family_To_LUT_Size(C_TARGET)-2) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal data   : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal A_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
  begin

    assign_sigs : process (A_Vec, M_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      M                     <= (others => C_IS_COLD);
      M(C_SIZE-1 downto 0)  <= M_Vec;
    end process assign_sigs;
  
    assign_order : process (A, M) is
    begin  -- process assign_order
      A_I <= A;
      M_I <= M;
      
      if( REVERSE ) then 
        for i in 0 to C_SIZE - 1 loop
          A_I(A_I'left - i) <= A(A'right + i);
          M_I(M_I'left - i) <= M(M'right + i);
        end loop; 
      end if;
    end process assign_order;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A_I, M_I, Enable)
        variable sel_I   : std_logic;
        variable data_I  : std_logic;
      begin
        sel_I   := '1';
        data_I  := A_I(C_BITS_PER_LUT * I);
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          if( M_I(C_BITS_PER_LUT * I + J) = not C_IS_COLD ) then
            data_I  := A_I(C_BITS_PER_LUT * I + J);
          end if;
          sel_I  := sel_I and ( ( C_IS_COLD xnor M_I(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I)  <= sel_I or not Enable;
        data(I) <= data_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => data(I),
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal data   : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal A_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal M_I    : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
    attribute KEEP  : string;
    attribute KEEP  of sel  : signal is "true";
    attribute KEEP  of data : signal is "true";
  begin

    assign_sigs : process (A_Vec, M_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      M                     <= (others => C_IS_COLD);
      M(C_SIZE-1 downto 0)  <= M_Vec;
    end process assign_sigs;
  
    assign_order : process (A, M) is
    begin  -- process assign_order
      A_I <= A;
      M_I <= M;
      
      if( REVERSE ) then 
        for i in 0 to C_SIZE - 1 loop
          A_I(A_I'left - i) <= A(A'right + i);
          M_I(M_I'left - i) <= M(M'right + i);
        end loop; 
      end if;
    end process assign_order;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A_I, M_I, Enable)
        variable sel_I   : std_logic;
        variable data_I  : std_logic;
      begin
        sel_I   := '1';
        data_I  := A_I(C_BITS_PER_LUT * I);
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          if( M_I(C_BITS_PER_LUT * I + J) = not C_IS_COLD ) then
            data_I  := A_I(C_BITS_PER_LUT * I + J);
          end if;
          sel_I  := sel_I and ( ( C_IS_COLD xnor M_I(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I)  <= sel_I or not Enable;
        data(I) <= data_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => data(I),
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Find_Highest_Prio: process(A_Vec, M_Vec, Enable)
    begin
      -- Default assignment.
      Carry_OUT  <= Carry_IN;
      
      -- Find highest prio that is selected.
      if( REVERSE ) then 
        for i in C_SIZE - 1 downto 0 loop
          if( M_Vec(i) = not C_IS_COLD and Enable = '1' ) then
            Carry_OUT <= A_Vec(i);
          end if;
        end loop; 
      else
        for i in 0 to C_SIZE - 1 loop
          if( M_Vec(i) = not C_IS_COLD and Enable = '1' ) then
            Carry_OUT <= A_Vec(i);
          end if;
        end loop; 
      end if;
    end process Find_Highest_Prio;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_select_and is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural
  );
  port (
    Carry_In  : in  std_logic;
    No        : in  natural range 0 to C_SIZE-1;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_Out : out std_logic
  );
end entity carry_select_and;


architecture IMP of carry_select_and is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

--  constant C_INPUTS_PER_BIT : integer := 1 + Log2(C_SIZE);
  constant C_INPUTS_PER_BIT : integer := Family_To_LUT_Size(C_TARGET);
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

begin  -- architecture IMP

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A_Vec, No)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        if( No = C_BITS_PER_LUT * I + J ) then
          sel_I  := A_Vec(C_BITS_PER_LUT * I + J);
        end if;
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_select_and_n is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural
  );
  port (
    Carry_In  : in  std_logic;
    No        : in  natural range 0 to C_SIZE-1;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_Out : out std_logic
  );
end entity carry_select_and_n;


architecture IMP of carry_select_and_n is

  component carry_and_n is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and_n;

--  constant C_INPUTS_PER_BIT : integer := 1 + Log2(C_SIZE);
  constant C_INPUTS_PER_BIT : integer := Family_To_LUT_Size(C_TARGET);
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

begin  -- architecture IMP

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A_Vec, No)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '0';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        if( No = C_BITS_PER_LUT * I + J ) then
          sel_I  := A_Vec(C_BITS_PER_LUT * I + J);
        end if;
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and_n
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A_N       => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_select_or is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural
  );
  port (
    Carry_In  : in  std_logic;
    No        : in  natural range 0 to C_SIZE-1;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_Out : out std_logic
  );
end entity carry_select_or;


architecture IMP of carry_select_or is

  component carry_or is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_or;

--  constant C_INPUTS_PER_BIT : integer := 1 + Log2(C_SIZE);
  constant C_INPUTS_PER_BIT : integer := Family_To_LUT_Size(C_TARGET);
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

begin  -- architecture IMP

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A_Vec, No)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '0';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        if( No = C_BITS_PER_LUT * I + J ) then
          sel_I  := A_Vec(C_BITS_PER_LUT * I + J);
        end if;
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_or_I1: carry_or
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_select_or_n is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural
  );
  port (
    Carry_In  : in  std_logic;
    No        : in  natural range 0 to C_SIZE-1;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_Out : out std_logic
  );
end entity carry_select_or_n;


architecture IMP of carry_select_or_n is

  component carry_or_n is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_or_n;

--  constant C_INPUTS_PER_BIT : integer := 1 + Log2(C_SIZE);
  constant C_INPUTS_PER_BIT : integer := Family_To_LUT_Size(C_TARGET);
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

begin  -- architecture IMP

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A_Vec, No)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        if( No = C_BITS_PER_LUT * I + J ) then
          sel_I  := A_Vec(C_BITS_PER_LUT * I + J);
        end if;
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_or_I1: carry_or_n
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A_N       => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_compare_const is
  generic (
    C_KEEP    : boolean:= false;
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_SIGNALS : natural := 1;
    C_SIZE    : natural;
    B_Vec     : std_logic_vector);
  port (
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_In  : in  std_logic;
    Carry_Out : out std_logic);
end entity carry_compare_const;


architecture IMP of carry_compare_const is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

  constant C_INPUTS_PER_BIT : integer := C_SIGNALS;
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
begin  -- architecture IMP

  assign_sigs : process (A_Vec) is
  begin  -- process assign_sigs
    A                   <= (others => '1');
    A(C_SIZE-1 downto 0)  <= A_Vec;
    B                   <= (others => '1');
    B(C_SIZE-1 downto 0)  <= B_Vec;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A, B)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I and ( ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_compare_mask is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural);
  port (
    A_Vec      : in  std_logic_vector(C_SIZE-1 downto 0);
    B_Vec      : in  std_logic_vector(C_SIZE-1 downto 0);
    Mask       : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_In   : in  std_logic;
    Carry_Out  : out std_logic);
end entity carry_compare_mask;


architecture IMP of carry_compare_mask is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

  constant C_INPUTS_PER_BIT : integer:= 3;
  constant C_BITS_PER_LUT   : integer:= (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);

begin  -- architecture IMP

  assign_sigs : process (A_Vec, B_Vec, Mask) is
  begin  -- process assign_sigs
    A                   <= (others => '1');
    A(C_SIZE-1 downto 0)  <= A_Vec;
    B                   <= (others => '1');
    B(C_SIZE-1 downto 0)  <= B_Vec;
    M                   <= (others => '1');
    M(C_SIZE-1 downto 0)  <= Mask;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A, B, M)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I and ( not(M(C_BITS_PER_LUT * I + J)) or
                              ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity carry_compare_mask_const is
  generic (
    C_KEEP   : boolean:= false;
    C_TARGET : TARGET_FAMILY_TYPE;
    C_SIZE   : natural;
    B_Vec    : std_logic_vector);
  port (
    A_Vec      : in  std_logic_vector(C_SIZE-1 downto 0);
    Mask       : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_In   : in  std_logic;
    Carry_Out  : out std_logic);
end entity carry_compare_mask_const;


architecture IMP of carry_compare_mask_const is

  component carry_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE);
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;

  constant C_INPUTS_PER_BIT : integer:= 2;
  constant C_BITS_PER_LUT   : integer:= (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;

  signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
  signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);

  signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  signal M      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);

begin  -- architecture IMP

  assign_sigs : process (A_Vec, Mask) is
  begin  -- process assign_sigs
    A                   <= (others => '1');
    A(C_SIZE-1 downto 0)  <= A_Vec;
    B                   <= (others => '1');
    B(C_SIZE-1 downto 0)  <= B_Vec;
    M                   <= (others => '1');
    M(C_SIZE-1 downto 0)  <= Mask;
  end process assign_sigs;

  carry(0) <= Carry_In;

  The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
  begin
    -- Combine the signals that fit into one LUT.
    Compare_All_Bits: process(A, B, M)
      variable sel_I   : std_logic;
    begin
      sel_I  :=  '1';
      Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
        sel_I  := sel_I and ( not(M(C_BITS_PER_LUT * I + J)) or
                              ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
      end loop Compare_Bits;
      sel(I) <= sel_I;
    end process Compare_All_Bits;

    carry_and_I1: carry_and
      generic map (
        C_KEEP   => C_KEEP,
        C_TARGET => C_TARGET)     -- [TARGET_FAMILY_TYPE]
      port map (
        Carry_IN  => Carry(I),    -- [in  std_logic]
        A         => sel(I),      -- [in  std_logic]
        Carry_OUT => Carry(I+1)); -- [out std_logic]

  end generate The_Compare;

  Carry_Out <= Carry(C_NR_OF_LUTS);

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity comparator is
  generic (
    C_KEEP            : boolean:= false;
    C_TARGET          : TARGET_FAMILY_TYPE;
    C_SIZE            : natural);
  port (
    Carry_IN  : in  std_logic;
    DI        : in  std_logic;
    A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    B_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
    Carry_OUT : out std_logic);
end entity comparator;

architecture IMP of comparator is

  constant C_INPUTS_PER_BIT : integer := 2;
  constant C_BITS_PER_LUT   : integer := (Family_To_LUT_Size(C_TARGET) / C_INPUTS_PER_BIT);
  constant C_NR_OF_LUTS     : integer := (C_SIZE + (C_BITS_PER_LUT - 1)) / C_BITS_PER_LUT;


begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- FPGA implementation
  -----------------------------------------------------------------------------
  Using_FPGA : if (C_TARGET /= RTL and not C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
  begin

    assign_sigs : process (A_Vec, B_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      B                     <= (others => '1');
      B(C_SIZE-1 downto 0)  <= B_Vec;
    end process assign_sigs;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A, B)
        variable sel_I   : std_logic;
      begin
        sel_I  :=  '1';
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          sel_I  := sel_I and ( ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I) <= sel_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => DI,
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA;

  Using_FPGA_Keep : if (C_TARGET /= RTL and C_KEEP) generate

    signal sel    : std_logic_vector(C_NR_OF_LUTS - 1 downto 0);
    signal carry  : std_logic_vector(C_NR_OF_LUTS     downto 0);
  
    signal A      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
    signal B      : std_logic_vector(C_NR_OF_LUTS * C_BITS_PER_LUT - 1 downto 0);
  
    attribute KEEP  : string;
    attribute KEEP  of sel  : signal is "true";
  begin

    assign_sigs : process (A_Vec, B_Vec) is
    begin  -- process assign_sigs
      A                     <= (others => '1');
      A(C_SIZE-1 downto 0)  <= A_Vec;
      B                     <= (others => '1');
      B(C_SIZE-1 downto 0)  <= B_Vec;
    end process assign_sigs;
  
    carry(0) <= Carry_In;
  
    The_Compare : for I in 0 to C_NR_OF_LUTS - 1 generate
    begin
      -- Combine the signals that fit into one LUT.
      Compare_All_Bits: process(A, B)
        variable sel_I   : std_logic;
      begin
        sel_I  :=  '1';
        Compare_Bits: for J in 0 to C_BITS_PER_LUT - 1 loop
          sel_I  := sel_I and ( ( A(C_BITS_PER_LUT * I + J) xnor B(C_BITS_PER_LUT * I + J) ) );
        end loop Compare_Bits;
        sel(I) <= sel_I;
      end process Compare_All_Bits;
  
      MUXCY_I : MUXCY_L
        port map (
          DI => DI,
          CI => Carry(I),
          S  => sel(I),
          LO => Carry(I+1));    
  
    end generate The_Compare;
  
    Carry_Out <= Carry(C_NR_OF_LUTS);

  end generate Using_FPGA_Keep;

  -----------------------------------------------------------------------------
  -- RTL Implementation
  -----------------------------------------------------------------------------
  Using_RTL: if (C_TARGET = RTL) generate
  begin
    Carry_OUT <= Carry_IN when A_Vec = B_Vec else DI;
  end generate Using_RTL;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity reg_ce is
  generic (
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_IS_SET  : std_logic_vector;
    C_CE_LOW  : std_logic_vector;
    C_NUM_CE  : natural;
    C_SIZE    : natural
  );
  port (
    CLK       : in  std_logic;
    SR        : in  std_logic;
    CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
    D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
    Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
  );
end entity reg_ce;


architecture IMP of reg_ce is

  constant C_IS_SET_I       : std_logic_vector(C_SIZE   - 1 downto 0) := C_IS_SET;
  constant C_CE_LOW_I       : std_logic_vector(C_NUM_CE - 1 downto 0) := C_CE_LOW;
  
  signal CE_I               : std_logic_vector(C_NUM_CE - 1 downto 0);
  signal D_I                : std_logic_vector(C_SIZE   - 1 downto 0);
  signal Q_I                : std_logic_vector(C_SIZE   - 1 downto 0);
  
begin  -- architecture IMP

  CE_I  <= CE xor C_CE_LOW_I;

  The_Bit : for I in 0 to C_SIZE - 1 generate
  begin
    -----------------------------------------------------------------------------
    -- FPGA implementation
    -----------------------------------------------------------------------------
    Using_FPGA : if (C_TARGET /= RTL) generate
    begin
      D_I(I)  <= D(I)   when ( reduce_and(CE_I(C_NUM_CE - 1 downto 1)) = '1' ) else 
                 Q_I(I);
      
      Using_Set : if ( C_IS_SET_I(I) = '1' ) generate
      begin
        FDS_Inst : FDSE
          port map (
            Q  => Q_I(I),                       -- [out std_logic]
            C  => CLK,                          -- [in  std_logic]
            CE => CE_I(0),                      -- [in  std_logic]
            D  => D_I(I),                       -- [in  std_logic]
            S  => SR                            -- [in  std_logic]
          );
      end generate Using_Set;
      Using_Reset : if ( C_IS_SET_I(I) /= '1' ) generate
      begin
        FDS_Inst : FDRE
          port map (
            Q  => Q_I(I),                       -- [out std_logic]
            C  => CLK,                          -- [in  std_logic]
            CE => CE_I(0),                      -- [in  std_logic]
            D  => D_I(I),                       -- [in  std_logic]
            R  => SR                            -- [in  std_logic]
          );
      end generate Using_Reset;
      
      Q(I)  <= Q_I(I) ;
    end generate Using_FPGA;
  
    -----------------------------------------------------------------------------
    -- RTL Implementation
    -----------------------------------------------------------------------------
    Using_RTL: if (C_TARGET = RTL) generate
    begin
      Reg_Handler : process (CLK) is
      begin  -- process Length_Handler
        if (CLK'event and CLK = '1') then   -- rising clock edge
          if ( SR = '1' ) then              -- synchronous reset (active high)
            Q(I) <= C_IS_SET_I(I);
          elsif( reduce_and(CE xor C_CE_LOW_I) = '1' ) then
            Q(I) <= D(I);
          end if;
        end if;
      end process Reg_Handler;
    end generate Using_RTL;
  end generate The_Bit;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity reg_ce_kill is
  generic (
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_IS_SET  : std_logic_vector;
    C_CE_LOW  : std_logic_vector;
    C_NUM_CE  : natural;
    C_SIZE    : natural
  );
  port (
    CLK       : in  std_logic;
    SR        : in  std_logic;
    KILL      : in  std_logic;
    CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
    D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
    Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
  );
end entity reg_ce_kill;


architecture IMP of reg_ce_kill is

  constant C_IS_SET_I       : std_logic_vector(C_SIZE   - 1 downto 0) := C_IS_SET;
  constant C_CE_LOW_I       : std_logic_vector(C_NUM_CE - 1 downto 0) := C_CE_LOW;
  
  signal CE_I               : std_logic_vector(C_NUM_CE - 1 downto 0);
  signal D_I                : std_logic_vector(C_SIZE   - 1 downto 0);
  signal Q_I                : std_logic_vector(C_SIZE   - 1 downto 0);
  
begin  -- architecture IMP

  CE_I  <= CE xor C_CE_LOW_I;

  The_Bit : for I in 0 to C_SIZE - 1 generate
  begin
    -----------------------------------------------------------------------------
    -- FPGA implementation
    -----------------------------------------------------------------------------
    Using_FPGA : if (C_TARGET /= RTL) generate
    begin
      D_I(I)  <= D(I)                when ( reduce_and(CE_I(C_NUM_CE - 1 downto 1)) = '1' ) else 
                 Q_I(I) and not KILL;
      
      Using_Set : if ( C_IS_SET_I(I) = '1' ) generate
      begin
        FDS_Inst : FDSE
          port map (
            Q  => Q_I(I),                       -- [out std_logic]
            C  => CLK,                          -- [in  std_logic]
            CE => CE_I(0),                      -- [in  std_logic]
            D  => D_I(I),                       -- [in  std_logic]
            S  => SR                            -- [in  std_logic]
          );
      end generate Using_Set;
      Using_Reset : if ( C_IS_SET_I(I) /= '1' ) generate
      begin
        FDS_Inst : FDRE
          port map (
            Q  => Q_I(I),                       -- [out std_logic]
            C  => CLK,                          -- [in  std_logic]
            CE => CE_I(0),                      -- [in  std_logic]
            D  => D_I(I),                       -- [in  std_logic]
            R  => SR                            -- [in  std_logic]
          );
      end generate Using_Reset;
      
      Q(I)  <= Q_I(I) ;
    end generate Using_FPGA;
  
    -----------------------------------------------------------------------------
    -- RTL Implementation
    -----------------------------------------------------------------------------
    Using_RTL: if (C_TARGET = RTL) generate
    begin
      Reg_Handler : process (CLK) is
      begin  -- process Length_Handler
        if (CLK'event and CLK = '1') then   -- rising clock edge
          if ( SR = '1' ) then              -- synchronous reset (active high)
            Q(I) <= C_IS_SET_I(I);
          elsif( reduce_and(CE xor C_CE_LOW_I) = '1' ) then
            Q(I) <= D(I);
          elsif( KILL = '1' ) then
            Q(I) <= C_IS_SET_I(I);
          end if;
        end if;
      end process Reg_Handler;
    end generate Using_RTL;
  end generate The_Bit;

end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity bit_reg_ce is
  generic (
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_IS_SET  : std_logic;
    C_CE_LOW  : std_logic_vector;
    C_NUM_CE  : natural
  );
  port (
    CLK       : in  std_logic;
    SR        : in  std_logic;
    CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
    D         : in  std_logic;
    Q         : out std_logic
  );
end entity bit_reg_ce;


architecture IMP of bit_reg_ce is

  component reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic_vector;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural;
      C_SIZE    : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
      Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
    );
  end component reg_ce;
  
  signal D_I                : std_logic_vector(0 downto 0);
  signal Q_I                : std_logic_vector(0 downto 0);
  
begin  -- architecture IMP

  D_I(0) <= D;
  
  Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (0 downto 0=>C_IS_SET),
      C_CE_LOW  => C_CE_LOW,
      C_NUM_CE  => C_NUM_CE,
      C_SIZE    => 1
    )
    port map(
      CLK       => CLK,
      SR        => SR,
      CE        => CE,
      D         => D_I,
      Q         => Q_I
    );

  Q <= Q_I(0);
  
end architecture IMP;


library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

library Unisim;
use Unisim.vcomponents.all;


entity bit_reg_ce_kill is
  generic (
    C_TARGET  : TARGET_FAMILY_TYPE;
    C_IS_SET  : std_logic;
    C_CE_LOW  : std_logic_vector;
    C_NUM_CE  : natural
  );
  port (
    CLK       : in  std_logic;
    SR        : in  std_logic;
    KILL      : in  std_logic;
    CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
    D         : in  std_logic;
    Q         : out std_logic
  );
end entity bit_reg_ce_kill;


architecture IMP of bit_reg_ce_kill is

  component reg_ce_kill is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic_vector;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural;
      C_SIZE    : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      KILL      : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
      Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
    );
  end component reg_ce_kill;
  
  signal D_I                : std_logic_vector(0 downto 0);
  signal Q_I                : std_logic_vector(0 downto 0);
  
begin  -- architecture IMP

  D_I(0) <= D;
  
  Inst: reg_ce_kill
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (0 downto 0=>C_IS_SET),
      C_CE_LOW  => C_CE_LOW,
      C_NUM_CE  => C_NUM_CE,
      C_SIZE    => 1
    )
    port map(
      CLK       => CLK,
      SR        => SR,
      KILL      => KILL,
      CE        => CE,
      D         => D_I,
      Q         => Q_I
    );

  Q <= Q_I(0);
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_statistics_counters.vhd - Entity and architecture
--
--  ***************************************************************************
--  **  Copyright(C) 2008 by Xilinx, Inc. All rights reserved.               **
--  **                                                                       **
--  **  This text contains proprietary, confidential                         **
--  **  information of Xilinx, Inc. , is distributed by                      **
--  **  under license from Xilinx, Inc., and may be used,                    **
--  **  copied and/or disclosed only pursuant to the terms                   **
--  **  of a valid license agreement with Xilinx, Inc.                       **
--  **                                                                       **
--  **  Unmodified source code is guaranteed to place and route,             **
--  **  function and run at speed according to the datasheet                 **
--  **  specification. Source code is provided "as-is", with no              **
--  **  obligation on the part of Xilinx to provide support.                 **
--  **                                                                       **
--  **  Xilinx Hotline support of source code IP shall only include          **
--  **  standard level Xilinx Hotline support, and will only address         **
--  **  issues and questions related to the standard released Netlist        **
--  **  version of the core (and thus indirectly, the original core source). **
--  **                                                                       **
--  **  The Xilinx Support Hotline does not have access to source            **
--  **  code and therefore cannot answer specific questions related          **
--  **  to source HDL. The Xilinx Support Hotline will only be able          **
--  **  to confirm the problem in the Netlist version of the core.           **
--  **                                                                       **
--  **  This copyright and support notice must be retained as part           **
--  **  of this text at all times.                                           **
--  ***************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        sc_statistics_counters.vhd
--
-- Description:     
--    Use ring of counters: 1, 2, 4, 8, 16, 32 ...
--      lastCounterIndex indicates the counter to start
--      firstCounterIndex indicates the counter to stop
--
--    xpsl assume always Running -> eventually Stopping;
--    xpsl assume never Running and Stopping;
--
--    if Starting and not full then
--      start counter(lastCounterIndex);
--      lastCounterIndex <= lastCounterIndex + 1;
--      if lastCounterIndex = firstCounterIndex then
--        full <= true;
--      end if;
--    end if;
--    if Ending then
--      if lastCounterIndex = firstCounterIndex and not full then
--        empty <= true;
--      else
--        stop counter(firstCounterIndex);
--        update statistics(firstCounterIndex);
--        firstCounterIndex <= firstCounterIndex + 1;
--      end if;
--    end if;
--
--    if updateStatistics then
--      counterValue        <= counter(firstCounterIndex);
--      totalAccesses       <= totalAccesses + 1;
--      accessCycles        <= accessCycles + counterValue;
--      accessCyclesSquared <= accessCyclesSquared +
--                                counterValue * counterValue;
--      if maxAccessLength < counterValue then
--        maxAccessLength   <= counterValue;
--      end if;
--    end if;
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_statistics_counters.vhd
--
-------------------------------------------------------------------------------
-- Author:          stefana
--
-- History:
--   stefana  2008-07-28    First Version
--   stefana  2008-11-10    Added simple counters
--   stefana  2009-03-02    Increased width of access counter
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_statistics_counters is
  generic (
    -- Module implementation generics
    C_ACCESS_COUNTER_WIDTH : integer range 1 to 64 := 32;
    C_CYCLE_COUNTER_WIDTH  : integer range 1 to 64 := 48;
    C_USE_STDDEV           : integer range 0 to 1  :=  0;
    C_PIPELINE_DEPTH       : integer range 1 to 32 :=  1;
    C_MAX_CYCLE_WIDTH      : integer range 2 to 16 :=  8;
    C_SIMPLE_COUNTER       : boolean := false
  );
  port (
    CLK            : in  std_logic;
    Rst            : in  std_logic;

    -- Access signals
    Access_Request : in  std_logic;
    Access_Ready   : in  std_logic;
    Access_Active  : in  std_logic;
    Access_ActiveN : in  std_logic;
    Access_Valid   : in  std_logic;
    Access_Abort   : in  std_logic;

    Pause          : in  std_logic;
    Clear          : in  std_logic;

    Is_Running     : out std_logic;
    Is_Stopped     : out std_logic;

    Min_Max_Status : out STAT_TYPE;
    Access_Count   : out STAT_TYPE;
    Cycle_Count    : out STAT_TYPE;
    Cycle_Count_2  : out STAT_TYPE
  );
end entity sc_statistics_counters;

library IEEE;
use IEEE.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

architecture IMP of sc_statistics_counters is

  -- log2 function returns the number of bits required to encode x choices
  function log2(x : natural) return integer is
    variable i  : integer := 0;   
  begin 
    if x = 0 then return 0;
    else
      while 2**i < x loop
        i := i+1;
      end loop;
      return i;
    end if;
  end function log2;
  
  subtype Cycle_Type    is std_logic_vector(0 to C_MAX_CYCLE_WIDTH - 1);
  subtype Power_Type    is std_logic_vector(0 to 2*C_MAX_CYCLE_WIDTH - 1);
  subtype Counter_Type  is std_logic_vector(0 to C_CYCLE_COUNTER_WIDTH - 1);
  subtype Index_Type    is rinteger range 0 to C_PIPELINE_DEPTH - 1;
  subtype Pipeline_Type is std_logic_vector(0 to C_PIPELINE_DEPTH - 1);

  type Cycle_Array_Type is array(0 to C_PIPELINE_DEPTH - 1) of Cycle_Type;

  signal Count           : Cycle_Array_Type;
  signal Count_Stop      : Cycle_Type;
  signal Count_Stop_d1   : Cycle_Type;
  signal Access_Overflow : Pipeline_Type;

  signal firstIndex      : Index_Type;
  signal lastIndex       : Index_Type;
  signal stopIndex       : Index_Type;
  signal firstIndex_Next : Index_Type;
  signal lastIndex_Next  : Index_Type;
  signal Empty           : boolean;

  signal Maximum         : Cycle_Type;
  signal Minimum         : Cycle_Type;
  signal Access_Count_i  : std_logic_vector(0 to C_ACCESS_COUNTER_WIDTH-1);
  signal Cycle_Count_i   : Counter_Type;
  signal Cycle_Count_2_i : Counter_Type;
  signal Overflow        : std_logic;
  signal Full            : std_logic;

  signal Stopping        : boolean;
  signal Starting        : boolean;
  signal Running         : Pipeline_Type;
  signal Is_Valid        : Pipeline_Type;
  signal update_d1       : std_logic;
  signal update_d2       : std_logic;
  signal counter_2_d1    : Power_Type;

begin

  Gen_Simple_Counter: if C_SIMPLE_COUNTER generate
    Counters_FF: process(Clk)
    begin
      if Clk'event and Clk = '1' then     -- rising clock edge
        if Rst = '1' then
          Access_Count_i  <= (others => '0');

          Count           <= (others => (others => '0'));
          Access_Overflow <= (others => '0');
          Overflow        <= '0';
        else
          for I in 0 to C_PIPELINE_DEPTH - 1 loop
            if Running(I) = '1' then
              if Count(I) = (Cycle_Type'range => '1') then
                Access_Overflow(I) <= '1';
                Overflow <= '1';
              else
                Count(I) <= std_logic_vector(unsigned(Count(I)) + 1);
              end if;
            end if;
          end loop;
          if Stopping then
            if Is_Valid(stopIndex) = '1' then
              Access_Count_i  <= std_logic_vector(unsigned(Access_Count_i) + 1);
            end if;
            Count(stopIndex) <= (others => '0');
            Access_Overflow(stopIndex) <= '0';
          end if;
          if Clear = '1' then
            Access_Count_i  <= (others => '0');
          end if;
        end if;
      end if;
    end process Counters_FF;

    Cycle_Count_i   <= (others => '0');
    Cycle_Count_2_i <= (others => '0');
    Minimum         <= (others => '0');
    Maximum         <= (others => '0');
  end generate Gen_Simple_Counter;


  Gen_Access_Counter: if not C_SIMPLE_COUNTER generate
    Counters_FF: process(Clk)
    begin
      if Clk'event and Clk = '1' then     -- rising clock edge
        if Rst = '1' then
          Access_Count_i  <= (others => '0');
          Cycle_Count_i   <= (others => '0');
          Minimum         <= (others => '1');
          Maximum         <= (others => '0');

          update_d1       <= '0';
          Count_Stop_d1   <= (others => '0');
          Count           <= (others => (others => '0'));
          Access_Overflow <= (others => '0');
          Overflow        <= '0';
        else
          update_d1       <= '0';
          Count_Stop_d1   <= Count_Stop;
          
          if Clear = '1' then
            Access_Count_i  <= (others => '0');
            Cycle_Count_i   <= (others => '0');
            Minimum         <= (others => '1');
            Maximum         <= (others => '0');
          end if;
          for I in 0 to C_PIPELINE_DEPTH - 1 loop
            if Running(I) = '1' then
              if Count(I) = (Cycle_Type'range => '1') then
                Access_Overflow(I) <= '1';
                Overflow <= '1';
              else
                Count(I) <= std_logic_vector(unsigned(Count(I)) + 1);
              end if;
            end if;
          end loop;
          if Stopping then
            if Is_Valid(stopIndex) = '1' then
              Access_Count_i  <= std_logic_vector(unsigned(Access_Count_i) + 1);
              Cycle_Count_i   <= std_logic_vector(unsigned(Cycle_Count_i) +
                                                  unsigned(Count_Stop));
              update_d1       <= '1';
              if Count_Stop < Minimum then
                Minimum <= Count_Stop;
              end if;
              if Count_Stop > Maximum and Access_Overflow(stopIndex) = '0' then
                Maximum <= Count_Stop;
              end if;
            end if;
            Count(stopIndex) <= (others => '0');
            Access_Overflow(stopIndex) <= '0';
          end if;
        end if;
      end if;
    end process Counters_FF;
  end generate Gen_Access_Counter;

  Delayed_Statistics_Handler : process (Clk) is
  begin  -- process Delayed_Statistics_Handler
    if( Clk'event and Clk = '1' ) then   -- rising clock edge
      if( Rst = '1' ) then              -- synchronous reset (active high)
        update_d2         <= '0';
        counter_2_d1      <= (others=>'0');
        Cycle_Count_2_i   <= (others=>'0');
        
      else
        update_d2         <= update_d1;
        counter_2_d1      <= std_logic_vector(unsigned(Count_Stop_d1) * unsigned(Count_Stop_d1));
        
        if Clear = '1' then
          Cycle_Count_2_i <= (others => '0');
        end if;
        if( update_d2 = '1' ) then
          -- Sum of all counter events.
          if( C_USE_STDDEV /= 0 ) then
            Cycle_Count_2_i <= std_logic_vector(unsigned(Cycle_Count_2_i) + unsigned(counter_2_d1));
          else
            Cycle_Count_2_i <= (others=>'0');
          end if;
          
        end if;
      end if;
    end if;
  end process Delayed_Statistics_Handler;
  
  Count_Stop <= Count(stopIndex);

  Access_FF : process(Clk)
  begin
    if Clk'event and Clk = '1' then     -- rising clock edge
      if Rst = '1' then
        Starting   <= false;
        Stopping   <= false;
        Running    <= (others => '0');
        Is_Valid   <= (others => '0');
        firstIndex <= 0;
        lastIndex  <= 0;
        stopIndex  <= 0;
        Empty      <= true;
        Full       <= '0';
      else
        Starting <= false;
        Stopping <= false;
        if (Running(firstIndex) = '1') then
          if (Access_Abort = '1') then
            Is_Valid(firstIndex) <= '0';
            Running(firstIndex)  <= '0';
            firstIndex           <= firstIndex_Next;
            stopIndex            <= firstIndex;
            Stopping             <= true;
            if firstIndex_Next = lastIndex then
              Empty <= true;
            end if;
          else
            if Access_Valid = '1' then
              Is_Valid(firstIndex) <= '1';
            end if;
            if Access_Ready = '1' then
              -- No check of Access_Active or Access_Active_N
              Running(firstIndex) <= '0';
              firstIndex          <= firstIndex_Next;
              stopIndex           <= firstIndex;
              Stopping            <= true;
              if firstIndex_Next = lastIndex then
                Empty <= true;
              end if;
            end if;
          end if;
        end if;
        if Access_Request = '1' and
           Access_Active = '1' and
           Access_ActiveN = '0' and
           Pause = '0' then
          if lastIndex = firstIndex and not Empty and Access_Abort = '0' then
            Full <= '1';
          else
            Running(lastIndex)  <= '1';
            Is_Valid(lastIndex) <= '0';
            lastIndex           <= lastIndex_Next;
            Empty               <= false;
            Starting            <= true;
            
            -- Support for zero cycle accesses
            if Access_Abort = '0' and Empty then
              if Access_Valid = '1' then
                Is_Valid(lastIndex) <= '1';
              end if;
              if Access_Ready = '1' then
                -- No check of Access_Active or Access_Active_N
                Running(lastIndex) <= '0';
                firstIndex <= firstIndex_Next;
                stopIndex  <= lastIndex;
                Stopping   <= true;
                Empty      <= true;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end process Access_FF;

  No_PipeLining : if C_PIPELINE_DEPTH = 1 generate
    firstIndex_Next <= 0;
    lastIndex_Next  <= 0;
  end generate No_PipeLining;

  PipeLining : if C_PIPELINE_DEPTH > 1 generate
    constant C_PIPELINE_BITS : integer := Log2(C_PIPELINE_DEPTH);

    subtype Index_Vector is std_logic_vector(0 to C_PIPELINE_BITS - 1);

    signal firstIndex_Vector : Index_Vector;
    signal lastIndex_Vector  : Index_Vector;
  begin
    firstIndex_Vector <= std_logic_vector(to_unsigned(firstIndex, C_PIPELINE_BITS));
    firstIndex_Next   <= to_integer(unsigned(firstIndex_Vector) + 1);

    lastIndex_Vector  <= std_logic_vector(to_unsigned(lastIndex, C_PIPELINE_BITS));
    lastIndex_Next    <= to_integer(unsigned(lastIndex_Vector)  + 1);
  end generate PipeLining;


  Assign: process(Access_Count_i, Minimum, Maximum, Full, Overflow, Cycle_Count_i, Cycle_Count_2_i)
  begin
    Access_Count  <= (others => '0');
    Access_Count(C_ACCESS_COUNTER_WIDTH - 1 downto 0) <= Access_Count_i;
    
    Min_Max_Status  <= (others => '0');
    Min_Max_Status(C_STAT_MIN_POS)      <= Minimum;
    Min_Max_Status(C_STAT_MAX_POS)      <= Maximum;
    Min_Max_Status(C_STAT_FULL_POS)     <= Full;
    Min_Max_Status(C_STAT_OVERFLOW_POS) <= Overflow;
    
    Cycle_Count   <= (others => '0');
    Cycle_Count(C_CYCLE_COUNTER_WIDTH   - 1 downto 0) <= Cycle_Count_i;
    
    Cycle_Count_2 <= (others => '0');
    Cycle_Count_2(C_CYCLE_COUNTER_WIDTH - 1 downto 0) <= Cycle_Count_2_i;

  end process Assign;


  Is_Running <= Running(firstIndex);
  Is_Stopped <= not Running(firstIndex);

end architecture IMP;



-------------------------------------------------------------------------------
-- sc_stat_latency.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_stat_latency.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_stat_latency.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_stat_latency is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    
    -- Configuration.
    C_STAT_LATENCY_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_LATENCY_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common Signals
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Counter Interface
    
    ar_start                  : in  std_logic;
    ar_ack                    : in  std_logic;
    rd_valid                  : in  std_logic;
    rd_last                   : in  std_logic;
    aw_start                  : in  std_logic;
    aw_ack                    : in  std_logic;
    wr_valid                  : in  std_logic;
    wr_last                   : in  std_logic;
    wr_resp                   : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_enable               : in  std_logic;
    
    stat_rd_latency           : out STAT_POINT_TYPE;    -- External Read Latency
    stat_wr_latency           : out STAT_POINT_TYPE;    -- External Write Latency
    stat_rd_latency_conf      : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
    stat_wr_latency_conf      : in  STAT_CONF_TYPE      -- External Write Latency Configuration
  );
end entity sc_stat_latency;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_stat_latency is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_statistics_counters is
    generic (
      -- Module implementation generics
      C_ACCESS_COUNTER_WIDTH : integer range 1 to 64 := 32;
      C_CYCLE_COUNTER_WIDTH  : integer range 1 to 64 := 48;
      C_USE_STDDEV           : integer range 0 to 1  :=  0;
      C_PIPELINE_DEPTH       : integer range 1 to 32 :=  1;
      C_MAX_CYCLE_WIDTH      : integer range 2 to 16 :=  8;
      C_SIMPLE_COUNTER       : boolean := false
    );
    port (
      CLK            : in  std_logic;
      Rst            : in  std_logic;
  
      -- Access signals
      Access_Request : in  std_logic;
      Access_Ready   : in  std_logic;
      Access_Active  : in  std_logic;
      Access_ActiveN : in  std_logic;
      Access_Valid   : in  std_logic;
      Access_Abort   : in  std_logic;
  
      Pause          : in  std_logic;
      Clear          : in  std_logic;
  
      Is_Running     : out std_logic;
      Is_Stopped     : out std_logic;
  
      Min_Max_Status : out STAT_TYPE;
      Access_Count   : out STAT_TYPE;
      Cycle_Count    : out STAT_TYPE;
      Cycle_Count_2  : out STAT_TYPE
    );
  end component sc_statistics_counters;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Statistics Control
  
  signal Rd_Access_Request        : std_logic;
  signal Rd_Access_Ready          : std_logic;
  signal Wr_Access_Request        : std_logic;
  signal Wr_Access_Ready          : std_logic;
  
  signal rd_first                 : std_logic;
  signal wr_first                 : std_logic;
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Statistics Control
  -----------------------------------------------------------------------------
  
  Detect_Handler : process (ACLK) is
  begin  -- process Detect_Handler
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        Rd_Access_Request <= '0';
        Rd_Access_Ready   <= '0';
        Wr_Access_Request <= '0';
        Wr_Access_Ready   <= '0';
        
        rd_first          <= '1';
        wr_first          <= '1';
        
      else
        -- Simple start.
        if( ( stat_rd_latency_conf(C_RD_LATENCY_POS) = C_STAT_RD_LATENCY_VALID ) or
            ( stat_rd_latency_conf(C_RD_LATENCY_POS) = C_STAT_RD_LATENCY_LAST  ) ) then 
          Rd_Access_Request <= stat_enable and ar_start;
        else 
          Rd_Access_Request <= stat_enable and ar_ack;
        end if;
        if( ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_VALID ) or 
            ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_LAST  ) or 
            ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_BRESP ) )then 
          Wr_Access_Request <= stat_enable and aw_start;
        else 
          Wr_Access_Request <= stat_enable and aw_ack;
        end if;
        
        -- Select end point.
        if( ( stat_rd_latency_conf(C_RD_LATENCY_POS) = C_STAT_RD_LATENCY_VALID     ) or
            ( stat_rd_latency_conf(C_RD_LATENCY_POS) = C_STAT_RD_LATENCY_ACK_VALID ) ) then 
          Rd_Access_Ready   <= stat_enable and rd_valid and rd_first;
        else 
          Rd_Access_Ready   <= stat_enable and rd_last;
        end if;
        
        if( ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_VALID     ) or 
            ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_ACK_VALID ) )then 
          Wr_Access_Ready   <= stat_enable and wr_valid and wr_first;
        elsif( ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_LAST     ) or 
               ( stat_wr_latency_conf(C_WR_LATENCY_POS) = C_STAT_WR_LATENCY_ACK_LAST ) ) then 
          Wr_Access_Ready   <= stat_enable and wr_last;
        else 
          Wr_Access_Ready   <= stat_enable and wr_resp;
        end if;
        
        -- Keep track of transaction.
        if( rd_valid = '1' ) then
          rd_first          <= rd_last;
        end if;
        if( wr_valid = '1' ) then
          wr_first          <= wr_last;
        end if;
        
      end if;
    end if;
  end process Detect_Handler;
  
  
  -----------------------------------------------------------------------------
  -- Statistics Count
  -----------------------------------------------------------------------------
  
  Rd_Inst: sc_statistics_counters
    generic map(
      -- Module implementation generics
      C_ACCESS_COUNTER_WIDTH  => C_STAT_BITS,
      C_CYCLE_COUNTER_WIDTH   => C_STAT_BIG_BITS,
      C_USE_STDDEV            => C_STAT_USE_STDDEV,
      C_PIPELINE_DEPTH        => C_STAT_LATENCY_RD_DEPTH,
      C_MAX_CYCLE_WIDTH       => C_STAT_MAX_CYCLE_WIDTH,
      C_SIMPLE_COUNTER        => false
    )
    port map(
      CLK                     => ACLK,
      Rst                     => ARESET,
  
      -- Access signals
      Access_Request          => Rd_Access_Request,
      Access_Ready            => Rd_Access_Ready,
      Access_Active           => '1',
      Access_ActiveN          => '0',
      Access_Valid            => '1',
      Access_Abort            => '0',
  
      Pause                   => '0',
      Clear                   => '0',
  
      Is_Running              => open,
      Is_Stopped              => open,
  
      Min_Max_Status          => stat_rd_latency.Min_Max_Status,
      Access_Count            => stat_rd_latency.Events,
      Cycle_Count             => stat_rd_latency.Sum,
      Cycle_Count_2           => stat_rd_latency.Sum_2
    );
  
  Wr_Inst: sc_statistics_counters
    generic map(
      -- Module implementation generics
      C_ACCESS_COUNTER_WIDTH  => C_STAT_BITS,
      C_CYCLE_COUNTER_WIDTH   => C_STAT_BIG_BITS,
      C_USE_STDDEV            => C_STAT_USE_STDDEV,
      C_PIPELINE_DEPTH        => C_STAT_LATENCY_WR_DEPTH,
      C_MAX_CYCLE_WIDTH       => C_STAT_MAX_CYCLE_WIDTH,
      C_SIMPLE_COUNTER        => false
    )
    port map(
      CLK                     => ACLK,
      Rst                     => ARESET,
  
      -- Access signals
      Access_Request          => Wr_Access_Request,
      Access_Ready            => Wr_Access_Ready,
      Access_Active           => '1',
      Access_ActiveN          => '0',
      Access_Valid            => '1',
      Access_Abort            => '0',
  
      Pause                   => '0',
      Clear                   => '0',
  
      Is_Running              => open,
      Is_Stopped              => open,
  
      Min_Max_Status          => stat_wr_latency.Min_Max_Status,
      Access_Count            => stat_wr_latency.Events,
      Cycle_Count             => stat_wr_latency.Sum,
      Cycle_Count_2           => stat_wr_latency.Sum_2
    );
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_srl_fifo_counter.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_srl_fifo_counter.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_srl_fifo_counter.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_srl_fifo_counter is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- Configuration.
    C_PUSH_ON_CARRY           : boolean                       := false;
    C_POP_ON_CARRY            : boolean                       := false;
    C_ENABLE_PROTECTION       : boolean                       := false;
    C_USE_QUALIFIER           : boolean                       := false;
    C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
    C_USE_REGISTER_OUTPUT     : boolean                       := false;
    C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
    C_LINE_LENGTH             : natural range  1 to 1023      :=  4
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- Queue Counter Interface
    
    queue_push                : in  std_logic;
    queue_pop                 : in  std_logic;
    queue_push_qualifier      : in  std_logic;
    queue_pop_qualifier       : in  std_logic;
    queue_refresh_reg         : out std_logic;
    
    queue_almost_full         : out std_logic := '0';
    queue_full                : out std_logic := '0';
    queue_almost_empty        : out std_logic := '0';
    queue_empty               : out std_logic := '1';
    queue_exist               : out std_logic := '0';
    queue_line_fit            : out std_logic := '1';
    queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_data                 : out STAT_FIFO_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals
    
    DEBUG                     : out std_logic_vector(255 downto 0)
  );
end entity sc_srl_fifo_counter;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_srl_fifo_counter is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Custom types (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_READ_FROM_EMPTY           : natural :=  0;
  constant C_ASSERT_WRITE_TO_FULL             : natural :=  1;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  2;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  -- Types for Queue Length.
  constant C_DATA_QUEUE_LENGTH        : integer:= 2 ** C_QUEUE_ADDR_WIDTH;
  constant C_DATA_QUEUE_LENGTH_BITS   : integer:= C_QUEUE_ADDR_WIDTH;
  subtype DATA_QUEUE_ADDR_POS         is natural range C_DATA_QUEUE_LENGTH - 1 downto 0;
  subtype DATA_QUEUE_ADDR_TYPE        is std_logic_vector(C_DATA_QUEUE_LENGTH_BITS - 1 downto 0);
  
  -- Levels for counters.
  constant C_DATA_QUEUE_EMPTY         : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - 1,                 C_DATA_QUEUE_LENGTH_BITS));
                      
  constant C_DATA_QUEUE_ALMOST_EMPTY  : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(1,                                       C_DATA_QUEUE_LENGTH_BITS));
                      
  constant C_DATA_QUEUE_ALMOST_FULL   : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - 4,                 C_DATA_QUEUE_LENGTH_BITS));
                      
  constant C_DATA_QUEUE_LINE_LEVEL_UP : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - 3 - C_LINE_LENGTH, C_DATA_QUEUE_LENGTH_BITS));
                      
  constant C_DATA_QUEUE_LINE_LEVEL_DN : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - 1 - C_LINE_LENGTH, C_DATA_QUEUE_LENGTH_BITS));
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or_n;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Queue Control Selection
  
  signal queue_push_srl           : std_logic;
  signal queue_pop_srl            : std_logic;
  signal queue_refresh_reg_i      : std_logic;
  signal queue_exist_i            : std_logic;
  
  
  -- ----------------------------------------
  -- Queue Handling
  
  signal refresh_counter          : std_logic;
  signal read_fifo_addr           : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
  
  signal queue_almost_full_cmb    : std_logic;
  signal queue_almost_empty_cmb   : std_logic;
  signal queue_line_fit_up_cmb    : std_logic;
  signal queue_line_fit_dn_cmb    : std_logic;
  
  signal queue_almost_full_i      : std_logic;
  signal queue_full_i             : std_logic;
  signal queue_almost_empty_i     : std_logic;
  signal queue_empty_i            : std_logic;
  signal queue_line_fit_i         : std_logic;
  signal queue_push_prot          : std_logic;
  signal queue_pop_prot           : std_logic;
  
  signal stat_index               : STAT_POINT_TYPE;
  signal stat_empty               : STAT_POINT_TYPE;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1             : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Queue Control Selection
  -----------------------------------------------------------------------------
  
  No_Reg_Ctrl: if( not C_USE_REGISTER_OUTPUT ) generate
  begin
    queue_push_srl      <= queue_push;
    queue_pop_srl       <= queue_pop;
    queue_refresh_reg_i <= '0';
    
    queue_exist         <= not queue_empty_i;
  end generate No_Reg_Ctrl;
  
  Use_Reg_Ctrl: if( C_USE_REGISTER_OUTPUT ) generate
    signal queue_pop_reg            : std_logic;
  begin
    queue_push_srl      <= queue_push;
    
    No_Pop_Carry: if( not C_POP_ON_CARRY ) generate
    begin
      queue_pop_srl       <= queue_refresh_reg_i and not queue_empty_i;
      queue_pop_reg       <= queue_pop;
      queue_refresh_reg_i <= queue_pop_reg or not queue_exist_i;
    end generate No_Pop_Carry;
    
    Use_Pop_Carry: if( C_POP_ON_CARRY ) generate
    begin
      SRL_Or_Inst1: carry_or_n 
        generic map(
          C_TARGET => C_TARGET
        )
        port map(
          Carry_IN  => queue_pop,
          A_N       => queue_exist_i,
          Carry_OUT => queue_refresh_reg_i
        );
      SRL_And_Inst1: carry_and_n 
        generic map(
          C_TARGET => C_TARGET
        )
        port map(
          Carry_IN  => queue_refresh_reg_i,
          A_N       => queue_empty_i,
          Carry_OUT => queue_pop_srl
        );
    end generate Use_Pop_Carry;
    
    -- Handle flags for register stage.
    Register_Flag_Handling : process (ACLK) is
    begin  -- process Register_Flag_Handling
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          queue_exist_i         <= '0';
          
        elsif( queue_refresh_reg_i = '1' ) then
          queue_exist_i         <= not queue_empty_i;
          
        end if;
      end if;
    end process Register_Flag_Handling;
    
    queue_exist         <= queue_exist_i;
    
  end generate Use_Reg_Ctrl;
  
  
  -----------------------------------------------------------------------------
  -- Queue Handling
  -----------------------------------------------------------------------------
  
  No_Qualifier: if( not C_USE_QUALIFIER ) generate
  begin
    -- Is protection enabled?
    queue_push_prot   <= queue_full_i  when C_ENABLE_PROTECTION else '0';
    queue_pop_prot    <= queue_empty_i when C_ENABLE_PROTECTION else '0';
  end generate No_Qualifier;
  
  Use_Qualifier: if( C_USE_QUALIFIER ) generate
  begin
    queue_push_prot   <= queue_push_qualifier  when C_QUALIFIER_LEVEL = 0 else not queue_push_qualifier;
    queue_pop_prot    <= queue_pop_qualifier   when C_QUALIFIER_LEVEL = 0 else not queue_pop_qualifier;
  end generate Use_Qualifier;
  
  -- Detect when pointer needs updating.
  refresh_counter <= ( queue_push_srl and not queue_push_prot ) xor ( queue_pop_srl and not queue_pop_prot );
  
  Use_RTL: if( C_TARGET = RTL ) generate
  begin
    -- Handle pointer to Queue.
    FIFO_Pointer : process (ACLK) is
    begin  -- process FIFO_Pointer
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          read_fifo_addr  <= C_DATA_QUEUE_EMPTY;
        elsif( refresh_counter = '1' ) then
          if ( queue_push_srl = '1' ) then
            read_fifo_addr  <= std_logic_vector(unsigned(read_fifo_addr) + 1);
          else
            read_fifo_addr  <= std_logic_vector(unsigned(read_fifo_addr) - 1);
          end if;
        end if;
      end if;
    end process FIFO_Pointer;
    
    -- Handle flags to Queue.
    Flag_Handling : process (ACLK) is
    begin  -- process Flag_Handling
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          queue_almost_full_i   <= '0';
          queue_full_i          <= '0';
          queue_almost_empty_i  <= '0';
          queue_empty_i         <= '1';
          if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) then
            queue_line_fit_i      <= '0';
          else
            queue_line_fit_i      <= '1';
          end if;
          
        elsif( refresh_counter = '1' ) then
          if ( queue_push_srl = '1' ) then
            queue_almost_full_i   <= queue_almost_full_cmb;
            queue_full_i          <= queue_almost_full_i;
            queue_almost_empty_i  <= queue_empty_i;
            queue_empty_i         <= '0';
            if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) then
              queue_line_fit_i      <= '0';
            else
              queue_line_fit_i      <= queue_line_fit_up_cmb;
            end if;
            
          else
            queue_almost_full_i   <= queue_full_i;
            queue_full_i          <= '0';
            queue_almost_empty_i  <= queue_almost_empty_cmb;
            queue_empty_i         <= queue_almost_empty_i;
            if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) then
              queue_line_fit_i      <= '0';
            else
              queue_line_fit_i      <= queue_line_fit_dn_cmb;
            end if;
            
          end if;
        end if;
      end if;
    end process Flag_Handling;
    
  end generate Use_RTL;
  
  Use_FPGA: if( C_TARGET /= RTL ) generate
    signal queue_almost_full_next   : std_logic;
    signal queue_full_next          : std_logic;
    signal queue_almost_empty_next  : std_logic;
    signal queue_empty_next         : std_logic;
    signal queue_line_fit_next      : std_logic;
    
    signal cnt_s                    : std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
    signal cnt_di                   : std_logic_vector(C_QUEUE_ADDR_WIDTH - 2 downto 0);
    signal carry                    : std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
    signal read_fifo_addr_next      : std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
  begin
    -- Start carry chain.
    carry(0)  <= '0';
    
    Cnt_Bit_Gen: for I in 0 to C_QUEUE_ADDR_WIDTH - 1 generate
    begin
--      queue_pop_srl       <= queue_refresh_reg_i and not queue_empty_i;
--      queue_pop_reg       <= queue_pop;
--      queue_refresh_reg_i <= queue_pop_reg or not queue_exist_i;

      No_Prot: if ( ( not C_USE_QUALIFIER ) and ( C_USE_REGISTER_OUTPUT and not C_POP_ON_CARRY ) ) generate
      begin
        Last_Bit: if( I = C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6
            generic map(
              INIT => X"FFAE005100510051"
            )
            port map(
              O  => cnt_s(I),                     -- [out]
              I0 => queue_empty_i,                -- [in]
              I1 => queue_exist_i,                -- [in]
              I2 => queue_pop,                    -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Last_Bit;
        Other_Bits: if( I /= 0 and I /= C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"FFAE005100510051"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_empty_i,                -- [in]
              I1 => queue_exist_i,                -- [in]
              I2 => queue_pop,                    -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Other_Bits;
        First_Bit: if( I = 0 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"51AEAE51AE51AE51"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_empty_i,                -- [in]
              I1 => queue_exist_i,                -- [in]
              I2 => queue_pop,                    -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate First_Bit;
      end generate No_Prot;
          
      Active_Low: if ( C_USE_QUALIFIER and C_QUALIFIER_LEVEL = 0 ) or
                     ( ( not C_USE_QUALIFIER ) and not ( C_USE_REGISTER_OUTPUT and not C_POP_ON_CARRY ) ) generate
      begin
        Last_Bit: if( I = C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6
            generic map(
              INIT => X"BFAF405040504050"
            )
            port map(
              O  => cnt_s(I),                     -- [out]
              I0 => queue_pop_prot,               -- [in]
              I1 => queue_push_prot,              -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Last_Bit;
        Other_Bits: if( I /= 0 and I /= C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"BFAF405040504050"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_pop_prot,               -- [in]
              I1 => queue_push_prot,              -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Other_Bits;
        First_Bit: if( I = 0 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"9CAF635063506350"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_pop_prot,               -- [in]
              I1 => queue_push_prot,              -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate First_Bit;
      end generate Active_Low;
          
      Active_High: if ( C_USE_QUALIFIER and C_QUALIFIER_LEVEL = 1 ) generate
      begin
        -- Use qualifier directly since the inverter might cause suboptimal implementation for counter.
        
        Last_Bit: if( I = C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6
            generic map(
              INIT => X"4F5FB0A0B0A0B0A0"
            )
            port map(
              O  => cnt_s(I),                     -- [out]
              I0 => queue_pop_qualifier,          -- [in]
              I1 => queue_push_qualifier,         -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Last_Bit;
        Other_Bits: if( I /= 0 and I /= C_QUEUE_ADDR_WIDTH - 1 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"4F5FB0A0B0A0B0A0"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_pop_qualifier,          -- [in]
              I1 => queue_push_qualifier,         -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate Other_Bits;
        First_Bit: if( I = 0 ) generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"635F9CA09CA09CA0"
            )
            port map(
              O5 => cnt_di(I),                    -- [out]
              O6 => cnt_s(I),                     -- [out]
              I0 => queue_pop_qualifier,          -- [in]
              I1 => queue_push_qualifier,         -- [in]
              I2 => queue_pop_srl,                -- [in]
              I3 => queue_push_srl,               -- [in]
              I4 => read_fifo_addr(I),            -- [in]
              I5 => '1'                           -- [in]
            );
        end generate First_Bit;
      end generate Active_High;
          
      Use_Muxcy: if( I /= C_QUEUE_ADDR_WIDTH - 1 ) generate
      begin
        MUXCY_Inst : MUXCY_L
          port map (
            DI => cnt_di(I),
            CI => carry(I),
            S  => cnt_s(I),
            LO => carry(I+1));
      end generate Use_Muxcy;
  
      -- Merge addsub result with carry in to get final result
      XOR_Inst : XORCY
        port map (
          LI => cnt_s(I),
          CI => carry(I),
          O  => read_fifo_addr_next(I));
          
      FDS_Inst : FDS
        port map (
          Q  => read_fifo_addr(I),            -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => read_fifo_addr_next(I),       -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
      
    end generate Cnt_Bit_Gen;
  
    -- Handle flags to Queue.
    Flag_Handling : process (refresh_counter, queue_push_srl, queue_push_prot, 
                             queue_full_i, 
                             queue_almost_full_cmb, queue_almost_full_i, 
                             queue_almost_empty_cmb, queue_almost_empty_i, 
                             queue_empty_i, 
                             queue_line_fit_up_cmb, queue_line_fit_dn_cmb, queue_line_fit_i) is
    begin  -- process Flag_Handling
      if( refresh_counter = '1' ) then
        if ( ( queue_push_srl and not queue_push_prot ) = '1' ) then
          queue_almost_full_next  <= queue_almost_full_cmb;
          queue_full_next         <= queue_almost_full_i;
          queue_almost_empty_next <= queue_empty_i;
          queue_empty_next        <= '0';
          if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= queue_line_fit_up_cmb;
          end if;
          
        else
          queue_almost_full_next  <= queue_full_i;
          queue_full_next         <= '0';
          queue_almost_empty_next <= queue_almost_empty_cmb;
          queue_empty_next        <= queue_almost_empty_i;
          if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= queue_line_fit_dn_cmb;
          end if;
          
        end if;
      else
        queue_almost_full_next  <= queue_almost_full_i;
        queue_full_next         <= queue_full_i;
        queue_almost_empty_next <= queue_almost_empty_i;
        queue_empty_next        <= queue_empty_i;
        queue_line_fit_next     <= queue_line_fit_i;
      end if;
    end process Flag_Handling;
      
    Almost_Full_Inst : FDR
      port map (
        Q  => queue_almost_full_i,          -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_full_next,       -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Full_Inst : FDR
      port map (
        Q  => queue_full_i,                 -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_full_next,              -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Almost_Empty_Inst : FDR
      port map (
        Q  => queue_almost_empty_i,         -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_empty_next,      -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Empty_Inst : FDS
      port map (
        Q  => queue_empty_i,                -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_empty_next,             -- [in  std_logic]
        S  => ARESET                        -- [in  std_logic]
      );
    
    Use_Normal_Line: if( C_LINE_LENGTH < C_DATA_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDS
        port map (
          Q  => queue_line_fit_i,             -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Normal_Line;
    Use_Long_Line: if( C_LINE_LENGTH >= C_DATA_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDR
        port map (
          Q  => queue_line_fit_i,             -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          R  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Long_Line;
  end generate Use_FPGA;
  
  
  -----------------------------------------------------------------------------
  -- Queue Level Decoding
  -----------------------------------------------------------------------------
  
  -- Calculate Queue Status.
  queue_almost_full_cmb  <= '1' when (read_fifo_addr  = C_DATA_QUEUE_ALMOST_FULL)   else '0';
  queue_almost_empty_cmb <= '1' when (read_fifo_addr  = C_DATA_QUEUE_ALMOST_EMPTY)  else '0';
  queue_line_fit_up_cmb  <= '1' when (read_fifo_addr  = C_DATA_QUEUE_EMPTY) or         
                                     (read_fifo_addr  < C_DATA_QUEUE_LINE_LEVEL_UP) else '0';
  queue_line_fit_dn_cmb  <= '1' when (read_fifo_addr  < C_DATA_QUEUE_LINE_LEVEL_DN) else '0';
  
  
  -----------------------------------------------------------------------------
  -- Assign Outputs
  -----------------------------------------------------------------------------
  
  queue_refresh_reg   <= queue_refresh_reg_i;
  queue_almost_full   <= queue_almost_full_i;
  queue_full          <= queue_full_i;
  queue_almost_empty  <= queue_almost_empty_i;
  queue_empty         <= queue_empty_i;
  queue_line_fit      <= queue_line_fit_i;
  queue_index         <= read_fifo_addr;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Statistics: if( not C_USE_STATISTICS ) generate
  begin
    stat_empty  <= C_NULL_STAT_POINT;
    stat_index  <= C_NULL_STAT_POINT;
  end generate No_Statistics;
  
  Use_Statistics: if( C_USE_STATISTICS ) generate
    signal stat_fifo_update         : std_logic:= '0';
    signal stat_fifo_addr           : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
  begin
    Stat_Pipeline : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (stat_reset = '1') then          -- synchronous reset (active true)
          stat_fifo_update  <= '0';
          stat_fifo_addr    <= (others=>'0');
        else
          stat_fifo_update  <= refresh_counter;
          stat_fifo_addr    <= std_logic_vector(unsigned(read_fifo_addr) + 1);
        end if;
      end if;
    end process Stat_Pipeline;
    
    STAT_CNT_INST: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_QUEUE_ADDR_WIDTH,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
    
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => stat_fifo_update,
        counter                   => stat_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
    
        stat_data                 => stat_index
      );
      
    STAT_EMPTY_INST: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => 2,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
    
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => queue_empty_i,
        counter                   => std_logic_vector(to_unsigned(1, 2)),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_empty
      );
      
  end generate Use_Statistics;
  
  -- Assign outputs.
  Assign_Output : process (stat_empty, stat_index) is
  begin  -- process Assign_Output
    -- Default.
    stat_data.Empty_Cycles              <= (others=>'0');
    stat_data.Index_Updates             <= (others=>'0');
    stat_data.Index_Max                 <= (others=>'0');
    stat_data.Index_Sum                 <= (others=>'0');
    
    stat_data.Empty_Cycles              <= stat_empty.Sum;
    stat_data.Index_Updates             <= stat_index.Events;
    stat_data.Index_Max(C_STAT_MAX_POS) <= stat_index.Min_Max_Status(C_STAT_MAX_POS);
    stat_data.Index_Sum                 <= stat_index.Sum;
  end process Assign_Output;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          DEBUG  <= (others=>'0');
        else
          -- Default assignment.
          DEBUG      <= (others=>'0');
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect FIFO behaviour
  
  FIFO_Assertions: block
  begin
    -- Detect error conditions.
    assert_err(C_ASSERT_READ_FROM_EMPTY)  <= ( queue_empty_i and ( queue_pop_srl and not queue_pop_prot   ) )
                                                  when C_USE_ASSERTIONS else 
                                             '0';
    assert_err(C_ASSERT_WRITE_TO_FULL)    <= ( queue_full_i  and ( queue_push_srl and not queue_push_prot ) and not 
                                                                 ( queue_pop_srl  and not queue_pop_prot  ) ) 
                                                  when C_USE_ASSERTIONS else 
                                             '0';
    
    -- pragma translate_off
    
    -- Report any issues.
    assert assert_err_1(C_ASSERT_READ_FROM_EMPTY) /= '1' 
      report "SRL_FIFO Counter: Illegal Read from Empty FIFO."
        severity error;
    
    
    assert assert_err_1(C_ASSERT_WRITE_TO_FULL) /= '1' 
      report "SRL_FIFO Counter: Illegal Write to Full FIFO."
        severity error;
      
    -- pragma translate_on
  end block FIFO_Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_stat_counter.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_stat_counter.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_stat_counter.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_stat_counter is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    
    -- Configuration.
    C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common Signals
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Counter Interface
    
    update                    : in  std_logic;
    counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_enable               : in  std_logic;
    
    stat_data                 : out STAT_POINT_TYPE
  );
end entity sc_stat_counter;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_stat_counter is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Statistics
  
  signal counter_2                : std_logic_vector(2 * C_STAT_COUNTER_BITS - 1 downto 0);
  signal counter_events_i         : std_logic_vector(C_STAT_BITS             - 1 downto 0);
  signal counter_i                : std_logic_vector(C_STAT_COUNTER_BITS     - 1 downto 0);
  signal counter_min_i            : std_logic_vector(C_STAT_COUNTER_BITS     - 1 downto 0);
  signal counter_max_i            : std_logic_vector(C_STAT_COUNTER_BITS     - 1 downto 0);
  signal counter_sum_i            : std_logic_vector(C_STAT_BIG_BITS         - 1 downto 0);
  
  signal update_d1                : std_logic;
  signal counter_2_d1             : std_logic_vector(2 * C_STAT_COUNTER_BITS - 1 downto 0);
  signal counter_sum_2_i          : std_logic_vector(C_STAT_BIG_BITS         - 1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  Gen_Simple: if( C_STAT_SIMPLE_COUNTER /= 0 ) generate
  begin
    counter_i <= std_logic_vector(to_unsigned(1, counter_i'length));
    counter_2 <= std_logic_vector(to_unsigned(1, counter_2'length));
  end generate Gen_Simple;
  Not_Simple: if( C_STAT_SIMPLE_COUNTER = 0 ) generate
  begin
    counter_i <= counter;
    -- Generate Counter^2.
    counter_2 <= std_logic_vector( unsigned(counter) * unsigned(counter) );
  end generate Not_Simple;
  
  Statistics_Handler : process (ACLK) is
  begin  -- process Statistics_Handler
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        counter_events_i  <= (others=>'0');
        counter_min_i     <= (others=>'1');
        counter_max_i     <= (others=>'0');
        counter_sum_i     <= (others=>'0');
        
      elsif( ( stat_enable and update ) = '1' ) then
        -- Event counter.
        counter_events_i  <= std_logic_vector(unsigned(counter_events_i) + 1);
        
        if( C_STAT_SIMPLE_COUNTER = 0 ) then
          -- Detect Minimum.
          if ( unsigned(counter_i) < unsigned(counter_min_i) ) then
            counter_min_i                 <= (others=>'0');
            counter_min_i(counter'range)  <= counter_i;
          end if;
          
          -- Detect Maximum.
          if ( unsigned(counter_i) > unsigned(counter_max_i) ) then
            counter_max_i                 <= (others=>'0');
            counter_max_i(counter'range)  <= counter_i;
          end if;
        else
          counter_min_i     <= (others=>'1');
          counter_max_i     <= (others=>'0');
        end if;
        
        -- Sum of all counter events.
        counter_sum_i     <= std_logic_vector(unsigned(counter_sum_i)   + unsigned(counter_i));
        
      end if;
    end if;
  end process Statistics_Handler;
  
  Delayed_Statistics_Handler : process (ACLK) is
  begin  -- process Delayed_Statistics_Handler
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        update_d1         <= '0';
        counter_2_d1      <= (others=>'0');     
        counter_sum_2_i   <= (others=>'0');
        
      else
        update_d1         <= stat_enable and update;
        counter_2_d1      <= counter_2;
        
        if( update_d1 = '1' ) then
          -- Sum of all counter events.
          if( C_STAT_USE_STDDEV /= 0 ) then
            counter_sum_2_i   <= std_logic_vector(unsigned(counter_sum_2_i) + 
                                                  unsigned(counter_2_d1(C_STAT_COUNTER_BITS - 1 downto 0)));
          else
            counter_sum_2_i   <= (others=>'0');
          end if;
          
        end if;
      end if;
    end if;
  end process Delayed_Statistics_Handler;
  
  -- Assign outputs.
  Assign_Output : process (counter_events_i, counter_min_i, counter_max_i, counter_sum_i, counter_sum_2_i) is
  begin  -- process Assign_Output
    -- Default.
    stat_data.Events          <= (others=>'0');
    stat_data.Min_Max_Status  <= (others=>'0');
    stat_data.Sum             <= (others=>'0');
    stat_data.Sum_2           <= (others=>'0');
    
    stat_data.Events(C_STAT_BITS    - 1 downto 0)                                           <= counter_events_i;
    stat_data.Min_Max_Status(C_STAT_MIN_LO + C_STAT_COUNTER_BITS - 1 downto C_STAT_MIN_LO)  <= counter_min_i;
    stat_data.Min_Max_Status(C_STAT_MAX_LO + C_STAT_COUNTER_BITS - 1 downto C_STAT_MAX_LO)  <= counter_max_i;
    stat_data.Min_Max_Status(C_STAT_FULL_POS)                                               <= '0';
    stat_data.Min_Max_Status(C_STAT_OVERFLOW_POS)                                           <= '0';
    stat_data.Sum(C_STAT_BIG_BITS   - 1 downto 0)                                           <= counter_sum_i;
    stat_data.Sum_2(C_STAT_BIG_BITS - 1 downto 0)                                           <= counter_sum_2_i;
    
  end process Assign_Output;
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_stat_event.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_stat_event.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_stat_event.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_stat_event is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    
    -- Configuration.
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common Signals
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Probe Interface
    
    probe                     : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_enable               : in  std_logic;
    
    stat_data                 : out STAT_POINT_TYPE
  );
end entity sc_stat_event;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_stat_event is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Statistics
  
  signal probe_d1                 : std_logic;
  signal probe_d2                 : std_logic;
  signal probe_fall_edge          : std_logic;
  
  signal num_cycles               : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Detection
  -----------------------------------------------------------------------------
  
  Detect_Handler : process (ACLK) is
  begin  -- process Detect_Handler
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        probe_d1    <= '0';
        probe_d2    <= '0';
        num_cycles  <= (others=>'0');
        
      else
        probe_d1    <= probe;
        probe_d2    <= probe_d1;
        
        if( probe_d1 = '1' ) then
          num_cycles  <= std_logic_vector(unsigned(num_cycles) + 1);
        else
          num_cycles  <= (others=>'0');
        end if;
        
      end if;
    end if;
  end process Detect_Handler;
  
  probe_fall_edge  <= (not probe_d1) and probe_d2;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  CNT_INST: sc_stat_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      
      -- Configuration.
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
    )
    port map(
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    => probe_fall_edge,
      counter                   => num_cycles,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               => stat_enable,
      
      stat_data                 => stat_data
    );
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_m_axi_interface.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_m_axi_interface.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_m_axi_interface.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-06-21    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_m_axi_interface is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    
    -- Data type and settings specific.
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    
    -- AXI4 Master Interface specific.
    C_M_AXI_THREAD_ID_WIDTH   : natural range  1 to   32      := 1;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Out).
    
    write_req_ordered_info    : in  WRITE_REQ_TYPE;
    write_req_ordered_ready   : out std_logic;
    
    write_data_ordered_info   : in  DATA_PORT_TYPE;
    write_data_ordered_ready  : out std_logic;
    
    read_req_ordered_info     : in  READ_REQ_TYPE;
    read_req_ordered_ready    : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (In).
    
    mst_if_wr_resp_info       : out WRITE_RESP_TYPE;
    mst_if_wr_resp_ready      : in  std_logic;
    
    mst_if_rd_data_info       : out READ_RESP_TYPE;
    mst_if_rd_data_ready      : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Master Interface Signals.
    
    M_AXI_AWID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_AWADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_AWLEN               : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE              : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST             : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK              : out std_logic;
    M_AXI_AWCACHE             : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT              : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS               : out std_logic_vector(3 downto 0);
    M_AXI_AWVALID             : out std_logic;
    M_AXI_AWREADY             : in  std_logic;
    
    M_AXI_WDATA               : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_WSTRB               : out std_logic_vector((C_M_AXI_DATA_WIDTH/8)-1 downto 0);
    M_AXI_WLAST               : out std_logic;
    M_AXI_WVALID              : out std_logic;
    M_AXI_WREADY              : in  std_logic;
    
    M_AXI_BRESP               : in  std_logic_vector(1 downto 0);
    M_AXI_BID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_BVALID              : in  std_logic;
    M_AXI_BREADY              : out std_logic;
    
    M_AXI_ARID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_ARADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_ARLEN               : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE              : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST             : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK              : out std_logic;
    M_AXI_ARCACHE             : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT              : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS               : out std_logic_vector(3 downto 0);
    M_AXI_ARVALID             : out std_logic;
    M_AXI_ARREADY             : in  std_logic;
    
    M_AXI_RID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_RDATA               : in  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_RRESP               : in  std_logic_vector(1 downto 0);
    M_AXI_RLAST               : in  std_logic;
    M_AXI_RVALID              : in  std_logic;
    M_AXI_RREADY              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_be_rd_latency        : out STAT_POINT_TYPE;    -- External Read Latency
    stat_be_wr_latency        : out STAT_POINT_TYPE;    -- External Write Latency
    stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
    stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    M_IF_DEBUG                : out MAX_DEBUG_TYPE
  );
end entity sc_m_axi_interface;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


architecture IMP of sc_m_axi_interface is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Ranges for address parts.
  subtype C_ADDR_VALID_POS            is natural range C_ADDR_VALID_HI downto C_ADDR_VALID_LO;
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI downto C_ADDR_INTERNAL_LO;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  component sc_stat_latency is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_LATENCY_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_LATENCY_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      ar_start                  : in  std_logic;
      ar_ack                    : in  std_logic;
      rd_valid                  : in  std_logic;
      rd_last                   : in  std_logic;
      aw_start                  : in  std_logic;
      aw_ack                    : in  std_logic;
      wr_valid                  : in  std_logic;
      wr_last                   : in  std_logic;
      wr_resp                   : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_rd_latency           : out STAT_POINT_TYPE;    -- External Read Latency
      stat_wr_latency           : out STAT_POINT_TYPE;    -- External Write Latency
      stat_rd_latency_conf      : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_wr_latency_conf      : in  STAT_CONF_TYPE      -- External Write Latency Configuration
    );
  end component sc_stat_latency;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Internal signals.
  
  signal M_AXI_AWVALID_I            : std_logic;
  signal M_AXI_WVALID_I             : std_logic;
  signal M_AXI_WLAST_I              : std_logic;
  signal M_AXI_ARVALID_I            : std_logic;
  signal write_req_ordered_ready_i  : std_logic;
  signal write_data_ordered_ready_i : std_logic;
  signal read_req_ordered_ready_i   : std_logic;
  
    
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Write Address Channel
  -----------------------------------------------------------------------------
  
  write_req_ordered_ready_i  <= ( M_AXI_AWREADY or not M_AXI_AWVALID_I );
  write_req_ordered_ready    <= write_req_ordered_ready_i;
  
  -- Control output register for AW.
  Write_Addr_Request : process (ACLK) is
    variable M_AXI_AWADDR_I           : std_logic_vector(C_MAX_ADDR_WIDTH - 1 downto 0);
  begin  -- process Write_Addr_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        M_AXI_AWVALID_I                     <= '0';
        M_AXI_AWADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
        M_AXI_AWADDR_I(C_ADDR_INTERNAL_POS) := (others=>'0');
        M_AXI_AWADDR                        <= fit_vec(M_AXI_AWADDR_I, C_M_AXI_ADDR_WIDTH);
        M_AXI_AWLEN                         <= (others=>'0');
        M_AXI_AWBURST                       <= (others=>'0');
        M_AXI_AWSIZE                        <= std_logic_vector(to_unsigned(log2(C_M_AXI_DATA_WIDTH / 8), 3));
        M_AXI_AWLOCK                        <= '0';
        M_AXI_AWPROT                        <= NULL_AXI_PROT;       -- Normal and non-secure Data access only
        
      else
        if( M_AXI_AWREADY = '1' ) then
          M_AXI_AWVALID_I                     <= '0';
        end if;
          
        if( write_req_ordered_ready_i = '1' ) then
          M_AXI_AWVALID_I                     <= write_req_ordered_info.Valid;
          M_AXI_AWADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
          M_AXI_AWADDR_I(C_ADDR_INTERNAL_POS) := write_req_ordered_info.Addr(C_ADDR_INTERNAL_POS);
          M_AXI_AWADDR                        <= fit_vec(M_AXI_AWADDR_I, C_M_AXI_ADDR_WIDTH);
          M_AXI_AWLEN                         <= write_req_ordered_info.Len;
          M_AXI_AWSIZE                        <= write_req_ordered_info.Size;
          M_AXI_AWLOCK                        <= write_req_ordered_info.Exclusive;
          if( write_req_ordered_info.Kind = C_KIND_WRAP ) then
            M_AXI_AWBURST                       <= C_AW_WRAP;
          else
            M_AXI_AWBURST                       <= C_AW_INCR;
          end if;
          M_AXI_AWPROT                        <= write_req_ordered_info.Prot;
          
        end if;
      end if;
    end if;
  end process Write_Addr_Request;
  
  -- Set constant values and assign external signals for AW-Channel.
  M_AXI_AWVALID <= M_AXI_AWVALID_I;
  M_AXI_AWID    <= (others=>'0');
  M_AXI_AWCACHE <= "0011";
  M_AXI_AWQOS   <= (others=>'1');
  
  
  -----------------------------------------------------------------------------
  -- Write Channel
  -----------------------------------------------------------------------------
  
  write_data_ordered_ready_i  <= ( M_AXI_WREADY or not M_AXI_WVALID_I );
  write_data_ordered_ready    <= write_data_ordered_ready_i;
  
  -- Control output register for W.
  Write_Data_Request : process (ACLK) is
  begin  -- process Write_Data_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_WVALID_I  <= '0';
        M_AXI_WLAST_I   <= '0';
        M_AXI_WSTRB     <= (others=>'0');
        M_AXI_WDATA     <= (others=>'0');
        
      else
        if( M_AXI_WREADY = '1' ) then
          M_AXI_WVALID_I <= '0';
        end if;
          
        if( write_data_ordered_ready_i = '1' ) then
          M_AXI_WVALID_I  <= write_data_ordered_info.Valid;
          M_AXI_WLAST_I   <= write_data_ordered_info.Last;
          M_AXI_WSTRB     <= write_data_ordered_info.BE(C_M_AXI_DATA_WIDTH/8 - 1 downto 0);
          M_AXI_WDATA     <= write_data_ordered_info.Data(C_M_AXI_DATA_WIDTH - 1 downto 0);
        end if;
      end if;
    end if;
  end process Write_Data_Request;
  
  -- Assign external signal for W-Channel.
  M_AXI_WVALID                    <= M_AXI_WVALID_I;
  M_AXI_WLAST                     <= M_AXI_WLAST_I;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Channel
  -----------------------------------------------------------------------------
  
  -- No custom logic in this level.
  mst_if_wr_resp_info.Valid <= M_AXI_BVALID;
  mst_if_wr_resp_info.BRESP <= M_AXI_BRESP;
  M_AXI_BREADY              <= mst_if_wr_resp_ready;
  
  
  -----------------------------------------------------------------------------
  -- Read Address Channel
  -----------------------------------------------------------------------------
  
  read_req_ordered_ready_i  <= ( M_AXI_ARREADY or not M_AXI_ARVALID_I );
  read_req_ordered_ready    <= read_req_ordered_ready_i;
  
  -- Control output register for AW.
  Read_Addr_Request : process (ACLK) is
    variable M_AXI_ARADDR_I           : std_logic_vector(C_MAX_ADDR_WIDTH - 1 downto 0);
  begin  -- process Read_Addr_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_ARVALID_I                     <= '0';
        M_AXI_ARADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
        M_AXI_ARADDR_I(C_ADDR_INTERNAL_POS) := (others=>'0');
        M_AXI_ARADDR                        <= fit_vec(M_AXI_ARADDR_I, C_M_AXI_ADDR_WIDTH);
        M_AXI_ARLEN                         <= (others=>'0');
        M_AXI_ARBURST                       <= (others=>'0');
        M_AXI_ARSIZE                        <= std_logic_vector(to_unsigned(log2(C_M_AXI_DATA_WIDTH / 8), 3));
        M_AXI_ARLOCK                        <= '0';
        M_AXI_ARPROT                        <= NULL_AXI_PROT;       -- Normal and non-secure Data access only
        
      else
        if( M_AXI_ARREADY = '1' ) then
          M_AXI_ARVALID_I                     <= '0';
        end if;
          
        if( read_req_ordered_ready_i = '1' ) then
          M_AXI_ARVALID_I                     <= read_req_ordered_info.Valid;
          M_AXI_ARADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
          M_AXI_ARADDR_I(C_ADDR_INTERNAL_POS) := read_req_ordered_info.Addr(C_ADDR_INTERNAL_POS);
          M_AXI_ARADDR                        <= fit_vec(M_AXI_ARADDR_I, C_M_AXI_ADDR_WIDTH);
          M_AXI_ARLEN                         <= read_req_ordered_info.Len;
          M_AXI_ARSIZE                        <= read_req_ordered_info.Size;
          M_AXI_ARLOCK                        <= read_req_ordered_info.Exclusive;
          if( read_req_ordered_info.Kind = C_KIND_WRAP ) then
            M_AXI_ARBURST                       <= C_AR_WRAP;
          else
            M_AXI_ARBURST                       <= C_AR_INCR;
          end if;
          M_AXI_ARPROT                        <= read_req_ordered_info.Prot;
          
        end if;
      end if;
    end if;
  end process Read_Addr_Request;
  
  -- Set constant values and assign external signals for AW-Channel.
  M_AXI_ARVALID <= M_AXI_ARVALID_I;
  M_AXI_ARID    <= (others=>'0');
  M_AXI_ARCACHE <= "0011";
  M_AXI_ARQOS   <= (others=>'1');
  
  
  -----------------------------------------------------------------------------
  -- Read Channel
  -----------------------------------------------------------------------------
    
  -- No custom logic in this level.
  mst_if_rd_data_info.Valid <= M_AXI_RVALID;
  mst_if_rd_data_info.Last  <= M_AXI_RLAST;
  mst_if_rd_data_info.Data  <= fit_vec(M_AXI_RDATA, C_MAX_DATA_WIDTH);
  mst_if_rd_data_info.RRESP <= fit_vec(M_AXI_RRESP, C_MAX_RRESP_WIDTH);
  M_AXI_RREADY              <= mst_if_rd_data_ready;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_be_rd_latency  <= C_NULL_STAT_POINT;
    stat_be_wr_latency  <= C_NULL_STAT_POINT;
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal ar_start                   : std_logic;
    signal ar_done                    : std_logic;
    signal ar_ack                     : std_logic;
    signal rd_valid                   : std_logic;
    signal rd_last                    : std_logic;
    signal aw_start                   : std_logic;
    signal aw_done                    : std_logic;
    signal aw_ack                     : std_logic;
    signal wr_valid                   : std_logic;
    signal wr_last                    : std_logic;
    signal wr_resp                    : std_logic;
  begin
    
    -- Detect conditions.
    Trans_Handle : process (ACLK) is
    begin  -- process Trans_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          ar_start  <= '0';
          ar_done   <= '0';
          ar_ack    <= '0';
          rd_valid  <= '0';
          rd_last   <= '0';
          aw_start  <= '0';
          aw_done   <= '0';
          aw_ack    <= '0';
          wr_valid  <= '0';
          wr_last   <= '0';
          wr_resp   <= '0';
          
        else
          ar_start  <= M_AXI_ARVALID_I  and not ar_done;
          ar_ack    <= M_AXI_ARVALID_I  and M_AXI_ARREADY;
          rd_valid  <= M_AXI_RVALID     and mst_if_rd_data_ready;
          rd_last   <= M_AXI_RVALID     and mst_if_rd_data_ready and M_AXI_RLAST;
          
          aw_start  <= M_AXI_AWVALID_I  and not aw_done;
          aw_ack    <= M_AXI_AWVALID_I  and M_AXI_AWREADY;
          wr_valid  <= M_AXI_WVALID_I   and M_AXI_WREADY;
          wr_last   <= M_AXI_WVALID_I   and M_AXI_WREADY and M_AXI_WLAST_I;
          wr_resp   <= M_AXI_BVALID     and mst_if_wr_resp_ready;
          
          if( M_AXI_ARREADY = '1' ) then
            ar_done   <= '0';
          elsif( M_AXI_ARVALID_I = '1' ) then
            ar_done   <= '1';
          end if;
          
          if( M_AXI_AWREADY = '1' ) then
            aw_done   <= '0';
          elsif( M_AXI_AWVALID_I = '1' ) then
            aw_done   <= '1';
          end if;
          
        end if;
      end if;
    end process Trans_Handle;
    
    Latency_Inst: sc_stat_latency
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_LATENCY_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_LATENCY_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        ar_start                  => ar_start,
        ar_ack                    => ar_ack,
        rd_valid                  => rd_valid,
        rd_last                   => rd_last,
        aw_start                  => aw_start,
        aw_ack                    => aw_ack,
        wr_valid                  => wr_valid,
        wr_last                   => wr_last,
        wr_resp                   => wr_resp,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
    
        stat_rd_latency           => stat_be_rd_latency,
        stat_wr_latency           => stat_be_wr_latency,
        stat_rd_latency_conf      => stat_be_rd_latency_conf,
        stat_wr_latency_conf      => stat_be_wr_latency_conf
      );
    
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    M_IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    M_IF_DEBUG  <= (others=>'0');
  end generate Use_Debug;
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_m_ace_interface.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_m_ace_interface.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_m_ace_interface.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-06-21    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_m_ace_interface is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_NUM_WAYS                : natural range  1 to    8      :=  2;
    C_SNOOP_KEEP_READ_SHARED  : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_READ_CLEAN   : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_READ_NSD     : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_CLEAN_SHARED : natural range  0 to    1      :=  0;
    C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    
    -- AXI4 Master Interface specific.
    C_M_AXI_THREAD_ID_WIDTH   : natural range  1 to   32      := 1;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Out).
    
    write_req_ordered_info    : in  WRITE_REQ_TYPE;
    write_req_ordered_ready   : out std_logic;
    
    write_data_ordered_info   : in  DATA_PORT_TYPE;
    write_data_ordered_ready  : out std_logic;
    
    read_req_ordered_info     : in  READ_REQ_TYPE;
    read_req_ordered_ready    : out std_logic;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Sync Request.
    
    ctrl_dvm_req              : in  INTERNAL_DVM_TYPE;
    ctrl_dvm_done             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_backend_done         : out std_logic;
    ctrl_bar_req              : in  INTERNAL_BAR_TYPE;
    ctrl_bar_done             : out std_logic;
    ctrl_insert_running       : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (In).
    
    mst_if_wr_resp_info       : out WRITE_RESP_TYPE;
    mst_if_wr_resp_ready      : in  std_logic;
    
    mst_if_rd_data_info       : out READ_RESP_TYPE;
    mst_if_rd_data_ready      : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Master Snoop Interface Signals.
    
    mst_snoop_fetch_piperun   : out std_logic;
    mst_snoop_fetch_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_piperun     : out std_logic;
    mst_snoop_mem_info        : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_piperun   : out std_logic;
    mst_snoop_check_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_fetch_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_ack_info    : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_update_ack_info : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_fetch_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_mem_hazard       : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_check_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_hazard    : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_cross_order_hazard    : in  MST_SNOOP_HAZ_TYPE;
    
    mst_snoop_mem_rm_alloc    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_rm_alloc  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_tag_valid       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_way         : out natural range C_NUM_WAYS - 1 downto 0;
    mst_snoop_tag_info        : out WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_stall       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_sdr_push        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_info        : out MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_empty       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_full        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_update_data_info : in  MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_data_ready: out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_be_data_info     : in  MST_SNOOP_DATA_TYPE;
    mst_core_be_data_ready    : out std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4/ACE Master Interface Signals.
    
    M_AXI_AWID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_AWADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_AWLEN               : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE              : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST             : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK              : out std_logic;
    M_AXI_AWCACHE             : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT              : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS               : out std_logic_vector(3 downto 0);
    M_AXI_AWVALID             : out std_logic;
    M_AXI_AWREADY             : in  std_logic;
    M_AXI_AWDOMAIN            : out std_logic_vector(1 downto 0);                      -- For ACE
    M_AXI_AWSNOOP             : out std_logic_vector(2 downto 0);                      -- For ACE
    M_AXI_AWBAR               : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M_AXI_WDATA               : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_WSTRB               : out std_logic_vector((C_M_AXI_DATA_WIDTH/8)-1 downto 0);
    M_AXI_WLAST               : out std_logic;
    M_AXI_WVALID              : out std_logic;
    M_AXI_WREADY              : in  std_logic;
    
    M_AXI_BRESP               : in  std_logic_vector(1 downto 0);
    M_AXI_BID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_BVALID              : in  std_logic;
    M_AXI_BREADY              : out std_logic;
    M_AXI_WACK                : out std_logic;                                         -- For ACE
    
    M_AXI_ARID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_ARADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_ARLEN               : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE              : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST             : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK              : out std_logic;
    M_AXI_ARCACHE             : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT              : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS               : out std_logic_vector(3 downto 0);
    M_AXI_ARVALID             : out std_logic;
    M_AXI_ARREADY             : in  std_logic;
    M_AXI_ARDOMAIN            : out std_logic_vector(1 downto 0);                      -- For ACE
    M_AXI_ARSNOOP             : out std_logic_vector(3 downto 0);                      -- For ACE
    M_AXI_ARBAR               : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M_AXI_RID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
    M_AXI_RDATA               : in  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_RRESP               : in  std_logic_vector(4-1 downto 0);
    M_AXI_RLAST               : in  std_logic;
    M_AXI_RVALID              : in  std_logic;
    M_AXI_RREADY              : out std_logic;
    M_AXI_RACK                : out std_logic;                                         -- For ACE
    
    M_AXI_ACVALID             : in  std_logic;                                         -- For ACE
    M_AXI_ACADDR              : in  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);   -- For ACE
    M_AXI_ACSNOOP             : in  std_logic_vector(3 downto 0);                      -- For ACE
    M_AXI_ACPROT              : in  std_logic_vector(2 downto 0);                      -- For ACE
    M_AXI_ACREADY             : out std_logic;                                         -- For ACE
    
    M_AXI_CRVALID             : out std_logic;                                         -- For ACE
    M_AXI_CRRESP              : out std_logic_vector(4 downto 0);                      -- For ACE
    M_AXI_CRREADY             : in  std_logic;                                         -- For ACE
    
    M_AXI_CDVALID             : out std_logic;                                         -- For ACE
    M_AXI_CDDATA              : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);   -- For ACE
    M_AXI_CDLAST              : out std_logic;                                         -- For ACE
    M_AXI_CDREADY             : in  std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_be_rd_latency        : out STAT_POINT_TYPE;    -- External Read Latency
    stat_be_wr_latency        : out STAT_POINT_TYPE;    -- External Write Latency
    stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
    stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    M_IF_DEBUG                : out MAX_DEBUG_TYPE
  );
end entity sc_m_ace_interface;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_m_ace_interface is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  
    
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  function Calc_Size(datasize  : natural) return std_logic_vector is
  begin
    if( datasize = 32 ) then
      return "010";
    elsif( datasize = 64 ) then
      return "011";
    elsif( datasize = 128 ) then
      return "100";
    elsif( datasize = 256 ) then
      return "101";
    elsif( datasize = 512 ) then
      return "110";
    -- coverage off
    else
      assert false report "Unsupported AXI width" severity failure;
      return "010";
    -- coverage on
    end if;
    
  end function Calc_Size;

  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Ranges for address parts.
  subtype C_ADDR_VALID_POS            is natural range C_ADDR_VALID_HI downto C_ADDR_VALID_LO;
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  
  -- Coherency CD Channel
  subtype C_DATA_POS                  is natural range C_EXTERNAL_DATA_WIDTH - 1 downto 0;
  subtype DATA_TYPE                   is std_logic_vector(C_DATA_POS);
  type DATA_VECTOR_TYPE               is array(natural range <>) of DATA_TYPE;
  
  -- Types for Queue Length.
  constant C_DATA_QUEUE_LINE_LENGTH   : integer:= 32 * 16 / C_EXTERNAL_DATA_WIDTH;
  constant C_DATA_QUEUE_LENGTH        : integer:= max_of(32, 4 * C_DATA_QUEUE_LINE_LENGTH);
  constant C_DATA_QUEUE_LENGTH_BITS   : integer:= log2(C_DATA_QUEUE_LENGTH);
  subtype DATA_QUEUE_ADDR_POS         is natural range C_DATA_QUEUE_LENGTH - 1 downto 0;
  subtype DATA_QUEUE_ADDR_TYPE        is std_logic_vector(C_DATA_QUEUE_LENGTH_BITS - 1 downto 0);
  
  type RD_INS_TYPE                    is (DVM, Barrier, Complete);
  type WR_INS_TYPE                    is (Barrier);
  
  type RD_INS_VECTOR_TYPE             is array(natural range <>) of RD_INS_TYPE;
  type WR_INS_VECTOR_TYPE             is array(natural range <>) of WR_INS_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component sc_stat_latency is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_LATENCY_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_LATENCY_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      ar_start                  : in  std_logic;
      ar_ack                    : in  std_logic;
      rd_valid                  : in  std_logic;
      rd_last                   : in  std_logic;
      aw_start                  : in  std_logic;
      aw_ack                    : in  std_logic;
      wr_valid                  : in  std_logic;
      wr_last                   : in  std_logic;
      wr_resp                   : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_rd_latency           : out STAT_POINT_TYPE;    -- External Read Latency
      stat_wr_latency           : out STAT_POINT_TYPE;    -- External Write Latency
      stat_rd_latency_conf      : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_wr_latency_conf      : in  STAT_CONF_TYPE      -- External Write Latency Configuration
    );
  end component sc_stat_latency;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Internal signals.
  
  -- Write Channel
  signal M_AXI_AWVALID_I            : std_logic;
  signal M_AXI_WVALID_I             : std_logic;
  signal M_AXI_WLAST_I              : std_logic;
  signal M_AXI_ARVALID_I            : std_logic;
  signal write_req_ordered_ready_i  : std_logic;
  signal write_data_ordered_ready_i : std_logic;
  signal new_aw_transaction         : std_logic;
  signal internal_ctrl_aw_ready     : std_logic;
  signal internal_ctrl_aw_hold      : std_logic;
  
  -- Write Insert Handling
  signal wr_ins_push                : std_logic;
  signal wr_ins_pop                 : std_logic;
  signal wr_ins_fifo_full           : std_logic;
  signal wr_ins_fifo_empty          : std_logic;
  signal wr_ins_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
  signal wr_ins_fifo_mem            : WR_INS_VECTOR_TYPE(QUEUE_ADDR_POS);
  signal wr_ins_src                 : WR_INS_TYPE;
  
  -- Write Response Channel
  signal ack_insert_write_msg       : std_logic;
  signal M_AXI_BREADY_I             : std_logic;
  
  -- Read Channel
  signal ack_insert_read_msg        : std_logic;
  signal M_AXI_RREADY_I             : std_logic;
  
  -- Read Insert Handling
  signal rd_ins_push                : std_logic;
  signal rd_ins_pop                 : std_logic;
  signal rd_ins_fifo_full           : std_logic;
  signal rd_ins_fifo_empty          : std_logic;
  signal rd_ins_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
  signal rd_ins_fifo_mem            : RD_INS_VECTOR_TYPE(QUEUE_ADDR_POS);
  signal rd_ins_src                 : RD_INS_TYPE;
  
  -- ACE Downstream Sync Request Handling
  signal internal_dvm_valid         : std_logic;
  signal internal_sync_valid        : std_logic;
  signal other_req                  : std_logic;
  signal need_2nd_part              : std_logic;
  signal force_2nd_part             : std_logic;
  signal internal_ctrl_ar_ready     : std_logic;
  signal internal_ctrl_ar_hold      : std_logic;
  signal waiting_for_complete       : std_logic;
  signal sync_req                   : std_logic;
  signal sync_done                  : std_logic;
  signal dvm_other_done             : std_logic;
  signal ctrl_bar_done_i            : std_logic;
  
  -- Coherency AC Channel
  signal M_AXI_ACREADY_I            : std_logic;
  signal new_ac                     : std_logic;
  signal last_acaddr                : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
  signal internal_complete_valid    : std_logic;
  signal internal_complete_ready    : std_logic;
  signal internal_complete_already  : std_logic;
  signal new_ar_transaction         : std_logic;
  
  
  -- Coherency CR Channel
  signal new_crresp                 : AXI_CRRESP_TYPE;
  signal crresp_push                : std_logic;
  signal crresp_pop                 : std_logic;
  signal crresp_stall               : std_logic;
  signal crresp_fifo_full           : std_logic;
  signal crresp_fifo_empty          : std_logic;
  signal crresp_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
  signal crresp_fifo_mem            : AXI_CRRESP_VECTOR_TYPE(QUEUE_ADDR_POS);
  signal crresp_already_pushed      : std_logic;
  
  -- Coherency CD Channel
  signal mst_core_be_data_ready_i   : std_logic;
  signal cddata_fifo_full           : std_logic_vector(0 to C_CACHE_BLOCKS - 1);
  signal cd_sel_block               : rinteger range 0 to C_CACHE_BLOCKS - 1;
  signal cd_valid                   : std_logic_vector(0 to C_CACHE_BLOCKS - 1);
  signal cd_last                    : std_logic_vector(0 to C_CACHE_BLOCKS - 1);
  signal cd_data                    : DATA_VECTOR_TYPE(0 to C_CACHE_BLOCKS - 1);
  signal cd_src_valid               : std_logic;
  signal cd_src_stall               : std_logic;
  
  -- Pipeline Stage: Master Snoop Decode
  signal mst_snoop_decode_piperun   : std_logic;
  signal mst_snoop_decode_stall     : std_logic;
  signal mst_snoop_decode_info      : MST_SNOOP_REQ_TYPE;
  signal mst_snoop_decode_sel_block : rinteger range 0 to C_CACHE_BLOCKS - 1;
  
  -- Pipeline Stage: Master Snoop Fetch
  signal mst_snoop_fetch_piperun_i  : std_logic;
  signal mst_snoop_fetch_stall      : std_logic;
  signal mst_snoop_fetch_info_i     : MST_SNOOP_REQ_TYPE;
  signal mst_snoop_fetch_sel_block  : rinteger range 0 to C_CACHE_BLOCKS - 1;
  signal mstf_core_mem_stall        : std_logic;
  signal mstf_core_check_stall      : std_logic;
  signal mstf_core_update_stall     : std_logic;
  signal mst_snoop_mem_tag_conflict   : std_logic;
  signal mst_snoop_check_tag_conflict : std_logic;
  signal mstf_core_make_unique      : std_logic;
  signal mstf_core_make_dirty       : std_logic;
  
  -- Pipeline Stage: Master Snoop Mem
  signal mst_snoop_mem_piperun_i    : std_logic;
  signal mst_snoop_mem_stall        : std_logic;
  signal mst_snoop_mem_info_i       : MST_SNOOP_REQ_TYPE;
  signal mst_snoop_mem_sel_block    : rinteger range 0 to C_CACHE_BLOCKS - 1;
  signal mst_snoop_mem_rm_alloc_done: std_logic;
  signal mst_snoop_mem_make_unique  : std_logic;
  signal mst_snoop_mem_make_dirty   : std_logic;
  
  -- Pipeline Stage: Master Snoop Check
  signal mst_snoop_check_piperun_i  : std_logic;
  signal mst_snoop_check_stall      : std_logic;
  signal mst_snoop_check_info_i     : MST_SNOOP_REQ_TYPE;
  signal mst_snoop_check_alloc_done : std_logic;
  signal mst_snoop_check_sel_block  : rinteger range 0 to C_CACHE_BLOCKS - 1;
  signal mst_snoop_check_sel_ack    : MST_SNOOP_ACK_TYPE;
  signal mst_snoop_tag_valid_i      : std_logic;
  signal mst_snoop_tag_info_i       : WAY_LINE_TAG_TYPE;
  signal tag_already_written        : std_logic;
  signal sdr_info                   : MST_SNOOP_ADDR_TYPE;
  signal sdr_stall                  : std_logic;
  signal sdr_already_pushed         : std_logic;
  signal update_allocating_line     : std_logic;
  signal mst_snoop_check_make_unique  : std_logic;
  signal mst_snoop_check_make_dirty   : std_logic;

  -- Pipeline Stage: Start of PipeRun
  signal mst_snoop_start_piperun_i  : std_logic;
  
  
    
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Write Address Channel
  -----------------------------------------------------------------------------
  
  new_aw_transaction        <= ( M_AXI_AWREADY or not M_AXI_AWVALID_I );
  write_req_ordered_ready   <= write_req_ordered_ready_i;
  write_req_ordered_ready_i <= new_aw_transaction;
  internal_ctrl_aw_ready    <= new_aw_transaction                  and 
                               ( not write_req_ordered_info.Valid );
  
  -- Control output register for AW.
  Write_Addr_Request : process (ACLK) is
    variable M_AXI_AWADDR_I           : std_logic_vector(C_MAX_ADDR_WIDTH - 1 downto 0);
  begin  -- process Write_Addr_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        M_AXI_AWVALID_I                     <= '0';
        M_AXI_AWADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
        M_AXI_AWADDR_I(C_ADDR_INTERNAL_POS) := (others=>'0');
        M_AXI_AWADDR                        <= fit_vec(M_AXI_AWADDR_I, C_M_AXI_ADDR_WIDTH);
        M_AXI_AWLEN                         <= (others=>'0');
        M_AXI_AWSIZE                        <= std_logic_vector(to_unsigned(log2(C_M_AXI_DATA_WIDTH / 8), 3));
        M_AXI_AWLOCK                        <= '0';
        M_AXI_AWBURST                       <= (others=>'0');
        M_AXI_AWID                          <= (others=>'0');
        M_AXI_AWSNOOP                       <= (others=>'0');
        M_AXI_AWDOMAIN                      <= (others=>'0');
        M_AXI_AWBAR                         <= C_BAR_NORMAL_RESPECTING;
        M_AXI_AWPROT                        <= NULL_AXI_PROT;       -- Normal and non-secure Data access only
        
      else
        if( M_AXI_AWREADY = '1' ) then
          M_AXI_AWVALID_I                     <= '0';
        end if;
          
        if( new_aw_transaction = '1' ) then
          if( write_req_ordered_info.Valid = '1' ) then
            M_AXI_AWVALID_I                     <= '1';
            M_AXI_AWADDR_I(C_ADDR_VALID_POS)    := C_BASEADDR(C_ADDR_VALID_POS);
            M_AXI_AWADDR_I(C_ADDR_INTERNAL_POS) := write_req_ordered_info.Addr(C_ADDR_INTERNAL_POS);
            M_AXI_AWADDR                        <= fit_vec(M_AXI_AWADDR_I, C_M_AXI_ADDR_WIDTH);
            M_AXI_AWLEN                         <= write_req_ordered_info.Len;
            M_AXI_AWSIZE                        <= write_req_ordered_info.Size;
            M_AXI_AWLOCK                        <= write_req_ordered_info.Exclusive;
            if( write_req_ordered_info.Kind = C_KIND_WRAP ) then
              M_AXI_AWBURST                       <= C_AW_WRAP;
            else
              M_AXI_AWBURST                       <= C_AW_INCR;
            end if;
            M_AXI_AWID                          <= (others=>'0');
            M_AXI_AWSNOOP                       <= write_req_ordered_info.Snoop;
            M_AXI_AWDOMAIN                      <= write_req_ordered_info.Domain;
            M_AXI_AWBAR                         <= C_BAR_NORMAL_RESPECTING;
            M_AXI_AWPROT                        <= write_req_ordered_info.Prot;
            
          elsif( ctrl_bar_req.Valid = '1' ) then
            M_AXI_AWVALID_I                     <= '1';
            M_AXI_AWADDR                        <= fit_vec(ctrl_bar_req.Addr, C_M_AXI_ADDR_WIDTH);
            M_AXI_AWLEN                         <= (others=>'0');
            M_AXI_AWSIZE                        <= Calc_Size(C_M_AXI_DATA_WIDTH);
            M_AXI_AWLOCK                        <= '0';
            M_AXI_AWBURST                       <= C_AW_INCR;
            M_AXI_AWID                          <= std_logic_vector(to_unsigned(1, C_M_AXI_THREAD_ID_WIDTH));
            M_AXI_AWSNOOP                       <= C_AWSNOOP_Barrier;
            M_AXI_AWDOMAIN                      <= C_DOMAIN_INNER_SHAREABLE;
            if( ctrl_bar_req.Synchronizing = '1' ) then
              M_AXI_AWBAR                         <= C_BAR_SYNCHRONIZATION;
            else
              M_AXI_AWBAR                         <= C_BAR_MEMORY_BARRIER;
            end if;
            M_AXI_AWPROT                        <= write_req_ordered_info.Prot;
            
          end if;
        end if;
      end if;
    end if;
  end process Write_Addr_Request;
  
  -- Set constant values and assign external signals for AW-Channel.
  M_AXI_AWVALID   <= M_AXI_AWVALID_I;
  M_AXI_AWCACHE   <= "0011";
  M_AXI_AWQOS     <= (others=>'1');
  
  
  -----------------------------------------------------------------------------
  -- Write Insert Handling
  -----------------------------------------------------------------------------
  
  -- Handle push pop.
  wr_ins_push <= new_ar_transaction and
                 ( ctrl_bar_req.Valid );
  wr_ins_pop  <= M_AXI_BVALID and M_AXI_BREADY_I and M_AXI_BID(0);
  
  -- Instantiate CRRESP Queue pointer handling.
  FIFO_WR_INS_POINTER: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wr_ins_push,
      queue_pop                 => wr_ins_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => wr_ins_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => wr_ins_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => wr_ins_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => open,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Insert FIFO.
  FIFO_WR_INS_MEMORY : process (ACLK) is
  begin  -- process FIFO_WR_INS_MEMORY
    if( ACLK'event and ACLK = '1' ) then    -- rising clock edge
      if( wr_ins_push = '1' ) then
        -- Insert new item.
        wr_ins_fifo_mem(0)  <= Barrier;
        
        -- Shift FIFO contents.
        wr_ins_fifo_mem(wr_ins_fifo_mem'left downto 1)  <= wr_ins_fifo_mem(wr_ins_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_WR_INS_MEMORY;
  
  -- Assign output.
  wr_ins_src <= wr_ins_fifo_mem(to_integer(unsigned(wr_ins_read_fifo_addr)));
  
  
  -----------------------------------------------------------------------------
  -- Write Channel
  -----------------------------------------------------------------------------
  
  write_data_ordered_ready_i  <= ( M_AXI_WREADY or not M_AXI_WVALID_I );
  write_data_ordered_ready    <= write_data_ordered_ready_i;
  
  -- Control output register for W.
  Write_Data_Request : process (ACLK) is
  begin  -- process Write_Data_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_WVALID_I  <= '0';
        M_AXI_WLAST_I   <= '0';
        M_AXI_WSTRB     <= (others=>'0');
        M_AXI_WDATA     <= (others=>'0');
        
      else
        if( M_AXI_WREADY = '1' ) then
          M_AXI_WVALID_I <= '0';
        end if;
          
        if( write_data_ordered_ready_i = '1' ) then
          M_AXI_WVALID_I  <= write_data_ordered_info.Valid;
          M_AXI_WLAST_I   <= write_data_ordered_info.Last;
          M_AXI_WSTRB     <= write_data_ordered_info.BE(C_M_AXI_DATA_WIDTH/8 - 1 downto 0);
          M_AXI_WDATA     <= write_data_ordered_info.Data(C_M_AXI_DATA_WIDTH - 1 downto 0);
        end if;
      end if;
    end if;
  end process Write_Data_Request;
  
  -- Assign external signal for W-Channel.
  M_AXI_WVALID                    <= M_AXI_WVALID_I;
  M_AXI_WLAST                     <= M_AXI_WLAST_I;
  
  
 -----------------------------------------------------------------------------
  -- Write Response Channel
  -----------------------------------------------------------------------------
  
  -- Only propagate non inserted messages (DVM and others).
  mst_if_wr_resp_info.Valid <= M_AXI_BVALID and not M_AXI_BID(0);
  mst_if_wr_resp_info.BRESP <= M_AXI_BRESP;
  M_AXI_BREADY              <= M_AXI_BREADY_I;
  M_AXI_BREADY_I            <= mst_if_wr_resp_ready or ack_insert_write_msg;
  
  Generate_WACK : process (ACLK) is
  begin  -- process Generate_WACK
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_WACK  <= '0';
        
      else
        M_AXI_WACK  <= M_AXI_BVALID and mst_if_wr_resp_ready;
        
      end if;
    end if;
  end process Generate_WACK;
  
  Insert_Wr_Ready : process (ACLK) is
  begin  -- process Insert_Wr_Ready
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        ack_insert_write_msg  <= '0';
        
      else
        -- Insert Ack (Ready) for DVM messages if we are not able to use an already existing
        -- Ready for the normal data path.
        ack_insert_write_msg  <= M_AXI_BVALID and M_AXI_BID(0) and not M_AXI_BREADY_I;
        
      end if;
    end if;
  end process Insert_Wr_Ready;
  
  
  -----------------------------------------------------------------------------
  -- Read Address Channel
  -----------------------------------------------------------------------------
  
  -- Prioritize which source that is acknowledged. 
  new_ar_transaction        <= ( M_AXI_ARREADY or not M_AXI_ARVALID_I );
  read_req_ordered_ready    <= new_ar_transaction                  and 
                               read_req_ordered_info.Valid         and
                               ( not force_2nd_part );
  internal_ctrl_ar_ready    <= new_ar_transaction                  and 
                               ( force_2nd_part or not read_req_ordered_info.Valid );
  internal_complete_ready   <= new_ar_transaction                  and 
                               ( not read_req_ordered_info.Valid ) and 
                               ( not internal_dvm_valid )          and 
                               ( not ctrl_bar_req.Valid );
  
  -- Control output register for AW.
  Read_Addr_Request : process (ACLK) is
    variable M_AXI_ARADDR_I           : std_logic_vector(C_MAX_ADDR_WIDTH - 1 downto 0);
  begin  -- process Read_Addr_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_ARVALID_I                         <= '0';
        M_AXI_ARADDR_I(C_ADDR_VALID_POS)        := C_BASEADDR(C_ADDR_VALID_POS);
        M_AXI_ARADDR_I(C_ADDR_INTERNAL_POS)     := (others=>'0');
        M_AXI_ARADDR                            <= fit_vec(M_AXI_ARADDR_I, C_M_AXI_ADDR_WIDTH);
        M_AXI_ARLEN                             <= (others=>'0');
        M_AXI_ARCACHE                           <= "0011";
        M_AXI_ARBURST                           <= (others=>'0');
        M_AXI_ARSIZE                            <= std_logic_vector(to_unsigned(log2(C_M_AXI_DATA_WIDTH / 8), 3));
        M_AXI_ARLOCK                            <= '0';
        M_AXI_ARID                              <= (others=>'0');
        M_AXI_ARSNOOP                           <= (others=>'0');
        M_AXI_ARDOMAIN                          <= C_DOMAIN_INNER_SHAREABLE;
        M_AXI_ARBAR                             <= C_BAR_NORMAL_RESPECTING;
        M_AXI_ARPROT                            <= NULL_AXI_PROT;       -- Normal and non-secure Data access only
        
      else
        if( M_AXI_ARREADY = '1' ) then
          M_AXI_ARVALID_I                         <= '0';
        end if;
          
        if( new_ar_transaction = '1' ) then
          if( read_req_ordered_info.Valid = '1' ) then
            -- Regular data transaction path.
            M_AXI_ARVALID_I                         <= '1';
            M_AXI_ARADDR_I(C_ADDR_VALID_POS)        := C_BASEADDR(C_ADDR_VALID_POS);
            M_AXI_ARADDR_I(C_ADDR_INTERNAL_POS)     := read_req_ordered_info.Addr(C_ADDR_INTERNAL_POS);
            M_AXI_ARADDR                            <= fit_vec(M_AXI_ARADDR_I, C_M_AXI_ADDR_WIDTH);
            M_AXI_ARLEN                             <= read_req_ordered_info.Len;
            M_AXI_ARCACHE                           <= "1111";
            M_AXI_ARSIZE                            <= read_req_ordered_info.Size;
            M_AXI_ARLOCK                            <= read_req_ordered_info.Exclusive;
            if( read_req_ordered_info.Kind = C_KIND_WRAP ) then
              M_AXI_ARBURST                           <= C_AR_WRAP;
            else    
              M_AXI_ARBURST                           <= C_AR_INCR;
            end if;   
            M_AXI_ARID                              <= (others=>'0');
            M_AXI_ARSNOOP                           <= read_req_ordered_info.Snoop;
            M_AXI_ARDOMAIN                          <= read_req_ordered_info.Domain;
            M_AXI_ARBAR                             <= C_BAR_NORMAL_RESPECTING;
            M_AXI_ARPROT                            <= read_req_ordered_info.Prot;
            
          elsif( internal_dvm_valid = '1' ) then
            -- Insert a DVM message requested by Ctrl interface.
            M_AXI_ARVALID_I                         <= '1';
            if( force_2nd_part = '0' ) then
              M_AXI_ARADDR                            <= fit_vec(ctrl_dvm_req.Addr_1st, C_M_AXI_ADDR_WIDTH);
            else
              M_AXI_ARADDR                            <= fit_vec(ctrl_dvm_req.Addr_2nd, C_M_AXI_ADDR_WIDTH);
            end if;
            M_AXI_ARLEN                             <= (others=>'0');
            M_AXI_ARCACHE                           <= "0010";
            M_AXI_ARSIZE                            <= Calc_Size(C_M_AXI_DATA_WIDTH);
            M_AXI_ARLOCK                            <= '0';
            M_AXI_ARBURST                           <= C_AR_INCR;
            M_AXI_ARID                              <= std_logic_vector(to_unsigned(1, C_M_AXI_THREAD_ID_WIDTH));
            M_AXI_ARSNOOP                           <= C_ARSNOOP_DVMMessage;
            M_AXI_ARDOMAIN                          <= C_DOMAIN_INNER_SHAREABLE;
            M_AXI_ARBAR                             <= C_BAR_NORMAL_RESPECTING;
            M_AXI_ARPROT                            <= read_req_ordered_info.Prot;
          
          elsif( ctrl_bar_req.Valid = '1' ) then
            -- Insert a Barrier requested by Ctrl interface.
            M_AXI_ARVALID_I                         <= '1';
            M_AXI_ARADDR                            <= fit_vec(ctrl_bar_req.Addr, C_M_AXI_ADDR_WIDTH);
            M_AXI_ARLEN                             <= (others=>'0');
            M_AXI_ARCACHE                           <= "0010";
            M_AXI_ARSIZE                            <= Calc_Size(C_M_AXI_DATA_WIDTH);
            M_AXI_ARLOCK                            <= '0';
            M_AXI_ARBURST                           <= C_AR_INCR;
            M_AXI_ARID                              <= std_logic_vector(to_unsigned(1, C_M_AXI_THREAD_ID_WIDTH));
            M_AXI_ARSNOOP                           <= C_ARSNOOP_Barrier;
            M_AXI_ARDOMAIN                          <= C_DOMAIN_INNER_SHAREABLE;
            if( ctrl_bar_req.Synchronizing = '1' ) then
              M_AXI_ARBAR                         <= C_BAR_SYNCHRONIZATION;
            else
              M_AXI_ARBAR                         <= C_BAR_MEMORY_BARRIER;
            end if;
            M_AXI_ARPROT                            <= read_req_ordered_info.Prot;
          
          elsif( internal_complete_valid = '1' ) then
            -- Insert a Complete message as a response to an external Sync request.
            M_AXI_ARVALID_I                         <= '1';
            M_AXI_ARADDR_I                          := (others=>'0');
            M_AXI_ARADDR                            <= fit_vec(M_AXI_ARADDR_I, C_M_AXI_ADDR_WIDTH);
            M_AXI_ARLEN                             <= (others=>'0');
            M_AXI_ARCACHE                           <= "0010";
            M_AXI_ARSIZE                            <= Calc_Size(C_M_AXI_DATA_WIDTH);
            M_AXI_ARLOCK                            <= '0';
            M_AXI_ARBURST                           <= C_AR_INCR;
            M_AXI_ARID                              <= std_logic_vector(to_unsigned(1, C_M_AXI_THREAD_ID_WIDTH));
            M_AXI_ARSNOOP                           <= C_ARSNOOP_DVMComplete;
            M_AXI_ARDOMAIN                          <= C_DOMAIN_INNER_SHAREABLE;
            M_AXI_ARBAR                             <= C_BAR_NORMAL_RESPECTING;
            M_AXI_ARPROT                            <= NULL_AXI_PROT;       -- Normal and non-secure Data access only
          
          end if;
          
        end if;
      end if;
    end if;
  end process Read_Addr_Request;
  
  -- Set constant values and assign external signals for AW-Channel.
  M_AXI_ARVALID <= M_AXI_ARVALID_I;
  M_AXI_ARQOS   <= (others=>'1');
  
  
  -----------------------------------------------------------------------------
  -- Read Insert Handling
  -----------------------------------------------------------------------------
  
  -- Handle push pop.
  rd_ins_push <= new_ar_transaction and
                 ( internal_dvm_valid      or 
                   ctrl_bar_req.Valid      or 
                   internal_complete_valid );
  rd_ins_pop  <= M_AXI_RVALID and M_AXI_RREADY_I and M_AXI_RLAST and M_AXI_RID(0);
  
  -- Instantiate CRRESP Queue pointer handling.
  FIFO_RD_INS_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => rd_ins_push,
      queue_pop                 => rd_ins_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => rd_ins_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => rd_ins_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => rd_ins_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => open,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Insert FIFO.
  FIFO_RD_INS_Memory : process (ACLK) is
  begin  -- process FIFO_RD_INS_Memory
    if( ACLK'event and ACLK = '1' ) then    -- rising clock edge
      if( rd_ins_push = '1' ) then
        -- Insert new item.
        if( internal_dvm_valid = '1' ) then
          rd_ins_fifo_mem(0)  <= DVM;
        elsif( ctrl_bar_req.Valid = '1' ) then
          rd_ins_fifo_mem(0)  <= Barrier;
        else
          rd_ins_fifo_mem(0)  <= Complete;
        end if;
        
        -- Shift FIFO contents.
        rd_ins_fifo_mem(rd_ins_fifo_mem'left downto 1)  <= rd_ins_fifo_mem(rd_ins_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_RD_INS_Memory;
  
  -- Assign output.
  rd_ins_src <= rd_ins_fifo_mem(to_integer(unsigned(rd_ins_read_fifo_addr)));
  
  
  -----------------------------------------------------------------------------
  -- Read Channel
  -----------------------------------------------------------------------------
  
  -- Only propagate non inserted messages (DVM and others).
  mst_if_rd_data_info.Valid <= M_AXI_RVALID and not M_AXI_RID(0);
  mst_if_rd_data_info.Last  <= M_AXI_RLAST;
  mst_if_rd_data_info.Data  <= fit_vec(M_AXI_RDATA, C_MAX_DATA_WIDTH);
  mst_if_rd_data_info.RRESP <= fit_vec(M_AXI_RRESP, C_MAX_RRESP_WIDTH);
  M_AXI_RREADY              <= M_AXI_RREADY_I;
  M_AXI_RREADY_I            <= mst_if_rd_data_ready or ack_insert_read_msg;
  
  Generate_RACK : process (ACLK) is
  begin  -- process Generate_RACK
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        M_AXI_RACK  <= '0';
        
      else
        M_AXI_RACK  <= M_AXI_RVALID and M_AXI_RREADY_I and M_AXI_RLAST;
        
      end if;
    end if;
  end process Generate_RACK;
  
  Insert_Rd_Ready : process (ACLK) is
  begin  -- process Insert_Rd_Ready
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        ack_insert_read_msg <= '0';
        
      else
        -- Insert Ack (Ready) for DVM messages if we are not able to use an already existing
        -- Ready for the normal data path.
        ack_insert_read_msg <= M_AXI_RVALID and M_AXI_RID(0) and not M_AXI_RREADY_I;
        
      end if;
    end if;
  end process Insert_Rd_Ready;
  
  
  -----------------------------------------------------------------------------
  -- ACE Downstream Sync Request Handling
  -----------------------------------------------------------------------------
  
  -- Detect if this is a Sync message
  sync_req            <= ctrl_dvm_req.Valid and     ctrl_dvm_req.Addr_1st(C_DVM_NEED_COMPLETE_POS);
  
  -- Detect if this is another type of DVM message.
  other_req           <= ctrl_dvm_req.Valid and not ctrl_dvm_req.Addr_1st(C_DVM_NEED_COMPLETE_POS);
  
  -- Detect if this is a two-part DVM message.
  need_2nd_part       <= ctrl_dvm_req.Valid and     ctrl_dvm_req.Addr_1st(C_DVM_MORE_POS);
  
  -- Try to insert Sync message until it has been accepted, only one per sequence.
  internal_sync_valid <= sync_req and not waiting_for_complete and not sync_done;
  
  -- Insert filtered Sync messages or other types of DVM messages from Ctrl If.
  internal_dvm_valid  <= internal_sync_valid or other_req;
  
  -- Handle wait for return of a Complete message to terminate the Internal Sync sequence.
  Handle_Internal_Sync_Request : process (ACLK) is
  begin  -- process Handle_Internal_Sync_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        sync_done             <= '0';
        dvm_other_done        <= '0';
        force_2nd_part        <= '0';
        waiting_for_complete  <= '0';
        ctrl_bar_done_i       <= '0';
        internal_ctrl_ar_hold <= '0';
        internal_ctrl_aw_hold <= '0';
        
      else
        -- One shot Done signal to terminate the Sync sequence.
        sync_done             <= waiting_for_complete and mst_snoop_check_info_i.Complete;
        
        -- Generate Done for all non Sync DVM message, either at only part or last part.
        dvm_other_done        <= other_req                               and
                                 internal_ctrl_ar_ready                  and
                                 ( force_2nd_part or not need_2nd_part ) and 
                                 ( not dvm_other_done );
                                 
        ctrl_bar_done_i       <= ctrl_bar_req.Valid                      and
                                 ( internal_ctrl_ar_ready              or
                                   internal_ctrl_ar_hold               ) and
                                 ( internal_ctrl_aw_ready              or
                                   internal_ctrl_aw_hold               ) and
                                 ( not ctrl_bar_done_i );
        
        -- Mark that second half must follow first.
        if( internal_ctrl_ar_ready = '1' ) then
          force_2nd_part  <= need_2nd_part and not force_2nd_part;
        end if;
        
        -- Remember that a Sync DVM has been and we are waiting for a Snoop Complete.
        if( mst_snoop_check_info_i.Complete = '1' ) then
          waiting_for_complete  <= '0';
          
        elsif( ( internal_sync_valid = '1' ) and ( internal_ctrl_ar_ready = '1' ) ) then
          waiting_for_complete  <= '1';
          
        end if;
        
        if( ctrl_bar_done_i = '1' ) then
          internal_ctrl_ar_hold <= '0';
          
        elsif( internal_ctrl_ar_ready = '1' ) then
          internal_ctrl_ar_hold <= '1';
          
        end if;
        
        if( ctrl_bar_done_i = '1' ) then
          internal_ctrl_aw_hold <= '0';
          
        elsif( internal_ctrl_aw_ready = '1' ) then
          internal_ctrl_aw_hold <= '1';
          
        end if;
        
      end if;
    end if;
  end process Handle_Internal_Sync_Request;
  
  -- Collect all done signals.
  ctrl_dvm_done       <= sync_done or dvm_other_done;
  ctrl_backend_done   <= ( not M_AXI_ARVALID_I   ) and 
                         ( not M_AXI_AWVALID_I   ) and
                         ( not rd_ins_fifo_full  ) and
                         ( not wr_ins_fifo_full  );
  ctrl_bar_done       <= ctrl_bar_done_i;
  ctrl_insert_running <= ( not rd_ins_fifo_empty ) or
                         ( not wr_ins_fifo_empty );
  
  
  -----------------------------------------------------------------------------
  -- ACE Response to Sync Request Handling
  -----------------------------------------------------------------------------
  
  -- Filter the request to avoid double insert.
  internal_complete_valid <= ( mst_snoop_check_info_i.Sync and not internal_complete_already );
  
  Handle_Complete_Insert : process (ACLK) is
  begin  -- process Handle_Complete_Insert
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        internal_complete_already <= '0';
        
      else
        if( mst_snoop_check_piperun_i = '1' ) then
          internal_complete_already <= '0';
        elsif( ( internal_complete_valid = '1' ) and ( new_ar_transaction = '1' ) ) then
          -- Disable further pushing until movement
          internal_complete_already <= '1';
        end if;
      end if;
    end if;
  end process Handle_Complete_Insert;
  
  
  -----------------------------------------------------------------------------
  -- Coherency AC Channel
  -- 
  -- Snoop transaction:
  -- -----------------
  -- ReadOnce             - Regardless of current state keep it after this operation.
  -- ReadShared           - Make the line Invalid under the assumption that peer master 
  --                        will be the next one that access the line.
  -- ReadClean            - -"-
  -- ReadNotSharedDirty   - -"-
  -- ReadUnique           - Line must be Invalid due to transaction nature.
  -- CleanShared          - Clean transaction, pass dirty and leave line Invalid.
  -- CleanInvalid         - Clean transaction, pass dirty and leave line Invalid.
  -- MakeInvalid          - Dump contents regardless of state, leave line Invalid.
  -- DVM Complete         - No need to query the Core, 
  -- DVM Message          - Depends on message, but mostly NOP.
  -- 
  -- 
  -- DVM Message transaction:
  -- -----------------
  -- TLB Invalidate       - No action, respond without delay.
  -- Branch Predict Inv   - No action, respond without delay.
  -- Phy Instr Cache Inv  - Clean cache and replay without delay.
  -- Vir Instr Cache Inv  - No action, respond without delay.
  -- Sync                 - Respond without delay. Check Backend for any earlier 
  --                        Invalidate Physical Instr Cache and delay until that 
  --                        has been completed before inserting Complete on AR.
  -- Hint                 - No action, respond without delay.
  -- 
  -- 
  -- 
  -----------------------------------------------------------------------------
  
  new_ac                      <= M_AXI_ACVALID and M_AXI_ACREADY_I;
  
  mst_snoop_decode_sel_block  <= get_block(mst_snoop_decode_info.Addr, C_ADDR_VALID_HI - C_ADDR_VALID_LO + 1, C_CACHE_BLOCKS);
  
  Decode_Coherency_Request : process (M_AXI_ACVALID, M_AXI_ACSNOOP, M_AXI_ACADDR, M_AXI_ACPROT, 
                                      last_acaddr) is
    
    variable dvm_msg  : DVM_MESSAGE_TYPE;
    
  begin  -- process Decode_Coherency_Request
    -- Default No Operation.
    mst_snoop_decode_info               <= C_NULL_MST_SNOOP_REQ;
    
    -- Include protection bits, to check if it is a secure access and such.
    mst_snoop_decode_info.Prot          <= M_AXI_ACPROT;
    
    if( M_AXI_ACSNOOP = C_ACSNOOP_DVMComplete ) then
      -- Handle DVM Complete request 
      -- No hazard check, only deliver Ack to Ctrl.
      mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
      mst_snoop_decode_info.First         <= M_AXI_ACVALID;
      mst_snoop_decode_info.Lookup        <= '0';
      mst_snoop_decode_info.Complete      <= '1';
      
    elsif( M_AXI_ACSNOOP = C_ACSNOOP_DVMMessage ) then
      dvm_msg := M_AXI_ACADDR(C_DVM_MESSAGE_POS);
      
      case dvm_msg is
        when C_DVM_MSG_PH_INSTR_INVAL   =>
          -- Handle DVM Physical Instruction Cache Invalidate.
          -- Only last part will trigger Hazard check.
          mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
          mst_snoop_decode_info.First         <= M_AXI_ACVALID;
          mst_snoop_decode_info.Lookup        <= M_AXI_ACVALID and not M_AXI_ACADDR(C_DVM_MORE_POS);
          mst_snoop_decode_info.Clean         <= '1';
          mst_snoop_decode_info.Kill          <= '0';
          mst_snoop_decode_info.Addr(C_DVM_PHY_PA11_04_POS)  <= M_AXI_ACADDR(C_DVM_PHY_PA11_04_POS);
          mst_snoop_decode_info.Addr(C_DVM_PHY_PA31_12_POS)  <= M_AXI_ACADDR(C_DVM_PHY_PA31_12_POS);
          
          if( C_M_AXI_ADDR_WIDTH > 39 ) then
            mst_snoop_decode_info.Addr(C_DVM_PHY_PA39_32_POS)   <= M_AXI_ACADDR(C_DVM_PHY_PA39_32_POS);
          end if;
          if( C_M_AXI_ADDR_WIDTH > 43) then
            mst_snoop_decode_info.Addr(C_DVM_PHY_PA43_40_POS)   <= M_AXI_ACADDR(C_DVM_PHY_PA43_40_POS);
          end if;
          if( C_M_AXI_ADDR_WIDTH > 47 ) then
            mst_snoop_decode_info.Addr(C_DVM_PHY_PA47_44_POS)   <= M_AXI_ACADDR(C_DVM_PHY_PA47_44_POS);
          end if;
          
        when C_DVM_MSG_TLB_INVALIDATE   |
             C_DVM_MSG_BP_INVALIDATE    |
             C_DVM_MSG_VIR_INSTR_INVAL  |
             C_DVM_MSG_HINT             =>
          -- Remaining DVM messages are simply acknowledged.
          mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
          mst_snoop_decode_info.First         <= M_AXI_ACVALID;
          mst_snoop_decode_info.Lookup        <= '0';
          
        when C_DVM_MSG_SYNC             =>
          -- DVM Sync message requires special handling.
          -- Insert DVM complete on AR channel as a response to the Sync request.
          mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
          mst_snoop_decode_info.First         <= M_AXI_ACVALID;
          mst_snoop_decode_info.Lookup        <= '0';
          mst_snoop_decode_info.Sync          <= '1';
          
        when others                     =>
          -- Illegal DVM message, treat as NULL.
          mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
          mst_snoop_decode_info.First         <= M_AXI_ACVALID;
          mst_snoop_decode_info.Lookup        <= '0';
          
      end case;
      
    else
      -- Default settings for all regular snoop requests.
      mst_snoop_decode_info.Valid         <= M_AXI_ACVALID;
      mst_snoop_decode_info.First         <= M_AXI_ACVALID;
      mst_snoop_decode_info.Addr          <= fit_vec(M_AXI_ACADDR, C_MAX_ADDR_WIDTH);
      
      case M_AXI_ACSNOOP is
        when C_ACSNOOP_ReadOnce           =>
          -- Only read data once without affecting state. 
          mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
          mst_snoop_decode_info.Update        <= '0';           -- Don't affect state.
          mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
          mst_snoop_decode_info.Keep          <= '1';           -- Keep data if allocated.
          mst_snoop_decode_info.Clean         <= '0';           -- Keep Dirty.
          mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          
        when C_ACSNOOP_ReadShared         =>
          -- Read data in any state.
          if( C_SNOOP_KEEP_READ_SHARED > 0 ) then
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Update Tag if any action is performed.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '1';           -- Keep data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          else
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          end if;
          
        when C_ACSNOOP_ReadClean          =>
          -- Read data preferably without Dirty.
          if( C_SNOOP_KEEP_READ_CLEAN > 0 ) then
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '1';           -- Keep data if allocated.
            mst_snoop_decode_info.Clean         <= '0';           -- Keep Dirty as ownership is not desired.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          else
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          end if;
          
        when C_ACSNOOP_ReadNotSharedDirty =>
          -- Read data preferably without write responsibility when Shared.
          if( C_SNOOP_KEEP_READ_NSD > 0 ) then
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '1';           -- Keep data if allocated.
            mst_snoop_decode_info.Clean         <= '0';           -- Keep Dirty as ownership is not desired.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          else
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
            mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          end if;
          
        when C_ACSNOOP_ReadUnique         =>
          -- Read data in a Unique state, to be able to write to the line.
          mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
          mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
          mst_snoop_decode_info.Get           <= '1';           -- Get data if available.
          mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
          mst_snoop_decode_info.Clean         <= '1';           -- Keep data if allocated.
          mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          
        when C_ACSNOOP_CleanShared        =>
          -- Make sure no one has this line Dirty.
          if( C_SNOOP_KEEP_CLEAN_SHARED > 0 ) then
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '0';           -- Ignore data, even if available.
            mst_snoop_decode_info.Keep          <= '1';           -- Keep data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          else
            mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
            mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
            mst_snoop_decode_info.Get           <= '0';           -- Ignore data, even if available.
            mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
            mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty.
            mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          end if;
          
        when C_ACSNOOP_CleanInvalid       =>
          -- Make sure no one has this line.
          mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
          mst_snoop_decode_info.Update        <= '1';           -- Make shared if not already.
          mst_snoop_decode_info.Get           <= '0';           -- Ignore data, even if available.
          mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
          mst_snoop_decode_info.Clean         <= '1';           -- Remove Dirty data.
          mst_snoop_decode_info.Kill          <= '0';           -- No forceful removal.
          
        when C_ACSNOOP_MakeInvalid        =>
          -- Force line Invalid.
          mst_snoop_decode_info.Lookup        <= '1';           -- Investigate state and perform Hazard test.
          mst_snoop_decode_info.Update        <= '1';           -- New tag is required if line exist.
          mst_snoop_decode_info.Get           <= '0';           -- Ignore data, even if available.
          mst_snoop_decode_info.Keep          <= '0';           -- Remove data if allocated.
          mst_snoop_decode_info.Clean         <= '1';           -- Ignore data, even if Dirty.
          mst_snoop_decode_info.Kill          <= '1';           -- Forceful removal, ditch Dirty data.
          
        when others                       =>
          -- Illegal Snoop request.
          null;
          
      end case;
    end if;
  end process Decode_Coherency_Request;
  
  Handle_Multi_Part_Request : process (ACLK) is
  begin  -- process Handle_Multi_Part_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        last_acaddr <= (others=>'0');
        
      else
        if( new_ac = '1' ) then
          if( M_AXI_ACADDR(C_DVM_MORE_POS) = '1' ) then
            last_acaddr <= M_AXI_ACADDR;
            
          else
            last_acaddr <= (others=>'0');
            
          end if;
        end if;
      end if;
    end if;
  end process Handle_Multi_Part_Request;
  
  -- Assign output.
  M_AXI_ACREADY_I <= mst_snoop_decode_piperun;
  M_AXI_ACREADY   <= M_AXI_ACREADY_I;
  
--                  : in  std_logic_vector(2 downto 0);                      -- For ACE
    
  -----------------------------------------------------------------------------
  -- Coherency CR Channel
  -----------------------------------------------------------------------------
  
  -- Handle push pop.
  crresp_push   <= mst_snoop_check_info_i.Valid and not crresp_already_pushed and not crresp_fifo_full and not mst_cross_order_hazard.Hazard;
  crresp_pop    <= M_AXI_CRREADY and ( not crresp_fifo_empty );
  crresp_stall  <= mst_snoop_check_info_i.Valid and not ( crresp_push or crresp_already_pushed);
  
  -- Instantiate CRRESP Queue pointer handling.
  FIFO_CRRESP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => crresp_push,
      queue_pop                 => crresp_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => crresp_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => crresp_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => crresp_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => open,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for CRRESP FIFO.
  FIFO_CRRESP_Memory : process (ACLK) is
  begin  -- process FIFO_CRRESP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( crresp_push = '1' ) then
        -- Insert new item.
        crresp_fifo_mem(0)                              <= new_crresp;
        
        -- Shift FIFO contents.
        crresp_fifo_mem(crresp_fifo_mem'left downto 1)  <= crresp_fifo_mem(crresp_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_CRRESP_Memory;
  
  Handle_CR_Queue_Pushing : process (ACLK) is
  begin  -- process Handle_CR_Queue_Pushing
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        crresp_already_pushed <= '0';
        
      else
        if( mst_snoop_check_piperun_i = '1' ) then
          crresp_already_pushed <= '0';
        elsif( crresp_push = '1' ) then
          -- Disable further pushing until movement
          crresp_already_pushed <= '1';
        end if;
      end if;
    end if;
  end process Handle_CR_Queue_Pushing;
  
  -- Assign output.
  M_AXI_CRVALID <= ( not crresp_fifo_empty );
  M_AXI_CRRESP  <= crresp_fifo_mem(to_integer(unsigned(crresp_read_fifo_addr))) when not s2b(crresp_fifo_empty) else
                   (others=>'0');
  
  
  -----------------------------------------------------------------------------
  -- Coherency CD Channel
  -- 
  -- Take the Snoop data and buffer it before making it available to the port.
  -- 
  -- With multiple Cache Blocks are a queue used to determine sequencing order
  -- between different Cache Blocks.
  -----------------------------------------------------------------------------
  
  -- WriteBack extract handshake handling.
  mst_core_be_data_ready    <= mst_core_be_data_ready_i;
  mst_core_be_data_ready_i  <= (     mst_core_be_data_info.Valid                    ) and
                               (     mst_snoop_sdr_empty(mst_snoop_check_sel_block) ) and 
                               ( not    cddata_fifo_full(mst_snoop_check_sel_block) );
  
  Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    
    signal cddata_push                : std_logic;
    signal cddata_pop                 : std_logic;
    signal cddata_fifo_empty          : std_logic;
    signal cddata_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
    signal cddata_fifo_mem            : MST_SNOOP_DATA_VECTOR_TYPE(QUEUE_ADDR_POS);
    
  begin
    
    -- Acknowledge snoop data when there is room left in the queue.
    mst_core_update_data_ready(J) <= not cddata_fifo_full(J);
    
    -- Handle push/pop of snoop data.
    cddata_push                   <= ( mst_core_update_data_info(J).Valid and not cddata_fifo_full(J) ) or
                                     ( mst_core_be_data_info.Valid and mst_core_be_data_ready_i and 
                                       b2s( mst_snoop_check_sel_block = J ) );
    cddata_pop                    <= ( M_AXI_CDREADY and not cddata_fifo_empty ) when ( J = cd_sel_block ) else 
                                     '0';
    
    -- Instantiate CRDATA Queue pointer handling.
    FIFO_CDDATA_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => cddata_push,
        queue_pop                 => cddata_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => cddata_fifo_full(J),
        queue_almost_empty        => open,
        queue_empty               => cddata_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => cddata_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => open,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => open,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for CDDATA FIFO.
    FIFO_CDDATA_Memory : process (ACLK) is
    begin  -- process FIFO_CDDATA_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( cddata_push = '1' ) then
          -- Insert new item.
          if( s2b(mst_core_be_data_ready_i) ) then
            cddata_fifo_mem(0)                              <= mst_core_be_data_info;
          else
            cddata_fifo_mem(0)                              <= mst_core_update_data_info(J);
          end if;
          
          -- Shift FIFO contents.
          cddata_fifo_mem(cddata_fifo_mem'left downto 1)  <= cddata_fifo_mem(cddata_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_CDDATA_Memory;
    
    cd_valid(J) <= ( not cddata_fifo_empty );
    cd_last(J)  <= cddata_fifo_mem(to_integer(unsigned(cddata_read_fifo_addr))).Last;
    cd_data(J)  <= cddata_fifo_mem(to_integer(unsigned(cddata_read_fifo_addr))).Data(C_M_AXI_DATA_WIDTH-1 downto 0);
    
  end generate Gen_Block;
  
  -- Assign output.
  M_AXI_CDVALID <= cd_valid(cd_sel_block);
  M_AXI_CDLAST  <= cd_last(cd_sel_block);
  M_AXI_CDDATA  <= cd_data(cd_sel_block);
  
  Use_Multi_Blocks: if ( C_CACHE_BLOCKS > 1 ) generate
    
    type DATA_SRC_TYPE is record
      Src               : integer range 0 to C_CACHE_BLOCKS - 1;
    end record DATA_SRC_TYPE;
    
    type DATA_SRC_VECTOR_TYPE        is array(natural range <>) of DATA_SRC_TYPE;
    
    signal cd_src_already_pushed      : std_logic;
    signal cd_src_push                : std_logic;
    signal cd_src_pop                 : std_logic;
    signal cd_src_fifo_full           : std_logic;
    signal cd_src_fifo_empty          : std_logic;
    signal cd_src_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
    signal cd_src_fifo_mem            : DATA_SRC_VECTOR_TYPE(QUEUE_ADDR_POS);
    
  begin
    -- Handle push/pop of snoop src.
    cd_src_push                   <= cd_src_valid and not cd_src_already_pushed and not cd_src_fifo_full;
    cd_src_pop                    <= cd_valid(cd_sel_block) and M_AXI_CDREADY and cd_last(cd_sel_block);
    cd_src_stall                  <= cd_src_valid and not ( cd_src_push or cd_src_already_pushed );
    
    Handle_CD_Queue_Pushing : process (ACLK) is
    begin  -- process Handle_CD_Queue_Pushing
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          cd_src_already_pushed <= '0';
          
        else
          if( mst_snoop_mem_piperun_i = '1' ) then
            cd_src_already_pushed <= '0';
          elsif( cd_src_push = '1' ) then
            -- Disable further pushing until movement
            cd_src_already_pushed <= '1';
          end if;
        end if;
      end if;
    end process Handle_CD_Queue_Pushing;
    
    -- Instantiate CRDATA Queue pointer handling.
    FIFO_CD_SRC_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => cd_src_push,
        queue_pop                 => cd_src_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => cd_src_fifo_full,
        queue_almost_empty        => open,
        queue_empty               => cd_src_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => cd_src_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => open,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => open,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for CD SRC FIFO.
    FIFO_CDSRC_Memory : process (ACLK) is
    begin  -- process FIFO_CDSRC_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( cd_src_push = '1' ) then
          -- Insert new item.
          cd_src_fifo_mem(0).Src                          <= mst_snoop_check_sel_block;
          
          -- Shift FIFO contents.
          cd_src_fifo_mem(cd_src_fifo_mem'left downto 1)  <= cd_src_fifo_mem(cd_src_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_CDSRC_Memory;
    
    cd_sel_block  <= cd_src_fifo_mem(to_integer(unsigned(cd_src_read_fifo_addr))).Src;
    
  end generate Use_Multi_Blocks;
  
  Single_Block: if ( C_CACHE_BLOCKS = 1 ) generate
  begin
    cd_src_stall  <= '0';
    cd_sel_block  <= 0;
    
  end generate Single_Block;
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Master Snoop Decode
  -- 
  -----------------------------------------------------------------------------
  
  -- Pipeline control
  mst_snoop_decode_piperun  <= ( mst_snoop_fetch_piperun_i or not mst_snoop_fetch_info_i.Valid ) and not mst_snoop_decode_stall;
  
  -- Collect stall sources.
  mst_snoop_decode_stall    <= '0';
  
  Handle_Fetch_Coherency_Request : process (ACLK) is
  begin  -- process Handle_Fetch_Coherency_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        mst_snoop_fetch_info_i        <= C_NULL_MST_SNOOP_REQ;
        mst_snoop_fetch_sel_block     <= 0;
        
      elsif( mst_snoop_decode_piperun = '1' ) then
        mst_snoop_fetch_info_i        <= mst_snoop_decode_info;
        mst_snoop_fetch_info_i.First  <= mst_snoop_decode_info.Valid;
        mst_snoop_fetch_sel_block     <= mst_snoop_decode_sel_block;
        
      elsif( mst_snoop_fetch_piperun_i = '1' ) then
        -- Turn off when moving out of pipeline stage.
        mst_snoop_fetch_info_i.Valid  <= '0';
        mst_snoop_fetch_info_i.First  <= '0';
        
      else
        mst_snoop_fetch_info_i.First  <= '0';
        
      end if;
    end if;
  end process Handle_Fetch_Coherency_Request;
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Master Snoop Fetch
  -- 
  -----------------------------------------------------------------------------
  
  -- Pipeline control
  mst_snoop_fetch_piperun_i <= ( mst_snoop_mem_piperun_i or not mst_snoop_mem_info_i.Valid ) and not mst_snoop_fetch_stall;
  mst_snoop_fetch_piperun   <= mst_snoop_fetch_piperun_i;
  
  -- Collect stall sources.
  mst_snoop_fetch_stall     <= mstf_core_mem_stall          or 
                               mstf_core_check_stall        or 
                               mstf_core_update_stall       or
                               mst_snoop_mem_tag_conflict   or
                               mst_snoop_check_tag_conflict;
  
  -- Generate stall from records.
  Gen_Fetch_Haz_Stall : process (mst_core_mem_hazard, mst_core_check_hazard, mst_core_update_hazard) is
  begin  -- process Gen_Fetch_Haz_Stall
    -- Default assignments.
    mstf_core_mem_stall           <= '0';
    mstf_core_check_stall         <= '0';
    mstf_core_make_unique         <= '0';
    mstf_core_make_dirty          <= '0';
    mstf_core_update_stall        <= '0';
  
    for I in 0 to C_CACHE_BLOCKS - 1 loop
      if( mst_core_mem_hazard(I).Hazard = '1' ) then
        mstf_core_mem_stall           <= '1';
      end if;
      
      if( mst_core_check_hazard(I).Hazard = '1' ) then
        mstf_core_check_stall         <= '1';
      end if;
      
      if( mst_core_update_hazard(I).Hazard = '1' ) then
        mstf_core_update_stall        <= '1';
      end if;
      
      if( mst_core_check_hazard(I).MadeUnique = '1' ) then
        mstf_core_make_unique         <= '1';
      end if;
      
      if( mst_core_check_hazard(I).MadeDirty = '1' ) then
        mstf_core_make_dirty          <= '1';
      end if;
      
    end loop;
  end process Gen_Fetch_Haz_Stall;
  
  Handle_Mem_Coherency_Request : process (ACLK) is
  begin  -- process Handle_Mem_Coherency_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        mst_snoop_mem_info_i        <= C_NULL_MST_SNOOP_REQ;
        mst_snoop_mem_sel_block     <= 0;
        mst_snoop_mem_make_unique   <= '0';
        mst_snoop_mem_make_dirty    <= '0';
        
      elsif( mst_snoop_fetch_piperun_i = '1' ) then
        mst_snoop_mem_info_i        <= mst_snoop_fetch_info_i;
        mst_snoop_mem_info_i.First  <= mst_snoop_fetch_info_i.Valid;
        mst_snoop_mem_sel_block     <= mst_snoop_fetch_sel_block;
        mst_snoop_mem_make_unique   <= mstf_core_make_unique;
        mst_snoop_mem_make_dirty    <= mstf_core_make_dirty;
        
      elsif( mst_snoop_mem_piperun_i = '1' ) then
        -- Turn off when moving out of pipeline stage.
        mst_snoop_mem_info_i.Valid  <= '0';
        mst_snoop_mem_info_i.First  <= '0';
        
      else
        mst_snoop_mem_info_i.First  <= '0';
        
      end if;
    end if;
  end process Handle_Mem_Coherency_Request;
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Master Snoop Mem
  -- 
  -----------------------------------------------------------------------------
  
  -- Pipeline control
  mst_snoop_mem_piperun_i   <= ( mst_snoop_check_piperun_i or not mst_snoop_check_info_i.Valid ) and not mst_snoop_mem_stall;
  mst_snoop_mem_piperun     <= mst_snoop_mem_piperun_i;
  
  -- Handle snoop signal.
  mst_snoop_mem_stall       <= '0';
  
  Handle_Check_Coherency_Request : process (ACLK) is
  begin  -- process Handle_Check_Coherency_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        mst_snoop_check_info_i          <= C_NULL_MST_SNOOP_REQ;
        mst_snoop_check_sel_block       <= 0;
        mst_snoop_check_make_unique   <= '0';
        mst_snoop_check_make_dirty    <= '0';
        
      elsif( mst_snoop_mem_piperun_i = '1' ) then
        mst_snoop_check_info_i          <= mst_snoop_mem_info_i;
        mst_snoop_check_info_i.First    <= mst_snoop_mem_info_i.Valid;
        mst_snoop_check_info_i.Sync     <= mst_snoop_mem_info_i.Sync     and mst_snoop_mem_info_i.Valid;
        mst_snoop_check_info_i.Complete <= mst_snoop_mem_info_i.Complete and mst_snoop_mem_info_i.Valid;
        mst_snoop_check_sel_block       <= mst_snoop_mem_sel_block;
        mst_snoop_check_make_unique     <= mst_snoop_mem_make_unique;
        mst_snoop_check_make_dirty      <= mst_snoop_mem_make_dirty;
        
      else
        mst_snoop_check_info_i.First    <= '0';
        if( waiting_for_complete = '1' ) then
          -- Turn off one shot signal for Complete message received.
          mst_snoop_check_info_i.Complete <= '0';
          
        elsif( internal_complete_ready = '1' ) then
          -- Turn off one shot signal for Sync message received when a 
          -- Complete message has been generated on the output.
          mst_snoop_check_info_i.Sync     <= '0';
          
        end if;
        if( mst_snoop_check_piperun_i = '1' ) then
          -- Turn off when moving out of pipeline stage.
          mst_snoop_check_info_i.Valid  <= '0';
        end if;
      end if;
    end if;
  end process Handle_Check_Coherency_Request;
  
  Handle_Mem_Alloc_Release : process (ACLK) is
  begin  -- process Handle_Mem_Alloc_Release
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        mst_snoop_mem_rm_alloc_done <= '0';
        
      else
        if( mst_snoop_mem_piperun_i = '1' ) then
          -- Reset for next cycle.
          mst_snoop_mem_rm_alloc_done <= '0';
          
        elsif( reduce_or(mst_snoop_mem_rm_alloc) = '1' ) then
          -- Remember that this Line has actually been completely allocated, since
          -- it will not be visible in the pipeline Tag word.
          -- (No need to select since only one Block can match the transaction address space)
          mst_snoop_mem_rm_alloc_done <= '1';
          
        end if;
      end if;
    end if;
  end process Handle_Mem_Alloc_Release;
  
  Handle_Check_Alloc_Release : process (ACLK) is
  begin  -- process Handle_Check_Alloc_Release
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        mst_snoop_check_alloc_done  <= '0';
        
      else
        if( mst_snoop_mem_piperun_i = '1' ) then
          -- Move any current or remembered allocate complete signalling.
          -- (No need to select since only one Block can match the transaction address space)
          mst_snoop_check_alloc_done  <= mst_snoop_mem_rm_alloc_done       or
                                         reduce_or(mst_snoop_mem_rm_alloc);
          
        elsif( mst_snoop_check_piperun_i = '1' ) then
          -- Reset for next cycle.
          mst_snoop_check_alloc_done  <= '0';
          
        elsif( reduce_or(mst_snoop_check_rm_alloc) = '1' ) then
          -- Remember that this Line has actually been completely allocated, since
          -- it will not be visible in the pipeline Tag word.
          -- (No need to select since only one Block can match the transaction address space)
          mst_snoop_check_alloc_done  <= '1';
          
        end if;
      end if;
    end if;
  end process Handle_Check_Alloc_Release;
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Master Snoop Check
  -- 
  -----------------------------------------------------------------------------
  
  -- Pipeline control
  mst_snoop_check_piperun_i <= ( mst_snoop_start_piperun_i ) and not mst_snoop_check_stall;
  mst_snoop_check_piperun   <= mst_snoop_check_piperun_i;
  
  -- Handle snoop signal.
  mst_snoop_check_stall     <= mst_snoop_check_info_i.Complete or 
                               mst_snoop_check_info_i.Sync     or
                               reduce_or(mst_snoop_tag_stall)  or 
                               cd_src_stall                    or
                               crresp_stall                    or
                               sdr_stall                       or
                               mst_cross_order_hazard.Hazard;
  
  -- Select Tag info from the current Block.
  Patch_Snoop_Data_Information : process (mst_snoop_check_ack_info, mst_snoop_check_sel_block, 
                                          mst_snoop_check_make_dirty, mst_snoop_check_make_unique,
                                          mst_cross_order_hazard) is
    variable mst_snoop_check_sel_ack_raw : MST_SNOOP_ACK_TYPE;
  begin  -- process Patch_Snoop_Data_Information
    -- Default assignment by selecting the proper block information.
    mst_snoop_check_sel_ack_raw       := mst_snoop_check_ack_info(mst_snoop_check_sel_block);
    
    -- Patch the Dirty information.
    if( s2b(mst_snoop_check_make_dirty) ) then
      mst_snoop_check_sel_ack_raw.Dirty   := '1';
    end if;
    
    -- Patch the Unique information.
    if( s2b(mst_snoop_check_make_unique) ) then
      mst_snoop_check_sel_ack_raw.Unique  := '1';
    end if;
    
    -- Extracting from WriteBack queue.
    if( s2b(mst_cross_order_hazard.Extracted) ) then
      mst_snoop_check_sel_ack_raw.Valid   := '1';
      mst_snoop_check_sel_ack_raw.Unique  := '0';
      mst_snoop_check_sel_ack_raw.Dirty   := '1';
      
    end if;
    
    mst_snoop_check_sel_ack           <= mst_snoop_check_sel_ack_raw;
    
  end process Patch_Snoop_Data_Information;
  
  -- Determine if data shall be extracted depending on received Tag information and desired action.
  Assemble_Snoop_Data_Request : process (mst_snoop_check_info_i, mst_snoop_check_sel_ack, update_allocating_line) is
  begin  -- process Assemble_Snoop_Data_Request
    -- Default assignment.
    sdr_info                  <= C_NULL_MST_SNOOP_ADDR;
    
    sdr_info.Valid            <= mst_snoop_check_sel_ack.Valid       and
                                 mst_snoop_check_info_i.Valid        and
                                 ( ( mst_snoop_check_info_i.Get    ) or
                                   ( mst_snoop_check_info_i.Clean and
                                     mst_snoop_check_sel_ack.Dirty ) ) and
                                 ( not mst_snoop_check_info_i.Kill ) and
                                 ( not update_allocating_line ) and
                                 ( not mst_cross_order_hazard.Extracted );
    sdr_info.Way              <= mst_snoop_check_sel_ack.Way;
    sdr_info.Addr             <= mst_snoop_check_info_i.Addr;
  end process Assemble_Snoop_Data_Request;
  
  Handle_SDR_Queue_Pushing : process (ACLK) is
  begin  -- process Handle_SDR_Queue_Pushing
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        sdr_already_pushed  <= '0';
        
      else
        if( mst_snoop_check_piperun_i = '1' ) then
          sdr_already_pushed  <= '0';
          
        elsif( ( sdr_info.Valid and not sdr_stall )= '1' ) then
          -- Disable further pushing until movement
          sdr_already_pushed  <= '1';
          
        end if;
      end if;
    end if;
  end process Handle_SDR_Queue_Pushing;
  
  Handle_Tag_Write : process (ACLK) is
  begin  -- process Handle_Tag_Write
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        tag_already_written <= '0';
        
      else
        if( mst_snoop_check_piperun_i = '1' ) then
          tag_already_written <= '0';
          
        elsif( ( mst_snoop_tag_valid_i and not reduce_or(mst_snoop_tag_stall) ) = '1' ) then
-- TODO: select only relevant stall
          -- Disable additional write until movement.
          tag_already_written <= '1';
          
        end if;
      end if;
    end if;
  end process Handle_Tag_Write;
  
  cd_src_valid              <= ( sdr_info.Valid and not sdr_stall ) or 
                               mst_cross_order_hazard.Extracted;
  sdr_stall                 <= (     sdr_info.Valid                                    ) and 
                               ( (     mst_snoop_sdr_full(mst_snoop_check_sel_block) ) or
                                 (     mst_cross_order_hazard.Hazard                 and
                                       b2s(C_ENABLE_WB_EXTRACT > 0)                  ) ) and 
                               ( not sdr_already_pushed                                );
  
  -- Evaluate if there is an ongoing allocation that need to be ignored since
  -- it is to a later event that has not have happened yet (AC is to be considered first). 
  update_allocating_line    <= mst_snoop_check_info_i.Valid   and 
                               mst_snoop_check_sel_ack.Valid  and 
                               mst_snoop_check_sel_ack.Locked;
  
  -- Calculate if the Tag can should be updated, there are a number of reasons:
  --  * The line is updated to Shared
  --  * The line is made Clean
  --  * The line is Invalidated (soft or hard)
  mst_snoop_tag_valid_i     <= mst_snoop_check_info_i.Valid  and 
                               mst_snoop_check_info_i.Update and 
                               mst_snoop_check_sel_ack.Valid and
                               ( ( mst_snoop_check_info_i.Get   and     mst_snoop_check_sel_ack.Unique ) or
                                 ( mst_snoop_check_info_i.Clean and     mst_snoop_check_sel_ack.Dirty  ) or
                                 ( mst_snoop_check_info_i.Clean and not mst_snoop_check_info_i.Keep    ) or
                                 ( mst_snoop_check_info_i.Kill                                         ) ) and
                               ( not update_allocating_line ) and
                               ( not tag_already_written )    and 
                               ( not mst_cross_order_hazard.Extracted );
  
  -- Determine how the Tag for the Line shall be updated.
  Gen_New_Tag : process (mst_snoop_check_info_i, mst_snoop_check_sel_ack) is
  begin  -- process Gen_New_Tag
    -- Default assignment.
    mst_snoop_tag_info_i        <= C_NULL_WAY_LINE_TAG;
    
    mst_snoop_tag_info_i.Valid    <= mst_snoop_check_sel_ack.Valid;
    mst_snoop_tag_info_i.Unique   <= mst_snoop_check_sel_ack.Unique;
    mst_snoop_tag_info_i.Dirty    <= mst_snoop_check_sel_ack.Dirty;
    mst_snoop_tag_info_i.Secure   <= mst_snoop_check_sel_ack.Secure;
    mst_snoop_tag_info_i.Locked   <= mst_snoop_check_sel_ack.Locked;
    mst_snoop_tag_info_i.Reused   <= mst_snoop_check_sel_ack.Reused;
    mst_snoop_tag_info_i.Addr     <= mst_snoop_check_sel_ack.Addr;
    
    if( ( mst_snoop_check_info_i.Get   and     mst_snoop_check_sel_ack.Unique ) = '1' ) then
      mst_snoop_tag_info_i.Unique    <= '0';
    end if;
    
    if( ( mst_snoop_check_info_i.Clean and     mst_snoop_check_sel_ack.Dirty  ) = '1' ) then
      mst_snoop_tag_info_i.Dirty    <= '0';
    end if;
    
    if( ( mst_snoop_check_info_i.Clean and not mst_snoop_check_info_i.Keep    ) = '1' ) then
      mst_snoop_tag_info_i.Valid    <= '0';
    end if;
    
    if( ( mst_snoop_check_info_i.Kill                                         ) = '1' ) then
      mst_snoop_tag_info_i.Valid    <= '0';
    end if;
    
    mst_snoop_tag_way             <= ( mst_snoop_check_sel_ack.Way mod C_NUM_WAYS );
    
  end process Gen_New_Tag;
  
  -- Determine the correct Snoop response depending on received Tag information and desired action.
  new_crresp(C_CRRESP_WASUNIQUE_POS)    <=   (     mst_snoop_check_sel_ack.Valid         ) and 
                                             (     mst_snoop_check_sel_ack.Unique        ) and 
                                             ( not update_allocating_line                ) and 
                                             ( not mst_cross_order_hazard.Extracted      );
  
  new_crresp(C_CRRESP_ISSHARED_POS)     <=   (     mst_snoop_check_sel_ack.Valid         ) and 
                                             (     mst_snoop_check_info_i.Keep           ) and 
                                             ( not update_allocating_line                ) and
                                             ( not mst_cross_order_hazard.Extracted      );
  
  new_crresp(C_CRRESP_PASSDIRTY_POS)    <= ( (     mst_snoop_check_sel_ack.Valid         ) and 
                                             (     mst_snoop_check_sel_ack.Dirty         ) and 
                                             (     mst_snoop_check_info_i.Clean          ) and
                                             (     new_crresp(C_CRRESP_DATATRANSFER_POS) ) ) or
                                           ( (     mst_cross_order_hazard.Extracted      ) );
  
  new_crresp(C_CRRESP_ERROR_POS)        <= '0';
  
  new_crresp(C_CRRESP_DATATRANSFER_POS) <= sdr_info.Valid or
                                           mst_cross_order_hazard.Extracted;
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Start of PipeRun
  -- 
  -----------------------------------------------------------------------------
  
  mst_snoop_start_piperun_i <= '1';
  
  
  -----------------------------------------------------------------------------
  -- Tag Conflict Detection
  -- 
  -----------------------------------------------------------------------------
  
  mst_snoop_mem_tag_conflict    <= mst_snoop_fetch_info_i.Valid and mst_snoop_mem_info_i.Valid 
                                        when mst_snoop_fetch_info_i.Addr(C_ADDR_DIRECT_POS) = 
                                               mst_snoop_mem_info_i.Addr(C_ADDR_DIRECT_POS) else 
                                   '0';
  
  mst_snoop_check_tag_conflict  <= mst_snoop_fetch_info_i.Valid and mst_snoop_check_info_i.Valid 
                                        when mst_snoop_fetch_info_i.Addr(C_ADDR_DIRECT_POS) = 
                                             mst_snoop_check_info_i.Addr(C_ADDR_DIRECT_POS) else 
                                  '0';
  
  
  -----------------------------------------------------------------------------
  -- Distribute Snoop Request
  -- 
  -----------------------------------------------------------------------------
  
  Gen_Snoop_Array : process (mst_snoop_fetch_info_i, mst_snoop_mem_info_i, mst_snoop_check_info_i, 
                             mst_snoop_fetch_sel_block, mst_snoop_mem_sel_block, mst_snoop_check_sel_block, 
                             mst_snoop_tag_valid_i, mst_snoop_tag_info_i, 
                             sdr_info, sdr_stall, sdr_already_pushed) is
  begin  -- process Gen_Snoop_Array
    for I in 0 to C_CACHE_BLOCKS - 1 loop
      -- Forward Fetch to correct Block.
      mst_snoop_fetch_info(I)       <= mst_snoop_fetch_info_i;
      if( mst_snoop_fetch_sel_block = I ) then
        mst_snoop_fetch_info(I).Valid <= mst_snoop_fetch_info_i.Valid;
      else
        mst_snoop_fetch_info(I).Valid <= '0';
      end if;
      
      -- Forward Mem to correct Block.
      mst_snoop_mem_info(I)         <= mst_snoop_mem_info_i;
      if( mst_snoop_mem_sel_block = I ) then
        mst_snoop_mem_info(I).Valid   <= mst_snoop_mem_info_i.Valid;
      else
        mst_snoop_mem_info(I).Valid   <= '0';
      end if;
      
      -- Forward Check to correct Block.
      mst_snoop_check_info(I)       <= mst_snoop_check_info_i;
      mst_snoop_tag_info(I)         <= mst_snoop_tag_info_i;
      mst_snoop_sdr_info(I)         <= sdr_info;
      if( mst_snoop_check_sel_block = I ) then
        mst_snoop_check_info(I).Valid <= mst_snoop_check_info_i.Valid;
        mst_snoop_tag_valid(I)        <= mst_snoop_tag_valid_i;
        mst_snoop_sdr_info(I).Valid   <= sdr_info.Valid;
        mst_snoop_sdr_push(I)         <= sdr_info.Valid             and 
                                         ( not sdr_already_pushed ) and 
                                         ( not sdr_stall          );
      else
        mst_snoop_check_info(I).Valid <= '0';
        mst_snoop_tag_valid(I)        <= '0';
        mst_snoop_sdr_info(I).Valid   <= '0';
        mst_snoop_sdr_push(I)         <= '0';
      end if;
      
    end loop;
  end process Gen_Snoop_Array;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_be_rd_latency  <= C_NULL_STAT_POINT;
    stat_be_wr_latency  <= C_NULL_STAT_POINT;
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal ar_start                   : std_logic;
    signal ar_done                    : std_logic;
    signal ar_ack                     : std_logic;
    signal rd_valid                   : std_logic;
    signal rd_last                    : std_logic;
    signal aw_start                   : std_logic;
    signal aw_done                    : std_logic;
    signal aw_ack                     : std_logic;
    signal wr_valid                   : std_logic;
    signal wr_last                    : std_logic;
    signal wr_resp                    : std_logic;
  begin
    
    -- Detect conditions.
    Trans_Handle : process (ACLK) is
    begin  -- process Trans_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          ar_start  <= '0';
          ar_done   <= '0';
          ar_ack    <= '0';
          rd_valid  <= '0';
          rd_last   <= '0';
          aw_start  <= '0';
          aw_done   <= '0';
          aw_ack    <= '0';
          wr_valid  <= '0';
          wr_last   <= '0';
          wr_resp   <= '0';
          
        else
          ar_start  <= M_AXI_ARVALID_I  and not ar_done;
          ar_ack    <= M_AXI_ARVALID_I  and M_AXI_ARREADY;
          rd_valid  <= M_AXI_RVALID     and mst_if_rd_data_ready;
          rd_last   <= M_AXI_RVALID     and mst_if_rd_data_ready and M_AXI_RLAST;
          
          aw_start  <= M_AXI_AWVALID_I  and not aw_done;
          aw_ack    <= M_AXI_AWVALID_I  and M_AXI_AWREADY;
          wr_valid  <= M_AXI_WVALID_I   and M_AXI_WREADY;
          wr_last   <= M_AXI_WVALID_I   and M_AXI_WREADY and M_AXI_WLAST_I;
          wr_resp   <= M_AXI_BVALID     and mst_if_wr_resp_ready;
          
          if( M_AXI_ARREADY = '1' ) then
            ar_done   <= '0';
          elsif( M_AXI_ARVALID_I = '1' ) then
            ar_done   <= '1';
          end if;
          
          if( M_AXI_AWREADY = '1' ) then
            aw_done   <= '0';
          elsif( M_AXI_AWVALID_I = '1' ) then
            aw_done   <= '1';
          end if;
          
        end if;
      end if;
    end process Trans_Handle;
    
    Latency_Inst: sc_stat_latency
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_LATENCY_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_LATENCY_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        ar_start                  => ar_start,
        ar_ack                    => ar_ack,
        rd_valid                  => rd_valid,
        rd_last                   => rd_last,
        aw_start                  => aw_start,
        aw_ack                    => aw_ack,
        wr_valid                  => wr_valid,
        wr_last                   => wr_last,
        wr_resp                   => wr_resp,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
    
        stat_rd_latency           => stat_be_rd_latency,
        stat_wr_latency           => stat_be_wr_latency,
        stat_rd_latency_conf      => stat_be_rd_latency_conf,
        stat_wr_latency_conf      => stat_be_wr_latency_conf
      );
    
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    M_IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          M_IF_DEBUG <= (others=>'0');
        else
          -- Default assignment.
          M_IF_DEBUG <= (others=>'0');
          
          -- Write Channel
          M_IF_DEBUG(             0) <= M_AXI_AWVALID_I;
          M_IF_DEBUG(             1) <= M_AXI_WVALID_I;
          M_IF_DEBUG(             2) <= M_AXI_WLAST_I;
          M_IF_DEBUG(             3) <= M_AXI_ARVALID_I;
          M_IF_DEBUG(             4) <= write_req_ordered_ready_i;
          M_IF_DEBUG(             5) <= write_data_ordered_ready_i;
          M_IF_DEBUG(             6) <= new_aw_transaction;
          M_IF_DEBUG(             7) <= internal_ctrl_aw_ready;
          M_IF_DEBUG(             8) <= internal_ctrl_aw_hold;
          
          -- Write Insert Handling
          M_IF_DEBUG(             9) <= wr_ins_push;
          M_IF_DEBUG(            10) <= wr_ins_pop;
          M_IF_DEBUG(            11) <= wr_ins_fifo_full;
          M_IF_DEBUG( 15 downto  12) <= fit_vec(wr_ins_read_fifo_addr, 4);
          M_IF_DEBUG(            16) <= wr_ins_fifo_empty;
          
          -- Write Response Channel
          M_IF_DEBUG(            17) <= ack_insert_write_msg;
          M_IF_DEBUG(            18) <= M_AXI_BREADY_I;
          
          -- Read Channel
          M_IF_DEBUG(            19) <= ack_insert_read_msg;
          M_IF_DEBUG(            20) <= M_AXI_RREADY_I;
          
          -- Read Insert Handling
          M_IF_DEBUG(            21) <= rd_ins_push;
          M_IF_DEBUG(            22) <= rd_ins_pop;
          M_IF_DEBUG(            23) <= rd_ins_fifo_full;
          M_IF_DEBUG( 27 downto  24) <= fit_vec(rd_ins_read_fifo_addr, 4);
          M_IF_DEBUG( 29 downto  28) <= std_logic_vector(to_unsigned(RD_INS_TYPE'pos(rd_ins_src), 2));
          M_IF_DEBUG(            30) <= rd_ins_fifo_empty;
          
          -- ACE Downstream Sync Request Handling
          M_IF_DEBUG(            31) <= internal_dvm_valid;
          M_IF_DEBUG(            32) <= internal_sync_valid;
          M_IF_DEBUG(            33) <= other_req;
          M_IF_DEBUG(            34) <= need_2nd_part;
          M_IF_DEBUG(            35) <= force_2nd_part;
          M_IF_DEBUG(            36) <= internal_ctrl_ar_ready;
          M_IF_DEBUG(            37) <= internal_ctrl_ar_hold;
          M_IF_DEBUG(            38) <= waiting_for_complete;
          M_IF_DEBUG(            39) <= sync_req;
          M_IF_DEBUG(            40) <= sync_done;
          M_IF_DEBUG(            41) <= dvm_other_done;
          M_IF_DEBUG(            42) <= ctrl_bar_done_i;
          
          -- Coherency AC Channel
          M_IF_DEBUG(            43) <= M_AXI_ACREADY_I;
          M_IF_DEBUG(            44) <= new_ac;
--          M_IF_DEBUG(             0) <= last_acaddr                : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
          M_IF_DEBUG(            45) <= internal_complete_valid;
          M_IF_DEBUG(            46) <= internal_complete_ready;
          M_IF_DEBUG(            47) <= internal_complete_already;
          M_IF_DEBUG(            48) <= new_ar_transaction;
          
          
          -- Coherency CR Channel
          M_IF_DEBUG(            49) <= crresp_push;
          M_IF_DEBUG(            50) <= crresp_pop;
          M_IF_DEBUG(            51) <= crresp_stall;
          M_IF_DEBUG(            52) <= crresp_fifo_full;
          M_IF_DEBUG(            53) <= crresp_fifo_empty;
          M_IF_DEBUG( 57 downto  54) <= fit_vec(crresp_read_fifo_addr, 4);
          M_IF_DEBUG(            58) <= crresp_already_pushed;
          M_IF_DEBUG( 63 downto  59) <= fit_vec(new_crresp, 5);
          
          -- Coherency CD Channel
          M_IF_DEBUG(191 downto  64) <= fit_vec(cd_data(cd_sel_block), 128);
          M_IF_DEBUG(194 downto 192) <= std_logic_vector(to_unsigned(cd_sel_block, 3));
          M_IF_DEBUG(202 downto 195) <= fit_vec(cd_valid, 8);
          M_IF_DEBUG(210 downto 203) <= fit_vec(cd_last, 8);
          M_IF_DEBUG(           211) <= cd_src_valid;
          M_IF_DEBUG(           212) <= cd_src_stall;
          
          -- Pipeline Stage: Master Snoop Fetch
          M_IF_DEBUG(           213) <= mst_snoop_fetch_piperun_i;
          M_IF_DEBUG(           214) <= mst_snoop_fetch_stall;
          M_IF_DEBUG(           215) <= mstf_core_mem_stall;
          M_IF_DEBUG(           216) <= mstf_core_check_stall;
          M_IF_DEBUG(           217) <= mstf_core_update_stall;
          M_IF_DEBUG(           218) <= mst_snoop_mem_tag_conflict;
          M_IF_DEBUG(           219) <= mst_snoop_check_tag_conflict;
          M_IF_DEBUG(           220) <= mstf_core_make_dirty;
          M_IF_DEBUG(           221) <= mstf_core_make_unique;
          M_IF_DEBUG(224 downto 222) <= std_logic_vector(to_unsigned(mst_snoop_fetch_sel_block, 3));
--          M_IF_DEBUG(           225) <= mst_snoop_fetch_info_i.     : MST_SNOOP_REQ_TYPE;
          M_IF_DEBUG(           225) <= mst_snoop_fetch_info_i.Valid;
          M_IF_DEBUG(           226) <= mst_snoop_fetch_info_i.Lookup;
          M_IF_DEBUG(           227) <= mst_snoop_fetch_info_i.Update;
          M_IF_DEBUG(           228) <= mst_snoop_fetch_info_i.Get;
          M_IF_DEBUG(           229) <= mst_snoop_fetch_info_i.Keep;
          M_IF_DEBUG(           230) <= mst_snoop_fetch_info_i.Clean;
          M_IF_DEBUG(           231) <= mst_snoop_fetch_info_i.Kill;
          M_IF_DEBUG(           232) <= mst_snoop_fetch_info_i.Sync;
          M_IF_DEBUG(           233) <= mst_snoop_fetch_info_i.Complete;
          M_IF_DEBUG(271 downto 234) <= fit_vec(mst_snoop_fetch_info_i.Addr, 38);
          M_IF_DEBUG(287 downto 272) <= fit_vec(mst_snoop_fetch_info_i.ASID, 16);
          M_IF_DEBUG(295 downto 288) <= fit_vec(mst_snoop_fetch_info_i.VMID, 8);
          M_IF_DEBUG(298 downto 296) <= fit_vec(mst_snoop_fetch_info_i.Prot, 3);
          M_IF_DEBUG(           299) <= cddata_fifo_full(0);
          
          -- Pipeline Stage: Master Snoop Mem
          M_IF_DEBUG(           300) <= mst_snoop_mem_piperun_i;
          M_IF_DEBUG(           301) <= mst_snoop_mem_stall;
          M_IF_DEBUG(           302) <= mst_snoop_mem_make_unique;
          M_IF_DEBUG(           303) <= mst_snoop_mem_rm_alloc_done;
          M_IF_DEBUG(306 downto 304) <= std_logic_vector(to_unsigned(mst_snoop_mem_sel_block, 3));
--          M_IF_DEBUG(           300) <= mst_snoop_mem_info_i       : MST_SNOOP_REQ_TYPE;
          M_IF_DEBUG(           307) <= mst_snoop_mem_info_i.Valid;
          M_IF_DEBUG(           308) <= mst_snoop_mem_info_i.Lookup;
          M_IF_DEBUG(           309) <= mst_snoop_mem_info_i.Update;
          M_IF_DEBUG(           310) <= mst_snoop_mem_info_i.Get;
          M_IF_DEBUG(           311) <= mst_snoop_mem_info_i.Keep;
          M_IF_DEBUG(           312) <= mst_snoop_mem_info_i.Clean;
          M_IF_DEBUG(           313) <= mst_snoop_mem_info_i.Kill;
          M_IF_DEBUG(351 downto 314) <= fit_vec(mst_snoop_mem_info_i.Addr, 38);
          M_IF_DEBUG(367 downto 352) <= fit_vec(mst_snoop_mem_info_i.ASID, 16);
          M_IF_DEBUG(375 downto 368) <= fit_vec(mst_snoop_mem_info_i.VMID, 8);
          M_IF_DEBUG(378 downto 376) <= fit_vec(mst_snoop_mem_info_i.Prot, 3);
          M_IF_DEBUG(           379) <= mst_snoop_mem_info_i.Sync;
          M_IF_DEBUG(           380) <= mst_snoop_mem_info_i.Complete;
          M_IF_DEBUG(           381) <= mst_snoop_decode_piperun;
          
          -- Pipeline Stage: Master Snoop Check
          M_IF_DEBUG(           382) <= mst_snoop_check_piperun_i;
          M_IF_DEBUG(           383) <= mst_snoop_check_stall;
          M_IF_DEBUG(           384) <= mst_snoop_check_alloc_done;
          M_IF_DEBUG(           385) <= mst_snoop_check_make_dirty;
          M_IF_DEBUG(           386) <= mst_snoop_check_make_unique;
          M_IF_DEBUG(           387) <= mst_snoop_tag_valid_i;
          M_IF_DEBUG(           388) <= tag_already_written;
          M_IF_DEBUG(           389) <= sdr_stall;
          M_IF_DEBUG(           390) <= sdr_already_pushed;
          M_IF_DEBUG(           391) <= update_allocating_line;
          M_IF_DEBUG(           392) <= mst_snoop_sdr_empty(0);
--          M_IF_DEBUG(           393) <= mst_snoop_check_info_i     : MST_SNOOP_REQ_TYPE;
          M_IF_DEBUG(           393) <= mst_snoop_check_info_i.Valid;
          M_IF_DEBUG(           394) <= mst_snoop_check_info_i.Lookup;
          M_IF_DEBUG(           395) <= mst_snoop_check_info_i.Update;
          M_IF_DEBUG(           396) <= mst_snoop_check_info_i.Get;
          M_IF_DEBUG(           397) <= mst_snoop_check_info_i.Keep;
          M_IF_DEBUG(           398) <= mst_snoop_check_info_i.Clean;
          M_IF_DEBUG(           399) <= mst_snoop_check_info_i.Kill;
          M_IF_DEBUG(447 downto 400) <= fit_vec(mst_snoop_check_info_i.Addr, 48);
          M_IF_DEBUG(463 downto 448) <= fit_vec(mst_snoop_check_info_i.ASID, 16);
          M_IF_DEBUG(471 downto 464) <= fit_vec(mst_snoop_check_info_i.VMID, 8);
          M_IF_DEBUG(474 downto 472) <= fit_vec(mst_snoop_check_info_i.Prot, 3);
          M_IF_DEBUG(477 downto 475) <= std_logic_vector(to_unsigned(mst_snoop_check_sel_block, 3));
          M_IF_DEBUG(           478) <= mst_snoop_check_info_i.Sync;
          M_IF_DEBUG(           479) <= mst_snoop_check_info_i.Complete;
          M_IF_DEBUG(           480) <= '0';
--          M_IF_DEBUG(           470) <= mst_snoop_check_sel_ack    : MST_SNOOP_ACK_TYPE;
          M_IF_DEBUG(           481) <= mst_snoop_check_sel_ack.Valid;
          M_IF_DEBUG(           482) <= mst_snoop_check_sel_ack.Secure;
          M_IF_DEBUG(           483) <= mst_snoop_check_sel_ack.Unique;
          M_IF_DEBUG(531 downto 484) <= fit_vec(mst_snoop_check_sel_ack.Addr, 48);
          M_IF_DEBUG(           532) <= mst_snoop_check_sel_ack.Dirty;
          M_IF_DEBUG(           533) <= mst_snoop_check_sel_ack.Locked;
          M_IF_DEBUG(536 downto 534) <= std_logic_vector(to_unsigned(mst_snoop_check_sel_ack.Way, 3));
          M_IF_DEBUG(           537) <= mst_snoop_check_sel_ack.Reused;
--          M_IF_DEBUG(           527) <= mst_snoop_tag_info_i       : WAY_LINE_TAG_TYPE;
          M_IF_DEBUG(585 downto 538) <= fit_vec(mst_snoop_tag_info_i.Addr, 48);
          M_IF_DEBUG(           586) <= mst_snoop_tag_info_i.Valid;
          M_IF_DEBUG(           587) <= mst_snoop_tag_info_i.Unique;
          M_IF_DEBUG(           588) <= mst_snoop_tag_info_i.Dirty;
          M_IF_DEBUG(           589) <= mst_snoop_tag_info_i.Locked;
          M_IF_DEBUG(           590) <= mst_snoop_tag_info_i.Reused;
          M_IF_DEBUG(           591) <= mst_snoop_tag_info_i.Secure;
--          M_IF_DEBUG(           581) <= sdr_info                   : MST_SNOOP_ADDR_TYPE;
          M_IF_DEBUG(639 downto 592) <= fit_vec(sdr_info.Addr, 48);
          M_IF_DEBUG(642 downto 640) <= std_logic_vector(to_unsigned(sdr_info.Way, 3));
          M_IF_DEBUG(           643) <= sdr_info.Valid;

          -- Pipeline Stage: Start of PipeRun
          M_IF_DEBUG(           644) <= mst_snoop_start_piperun_i;
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_transaction_ordering.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_transaction_ordering.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_transaction_ordering.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-06-21    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_transaction_ordering is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
    C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
    C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
    C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
    C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
    C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
    C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
    C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
    C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    read_req_info             : in  READ_REQ_TYPE;
    read_req_ready            : out std_logic;
    
    write_req_info            : in  WRITE_REQ_TYPE;
    write_req_ready           : out std_logic;
    
    write_data_info           : in  DATA_PORT_TYPE;
    write_data_ready          : out std_logic;
    write_data_almost_full    : out std_logic;
    write_data_full           : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Ordered signals.
    
    read_req_ordered_info     : out READ_REQ_TYPE;
    read_req_ordered_ready    : in  std_logic;
    
    write_req_ordered_info    : out WRITE_REQ_TYPE;
    write_req_ordered_ready   : in  std_logic;
    
    write_data_ordered_info   : out DATA_PORT_TYPE;
    write_data_ordered_ready  : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Status signals (to Lookup).
    
    be_writeunique_inflight   : out std_logic;
    be_writeback_inflight     : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Monitor Backend signals (to Update).
    
    mst_if_wr_resp_info       : in  WRITE_RESP_TYPE;
    mst_if_wr_resp_ready      : in  std_logic;
    
    mst_if_rd_data_info       : in  READ_RESP_TYPE;
    mst_if_rd_data_ready      : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Backend signals.
    
    mst_snoop_mem_piperun     : in  std_logic;
    mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
    mst_snoop_check_piperun   : in  std_logic;
    mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
    mst_cross_order_hazard    : out MST_SNOOP_HAZ_TYPE;
    
    mst_core_be_data_info     : out MST_SNOOP_DATA_TYPE;
    mst_core_be_data_ready    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_be_aw                : out STAT_FIFO_TYPE;     -- Write Address
    stat_be_w                 : out STAT_FIFO_TYPE;     -- Write Data
    stat_be_ar                : out STAT_FIFO_TYPE;     -- Read Address
    stat_be_ar_search_depth   : out STAT_POINT_TYPE;    -- Average search depth
    stat_be_ar_stall          : out STAT_POINT_TYPE;    -- Average total stall
    stat_be_ar_protect_stall  : out STAT_POINT_TYPE;    -- Average protected stall
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    BACKEND_DEBUG             : out MAX_DEBUG_TYPE
  );
end entity sc_transaction_ordering;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_transaction_ordering is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_AW_QUEUE_ERROR            : natural :=  0;
  constant C_ASSERT_W_QUEUE_ERROR             : natural :=  1;
  constant C_ASSERT_AR_QUEUE_ERROR            : natural :=  2;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  3;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Ranges for address parts.
  subtype C_ADDR_VALID_POS            is natural range C_ADDR_VALID_HI        downto C_ADDR_VALID_LO;
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI     downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_REQ_POS              is natural range C_ADDR_REQ_HI          downto C_ADDR_REQ_LO;
  subtype C_ADDR_TAG_CONTENTS_POS     is natural range C_ADDR_TAG_CONTENTS_HI downto C_ADDR_TAG_CONTENTS_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI       downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_EXT_WORD_POS         is natural range C_ADDR_EXT_WORD_HI     downto C_ADDR_EXT_WORD_LO;
  
  -- Subtypes for address parts.
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_REQ_TYPE               is std_logic_vector(C_ADDR_REQ_POS);
  subtype ADDR_TAG_CONTENTS_TYPE      is std_logic_vector(C_ADDR_TAG_CONTENTS_POS);
  subtype ADDR_EXT_WORD_TYPE          is std_logic_vector(C_ADDR_EXT_WORD_POS);
  
  -- Read-Write reordering handling.
  constant C_MAX_OUTSTANDING_WRITE    : integer:= 31;
  subtype OUTSTANDING_WRITE_TYPE      is rinteger range 0 to C_MAX_OUTSTANDING_WRITE;
  constant C_SEQUENCE_ID_LENGTH       : integer:= 2 ** ( Log2(C_MAX_OUTSTANDING_WRITE) + 2 );
  constant C_MAX_SEQUENCE_ID          : integer:= C_SEQUENCE_ID_LENGTH - 1;
  subtype C_SEQUENCE_ID_POS           is natural range Log2(C_MAX_SEQUENCE_ID) - 1 downto 0;
  subtype C_SEQUENCE_BLOCK_POS        is natural range Log2(C_MAX_SEQUENCE_ID) - 1 downto Log2(C_MAX_SEQUENCE_ID) - 2;
  subtype C_SEQUENCE_NUM_POS          is natural range Log2(C_MAX_SEQUENCE_ID) - 3 downto 0;
  subtype SEQUENCE_ID_TYPE            is std_logic_vector(C_SEQUENCE_ID_POS);
  subtype SEQUENCE_BLOCK_TYPE         is std_logic_vector(C_SEQUENCE_BLOCK_POS);
  subtype SEQUENCE_NUM_TYPE           is std_logic_vector(C_SEQUENCE_NUM_POS);
  
  -- Per Port Write Counter
  subtype C_PER_PORT_POS              is rinteger range 0 to C_ORDER_PER_PORT * ( C_NUM_PORTS-1);
  type R_PROTECT_TYPE                 is array(C_PER_PORT_POS)         of ADDR_TAG_CONTENTS_TYPE;
  type PORT_WRITE_CNT_TYPE            is array(C_PER_PORT_POS)         of OUTSTANDING_WRITE_TYPE;
  
  type HISTORY_TYPE is record
    Stall_Snoop       : std_logic;
    Non_Secure        : std_logic;
    Line_Only         : std_logic;
    Cancelled         : std_logic;
    Addr              : ADDR_REQ_TYPE;
    SeqId             : SEQUENCE_ID_TYPE;
  end record HISTORY_TYPE;
  
  constant C_NULL_HISTORY             : HISTORY_TYPE  := (Stall_Snoop=>'0', Non_Secure=>'0', Line_Only=>'0', 
                                                          Cancelled=>'0', Addr=>(others=>'0'), SeqId=>(others=>'0'));
  
  type HISTORY_BUFFER_TYPE            is array(OUTSTANDING_WRITE_TYPE) of HISTORY_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  subtype BE_TYPE                     is std_logic_vector(C_EXTERNAL_DATA_WIDTH / 8 - 1 downto 0);
  subtype DATA_TYPE                   is std_logic_vector(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
  subtype LENGTH_TYPE                 is std_logic_vector(8 - 1 downto 0);
  subtype SIZE_TYPE                   is std_logic_vector(3 - 1 downto 0);
  subtype PORT_TYPE                   is std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Types for Queue Length.
  constant C_DATA_QUEUE_LINE_LENGTH   : integer:= 32 * C_CACHE_LINE_LENGTH / C_EXTERNAL_DATA_WIDTH;
  constant C_DATA_QUEUE_LENGTH        : integer:= max_of(16, sel(C_ENABLE_SLV_WR_THROTTLE > 0, 
                                                                 2 * 16 * C_CACHE_LINE_LENGTH,
                                                                 2 * C_DATA_QUEUE_LINE_LENGTH) );
  constant C_DATA_QUEUE_LENGTH_BITS   : integer:= log2(C_DATA_QUEUE_LENGTH);
  subtype DATA_QUEUE_POS              is natural range C_DATA_QUEUE_LENGTH - 1 downto 0;
  subtype DATA_QUEUE_TYPE             is std_logic_vector(DATA_QUEUE_POS);
  subtype DATA_QUEUE_ADDR_TYPE        is std_logic_vector(C_DATA_QUEUE_LENGTH_BITS - 1 downto 0);
  
  
  -- Types for information queue storage.
  type AW_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of WRITE_REQ_TYPE;
  type W_FIFO_MEM_TYPE            is array(DATA_QUEUE_POS)      of DATA_PORT_TYPE;
  type AR_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of READ_REQ_TYPE;
  type ID_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of SEQUENCE_ID_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  component comparator is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET          : TARGET_FAMILY_TYPE;
      C_SIZE            : natural);
    port (
      Carry_IN  : in  std_logic;
      DI        : in  std_logic;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      B_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_OUT : out std_logic
    );
  end component comparator;
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_latch_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_or;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Ordered signals.
    
  signal read_req_ordered_info_i    : READ_REQ_TYPE;
  signal write_req_ordered_info_i   : WRITE_REQ_TYPE;
  signal write_data_ordered_info_i  : DATA_PORT_TYPE;
    
  -- ----------------------------------------
  -- Write Buffers
  
  signal write_req_ready_i          : std_logic;
  signal aw_push                    : std_logic;
  signal aw_pop                     : std_logic;
  signal aw_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
  signal aw_fifo_mem                : AW_FIFO_MEM_TYPE; -- := (others=>C_NULL_AW);
  signal aw_fifo_full               : std_logic;
  signal aw_fifo_empty              : std_logic;
  signal aw_assert                  : std_logic;
  
  signal write_data_ready_i         : std_logic;
  signal w_push                     : std_logic;
  signal w_pop                      : std_logic;
  signal w_fifo_mem                 : W_FIFO_MEM_TYPE; -- := (others=>C_NULL_W);
  signal w_read_fifo_addr           : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
  signal w_fifo_almost_full         : std_logic;
  signal w_fifo_full                : std_logic;
  signal w_fifo_empty               : std_logic;
  signal w_assert                   : std_logic;

  signal w_read_addr                : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
  signal allow_snoop_data           : std_logic;
  signal last_snoop_to_extract      : std_logic;
  signal w_extracted                : DATA_QUEUE_TYPE;
  
  signal write_seq_id               : SEQUENCE_ID_TYPE;
  
  
  -- ----------------------------------------
  -- Write Throttling
  
  signal allow_write_req            : std_logic;
  signal allow_write_data           : std_logic;
  signal data_flowing               : std_logic;
  
  signal snoop_must_freeze_wr       : std_logic;
  
  
   -- ----------------------------------------
  -- Read Buffer
  
  signal read_req_ready_i           : std_logic;
  signal ar_push                    : std_logic;
  signal ar_pop_i                   : std_logic;
  signal ar_pop                     : std_logic;
  signal ar_pop_or_reset            : std_logic;
  signal ar_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
  signal ar_fifo_mem                : AR_FIFO_MEM_TYPE; -- := (others=>C_NULL_AR);
  signal ar_id_fifo_mem             : ID_FIFO_MEM_TYPE; -- := (others=>(others=>'0'));
  signal ar_fifo_full               : std_logic;
  signal ar_fifo_empty              : std_logic;
  
  signal ar_exist                   : std_logic;
  signal ar_valid                   : std_logic;
  signal ar_seq_id                  : SEQUENCE_ID_TYPE;
  signal ar_assert                  : std_logic;
  
  
 -- ----------------------------------------
  -- Placement of Reorder Check
  
  signal allow_read_req_ready       : std_logic;
  signal allow_ar_valid             : std_logic;
  signal check_port                 : rinteger range 0 to C_NUM_PORTS - 1;
  signal check_addr                 : ADDR_INTERNAL_TYPE;
  
  signal read_possible_for_pending  : std_logic;
  signal search_count               : OUTSTANDING_WRITE_TYPE;
  signal protected_read_hit_n       : std_logic;
  
  signal hist_fifo_mem              : HISTORY_BUFFER_TYPE;
  
  
  -- ----------------------------------------
  -- Write-Read Reordering Control
  
  signal pending_write              : OUTSTANDING_WRITE_TYPE;
  signal push_pending_write         : std_logic;
  signal pop_pending_write          : std_logic;
  signal refresh_pending_write      : std_logic;
  signal need_to_stall_write        : std_logic;
  signal need_to_stall_write_cmb    : std_logic;
  signal no_write_blocking_read     : std_logic;
  signal pending_write_is_1         : std_logic;
  signal read_must_stall_write      : std_logic;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP

  
  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Write Buffers
  -----------------------------------------------------------------------------
  
  -- Control signals for write address buffer.
  write_req_ready_i   <= not aw_fifo_full and not need_to_stall_write;
  write_req_ready     <= write_req_ready_i;
  aw_push             <= push_pending_write;
  aw_pop              <= write_req_ordered_info_i.Valid and write_req_ordered_ready;
  
  -- Control signals for write data buffer.
  write_data_ready_i  <= not w_fifo_full;
  write_data_ready    <= write_data_ready_i;
  w_push              <= write_data_info.Valid and write_data_ready_i;
  w_pop               <= write_data_ordered_info_i.Valid and write_data_ordered_ready;
    
  FIFO_AW_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => aw_push,
      queue_pop                 => aw_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => aw_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => aw_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => aw_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_be_aw,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => aw_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  FIFO_W_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_DATA_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => C_DATA_QUEUE_LINE_LENGTH
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => w_push,
      queue_pop                 => w_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => w_fifo_almost_full,
      queue_full                => w_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => w_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => w_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_be_w,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => w_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for AW Channel FIFO.
  FIFO_AW_Memory : process (ACLK) is
  begin  -- process FIFO_AW_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( aw_push = '1' ) then
        -- Insert new item.
        aw_fifo_mem(0)                          <= write_req_info;
        
        -- Shift FIFO contents.
        aw_fifo_mem(aw_fifo_mem'left downto 1)  <= aw_fifo_mem(aw_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_AW_Memory;

  -- Handle memory for W Channel FIFO.
  FIFO_W_Memory : process (ACLK) is
  begin  -- process FIFO_W_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( w_push = '1') then
        -- Insert new item.
        w_fifo_mem(0)                         <= write_data_info;
        
        -- Shift FIFO contents.
        w_fifo_mem(w_fifo_mem'left downto 1)  <= w_fifo_mem(w_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_W_Memory;
  
  -- Extract data for AW-Channel.
  Gen_Ordered_Write_Trans: process(aw_fifo_empty, aw_fifo_mem, aw_read_fifo_addr, allow_write_req)
  begin
    write_req_ordered_info_i        <= aw_fifo_mem(to_integer(unsigned(aw_read_fifo_addr)));
    write_req_ordered_info_i.Valid  <= ( not aw_fifo_empty ) and allow_write_req;
  end process Gen_Ordered_Write_Trans;
  write_req_ordered_info  <= write_req_ordered_info_i;
  
  -- Extract data for W-Channel.
  Gen_Ordered_Write_Data_Trans: process(w_fifo_empty, w_fifo_mem, w_read_addr, allow_write_data, allow_snoop_data,
                                        last_snoop_to_extract, w_extracted)
  begin
    write_data_ordered_info_i           <= w_fifo_mem(to_integer(unsigned(w_read_addr)));
    write_data_ordered_info_i.Valid     <= ( not w_fifo_empty ) and allow_write_data;
    write_data_ordered_info_i.BE        <= w_fifo_mem(to_integer(unsigned(w_read_addr))).BE and
                                           not (C_AXI_BE_POS => w_extracted(to_integer(unsigned(w_read_addr))));
    
    mst_core_be_data_info.Valid         <= ( not w_fifo_empty ) and allow_snoop_data;
    mst_core_be_data_info.Last          <= last_snoop_to_extract;
    mst_core_be_data_info.Data          <= w_fifo_mem(to_integer(unsigned(w_read_addr))).Data;

  end process Gen_Ordered_Write_Data_Trans;
  write_data_ordered_info <= write_data_ordered_info_i;
  
  -- Assign external signals.
  write_data_almost_full  <= w_fifo_almost_full;
  write_data_full         <= w_fifo_full;
  
  
  -----------------------------------------------------------------------------
  -- Write Throttling
  -- 
  -----------------------------------------------------------------------------
  
  --
  Use_Slv_Wr_Throttle: if( C_ENABLE_SLV_WR_THROTTLE /= 0 ) generate
  
    signal wl_push                    : std_logic;
    signal wl_pop                     : std_logic;
    signal wl_fifo_empty              : std_logic;
    
  begin
    wl_push             <= w_push and write_data_info.Last;
    wl_pop              <= w_pop  and write_data_ordered_info_i.Last;
      
    FIFO_WL_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_DATA_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => wl_push,
        queue_pop                 => wl_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => open,
        queue_almost_empty        => open,
        queue_empty               => wl_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => open,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => open,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => open,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Track the data flow in order to know when to allow next Write Req.
    Write_Data_Flow : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          data_flowing  <= '0';
        else
          if( s2b(wl_pop) ) then
            data_flowing  <= '0';
            
          elsif( s2b(aw_pop) ) then
            data_flowing  <= '1';
            
          end if;
        end if;
      end if;
    end process Write_Data_Flow;
  
    allow_write_req   <=     write_req_ordered_ready  and 
                             write_data_ordered_ready and 
                         not wl_fifo_empty            and 
                         not aw_fifo_empty            and 
                         not w_fifo_empty             and 
                         not data_flowing             and
                         not snoop_must_freeze_wr;
    allow_write_data  <=     allow_write_req or 
-- TODO: should remove snoop_must_freeze_wr from data? Make sure decreasing depth doesn't disrupt extraction.
                             ( data_flowing and not snoop_must_freeze_wr );
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      BACKEND_DEBUG(250 downto 245) <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            BACKEND_DEBUG(250 downto 245)                   <= (others=>'0');
          else
            -- Default assignment.
            BACKEND_DEBUG(250 downto 245)                   <= (others=>'0');
            
            BACKEND_DEBUG(                             245) <= wl_fifo_empty;
            BACKEND_DEBUG(                             246) <= data_flowing;
            BACKEND_DEBUG(                             247) <= allow_write_req;
            BACKEND_DEBUG(                             248) <= allow_write_data;
            BACKEND_DEBUG(                             249) <= wl_push;
            BACKEND_DEBUG(                             250) <= wl_pop;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Use_Slv_Wr_Throttle;
  
  No_Slv_Wr_Throttle: if( C_ENABLE_SLV_WR_THROTTLE  = 0 ) generate
  begin
    allow_write_req   <= '1';
    allow_write_data  <= '1';
    data_flowing      <= '0';
    
    BACKEND_DEBUG(250 downto 245) <= (others=>'0');
  end generate No_Slv_Wr_Throttle;
  
  
  -----------------------------------------------------------------------------
  -- Read Buffer
  -----------------------------------------------------------------------------
  
  -- Control signals for read address buffer.
  read_req_ready_i  <= allow_read_req_ready and not ar_fifo_full;
  read_req_ready    <= read_req_ready_i;
  ar_push           <= read_req_info.Valid and read_req_ready_i;
--  ar_pop            <= ar_valid and read_req_ordered_ready;
  BE_Valid_And_Inst2: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ar_valid,
      A         => read_req_ordered_ready,
      Carry_OUT => ar_pop_i
    );
  LU_Mem_PR_Latch_Inst1: carry_latch_or
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => ar_pop_i,
      A         => ARESET_I,
      O         => ar_pop_or_reset,
      Carry_OUT => ar_pop
    );
  
  FIFO_AR_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => true,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => ar_push,
      queue_pop                 => ar_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => ar_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => ar_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => ar_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_be_ar,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => ar_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for AR Channel FIFO.
  FIFO_AR_Memory : process (ACLK) is
  begin  -- process FIFO_AR_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( ar_push = '1' ) then
        -- Insert new item.
        ar_fifo_mem(0)                                <= read_req_info;
        ar_id_fifo_mem(0)                             <= write_seq_id;
        
        -- Shift FIFO contents.
        ar_fifo_mem(ar_fifo_mem'left downto 1)        <= ar_fifo_mem(ar_fifo_mem'left-1 downto 0);
        ar_id_fifo_mem(ar_id_fifo_mem'left downto 1)  <= ar_id_fifo_mem(ar_id_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_AR_Memory;
  
  -- Extract data for AR-Channel.
  ar_exist      <= not ar_fifo_empty;
--  ar_valid      <= allow_ar_valid and ar_exist;
  BE_Valid_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => allow_ar_valid,
      A         => ar_exist,
      Carry_OUT => ar_valid
    );
  
  Gen_Ordered_Read_Trans: process(ar_valid, ar_fifo_mem, ar_read_fifo_addr)
  begin
    read_req_ordered_info_i       <= ar_fifo_mem(to_integer(unsigned(ar_read_fifo_addr)));
    read_req_ordered_info_i.Valid <= ar_valid;
  end process Gen_Ordered_Read_Trans;
  read_req_ordered_info <= read_req_ordered_info_i;
  ar_seq_id     <= ar_id_fifo_mem(to_integer(unsigned(ar_read_fifo_addr)));
  
  
  -----------------------------------------------------------------------------
  -- Placement of Reorder Check
  -----------------------------------------------------------------------------
  
  allow_read_req_ready  <= '1';
  allow_ar_valid        <= no_write_blocking_read;
  check_port            <= get_port_num(read_req_ordered_info_i.Port_Num, C_NUM_PORTS);
  check_addr            <= read_req_ordered_info_i.Addr(C_ADDR_INTERNAL_POS);
  
  
  -----------------------------------------------------------------------------
  -- Write-Read Reordering Control
  -----------------------------------------------------------------------------
  
  -- Create control signals.
  push_pending_write    <= write_req_info.Valid and write_req_ready_i;
  pop_pending_write     <= mst_if_wr_resp_info.Valid and mst_if_wr_resp_ready;
  refresh_pending_write <= push_pending_write xor pop_pending_write;
  
  -- Up/Down counter for outstanding transactions.
  Outstanding_Write_Cnt : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        pending_write           <= 0;
        pending_write_is_1      <= '0';
      elsif( refresh_pending_write = '1' ) then
        -- Handle Read Write ordering.
        if( push_pending_write = '1' ) then
          -- New write request.
          pending_write           <= pending_write + 1;
          pending_write_is_1      <= '0';
          if( pending_write = 0 ) then
            pending_write_is_1      <= '1';
          end if;
        else
          -- Write completed.
          -- pragma translate_off
          if (pending_write > 0) then
          -- pragma translate_on
          pending_write           <= pending_write - 1;
          -- pragma translate_off
          end if;
          -- pragma translate_on
          pending_write_is_1      <= '0';
          if( pending_write = 2 ) then
            pending_write_is_1      <= '1';
          end if;
        end if;
        
      end if;
    end if;
  end process Outstanding_Write_Cnt;
  
  -- Generate ID tracker.
  Id_Cnt : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        write_seq_id  <= (others=>'0');
        
      elsif( push_pending_write = '1' ) then
        -- New write request.
        write_seq_id  <= std_logic_vector(unsigned(write_seq_id) + 1);
        
      end if;
    end if;
  end process Id_Cnt;
  
  -- Flags for outstanding transactions.
  Outstanding_Write_Flags : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        need_to_stall_write     <= '0';
      elsif( refresh_pending_write = '1' ) then
        -- Handle Buffer level throttling.
        need_to_stall_write     <= need_to_stall_write_cmb;
      end if;
    end if;
  end process Outstanding_Write_Flags;
  
  -- Check threshold for outstanding write.
  -- => Stop further accesses if limit has been reached.
  need_to_stall_write_cmb     <= '0' when ( pending_write         < C_MAX_OUTSTANDING_WRITE - 1 ) and
                                          ( read_must_stall_write = '0'                         ) else push_pending_write;
  
  
  -----------------------------------------------------------------------------
  -- Write-Read Reordering Algorithm #4
  -- 
  -- Serial search a history buffer to see if there are any conflicting writes
  -- for the read.
  -- Wait until the blocking write has been removed from the history queue 
  -- with a BRESP.
  -----------------------------------------------------------------------------
  
  Order_Optimization_4: if( C_OPTIMIZE_ORDER = 4 ) generate
    signal buffer_addr                : std_logic_vector(Log2(C_MAX_OUTSTANDING_WRITE) - 1 downto 0);
    signal protected_read_addr        : ADDR_TAG_CONTENTS_TYPE;
    
    signal check_addr_i               : std_logic_vector(C_ADDR_TAG_CONTENTS_HI downto C_ADDR_TAG_CONTENTS_LO - 1);
    signal prot_addr_i                : std_logic_vector(C_ADDR_TAG_CONTENTS_HI downto C_ADDR_TAG_CONTENTS_LO - 1);
    signal protected_read_hit_high_n  : std_logic;
    signal protected_line_only        : std_logic;
    signal protected_read_hit_other_n : std_logic;
    signal be_no_block_1              : std_logic;
    signal be_pop_last_check          : std_logic;
    signal be_no_block_1to2_part      : std_logic;
    signal search_count_i             : std_logic_vector(Log2(C_MAX_OUTSTANDING_WRITE) - 1 downto 0);
    signal pending_write_i            : std_logic_vector(Log2(C_MAX_OUTSTANDING_WRITE) - 1 downto 0);
    signal be_no_block_1to2           : std_logic;
    signal be_all_checked             : std_logic;
    signal be_no_block_1to3           : std_logic;
    signal be_pop_last                : std_logic;
    signal be_no_block_1to4           : std_logic;
    signal be_no_write                : std_logic;
    signal protected_seq_id           : SEQUENCE_ID_TYPE;
    signal protected_seq_num          : SEQUENCE_NUM_TYPE;
    signal protected_seq_block        : SEQUENCE_BLOCK_TYPE;
    signal write_is_too_new           : std_logic;
    signal read_write_need_check      : std_logic;
    signal ar_seq_num                 : SEQUENCE_NUM_TYPE;
    signal ar_seq_block               : SEQUENCE_BLOCK_TYPE;
    signal read_write_distance        : SEQUENCE_BLOCK_TYPE;
    signal read_write_same_block      : std_logic;
    signal write_is_higher            : std_logic;
    signal write_in_prev_block        : std_logic;
    
  begin
    -- Extract data.
    protected_seq_num     <= protected_seq_id(C_SEQUENCE_NUM_POS);
    protected_seq_block   <= protected_seq_id(C_SEQUENCE_BLOCK_POS);
    ar_seq_num            <= ar_seq_id(C_SEQUENCE_NUM_POS);
    ar_seq_block          <= ar_seq_id(C_SEQUENCE_BLOCK_POS);
    
    -- Must detect if there is a risk of wrap issues.
    read_write_distance   <= std_logic_vector(unsigned(write_seq_id(C_SEQUENCE_BLOCK_POS)) - unsigned(ar_seq_block));
    read_must_stall_write <= read_write_distance(read_write_distance'left) and ar_exist;
    
    -- Determine if write history is in the previous block compare to read, i.e. it is 
    -- older and must be taken into account.
    write_in_prev_block   <= '1' when ( ( ar_seq_block = "00" ) and ( protected_seq_block = "11" ) ) or
                                      ( ( ar_seq_block = "01" ) and ( protected_seq_block = "00" ) ) or
                                      ( ( ar_seq_block = "10" ) and ( protected_seq_block = "01" ) ) or
                                      ( ( ar_seq_block = "11" ) and ( protected_seq_block = "10" ) ) else
                             '0';
    
    -- Check if it is the same block for read and write sequence id.
    read_write_same_block <= '1' when ( protected_seq_block = ar_seq_block                     ) else
                             '0';
    
    -- Check if number of sequence id is higher for write compared to read.
    write_is_higher       <= '1' when ( unsigned(protected_seq_num) >= unsigned(ar_seq_num) )else
                             '0';
    
    -- Determine if write has impact on read, i.e. if it is too new or not.
    read_write_need_check <= write_in_prev_block or ( read_write_same_block and not write_is_higher );
    write_is_too_new      <= not read_write_need_check;
  
    -- Handle search for address.
    Track_Read_Search: process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ar_pop_or_reset = '1' ) then    -- synchronous reset (active true)
          -- Buffer pointer is reset when a read is completed (on AR).
          buffer_addr   <= (others=>'0');
          search_count  <= 1;
        elsif( ( ( ( ar_exist = '1' ) and ( protected_read_hit_n = '1' ) and ( search_count <= pending_write ) ) or
                 ( ( ar_exist = '1' ) and ( push_pending_write   = '1' ) ) or
                 ( ( ar_exist = '1' ) and ( write_is_too_new     = '1' ) ) ) and 
               ( search_count < C_MAX_OUTSTANDING_WRITE ) ) then
          -- Buffer pointer is increased while there is no match in the buffer. When
          -- the last entry has been reach with no collision the read can commence 
          -- externally.
          buffer_addr   <= std_logic_vector(unsigned(buffer_addr) + 1);
          search_count  <= search_count + 1;
        end if;
        
      end if;
    end process Track_Read_Search;
    
    -- Write History buffer.
    Write_History : process (ACLK) is
    begin  -- process Req_FIFO_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( push_pending_write = '1') then
          -- Insert new item.
          hist_fifo_mem(0).Stall_Snoop  <= write_req_info.Stall_Snoop;
          hist_fifo_mem(0).Cancelled    <= write_req_info.Cancelled;
          hist_fifo_mem(0).Non_Secure   <= write_req_info.Prot(C_PROT_SECURE_POS);
          hist_fifo_mem(0).Line_Only    <= write_req_info.Line_Only;
          hist_fifo_mem(0).Addr         <= write_req_info.Addr(C_ADDR_REQ_POS);
          hist_fifo_mem(0).SeqId        <= write_seq_id;
          
          -- Shift FIFO contents.
          hist_fifo_mem(1 to hist_fifo_mem'right) <= hist_fifo_mem(0 to hist_fifo_mem'right-1);
        end if;
      end if;
    end process Write_History;
    
    -- Get currently searched entry.
    protected_read_addr <= hist_fifo_mem(to_integer(unsigned(buffer_addr))).Addr(C_ADDR_TAG_CONTENTS_POS); 
    protected_line_only <= hist_fifo_mem(to_integer(unsigned(buffer_addr))).Line_Only; 
    protected_seq_id    <= hist_fifo_mem(to_integer(unsigned(buffer_addr))).SeqId; 
  
    -- Detect hit in forbidden area.
--    protected_read_hit_n  <= '0' when check_addr(C_ADDR_TAG_CONTENTS_POS) = protected_read_addr(C_ADDR_TAG_CONTENTS_POS) 
--                             else '1';
    check_addr_i  <= check_addr(C_ADDR_TAG_CONTENTS_POS) & '1';
    prot_addr_i   <= protected_read_addr(C_ADDR_TAG_CONTENTS_POS) & '1';
    Prot_Inst_High: comparator
      generic map(
        C_TARGET          => C_TARGET,
        C_SIZE            => C_ADDR_TAG_CONTENTS_HI - C_ADDR_LINE_HI 
      )
      port map(
        Carry_IN          => '0',
        DI                => '1',
        A_Vec             => check_addr_i(C_ADDR_TAG_CONTENTS_HI downto C_ADDR_LINE_HI + 1),
        B_Vec             => prot_addr_i(C_ADDR_TAG_CONTENTS_HI downto C_ADDR_LINE_HI + 1),
        Carry_OUT         => protected_read_hit_high_n
      );
    
    Prot_Inst_Select: carry_and_n
      generic map(
        C_TARGET          => C_TARGET
      )
      port map(
        Carry_IN          => protected_read_hit_high_n,
        A_N               => protected_line_only,
        Carry_OUT         => protected_read_hit_other_n
      );
    
    Prot_Inst_Low: comparator
      generic map(
        C_TARGET          => C_TARGET,
        C_SIZE            => C_ADDR_LINE_HI - C_ADDR_TAG_CONTENTS_LO + 2
      )
      port map(
        Carry_IN          => protected_read_hit_other_n,
        DI                => '1',
        A_Vec             => check_addr_i(C_ADDR_LINE_HI downto C_ADDR_TAG_CONTENTS_LO - 1),
        B_Vec             => prot_addr_i(C_ADDR_LINE_HI downto C_ADDR_TAG_CONTENTS_LO - 1),
        Carry_OUT         => protected_read_hit_n
      );
    
    -- End of the write queue has been reached. If there is no collision the
    -- read can begin (externally).
    read_possible_for_pending <= '1' when ( search_count = pending_write ) else '0';
    
    -- Check when it is safe to initiate read.
    -- 1) All active write is safe.
    -- 2) Oldest and current element removed from queue (doesn't matter if it is collision).
    -- 3) Entire queue has been checked (includes no queue at all).
    -- 4) Last write acknowledged (for this port) regardless if it is conflict.
    -- 5) No pending write.
--    no_write_blocking_read  <= '1' when
--                               ( (protected_read_hit_n = '1') and read_possible_for_pending = '1' ) or 
--                               ( (pop_pending_write = '1') and read_possible_for_pending = '1' ) or
--                               ( search_count > pending_write ) or 
--                               ( (pending_write  = 1) and (pop_pending_write = '1') ) or 
--                               ( pending_write = 0 )
--                               else '0';

--    BE_Block_And_Inst1: carry_and
--      generic map(
--        C_TARGET  => C_TARGET
--      )
--      port map(
--        Carry_IN  => protected_read_hit_n,
--        A         => read_possible_for_pending,
--        Carry_OUT => be_no_block_1
--      );
--    
--    be_pop_last_check <= pop_pending_write and read_possible_for_pending;
--    
--    BE_Block_Or_Inst1: carry_or
--      generic map(
--        C_TARGET  => C_TARGET
--      )
--      port map(
--        Carry_IN  => be_no_block_1,
--        A         => be_pop_last_check,
--        Carry_OUT => be_no_block_1to2
--      );

    BE_Block_Or_Inst1: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => protected_read_hit_n,
        A         => pop_pending_write,
        Carry_OUT => be_no_block_1to2_part
      );
      
    search_count_i  <= std_logic_vector(to_unsigned(search_count,  Log2(C_MAX_OUTSTANDING_WRITE)));
    pending_write_i <= std_logic_vector(to_unsigned(pending_write, Log2(C_MAX_OUTSTANDING_WRITE)));
    
    Pos_Inst: comparator
      generic map(
        C_TARGET          => C_TARGET,
        C_SIZE            => Log2(C_MAX_OUTSTANDING_WRITE)
      )
      port map(
        Carry_IN          => be_no_block_1to2_part,
        DI                => '0',
        A_Vec             => search_count_i,
        B_Vec             => pending_write_i,
        Carry_OUT         => be_no_block_1to2
      );
    
    be_all_checked    <= '1' when ( search_count > pending_write ) else '0';
    
    BE_Block_Or_Inst2: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => be_no_block_1to2,
        A         => be_all_checked,
        Carry_OUT => be_no_block_1to3
      );
    
    be_pop_last       <= '1' when ( (pending_write_is_1 = '1') and (pop_pending_write = '1') ) else '0';
    
    BE_Block_Or_Inst3: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => be_no_block_1to3,
        A         => be_pop_last,
        Carry_OUT => be_no_block_1to4
      );
    
    be_no_write       <= '1' when ( pending_write = 0 ) else '0';
    
    BE_Block_Or_Inst4: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => be_no_block_1to4,
        A         => be_no_write,
        Carry_OUT => no_write_blocking_read
      );
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      BACKEND_DEBUG(244 downto 230) <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
      constant C_MY_ADDR    : natural := min_of(256-230, C_ADDR_TAG_CONTENTS_HI - C_ADDR_TAG_CONTENTS_LO + 1);
      constant C_MY_BADDR   : natural := min_of(6, Log2(C_MAX_OUTSTANDING_WRITE));
      
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            BACKEND_DEBUG(244                   downto 230) <= (others=>'0');
          else
            -- Default assignment.
            BACKEND_DEBUG(244                   downto 230) <= (others=>'0');
            
            BACKEND_DEBUG(230 + C_MY_BADDR  - 1 downto 230) <= buffer_addr(C_MY_BADDR- 1 downto 0);
            BACKEND_DEBUG(236 + C_MY_BADDR  - 1 downto 236) <= std_logic_vector(to_unsigned(search_count, C_MY_BADDR));
            BACKEND_DEBUG(                             242) <= protected_read_hit_n;
            BACKEND_DEBUG(                             243) <= read_possible_for_pending;
            BACKEND_DEBUG(                             244) <= ar_valid;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Order_Optimization_4;

  
  -----------------------------------------------------------------------------
  -- Write Snoop Scanning
  -- 
  -----------------------------------------------------------------------------
  
  Use_Mst_Coherent: if (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  
    type WR_EXTRACT_TYPE              is (Idle, Search, Extract);
    
    constant C_EXT_WORDS              : integer:= 2 ** (C_ADDR_EXT_WORD_HI - C_ADDR_EXT_WORD_LO + 1);
    
    signal ac_pop_or_reset            : std_logic;
    signal ac_exist                   : std_logic;
    signal ac_buffer_addr             : std_logic_vector(Log2(C_MAX_OUTSTANDING_WRITE) - 1 downto 0);
    signal ac_search_count            : OUTSTANDING_WRITE_TYPE;
    signal snoop_possible_for_pending : std_logic;
    
    signal protected_write_addr       : ADDR_REQ_TYPE;
    signal protected_stall_snoop      : std_logic;
    signal protected_cancelled        : std_logic;
    signal protected_non_secure       : std_logic;
    signal protected_snoop_hit_n      : std_logic;
    signal no_write_blocking_snoop    : std_logic;
    
    signal queued_write               : OUTSTANDING_WRITE_TYPE;
    signal push_queued_write          : std_logic;
    signal pop_queued_write           : std_logic;
    signal refresh_queued_write       : std_logic;
    
    signal possible_to_extract        : std_logic;
    signal last_to_extract            : std_logic;
    signal search_queue_empty         : std_logic;
    signal more_data_available        : std_logic;
    signal any_data_available         : std_logic;
    signal end_of_data_queue          : std_logic;
    signal w_push_d1                  : std_logic;
    signal extract_done               : std_logic;
    signal extract_hold               : std_logic;
    signal want_to_extract            : std_logic;
    signal num_to_discard             : OUTSTANDING_WRITE_TYPE;
    signal snoop_extract_state        : WR_EXTRACT_TYPE;
    signal extract_cnt                : natural range 0 to C_EXT_WORDS - 1;
    signal extract_base_addr          : DATA_QUEUE_ADDR_TYPE;
    signal extract_current_addr       : DATA_QUEUE_ADDR_TYPE;
    signal extract_idx                : ADDR_EXT_WORD_TYPE;
    signal w_extracted_cmb            : DATA_QUEUE_TYPE;

  begin
    -- Track ACE write types.
    Type_Track : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          be_writeunique_inflight <= '0';
          be_writeback_inflight   <= '0';
          
        else
          if( push_pending_write = '1' ) then
            be_writeback_inflight   <= not ( b2s( write_req_info.Snoop = C_AWSNOOP_WriteUnique     ) or 
                                             b2s( write_req_info.Snoop = C_AWSNOOP_WriteLineUnique ) );
            
          elsif( s2b(pending_write_is_1 and pop_pending_write) ) then
            be_writeback_inflight   <= '0';
            
          end if;
          
          if( push_pending_write = '1' ) then
            be_writeunique_inflight <=     ( b2s( write_req_info.Snoop = C_AWSNOOP_WriteUnique     ) or 
                                             b2s( write_req_info.Snoop = C_AWSNOOP_WriteLineUnique ) );
            
          elsif( s2b(pending_write_is_1 and pop_pending_write) ) then
            be_writeunique_inflight <= '0';
            
          end if;
          
        end if;
      end if;
    end process Type_Track;
    
    -- Create control signals.
    push_queued_write     <= push_pending_write;
    pop_queued_write      <= aw_pop;
    refresh_queued_write  <= push_queued_write xor pop_queued_write;
    
    -- Up/Down counter for queued transactions.
    Queue_Write_Cnt : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          queued_write           <= 0;
        elsif( refresh_queued_write = '1' ) then
          -- Handle Read Write ordering.
          if( push_queued_write = '1' ) then
            -- New write request.
            queued_write           <= queued_write + 1;
          else
            -- Write completed.
            -- pragma translate_off
            if (queued_write > 0) then
            -- pragma translate_on
            queued_write           <= queued_write - 1;
            -- pragma translate_off
            end if;
            -- pragma translate_on
          end if;
          
        end if;
      end if;
    end process Queue_Write_Cnt;
  
    -- Local reset when pipeline moves or regular reset.
    ac_pop_or_reset <= ARESET_I or mst_snoop_check_piperun;
    
    -- Enable search.
    ac_exist        <= mst_snoop_check_info.Valid;
    
    -- Handle search for address.
    Track_Read_Search: process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ac_pop_or_reset = '1' ) then    -- synchronous reset (active true)
          -- Buffer pointer is reset when a read is completed (on AR).
          ac_buffer_addr  <= (others=>'0');
          ac_search_count <= 1;
          
        elsif( ( ( ( ac_exist = '1' ) and ( protected_snoop_hit_n = '1' ) and ( ac_search_count <= pending_write ) ) or
                 ( ( ac_exist = '1' ) and ( push_pending_write    = '1' ) ) ) and 
               ( ac_search_count < C_MAX_OUTSTANDING_WRITE ) ) then
          -- Buffer pointer is increased while there is no match in the buffer. When
          -- the last entry has been reach with no collision the read can commence 
          -- externally.
          ac_buffer_addr  <= std_logic_vector(unsigned(ac_buffer_addr) + 1);
          ac_search_count <= ac_search_count + 1;
          
        end if;
      end if;
    end process Track_Read_Search;
    
    -- Get currently searched entry.
    protected_write_addr  <= hist_fifo_mem(to_integer(unsigned(ac_buffer_addr))).Addr(C_ADDR_REQ_POS); 
    protected_stall_snoop <= hist_fifo_mem(to_integer(unsigned(ac_buffer_addr))).Stall_Snoop; 
    protected_non_secure  <= hist_fifo_mem(to_integer(unsigned(ac_buffer_addr))).Non_Secure; 
    protected_cancelled   <= hist_fifo_mem(to_integer(unsigned(ac_buffer_addr))).Cancelled; 
    
    -- If it is a complete line match and the write transaction is of "stallable" kind 
    -- detect a hit (active low).
    protected_snoop_hit_n       <= not protected_stall_snoop 
                                                    when ( mst_snoop_check_info.Addr(C_ADDR_TAG_CONTENTS_POS) = 
                                                                protected_write_addr(C_ADDR_TAG_CONTENTS_POS) ) and
                                                         ( ( mst_snoop_check_info.Prot(C_PROT_SECURE_POS)   = 
                                                             protected_non_secure                           ) or 
                                                           ( C_ENABLE_NON_SECURE = 0                        ) ) and
                                                         ( extract_hold = '0'                                 ) and
                                                         ( protected_cancelled = '0'                          ) else 
                                   '1';
    
    -- End of the write queue has been reached. If there is no collision the
    -- snoop can continue.
    snoop_possible_for_pending  <= '1' when ( ac_search_count = pending_write ) else '0';
    
    -- Check when it is safe to continue with snoop.
    -- 1) All active write is safe.
    -- 2) Oldest and current element removed from queue (doesn't matter if it is collision).
    -- 3) Entire queue has been checked (includes no queue at all).
    -- 4) Last write acknowledged (for this port) regardless if it is conflict.
    -- 5) No pending write.
    no_write_blocking_snoop     <= '1' when
                                   ( (protected_snoop_hit_n = '1') and snoop_possible_for_pending = '1' ) or 
                                   ( (pop_pending_write = '1') and snoop_possible_for_pending = '1' ) or
                                   ( ac_search_count > pending_write ) or 
                                   ( (pending_write  = 1) and (pop_pending_write = '1') ) or 
                                   ( pending_write = 0 )
                                   else '0';
    
    -- Detect if data is wanted by the interface.
    want_to_extract             <= (     mst_snoop_check_info.Get or mst_snoop_check_info.Clean ) and
                                   ( not mst_snoop_check_info.Kill );
    
    -- Must extract WriteBack from queue in order to avoid CCI dead-lock.
    -- Entry only exist in queue until it has been committed to the interface, i.e. match and 
    -- flowing on last last entry mean this is already data for the interface.
    snoop_must_freeze_wr        <= ac_exist and want_to_extract and not protected_snoop_hit_n and 
                                   possible_to_extract and not data_flowing and 
                                   b2s(C_ENABLE_WB_EXTRACT > 0);
    
    -- Check if this is the last that is not yet visible on the bus.
    possible_to_extract         <= b2s( ac_search_count <= queued_write );
    last_to_extract             <= b2s( ac_search_count  = queued_write );
    
    --- Detect empty search point.
    search_queue_empty          <= b2s(extract_base_addr = ( C_DATA_QUEUE_LENGTH_BITS - 1 downto 0 => '1' ));
    
    -- More data available for search.
    more_data_available         <= b2s( to_integer(unsigned(extract_base_addr)) >  0 ) and not search_queue_empty;
    any_data_available          <= b2s( to_integer(unsigned(extract_base_addr)) >= 0 ) and not search_queue_empty;
    
    -- Track extraction of WriteBack data.
    Extract_Track : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          snoop_extract_state       <= Idle;
          extract_cnt               <= 0;
          num_to_discard            <= 0;
          end_of_data_queue         <= '0';
          w_push_d1                 <= '0';
          extract_hold              <= '0';
          extract_base_addr         <= (others=>'0');
          extract_idx               <= (others=>'0');
          
        else
          w_push_d1 <= w_push;
          
          if( s2b(mst_snoop_check_piperun) ) then
            extract_hold              <= '0';
            
          elsif( s2b(extract_done) ) then
            extract_hold              <= '1';
            
          end if;
          
          case snoop_extract_state is
            when Idle    =>
              -- Preparation for extract.
              extract_cnt               <= 0;
              num_to_discard            <= ( queued_write - ac_search_count ) mod ( C_MAX_OUTSTANDING_WRITE + 1 );
              extract_idx               <= std_logic_vector(unsigned(mst_snoop_check_info.Addr(C_ADDR_EXT_WORD_POS)) - 
                                                            unsigned     (protected_write_addr(C_ADDR_EXT_WORD_POS)));
              end_of_data_queue         <= '0';
              
              -- If possible determine how to start extracting data.
              if( s2b(snoop_must_freeze_wr) ) then
                if( s2b(last_to_extract and not data_flowing) ) then
                  -- Oldest transaction (and no lingering data) => no need to search.
                  snoop_extract_state       <= Extract;
                  if( s2b(w_push) ) then
                    -- Adjust counter
                    extract_base_addr         <= std_logic_vector(unsigned(w_read_fifo_addr) + 1);
                  else
                    -- Copy counter
                    extract_base_addr         <= w_read_fifo_addr;
                  end if;
                  
                else
                  -- Must search for start of transaction
                  snoop_extract_state       <= Search;
                  if( s2b(w_push) ) then
                    -- Adjust counter
                    extract_base_addr         <= std_logic_vector(unsigned(w_read_fifo_addr) + 1);
                  else
                    -- Copy counter
                    extract_base_addr         <= w_read_fifo_addr;
                    if( w_read_fifo_addr = ( C_DATA_QUEUE_LENGTH_BITS - 1 downto 0 => '1' ) ) then
                      end_of_data_queue         <= '1';
                    end if;
                  end if;
                end if;
              end if;
            when Search  =>
              if( s2b(any_data_available and not end_of_data_queue and not w_push) ) then
                -- Unless new data arrives has the base be reduced one in order to continue search.
                extract_base_addr         <= std_logic_vector(unsigned(extract_base_addr) - 1);
                
              end if;
              
              -- Detect end of queue.
              if( s2b(not more_data_available) and s2b(not w_push)) then
                end_of_data_queue         <= '1';
              end if;
              
              -- Check if there is data available to scan.
              if( s2b(end_of_data_queue and w_push_d1) or s2b(any_data_available and not end_of_data_queue) ) then
                if( s2b(write_data_ordered_info_i.Last) and ( num_to_discard = 1 ) ) then
                  -- Found, lets begin to extract.
                  snoop_extract_state       <= Extract;
                  
                  if( s2b(not w_push) and s2b(not end_of_data_queue) ) then
                    -- Unless new data arrives the base has to be decreased in order to follow 
                    -- the first beat in transaction.
                    extract_base_addr         <= std_logic_vector(unsigned(extract_base_addr) - 1);
                    
                  elsif( s2b(w_push) and s2b(end_of_data_queue) ) then
                    extract_base_addr         <= std_logic_vector(unsigned(extract_base_addr) + 1);
                  
                  end if;
                elsif( s2b(write_data_ordered_info_i.Last) ) then
                  -- Not found continue to next transaction.
                  num_to_discard            <= ( num_to_discard - 1 ) mod ( C_MAX_OUTSTANDING_WRITE + 1 );
                  
                end if;
              end if;
                
            when Extract =>
              if( s2b(w_push) ) then
                -- New write data => Adjust baser counter.
                extract_base_addr         <= std_logic_vector(unsigned(extract_base_addr) + 1);
              end if;
              
              if( to_integer(unsigned(extract_base_addr)) >= ( C_EXT_WORDS - 1 ) ) then
                -- Use one data => Adjust index offset.
                if( s2b(mst_core_be_data_ready) ) then
                  extract_cnt               <= ( extract_cnt + 1 ) mod C_EXT_WORDS;
                  extract_idx               <= std_logic_vector(unsigned(extract_idx) + 1);
                end if;
                
                if( s2b(mst_core_be_data_ready and last_snoop_to_extract) ) then
                  snoop_extract_state       <= Idle;
                end if;
              end if;
          end case;
        end if;
      end if;
    end process Extract_Track;
    
    -- Detect end.
    extract_done  <= allow_snoop_data and mst_core_be_data_ready and last_snoop_to_extract;
    
    -- Patch extract information.
    Gen_Extract: process(w_extracted, extract_current_addr, mst_core_be_data_ready)
    begin
      w_extracted_cmb                                             <= w_extracted;
      if( s2b(mst_core_be_data_ready) ) then
        w_extracted_cmb(to_integer(unsigned(extract_current_addr))) <= '1';
      end if;
      
    end process Gen_Extract;
    
    -- Handle memory for W Channel FIFO.
    FIFO_W_Extract_Memory : process (ACLK) is
    begin  -- process FIFO_W_Extract_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if (ARESET_I = '1') then             -- synchronous reset (active true)
          w_extracted                            <= (others=>'0');
          
        elsif ( w_push = '1') then
          -- Insert new item.
          w_extracted(0)                          <= '0';
          
          -- Shift FIFO contents.
          w_extracted(w_extracted'left downto 1)  <= w_extracted_cmb(w_extracted'left-1 downto 0);
          
        elsif( s2b(mst_core_be_data_ready) ) then
          w_extracted                             <= w_extracted_cmb;
          
        end if;
      end if;
    end process FIFO_W_Extract_Memory;
    
    last_snoop_to_extract <= b2s(extract_cnt = ( C_EXT_WORDS - 1 ));
  
    -- Determine when it is allowed to snoop the data unhindered, i.e. when the line is complete. 
    allow_snoop_data      <= b2s(     snoop_extract_state = Extract ) and 
                                ( not search_queue_empty            ) and 
                             b2s(     to_integer(unsigned(extract_base_addr)) >= ( C_EXT_WORDS - 1 ) );
    
    -- Create wrap adjusted address for extraction.
    extract_current_addr  <= std_logic_vector(unsigned(extract_base_addr) - unsigned(extract_idx));
    
    -- Select current write data read address.
    w_read_addr           <= (others=>'0')          when ( snoop_extract_state = Search  ) and s2b(end_of_data_queue) else 
                             extract_base_addr      when ( snoop_extract_state = Search  )                            else 
                             extract_current_addr   when ( snoop_extract_state = Extract )                            else 
                             w_read_fifo_addr;
    
    Gen_Haz: process(ac_exist, no_write_blocking_snoop, snoop_extract_state, extract_hold)
    begin
      mst_cross_order_hazard            <= C_NULL_MST_SNOOP_HAZ;
      
      mst_cross_order_hazard.Hazard     <= ac_exist and not no_write_blocking_snoop;
      mst_cross_order_hazard.Extracted  <= b2s( snoop_extract_state = Extract ) or
                                           extract_hold;
    end process Gen_Haz;
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      BACKEND_DEBUG(BACKEND_DEBUG'left    downto 251) <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
      constant C_MY_BADDR   : natural := 6;
      constant C_MY_DADDR   : natural := 8;
      constant C_MY_ADDR    : natural := 38;
    begin
      Debug_Handle : process (ACLK) is 
        variable protected_write_addr_adj  : AXI_ADDR_TYPE;
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            BACKEND_DEBUG(BACKEND_DEBUG'left    downto 251) <= (others=>'0');
          else
            -- Align bits to proper position.
            protected_write_addr_adj                        := (others => '0');
            protected_write_addr_adj(C_ADDR_REQ_POS)        := protected_write_addr(C_ADDR_REQ_POS);
            
            -- Default assignment.
            BACKEND_DEBUG(BACKEND_DEBUG'left    downto 251) <= (others=>'0');
            
            BACKEND_DEBUG(                             251) <= ac_pop_or_reset;
            BACKEND_DEBUG(                             252) <= ac_exist;
            BACKEND_DEBUG(                             253) <= protected_stall_snoop;
            BACKEND_DEBUG(                             254) <= protected_non_secure;
            BACKEND_DEBUG(                             255) <= protected_snoop_hit_n;
            
            BACKEND_DEBUG(256 + C_MY_BADDR  - 1 downto 256) <= fit_vec(ac_buffer_addr, C_MY_BADDR);
            BACKEND_DEBUG(262 + C_MY_ADDR   - 1 downto 262) <= fit_vec(protected_write_addr_adj, C_MY_ADDR);
            
            BACKEND_DEBUG(                             300) <= snoop_possible_for_pending;
            BACKEND_DEBUG(                             301) <= no_write_blocking_snoop;
            
            BACKEND_DEBUG(                             302) <= possible_to_extract;
            BACKEND_DEBUG(                             303) <= last_to_extract;
            BACKEND_DEBUG(                             304) <= more_data_available;
            BACKEND_DEBUG(                             305) <= any_data_available;
            BACKEND_DEBUG(                             306) <= end_of_data_queue;
            BACKEND_DEBUG(                             307) <= w_push_d1;
            BACKEND_DEBUG(                             308) <= allow_snoop_data;
            BACKEND_DEBUG(                             309) <= mst_core_be_data_ready;
            BACKEND_DEBUG(                             310) <= write_data_ordered_info_i.Last;
            BACKEND_DEBUG(                             311) <= snoop_must_freeze_wr;
            
            BACKEND_DEBUG(313                   downto 312) <= std_logic_vector(to_unsigned(WR_EXTRACT_TYPE'pos(snoop_extract_state), 2));
            BACKEND_DEBUG(315                   downto 314) <= std_logic_vector(to_unsigned(extract_cnt, 2));
            BACKEND_DEBUG(317                   downto 316) <= fit_vec(extract_idx, 2);
            BACKEND_DEBUG(318 + C_MY_DADDR  - 1 downto 318) <= fit_vec(extract_base_addr, C_MY_DADDR);
            BACKEND_DEBUG(326 + C_MY_DADDR  - 1 downto 326) <= fit_vec(extract_current_addr, C_MY_DADDR);
            BACKEND_DEBUG(338                   downto 334) <= std_logic_vector(to_unsigned(num_to_discard, 5));
            BACKEND_DEBUG(                             339) <= extract_done;
            BACKEND_DEBUG(                             340) <= extract_hold;
            BACKEND_DEBUG(                             341) <= want_to_extract;
            BACKEND_DEBUG(359                   downto 342) <= fit_vec(w_extracted, 18);
            -- queued_write
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Use_Mst_Coherent;
  
  No_Mst_Coherent: if ( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    mst_cross_order_hazard  <= C_NULL_MST_SNOOP_HAZ;
    
    be_writeunique_inflight <= '0';
    be_writeback_inflight   <= '0';
    
    w_read_addr             <= w_read_fifo_addr;
    allow_snoop_data        <= '0';
    last_snoop_to_extract   <= '0';
    w_extracted             <= (others=>'0');
  
    BACKEND_DEBUG(BACKEND_DEBUG'left downto 251) <= (others=>'0');
  end generate No_Mst_Coherent;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_be_ar_search_depth   <= C_NULL_STAT_POINT;
    stat_be_ar_stall          <= C_NULL_STAT_POINT;
    stat_be_ar_protect_stall  <= C_NULL_STAT_POINT;
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    
    signal new_access                 : std_logic;
    signal stat_search_depth          : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal stat_stall_cnt             : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal stat_stall                 : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal stat_prot_cnt              : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal stat_prot                  : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    
  begin
  
    Stat_Handle : process (ACLK) is
    begin  -- process Stat_Handle
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if stat_reset = '1' then                  -- synchronous reset (active high)
          new_access        <= '0';
          stat_search_depth <= (others=>'0');
          stat_stall_cnt    <= (others=>'0');
          stat_stall        <= (others=>'0');
          stat_prot_cnt     <= (others=>'0');
          stat_prot         <= (others=>'0');
          
        else
          new_access    <= '0';
          
          if( ar_exist = '1' ) then
            stat_stall_cnt  <= std_logic_vector(unsigned(stat_stall_cnt) + 1);
          end if;
          if( ( ar_exist and not protected_read_hit_n ) = '1' ) then
            stat_prot_cnt   <= std_logic_vector(unsigned(stat_prot_cnt) + 1);
          end if;
          if( ar_pop = '1' ) then
            new_access        <= '1';
            stat_search_depth <= std_logic_vector(to_unsigned(search_count, C_STAT_COUNTER_BITS));
            stat_stall        <= stat_stall_cnt;
            stat_prot         <= stat_prot_cnt;
            stat_stall_cnt    <= (others=>'0');
            stat_prot_cnt     <= (others=>'0');
            
          end if;
        end if;
      end if;
    end process Stat_Handle;
    
    Depth_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_access,
        counter                   => stat_search_depth,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_be_ar_search_depth
      );
      
    Stall_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_access,
        counter                   => stat_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_be_ar_stall
      );
      
    Protect_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_access,
        counter                   => stat_prot,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_be_ar_protect_stall
      );
      
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    BACKEND_DEBUG(229 downto   0) <= (others=>'0');
  end generate No_Debug;
  
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_WLEN    : natural := min_of( 8, C_DATA_QUEUE_LENGTH_BITS);
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          BACKEND_DEBUG(229 downto   0) <= (others=>'0');
        else
          -- Default assignment.
          BACKEND_DEBUG(229 downto   0) <= (others=>'0');
          
          -- Read Address: 1+4+8+3+1+1+1 = 19 + 32
          BACKEND_DEBUG(             0) <= read_req_info.Valid;
          BACKEND_DEBUG(  4 downto   1) <= fit_vec(read_req_info.Port_Num, 4);
          BACKEND_DEBUG( 36 downto   5) <= fit_vec(read_req_info.Addr, 32);
          BACKEND_DEBUG( 44 downto  37) <= read_req_info.Len;
          BACKEND_DEBUG( 47 downto  45) <= read_req_info.Size;
          BACKEND_DEBUG(            48) <= read_req_info.Exclusive;
          BACKEND_DEBUG(            49) <= read_req_info.kind;
          BACKEND_DEBUG(            50) <= read_req_ready_i;
          
          -- Write Address: 1+4+1+8+3+1+1+1 = 20 + 32
          BACKEND_DEBUG(            51) <= write_req_info.Valid;
          BACKEND_DEBUG( 55 downto  52) <= fit_vec(write_req_info.Port_Num, 4);
          BACKEND_DEBUG(            56) <= write_req_info.Internal;
          BACKEND_DEBUG( 88 downto  57) <= fit_vec(write_req_info.Addr, 32);
          BACKEND_DEBUG( 96 downto  89) <= write_req_info.Len;
          BACKEND_DEBUG( 99 downto  97) <= write_req_info.Size;
          BACKEND_DEBUG(           100) <= write_req_info.Exclusive;
          BACKEND_DEBUG(           101) <= write_req_info.Kind;
          BACKEND_DEBUG(           102) <= write_req_ready_i;
          
          -- Write Data: 1+1+1+1+1 = 5 + 4 + 32
          BACKEND_DEBUG(           103) <= write_data_info.Valid;
          BACKEND_DEBUG(           104) <= write_data_info.Last;
          BACKEND_DEBUG(108 downto 105) <= fit_vec(write_data_info.BE, 4);
          BACKEND_DEBUG(140 downto 109) <= fit_vec(write_data_info.Data, 32);
          BACKEND_DEBUG(           141) <= write_data_ready_i;
          BACKEND_DEBUG(           142) <= w_fifo_almost_full;
          BACKEND_DEBUG(           143) <= w_fifo_full;
          
          -- Write response: 1+4+1+2+1 = 9
          BACKEND_DEBUG(           144) <= mst_if_wr_resp_info.Valid;
--          BACKEND_DEBUG(148 downto 145) <= mst_if_wr_resp_conf.Port_Num(3 downto 0);
--          BACKEND_DEBUG(           149) <= mst_if_wr_resp_conf.Internal;
          BACKEND_DEBUG(151 downto 150) <= mst_if_wr_resp_info.BRESP;
          BACKEND_DEBUG(           152) <= mst_if_wr_resp_ready;
        
          -- Read Response: 1+1+2+1 = 5 + 32
          BACKEND_DEBUG(           153) <= mst_if_rd_data_info.Valid;
          BACKEND_DEBUG(           154) <= mst_if_rd_data_info.Last;
          BACKEND_DEBUG(186 downto 155) <= fit_vec(mst_if_rd_data_info.Data, 32);
          BACKEND_DEBUG(188 downto 187) <= mst_if_rd_data_info.RRESP(1 downto 0);
          BACKEND_DEBUG(           189) <= mst_if_rd_data_ready;
        
          -- Pending write and reorder: 5+1+1+1+1+1 = 10
          BACKEND_DEBUG(194 downto 190) <= std_logic_vector(to_unsigned(pending_write, Log2(C_MAX_OUTSTANDING_WRITE)));
          BACKEND_DEBUG(           195) <= push_pending_write;
          BACKEND_DEBUG(           196) <= pop_pending_write;
          BACKEND_DEBUG(           197) <= refresh_pending_write;
          BACKEND_DEBUG(           198) <= need_to_stall_write;
          BACKEND_DEBUG(           199) <= no_write_blocking_read;
          
          -- AW FIFO: 1+5+1 = 7
          BACKEND_DEBUG(           200) <= aw_pop;
          BACKEND_DEBUG(204 downto 201) <= fit_vec(aw_read_fifo_addr, 4);
          BACKEND_DEBUG(           205) <= aw_fifo_empty;
        
          -- W FIFO: 1+1+8+1 = 11
          BACKEND_DEBUG(           206) <= w_push;
          BACKEND_DEBUG(           207) <= w_pop;
          BACKEND_DEBUG(215 downto 208) <= fit_vec(w_read_fifo_addr, 8);
          BACKEND_DEBUG(           216) <= w_fifo_empty;
          
          -- AR FIFO: 1+1+5+1 = 8
          BACKEND_DEBUG(           217) <= ar_push;
          BACKEND_DEBUG(           218) <= ar_pop;
          BACKEND_DEBUG(222 downto 219) <= fit_vec(ar_read_fifo_addr, 4);
          BACKEND_DEBUG(           223) <= ar_fifo_empty;
          
          -- Placement of Reorder Check: 1+1+4 = 6
          BACKEND_DEBUG(           224) <= allow_read_req_ready;
          BACKEND_DEBUG(           225) <= allow_ar_valid;
          BACKEND_DEBUG(229 downto 226) <= std_logic_vector(to_unsigned(check_port, C_MAX_NUM_PORT_WIDTH - 1));
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_AW_QUEUE_ERROR)   <= aw_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_W_QUEUE_ERROR)    <= w_assert  when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_AR_QUEUE_ERROR)   <= ar_assert when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_AW_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of AW Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_W_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of W Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_AR_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of AR Queue , read from empty or push to full."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_crossbar.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_crossbar.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_crossbar.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-06-21    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_crossbar is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
    C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
    C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
    C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
    C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
    C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
    C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
    C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
    C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    read_req_info             : in  READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_req_ready            : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_req_info            : in  WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_req_ready           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_data_info           : in  DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_data_ready          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_almost_full    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_full           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Ordered signals.
    
    read_req_ordered_info     : out READ_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    read_req_ordered_ready    : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    write_req_ordered_info    : out WRITE_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    write_req_ordered_ready   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    write_data_ordered_info   : out DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    write_data_ordered_ready  : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Status signals (to Lookup).
    
    be_writeunique_inflight   : out std_logic;
    be_writeback_inflight     : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Monitor Backend signals (to Update).
    
    mst_if_wr_resp_info       : in  WRITE_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_if_wr_resp_ready      : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    mst_if_rd_data_info       : in  READ_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_if_rd_data_ready      : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Monitor Backend signals (to Update).
    
    backend_wr_resp_info      : out WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_wr_resp_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    backend_rd_data_info      : out READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_rd_data_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Backend signals.
    
    mst_snoop_mem_piperun     : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_snoop_mem_info        : in  MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_snoop_check_piperun   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_snoop_check_info      : in  MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_cross_order_hazard    : out MST_SNOOP_HAZ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    
    mst_core_be_data_info     : out MST_SNOOP_DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    mst_core_be_data_ready    : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_be_aw                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
    stat_be_w                 : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
    stat_be_ar                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
    stat_be_ar_search_depth   : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
    stat_be_ar_stall          : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
    stat_be_ar_protect_stall  : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    BACKEND_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0)
  );
end entity sc_crossbar;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


architecture IMP of sc_crossbar is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_M0_QUEUE_ERROR            : natural :=  0;
  constant C_ASSERT_M1_QUEUE_ERROR            : natural :=  1;
  constant C_ASSERT_M2_QUEUE_ERROR            : natural :=  2;
  constant C_ASSERT_M3_QUEUE_ERROR            : natural :=  3;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  4;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Queue depth constants.
  constant C_CB_QUEUE_LENGTH            : natural := 16;
  constant C_MST_QUEUE_LENGTH           : natural := 16;
  constant C_CB_QUEUE_LENGTH_BITS       : natural := Log2(C_CB_QUEUE_LENGTH);
  constant C_MST_QUEUE_LENGTH_BITS      : natural := Log2(C_MST_QUEUE_LENGTH);
  
  -- Queue address types.
  subtype CB_QUEUE_ADDR_POS             is natural range C_CB_QUEUE_LENGTH  - 1 downto 0;
  subtype MST_QUEUE_ADDR_POS            is natural range C_MST_QUEUE_LENGTH - 1 downto 0;
  subtype CB_QUEUE_ADDR_TYPE            is std_logic_vector(C_CB_QUEUE_LENGTH_BITS  - 1 downto 0);
  subtype MST_QUEUE_ADDR_TYPE           is std_logic_vector(C_MST_QUEUE_LENGTH_BITS - 1 downto 0);
  
  -- Selector sizes.
  subtype CB_NUM_POS                    is natural range C_CACHE_BLOCKS     - 1 downto 0;
  subtype MST_PORT_NUM_POS              is natural range C_NUM_MASTER_PORTS - 1 downto 0;
  subtype CB_NUM_TYPE                   is std_logic_vector(CB_NUM_POS);
  subtype MST_PORT_NUM_TYPE             is std_logic_vector(MST_PORT_NUM_POS);
  
  -- Select types.
  type BLOCK_ORDER_TYPE is record
    Valid             : std_logic;
    Num               : CB_NUM_POS;
  end record BLOCK_ORDER_TYPE;
  
  type MASTER_ORDER_TYPE is record
    Valid             : std_logic;
    Num               : MST_PORT_NUM_POS;
  end record MASTER_ORDER_TYPE;
  
  -- FIFO types.
  type CB_FIFO_MEM_TYPE                 is array(CB_QUEUE_ADDR_POS)      of BLOCK_ORDER_TYPE;
  type MST_FIFO_MEM_TYPE                is array(MST_QUEUE_ADDR_POS)     of MASTER_ORDER_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_transaction_ordering is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
      C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
      C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
      C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
      C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
      C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
      C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
      C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
      C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      read_req_info             : in  READ_REQ_TYPE;
      read_req_ready            : out std_logic;
      
      write_req_info            : in  WRITE_REQ_TYPE;
      write_req_ready           : out std_logic;
      
      write_data_info           : in  DATA_PORT_TYPE;
      write_data_ready          : out std_logic;
      write_data_almost_full    : out std_logic;
      write_data_full           : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Ordered signals.
      
      read_req_ordered_info     : out READ_REQ_TYPE;
      read_req_ordered_ready    : in  std_logic;
      
      write_req_ordered_info    : out WRITE_REQ_TYPE;
      write_req_ordered_ready   : in  std_logic;
      
      write_data_ordered_info   : out DATA_PORT_TYPE;
      write_data_ordered_ready  : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   : out std_logic;
      be_writeback_inflight     : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Monitor Backend signals (to Update).
      
      mst_if_wr_resp_info       : in  WRITE_RESP_TYPE;
      mst_if_wr_resp_ready      : in  std_logic;
      
      mst_if_rd_data_info       : in  READ_RESP_TYPE;
      mst_if_rd_data_ready      : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      mst_snoop_mem_piperun     : in  std_logic;
      mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
      mst_snoop_check_piperun   : in  std_logic;
      mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
      mst_cross_order_hazard    : out MST_SNOOP_HAZ_TYPE;
      
      mst_core_be_data_info     : out MST_SNOOP_DATA_TYPE;
      mst_core_be_data_ready    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_be_aw                : out STAT_FIFO_TYPE;     -- Write Address
      stat_be_w                 : out STAT_FIFO_TYPE;     -- Write Data
      stat_be_ar                : out STAT_FIFO_TYPE;     -- Read Address
      stat_be_ar_search_depth   : out STAT_POINT_TYPE;    -- Average search depth
      stat_be_ar_stall          : out STAT_POINT_TYPE;    -- Average total stall
      stat_be_ar_protect_stall  : out STAT_POINT_TYPE;    -- Average protected stall
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      BACKEND_DEBUG             : out MAX_DEBUG_TYPE
    );
  end component sc_transaction_ordering;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  
  
  -- ----------------------------------------
  -- Selected signals.
  
  signal read_req_selected_info     : READ_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal read_req_selected_ready    : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal write_req_selected_info    : WRITE_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal write_req_selected_ready   : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal write_data_selected_info   : DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal write_data_selected_ready  : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal write_data_selected_almost_full  : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal write_data_selected_full         : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  signal mst_if_wr_resp_ready_i     : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_if_rd_data_ready_i     : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal be_writeunique_inflight_i  : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal be_writeback_inflight_i    : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
  -- ----------------------------------------
  -- Assertion signals.
  
  signal m_assert                   : std_logic_vector(4 - 1 downto 0);
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Need_Reset: if( ( C_NUM_MASTER_PORTS > 1 ) or ( C_CACHE_BLOCKS > 1 ) ) generate
    attribute dont_touch              : string;
    attribute dont_touch              of Reset_Inst     : label is "true";
  begin
    Reset_Inst: bit_reg_ce
      generic map(
        C_TARGET  => C_TARGET,
        C_IS_SET  => '0',
        C_CE_LOW  => (0 downto 0=>'0'),
        C_NUM_CE  => 1
      )
      port map(
        CLK       => ACLK,
        SR        => '0',
        CE        => "1",
        D         => ARESET,
        Q         => ARESET_I
      );
    
  end generate Need_Reset;
  
  
  -----------------------------------------------------------------------------
  -- Read Request Handling
  -----------------------------------------------------------------------------
-- TODO: Add mux and demux between Block and Master.
  
  Gen_Rd_Block: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    read_req_selected_info(I) <= read_req_info(I);
  end generate Gen_Rd_Block;
  read_req_ready            <= read_req_selected_ready;
  
  
  -----------------------------------------------------------------------------
  -- Write Request Handling
  -----------------------------------------------------------------------------
-- TODO: Add mux and demux between Block and Master.
  
  Gen_Wr_Block: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    write_req_selected_info(I)  <= write_req_info(I);
  end generate Gen_Wr_Block;
  write_req_ready             <= write_req_selected_ready;
  
  
  -----------------------------------------------------------------------------
  -- Write Data Handling
  -----------------------------------------------------------------------------
-- TODO: Add mux and demux between Block and Master.
  
  Gen_WrData_Block: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    write_data_selected_info(I) <= write_data_info(I);
  end generate Gen_WrData_Block;
  write_data_ready            <= write_data_selected_ready;
  write_data_almost_full      <= write_data_selected_almost_full;
  write_data_full             <= write_data_selected_full;
  
  
  -----------------------------------------------------------------------------
  -- Read Response Handling
  -----------------------------------------------------------------------------
-- TODO: Add mux and demux between Block and Master.
  
  -- Rename signal.
  Gen_RdResp_Block: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    backend_rd_data_info(I) <= mst_if_rd_data_info(I);
  end generate Gen_RdResp_Block;
  mst_if_rd_data_ready_i  <= backend_rd_data_ready;
  mst_if_rd_data_ready    <= mst_if_rd_data_ready_i;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Handling
  -----------------------------------------------------------------------------
-- TODO: Add mux and demux between Block and Master.
  
  -- Rename signal.  
  Gen_WrResp_Block: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    backend_wr_resp_info(I) <= mst_if_wr_resp_info(I);
  end generate Gen_WrResp_Block;
  mst_if_wr_resp_ready_i  <= backend_wr_resp_ready;
  mst_if_wr_resp_ready    <= mst_if_wr_resp_ready_i;
  
  
  -----------------------------------------------------------------------------
  -- Cache Blocks Mapping Order
  -----------------------------------------------------------------------------
  
  Gen_Blocks: for J in 0 to C_CACHE_BLOCKS - 1 generate
  begin
    Single_Master: if( C_NUM_MASTER_PORTS = 1 ) generate
    begin
      
    end generate Single_Master;
    
    Multi_Master: if( C_NUM_MASTER_PORTS > 1 ) generate
    begin
    end generate Multi_Master;
    
  end generate Gen_Blocks;
  
  
  -----------------------------------------------------------------------------
  -- Master ports
  -----------------------------------------------------------------------------
  
  Gen_Master_Ports: for I in 0 to C_NUM_MASTER_PORTS - 1 generate
  begin
    Single_Block: if( C_CACHE_BLOCKS = 1 ) generate
    begin
      
    end generate Single_Block;
    
    Multi_Blocks: if( C_CACHE_BLOCKS > 1 ) generate
    
      signal cb_push  : std_logic;
      signal cb_pop   : std_logic;
      signal cb_num   : natural range 0 to C_CACHE_BLOCKS - 1;
      
    begin
    end generate Multi_Blocks;
    
    TransOrd: sc_transaction_ordering
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_NUM_PORTS               => C_NUM_PORTS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_OPTIMIZE_ORDER          => C_OPTIMIZE_ORDER,
        C_ORDER_PER_PORT          => C_ORDER_PER_PORT,
        C_NUM_ORDER_BINS          => C_NUM_ORDER_BINS,
        C_ORDER_BINS_ADDR_MASK    => C_ORDER_BINS_ADDR_MASK,
        C_ENABLE_SLV_WR_THROTTLE  => C_ENABLE_SLV_WR_THROTTLE,
        C_ENABLE_WB_EXTRACT       => C_ENABLE_WB_EXTRACT,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        C_ADDR_REQ_HI             => C_ADDR_REQ_HI,
        C_ADDR_REQ_LO             => C_ADDR_REQ_LO,
        C_ADDR_TAG_CONTENTS_HI    => C_ADDR_TAG_CONTENTS_HI,
        C_ADDR_TAG_CONTENTS_LO    => C_ADDR_TAG_CONTENTS_LO,
        C_ADDR_LINE_HI            => C_ADDR_LINE_HI,
        C_ADDR_LINE_LO            => C_ADDR_LINE_LO,
        C_ADDR_EXT_WORD_HI        => C_ADDR_EXT_WORD_HI,
        C_ADDR_EXT_WORD_LO        => C_ADDR_EXT_WORD_LO,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_HI,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_LO
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Update signals.
        
        read_req_info             => read_req_selected_info(I),
        read_req_ready            => read_req_selected_ready(I),
        
        write_req_info            => write_req_selected_info(I),
        write_req_ready           => write_req_selected_ready(I),
        
        write_data_info           => write_data_selected_info(I),
        write_data_ready          => write_data_selected_ready(I),
        write_data_almost_full    => write_data_selected_almost_full(I),
        write_data_full           => write_data_selected_full(I),
        
        
        -- ---------------------------------------------------
        -- Ordered signals.
        
        read_req_ordered_info     => read_req_ordered_info(I),
        read_req_ordered_ready    => read_req_ordered_ready(I),
        
        write_req_ordered_info    => write_req_ordered_info(I),
        write_req_ordered_ready   => write_req_ordered_ready(I),
        
        write_data_ordered_info   => write_data_ordered_info(I),
        write_data_ordered_ready  => write_data_ordered_ready(I),
        
        
        -- ---------------------------------------------------
        -- Status signals (to Lookup).
        
        be_writeunique_inflight   => be_writeunique_inflight_i(I),
        be_writeback_inflight     => be_writeback_inflight_i(I),
        
        
        -- ---------------------------------------------------
        -- Monitor Backend signals (to Update).
        
        mst_if_wr_resp_info       => mst_if_wr_resp_info(I),
        mst_if_wr_resp_ready      => mst_if_wr_resp_ready_i(I),
        
        mst_if_rd_data_info       => mst_if_rd_data_info(I),
        mst_if_rd_data_ready      => mst_if_rd_data_ready_i(I),
        
        
        -- ---------------------------------------------------
        -- Backend signals.
        
        mst_snoop_mem_piperun     => mst_snoop_mem_piperun(I),
        mst_snoop_mem_info        => mst_snoop_mem_info(I),
        mst_snoop_check_piperun   => mst_snoop_check_piperun(I),
        mst_snoop_check_info      => mst_snoop_check_info(I),
        mst_cross_order_hazard    => mst_cross_order_hazard(I),
        
        mst_core_be_data_info     => mst_core_be_data_info(I),
        mst_core_be_data_ready    => mst_core_be_data_ready(I),
    
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_aw                => stat_be_aw(I),
        stat_be_w                 => stat_be_w(I),
        stat_be_ar                => stat_be_ar(I),
        stat_be_ar_search_depth   => stat_be_ar_search_depth(I),
        stat_be_ar_stall          => stat_be_ar_stall(I),
        stat_be_ar_protect_stall  => stat_be_ar_protect_stall(I),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => m_assert(I),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        BACKEND_DEBUG             => BACKEND_DEBUG(I)
      );
    
  end generate Gen_Master_Ports;
  
  No_Master_Ports: for I in C_NUM_MASTER_PORTS to 4 - 1 generate
  begin
    m_assert(I) <= '0';
    
  end generate No_Master_Ports;
  
  -- Combine all master ACE signals (only one supported at the moment).
  be_writeunique_inflight <= reduce_or(be_writeunique_inflight_i);
  be_writeback_inflight   <= reduce_or(be_writeback_inflight_i);
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_M0_QUEUE_ERROR)   <= m_assert(0) when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_M1_QUEUE_ERROR)   <= m_assert(1) when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_M2_QUEUE_ERROR)   <= m_assert(2) when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_M3_QUEUE_ERROR)   <= m_assert(3) when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_M0_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of any M0 Queue."
        severity error;
    
    assert assert_err_1(C_ASSERT_M1_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of any M0 Queue."
        severity error;
    
    assert assert_err_1(C_ASSERT_M2_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of any M0 Queue."
        severity error;
    
    assert assert_err_1(C_ASSERT_M3_QUEUE_ERROR) /= '1' 
      report "Backend: Erroneous handling of any M0 Queue."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_back_end.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_back_end.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_back_end.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_back_end is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
    C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
    C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
    C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
    C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
    C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
    C_NUM_WAYS                : natural range  1 to    8      :=  2;
    C_SNOOP_KEEP_READ_SHARED  : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_READ_CLEAN   : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_READ_NSD     : natural range  0 to    1      :=  0;
    C_SNOOP_KEEP_CLEAN_SHARED : natural range  0 to    1      :=  0;
    
    -- Data type and settings specific.
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
    C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
    C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
    C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
    C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    
    -- AXI4/ACE Master Interface #0 specific.
    C_M0_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #1 specific.
    C_M1_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #2 specific.
    C_M2_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #3 specific.
    C_M3_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    read_req_info             : in  READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_req_ready            : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_req_info            : in  WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_req_ready           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_data_info           : in  DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_data_ready          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_almost_full    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_full           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Sync Request.
    
    ctrl_dvm_req              : in  INTERNAL_DVM_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_dvm_done             : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_backend_done         : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_bar_req              : in  INTERNAL_BAR_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_bar_done             : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_insert_running       : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Status signals (to Lookup).
    
    be_writeunique_inflight   : out std_logic;
    be_writeback_inflight     : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Backend signals (to Update).
    
    backend_wr_resp_info      : out WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_wr_resp_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    backend_wr_resp_conf      : in  WRITE_CONF_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    backend_rd_data_info      : out READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_rd_data_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Master Snoop Interface Signals.
    
    mst_snoop_fetch_piperun   : out std_logic;
    mst_snoop_fetch_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_piperun     : out std_logic;
    mst_snoop_mem_info        : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_piperun   : out std_logic;
    mst_snoop_check_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_fetch_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_ack_info    : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_update_ack_info : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_fetch_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_mem_hazard       : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_check_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_hazard    : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_mem_rm_alloc    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_rm_alloc  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_tag_valid       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_way         : out rinteger range C_NUM_WAYS - 1 downto 0;
    mst_snoop_tag_info        : out WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_stall       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_sdr_push        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_info        : out MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_empty       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_full        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_update_data_info : in  MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_data_ready: out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- AXI4/ACE Master Interface #0 signals.
    
    M0_AXI_AWID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_AWADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
    M0_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M0_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M0_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M0_AXI_AWLOCK             : out std_logic;
    M0_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M0_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M0_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M0_AXI_AWVALID            : out std_logic;
    M0_AXI_AWREADY            : in  std_logic;
    M0_AXI_AWDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
    M0_AXI_AWSNOOP            : out std_logic_vector(2 downto 0);                      -- For ACE
    M0_AXI_AWBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M0_AXI_WDATA              : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
    M0_AXI_WSTRB              : out std_logic_vector((C_M0_AXI_DATA_WIDTH/8)-1 downto 0);
    M0_AXI_WLAST              : out std_logic;
    M0_AXI_WVALID             : out std_logic;
    M0_AXI_WREADY             : in  std_logic;
    
    M0_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M0_AXI_BID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_BVALID             : in  std_logic;
    M0_AXI_BREADY             : out std_logic;
    M0_AXI_WACK               : out std_logic;                                         -- For ACE
    
    M0_AXI_ARID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_ARADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
    M0_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M0_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M0_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M0_AXI_ARLOCK             : out std_logic;
    M0_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M0_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M0_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M0_AXI_ARVALID            : out std_logic;
    M0_AXI_ARREADY            : in  std_logic;
    M0_AXI_ARDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
    M0_AXI_ARSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    M0_AXI_ARBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M0_AXI_RID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_RDATA              : in  std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
    M0_AXI_RRESP              : in  std_logic_vector(C_M0_AXI_RRESP_WIDTH-1 downto 0);
    M0_AXI_RLAST              : in  std_logic;
    M0_AXI_RVALID             : in  std_logic;
    M0_AXI_RREADY             : out std_logic;
    M0_AXI_RACK               : out std_logic;                                         -- For ACE
    
    M0_AXI_ACVALID            : in  std_logic;                                         -- For ACE
    M0_AXI_ACADDR             : in  std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    M0_AXI_ACSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    M0_AXI_ACPROT             : in  std_logic_vector(2 downto 0);                      -- For ACE
    M0_AXI_ACREADY            : out std_logic;                                         -- For ACE
    
    M0_AXI_CRVALID            : out std_logic;                                         -- For ACE
    M0_AXI_CRRESP             : out std_logic_vector(4 downto 0);                      -- For ACE
    M0_AXI_CRREADY            : in  std_logic;                                         -- For ACE
    
    M0_AXI_CDVALID            : out std_logic;                                         -- For ACE
    M0_AXI_CDDATA             : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    M0_AXI_CDLAST             : out std_logic;                                         -- For ACE
    M0_AXI_CDREADY            : in  std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- AXI4 Master Interface #1 signals.
    
    M1_AXI_AWID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_AWADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
    M1_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M1_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M1_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M1_AXI_AWLOCK             : out std_logic;
    M1_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M1_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M1_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M1_AXI_AWVALID            : out std_logic;
    M1_AXI_AWREADY            : in  std_logic;
    
    M1_AXI_WDATA              : out std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
    M1_AXI_WSTRB              : out std_logic_vector((C_M1_AXI_DATA_WIDTH/8)-1 downto 0);
    M1_AXI_WLAST              : out std_logic;
    M1_AXI_WVALID             : out std_logic;
    M1_AXI_WREADY             : in  std_logic;
    
    M1_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M1_AXI_BID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_BVALID             : in  std_logic;
    M1_AXI_BREADY             : out std_logic;
    
    M1_AXI_ARID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_ARADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
    M1_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M1_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M1_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M1_AXI_ARLOCK             : out std_logic;
    M1_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M1_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M1_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M1_AXI_ARVALID            : out std_logic;
    M1_AXI_ARREADY            : in  std_logic;
    
    M1_AXI_RID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_RDATA              : in  std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
    M1_AXI_RRESP              : in  std_logic_vector(C_M1_AXI_RRESP_WIDTH-1 downto 0);
    M1_AXI_RLAST              : in  std_logic;
    M1_AXI_RVALID             : in  std_logic;
    M1_AXI_RREADY             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Master Interface #2 signals.
    
    M2_AXI_AWID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_AWADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
    M2_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M2_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M2_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M2_AXI_AWLOCK             : out std_logic;
    M2_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M2_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M2_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M2_AXI_AWVALID            : out std_logic;
    M2_AXI_AWREADY            : in  std_logic;
    
    M2_AXI_WDATA              : out std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
    M2_AXI_WSTRB              : out std_logic_vector((C_M2_AXI_DATA_WIDTH/8)-1 downto 0);
    M2_AXI_WLAST              : out std_logic;
    M2_AXI_WVALID             : out std_logic;
    M2_AXI_WREADY             : in  std_logic;
    
    M2_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M2_AXI_BID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_BVALID             : in  std_logic;
    M2_AXI_BREADY             : out std_logic;
    
    M2_AXI_ARID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_ARADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
    M2_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M2_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M2_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M2_AXI_ARLOCK             : out std_logic;
    M2_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M2_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M2_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M2_AXI_ARVALID            : out std_logic;
    M2_AXI_ARREADY            : in  std_logic;
    
    M2_AXI_RID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_RDATA              : in  std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
    M2_AXI_RRESP              : in  std_logic_vector(C_M2_AXI_RRESP_WIDTH-1 downto 0);
    M2_AXI_RLAST              : in  std_logic;
    M2_AXI_RVALID             : in  std_logic;
    M2_AXI_RREADY             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Master Interface #3 signals.
    
    M3_AXI_AWID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_AWADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
    M3_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M3_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M3_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M3_AXI_AWLOCK             : out std_logic;
    M3_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M3_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M3_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M3_AXI_AWVALID            : out std_logic;
    M3_AXI_AWREADY            : in  std_logic;
    
    M3_AXI_WDATA              : out std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
    M3_AXI_WSTRB              : out std_logic_vector((C_M3_AXI_DATA_WIDTH/8)-1 downto 0);
    M3_AXI_WLAST              : out std_logic;
    M3_AXI_WVALID             : out std_logic;
    M3_AXI_WREADY             : in  std_logic;
    
    M3_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M3_AXI_BID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_BVALID             : in  std_logic;
    M3_AXI_BREADY             : out std_logic;
    
    M3_AXI_ARID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_ARADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
    M3_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M3_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M3_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M3_AXI_ARLOCK             : out std_logic;
    M3_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M3_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M3_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M3_AXI_ARVALID            : out std_logic;
    M3_AXI_ARREADY            : in  std_logic;
    
    M3_AXI_RID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_RDATA              : in  std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
    M3_AXI_RRESP              : in  std_logic_vector(C_M3_AXI_RRESP_WIDTH-1 downto 0);
    M3_AXI_RLAST              : in  std_logic;
    M3_AXI_RVALID             : in  std_logic;
    M3_AXI_RREADY             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_be_aw                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
    stat_be_w                 : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
    stat_be_ar                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
    stat_be_ar_search_depth   : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
    stat_be_ar_stall          : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
    stat_be_ar_protect_stall  : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
    stat_be_rd_latency        : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Read Latency
    stat_be_wr_latency        : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Write Latency
    stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
    stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    BACKEND_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    M_IF_DEBUG                : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0)
  );
end entity sc_back_end;

library IEEE;
use IEEE.numeric_std.all;

architecture IMP of sc_back_end is

  
  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_CROSS_ERROR               : natural :=  0;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  1;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_crossbar is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
      C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
      C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
      C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
      C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
      C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
      C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
      C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
      C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      read_req_info             : in  READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_req_ready            : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_req_info            : in  WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_req_ready           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_data_info           : in  DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_data_ready          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_almost_full    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_full           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Ordered signals.
      
      read_req_ordered_info     : out READ_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      read_req_ordered_ready    : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      write_req_ordered_info    : out WRITE_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      write_req_ordered_ready   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      write_data_ordered_info   : out DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      write_data_ordered_ready  : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   : out std_logic;
      be_writeback_inflight     : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Monitor Backend signals (to Update).
      
      mst_if_wr_resp_info       : in  WRITE_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_if_wr_resp_ready      : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      mst_if_rd_data_info       : in  READ_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_if_rd_data_ready      : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Monitor Backend signals (to Update).
      
      backend_wr_resp_info      : out WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_wr_resp_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      backend_rd_data_info      : out READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_rd_data_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      mst_snoop_mem_piperun     : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_snoop_mem_info        : in  MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_snoop_check_piperun   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_snoop_check_info      : in  MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_cross_order_hazard    : out MST_SNOOP_HAZ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      
      mst_core_be_data_info     : out MST_SNOOP_DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      mst_core_be_data_ready    : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_be_aw                : out STAT_FIFO_VECTOR_TYPE;     -- Write Address
      stat_be_w                 : out STAT_FIFO_VECTOR_TYPE;     -- Write Data
      stat_be_ar                : out STAT_FIFO_VECTOR_TYPE;     -- Read Address
      stat_be_ar_search_depth   : out STAT_POINT_VECTOR_TYPE;    -- Average search depth
      stat_be_ar_stall          : out STAT_POINT_VECTOR_TYPE;    -- Average total stall
      stat_be_ar_protect_stall  : out STAT_POINT_VECTOR_TYPE;    -- Average protected stall
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      BACKEND_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0)
    );
  end component sc_crossbar;

  component sc_m_axi_interface is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      
      -- AXI4 Master Interface specific.
      C_M_AXI_THREAD_ID_WIDTH   : natural range  1 to   32      := 1;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Out).
      
      write_req_ordered_info    : in  WRITE_REQ_TYPE;
      write_req_ordered_ready   : out std_logic;
      
      write_data_ordered_info   : in  DATA_PORT_TYPE;
      write_data_ordered_ready  : out std_logic;
      
      read_req_ordered_info     : in  READ_REQ_TYPE;
      read_req_ordered_ready    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (In).
      
      mst_if_wr_resp_info      : out WRITE_RESP_TYPE;
      mst_if_wr_resp_ready     : in  std_logic;
      
      mst_if_rd_data_info      : out READ_RESP_TYPE;
      mst_if_rd_data_ready     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface Signals.
      
      M_AXI_AWID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_AWADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_AWLEN               : out std_logic_vector(7 downto 0);
      M_AXI_AWSIZE              : out std_logic_vector(2 downto 0);
      M_AXI_AWBURST             : out std_logic_vector(1 downto 0);
      M_AXI_AWLOCK              : out std_logic;
      M_AXI_AWCACHE             : out std_logic_vector(3 downto 0);
      M_AXI_AWPROT              : out std_logic_vector(2 downto 0);
      M_AXI_AWQOS               : out std_logic_vector(3 downto 0);
      M_AXI_AWVALID             : out std_logic;
      M_AXI_AWREADY             : in  std_logic;
      
      M_AXI_WDATA               : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_WSTRB               : out std_logic_vector((C_M_AXI_DATA_WIDTH/8)-1 downto 0);
      M_AXI_WLAST               : out std_logic;
      M_AXI_WVALID              : out std_logic;
      M_AXI_WREADY              : in  std_logic;
      
      M_AXI_BRESP               : in  std_logic_vector(1 downto 0);
      M_AXI_BID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_BVALID              : in  std_logic;
      M_AXI_BREADY              : out std_logic;
      
      M_AXI_ARID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_ARADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_ARLEN               : out std_logic_vector(7 downto 0);
      M_AXI_ARSIZE              : out std_logic_vector(2 downto 0);
      M_AXI_ARBURST             : out std_logic_vector(1 downto 0);
      M_AXI_ARLOCK              : out std_logic;
      M_AXI_ARCACHE             : out std_logic_vector(3 downto 0);
      M_AXI_ARPROT              : out std_logic_vector(2 downto 0);
      M_AXI_ARQOS               : out std_logic_vector(3 downto 0);
      M_AXI_ARVALID             : out std_logic;
      M_AXI_ARREADY             : in  std_logic;
      
      M_AXI_RID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_RDATA               : in  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_RRESP               : in  std_logic_vector(1 downto 0);
      M_AXI_RLAST               : in  std_logic;
      M_AXI_RVALID              : in  std_logic;
      M_AXI_RREADY              : out std_logic;
    
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_be_rd_latency        : out STAT_POINT_TYPE;    -- External Read Latency
      stat_be_wr_latency        : out STAT_POINT_TYPE;    -- External Write Latency
      stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      M_IF_DEBUG                : out MAX_DEBUG_TYPE
    );
  end component sc_m_axi_interface;
  
  component sc_m_ace_interface is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_NUM_WAYS                : natural range  1 to    8      :=  2;
      C_SNOOP_KEEP_READ_SHARED  : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_READ_CLEAN   : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_READ_NSD     : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_CLEAN_SHARED : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      
      -- AXI4 Master Interface specific.
      C_M_AXI_THREAD_ID_WIDTH   : natural range  1 to   32      := 1;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Out).
      
      write_req_ordered_info    : in  WRITE_REQ_TYPE;
      write_req_ordered_ready   : out std_logic;
      
      write_data_ordered_info   : in  DATA_PORT_TYPE;
      write_data_ordered_ready  : out std_logic;
      
      read_req_ordered_info     : in  READ_REQ_TYPE;
      read_req_ordered_ready    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Sync Request.
      
      ctrl_dvm_req              : in  INTERNAL_DVM_TYPE;
      ctrl_dvm_done             : out std_logic;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_backend_done         : out std_logic;
      ctrl_bar_req              : in  INTERNAL_BAR_TYPE;
      ctrl_bar_done             : out std_logic;
      ctrl_insert_running       : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (In).
      
      mst_if_wr_resp_info       : out WRITE_RESP_TYPE;
      mst_if_wr_resp_ready      : in  std_logic;
      
      mst_if_rd_data_info       : out READ_RESP_TYPE;
      mst_if_rd_data_ready      : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   : out std_logic;
      mst_snoop_fetch_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_piperun     : out std_logic;
      mst_snoop_mem_info        : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_piperun   : out std_logic;
      mst_snoop_check_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_fetch_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_ack_info    : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_update_ack_info : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_fetch_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_mem_hazard       : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_check_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_hazard    : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_cross_order_hazard    : in  MST_SNOOP_HAZ_TYPE;
      
      mst_snoop_mem_rm_alloc    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_rm_alloc  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_tag_valid       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_way         : out natural range C_NUM_WAYS - 1 downto 0;
      mst_snoop_tag_info        : out WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_stall       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_sdr_push        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_info        : out MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_empty       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_full        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_update_data_info : in  MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_data_ready: out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_be_data_info     : in  MST_SNOOP_DATA_TYPE;
      mst_core_be_data_ready    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Master Interface Signals.
      
      M_AXI_AWID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_AWADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_AWLEN               : out std_logic_vector(7 downto 0);
      M_AXI_AWSIZE              : out std_logic_vector(2 downto 0);
      M_AXI_AWBURST             : out std_logic_vector(1 downto 0);
      M_AXI_AWLOCK              : out std_logic;
      M_AXI_AWCACHE             : out std_logic_vector(3 downto 0);
      M_AXI_AWPROT              : out std_logic_vector(2 downto 0);
      M_AXI_AWQOS               : out std_logic_vector(3 downto 0);
      M_AXI_AWVALID             : out std_logic;
      M_AXI_AWREADY             : in  std_logic;
      M_AXI_AWDOMAIN            : out std_logic_vector(1 downto 0);                      -- For ACE
      M_AXI_AWSNOOP             : out std_logic_vector(2 downto 0);                      -- For ACE
      M_AXI_AWBAR               : out std_logic_vector(1 downto 0);                      -- For ACE
      
      M_AXI_WDATA               : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_WSTRB               : out std_logic_vector((C_M_AXI_DATA_WIDTH/8)-1 downto 0);
      M_AXI_WLAST               : out std_logic;
      M_AXI_WVALID              : out std_logic;
      M_AXI_WREADY              : in  std_logic;
      
      M_AXI_BRESP               : in  std_logic_vector(1 downto 0);
      M_AXI_BID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_BVALID              : in  std_logic;
      M_AXI_BREADY              : out std_logic;
      M_AXI_WACK                : out std_logic;                                         -- For ACE
      
      M_AXI_ARID                : out std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_ARADDR              : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
      M_AXI_ARLEN               : out std_logic_vector(7 downto 0);
      M_AXI_ARSIZE              : out std_logic_vector(2 downto 0);
      M_AXI_ARBURST             : out std_logic_vector(1 downto 0);
      M_AXI_ARLOCK              : out std_logic;
      M_AXI_ARCACHE             : out std_logic_vector(3 downto 0);
      M_AXI_ARPROT              : out std_logic_vector(2 downto 0);
      M_AXI_ARQOS               : out std_logic_vector(3 downto 0);
      M_AXI_ARVALID             : out std_logic;
      M_AXI_ARREADY             : in  std_logic;
      M_AXI_ARDOMAIN            : out std_logic_vector(1 downto 0);                      -- For ACE
      M_AXI_ARSNOOP             : out std_logic_vector(3 downto 0);                      -- For ACE
      M_AXI_ARBAR               : out std_logic_vector(1 downto 0);                      -- For ACE
      
      M_AXI_RID                 : in  std_logic_vector(C_M_AXI_THREAD_ID_WIDTH-1 downto 0);
      M_AXI_RDATA               : in  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
      M_AXI_RRESP               : in  std_logic_vector(4-1 downto 0);
      M_AXI_RLAST               : in  std_logic;
      M_AXI_RVALID              : in  std_logic;
      M_AXI_RREADY              : out std_logic;
      M_AXI_RACK                : out std_logic;                                         -- For ACE
      
      M_AXI_ACVALID             : in  std_logic;                                         -- For ACE
      M_AXI_ACADDR              : in  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);   -- For ACE
      M_AXI_ACSNOOP             : in  std_logic_vector(3 downto 0);                      -- For ACE
      M_AXI_ACPROT              : in  std_logic_vector(2 downto 0);                      -- For ACE
      M_AXI_ACREADY             : out std_logic;                                         -- For ACE
      
      M_AXI_CRVALID             : out std_logic;                                         -- For ACE
      M_AXI_CRRESP              : out std_logic_vector(4 downto 0);                      -- For ACE
      M_AXI_CRREADY             : in  std_logic;                                         -- For ACE
      
      M_AXI_CDVALID             : out std_logic;                                         -- For ACE
      M_AXI_CDDATA              : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);   -- For ACE
      M_AXI_CDLAST              : out std_logic;                                         -- For ACE
      M_AXI_CDREADY             : in  std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_be_rd_latency        : out STAT_POINT_TYPE;    -- External Read Latency
      stat_be_wr_latency        : out STAT_POINT_TYPE;    -- External Write Latency
      stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      M_IF_DEBUG                : out MAX_DEBUG_TYPE
    );
  end component sc_m_ace_interface;

  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Internal Interface Signals (Out).
      
  signal write_req_ordered_info     : WRITE_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal write_req_ordered_ready    : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal write_data_ordered_info    : DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal write_data_ordered_ready   : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal read_req_ordered_info      : READ_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal read_req_ordered_ready     : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal mst_snoop_mem_piperun_i    : std_logic;
  signal mst_snoop_mem_info_i       : MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_check_piperun_i  : std_logic;
  signal mst_snoop_check_info_i     : MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  signal mst_snoop_mem_piperun_prt  : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_snoop_mem_info_prt     : MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_snoop_check_piperun_prt: std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_snoop_check_info_prt   : MST_SNOOP_REQ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_cross_order_hazard     : MST_SNOOP_HAZ_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal mst_core_be_data_info      : MST_SNOOP_DATA_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_core_be_data_ready     : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
  
  -- ----------------------------------------
  -- Internal Interface Signals (In).
  
  signal mst_if_wr_resp_info        : WRITE_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_if_wr_resp_ready       : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  signal mst_if_rd_data_info        : READ_RESP_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal mst_if_rd_data_ready       : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
  -- ----------------------------------------
  -- Assertion signals.
  
  signal cross_assert               : std_logic;
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- Master ACE Interface #0
  -----------------------------------------------------------------------------
  
  CB: sc_crossbar
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- IP Specific.
      C_NUM_PORTS               => C_NUM_PORTS,
      C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
      C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
      C_NUM_MASTER_PORTS        => C_NUM_MASTER_PORTS,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_OPTIMIZE_ORDER          => C_OPTIMIZE_ORDER,
      C_ORDER_PER_PORT          => C_ORDER_PER_PORT,
      C_NUM_ORDER_BINS          => C_NUM_ORDER_BINS,
      C_ORDER_BINS_ADDR_MASK    => C_ORDER_BINS_ADDR_MASK,
      C_ENABLE_SLV_WR_THROTTLE  => C_ENABLE_SLV_WR_THROTTLE,
      C_ENABLE_WB_EXTRACT       => C_ENABLE_WB_EXTRACT,
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
      C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
      C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
      C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
      C_ADDR_REQ_HI             => C_ADDR_REQ_HI,
      C_ADDR_REQ_LO             => C_ADDR_REQ_LO,
      C_ADDR_TAG_CONTENTS_HI    => C_ADDR_TAG_CONTENTS_HI,
      C_ADDR_TAG_CONTENTS_LO    => C_ADDR_TAG_CONTENTS_LO,
      C_ADDR_LINE_HI            => C_ADDR_LINE_HI,
      C_ADDR_LINE_LO            => C_ADDR_LINE_LO,
      C_ADDR_EXT_WORD_HI        => C_ADDR_EXT_WORD_HI,
      C_ADDR_EXT_WORD_LO        => C_ADDR_EXT_WORD_LO,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_HI,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_LO
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      read_req_info             => read_req_info,
      read_req_ready            => read_req_ready,
      
      write_req_info            => write_req_info,
      write_req_ready           => write_req_ready,
      
      write_data_info           => write_data_info,
      write_data_ready          => write_data_ready,
      write_data_almost_full    => write_data_almost_full,
      write_data_full           => write_data_full,
      
      
      -- ---------------------------------------------------
      -- Ordered signals.
      
      read_req_ordered_info     => read_req_ordered_info,
      read_req_ordered_ready    => read_req_ordered_ready,
      
      write_req_ordered_info    => write_req_ordered_info,
      write_req_ordered_ready   => write_req_ordered_ready,
      
      write_data_ordered_info   => write_data_ordered_info,
      write_data_ordered_ready  => write_data_ordered_ready,
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   => be_writeunique_inflight,
      be_writeback_inflight     => be_writeback_inflight,
      
      
      -- ---------------------------------------------------
      -- Monitor Backend signals (to Update).
      
      mst_if_wr_resp_info       => mst_if_wr_resp_info,
      mst_if_wr_resp_ready      => mst_if_wr_resp_ready,
      
      mst_if_rd_data_info       => mst_if_rd_data_info,
      mst_if_rd_data_ready      => mst_if_rd_data_ready,
      
      
      -- ---------------------------------------------------
      -- Monitor Backend signals (to Update).
      
      backend_wr_resp_info      => backend_wr_resp_info,
      backend_wr_resp_ready     => backend_wr_resp_ready,
      
      backend_rd_data_info      => backend_rd_data_info,
      backend_rd_data_ready     => backend_rd_data_ready,
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      mst_snoop_mem_piperun     => mst_snoop_mem_piperun_prt,
      mst_snoop_mem_info        => mst_snoop_mem_info_prt,
      mst_snoop_check_piperun   => mst_snoop_check_piperun_prt,
      mst_snoop_check_info      => mst_snoop_check_info_prt,
      mst_cross_order_hazard    => mst_cross_order_hazard,
      
      mst_core_be_data_info     => mst_core_be_data_info,
      mst_core_be_data_ready    => mst_core_be_data_ready,
    
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_be_aw                => stat_be_aw,
      stat_be_w                 => stat_be_w,
      stat_be_ar                => stat_be_ar,
      stat_be_ar_search_depth   => stat_be_ar_search_depth,
      stat_be_ar_stall          => stat_be_ar_stall,
      stat_be_ar_protect_stall  => stat_be_ar_protect_stall,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => cross_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      BACKEND_DEBUG             => BACKEND_DEBUG
    );
  
  
  -----------------------------------------------------------------------------
  -- Master ACE Interface #0
  -----------------------------------------------------------------------------
  
  Use_ACE_Port_0: if ( ( C_NUM_MASTER_PORTS > 0 ) and     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    M_ACE_INST: sc_m_ace_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_ENABLE_WB_EXTRACT       => C_ENABLE_WB_EXTRACT,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_SNOOP_KEEP_READ_SHARED  => C_SNOOP_KEEP_READ_SHARED,
        C_SNOOP_KEEP_READ_CLEAN   => C_SNOOP_KEEP_READ_CLEAN,
        C_SNOOP_KEEP_READ_NSD     => C_SNOOP_KEEP_READ_NSD,
        C_SNOOP_KEEP_CLEAN_SHARED => C_SNOOP_KEEP_CLEAN_SHARED,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_HI,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_LO,
        
        -- AXI4 Master Interface specific.
        C_M_AXI_THREAD_ID_WIDTH   => C_M0_AXI_THREAD_ID_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M0_AXI_DATA_WIDTH,
        C_M_AXI_ADDR_WIDTH        => C_M0_AXI_ADDR_WIDTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Out).
        
        write_req_ordered_info    => write_req_ordered_info(0),
        write_req_ordered_ready   => write_req_ordered_ready(0),
        
        write_data_ordered_info   => write_data_ordered_info(0),
        write_data_ordered_ready  => write_data_ordered_ready(0),
        
        read_req_ordered_info     => read_req_ordered_info(0),
        read_req_ordered_ready    => read_req_ordered_ready(0),
        
        
        -- ---------------------------------------------------
        -- ACE Downstream Sync Request.
        
        ctrl_dvm_req              => ctrl_dvm_req(0),
        ctrl_dvm_done             => ctrl_dvm_done(0),
        
        
        -- ---------------------------------------------------
        -- ACE Downstream Barrier Request.
        
        ctrl_backend_done         => ctrl_backend_done(0),
        ctrl_bar_req              => ctrl_bar_req(0),
        ctrl_bar_done             => ctrl_bar_done(0),
        ctrl_insert_running       => ctrl_insert_running(0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (In).
        
        mst_if_wr_resp_info      => mst_if_wr_resp_info(0),
        mst_if_wr_resp_ready     => mst_if_wr_resp_ready(0),
        
        mst_if_rd_data_info      => mst_if_rd_data_info(0),
        mst_if_rd_data_ready     => mst_if_rd_data_ready(0),
        
        
        -- ---------------------------------------------------
        -- Master Snoop Interface Signals.
        
        mst_snoop_fetch_piperun   => mst_snoop_fetch_piperun,
        mst_snoop_fetch_info      => mst_snoop_fetch_info,
        mst_snoop_mem_piperun     => mst_snoop_mem_piperun_i,
        mst_snoop_mem_info        => mst_snoop_mem_info_i,
        mst_snoop_check_piperun   => mst_snoop_check_piperun_i,
        mst_snoop_check_info      => mst_snoop_check_info_i,
        
        mst_snoop_fetch_ack_info  => mst_snoop_fetch_ack_info,
        mst_snoop_mem_ack_info    => mst_snoop_mem_ack_info,
        mst_snoop_check_ack_info  => mst_snoop_check_ack_info,
        mst_snoop_update_ack_info => mst_snoop_update_ack_info,
        
        mst_core_fetch_hazard     => mst_core_fetch_hazard,
        mst_core_mem_hazard       => mst_core_mem_hazard,
        mst_core_check_hazard     => mst_core_check_hazard,
        mst_core_update_hazard    => mst_core_update_hazard,
        mst_cross_order_hazard    => mst_cross_order_hazard(0),
        
        mst_snoop_mem_rm_alloc    => mst_snoop_mem_rm_alloc,
        mst_snoop_check_rm_alloc  => mst_snoop_check_rm_alloc,
        
        mst_snoop_tag_valid       => mst_snoop_tag_valid,
        mst_snoop_tag_way         => mst_snoop_tag_way,
        mst_snoop_tag_info        => mst_snoop_tag_info,
        mst_snoop_tag_stall       => mst_snoop_tag_stall,
        
        mst_snoop_sdr_push        => mst_snoop_sdr_push,
        mst_snoop_sdr_info        => mst_snoop_sdr_info,
        mst_snoop_sdr_empty       => mst_snoop_sdr_empty,
        mst_snoop_sdr_full        => mst_snoop_sdr_full,
        
        mst_core_update_data_info => mst_core_update_data_info,
        mst_core_update_data_ready=> mst_core_update_data_ready,
        
        mst_core_be_data_info      => mst_core_be_data_info(0),
        mst_core_be_data_ready     => mst_core_be_data_ready(0),
        
        
        -- ---------------------------------------------------
        -- AXI4/ACE Master Interface Signals.
        
        M_AXI_AWID                => M0_AXI_AWID,
        M_AXI_AWADDR              => M0_AXI_AWADDR,
        M_AXI_AWLEN               => M0_AXI_AWLEN,
        M_AXI_AWSIZE              => M0_AXI_AWSIZE,
        M_AXI_AWBURST             => M0_AXI_AWBURST,
        M_AXI_AWLOCK              => M0_AXI_AWLOCK,
        M_AXI_AWCACHE             => M0_AXI_AWCACHE,
        M_AXI_AWPROT              => M0_AXI_AWPROT,
        M_AXI_AWQOS               => M0_AXI_AWQOS,
        M_AXI_AWVALID             => M0_AXI_AWVALID,
        M_AXI_AWREADY             => M0_AXI_AWREADY,
        M_AXI_AWDOMAIN            => M0_AXI_AWDOMAIN,   -- For ACE
        M_AXI_AWSNOOP             => M0_AXI_AWSNOOP,    -- For ACE
        M_AXI_AWBAR               => M0_AXI_AWBAR,      -- For ACE
        
        M_AXI_WDATA               => M0_AXI_WDATA,
        M_AXI_WSTRB               => M0_AXI_WSTRB,
        M_AXI_WLAST               => M0_AXI_WLAST,
        M_AXI_WVALID              => M0_AXI_WVALID,
        M_AXI_WREADY              => M0_AXI_WREADY,
        
        M_AXI_BRESP               => M0_AXI_BRESP,
        M_AXI_BID                 => M0_AXI_BID,
        M_AXI_BVALID              => M0_AXI_BVALID,
        M_AXI_BREADY              => M0_AXI_BREADY,
        M_AXI_WACK                => M0_AXI_WACK,       -- For ACE
        
        M_AXI_ARID                => M0_AXI_ARID,
        M_AXI_ARADDR              => M0_AXI_ARADDR,
        M_AXI_ARLEN               => M0_AXI_ARLEN,
        M_AXI_ARSIZE              => M0_AXI_ARSIZE,
        M_AXI_ARBURST             => M0_AXI_ARBURST,
        M_AXI_ARLOCK              => M0_AXI_ARLOCK,
        M_AXI_ARCACHE             => M0_AXI_ARCACHE,
        M_AXI_ARPROT              => M0_AXI_ARPROT,
        M_AXI_ARQOS               => M0_AXI_ARQOS,
        M_AXI_ARVALID             => M0_AXI_ARVALID,
        M_AXI_ARREADY             => M0_AXI_ARREADY,
        M_AXI_ARDOMAIN            => M0_AXI_ARDOMAIN,   -- For ACE
        M_AXI_ARSNOOP             => M0_AXI_ARSNOOP,    -- For ACE
        M_AXI_ARBAR               => M0_AXI_ARBAR,      -- For ACE
        
        M_AXI_RID                 => M0_AXI_RID,
        M_AXI_RDATA               => M0_AXI_RDATA,
        M_AXI_RRESP               => M0_AXI_RRESP,
        M_AXI_RLAST               => M0_AXI_RLAST,
        M_AXI_RVALID              => M0_AXI_RVALID,
        M_AXI_RREADY              => M0_AXI_RREADY,
        M_AXI_RACK                => M0_AXI_RACK,       -- For ACE
        
        M_AXI_ACVALID             => M0_AXI_ACVALID,    -- For ACE
        M_AXI_ACADDR              => M0_AXI_ACADDR,     -- For ACE
        M_AXI_ACSNOOP             => M0_AXI_ACSNOOP,    -- For ACE
        M_AXI_ACPROT              => M0_AXI_ACPROT,     -- For ACE
        M_AXI_ACREADY             => M0_AXI_ACREADY,    -- For ACE
        
        M_AXI_CRVALID             => M0_AXI_CRVALID,    -- For ACE
        M_AXI_CRRESP              => M0_AXI_CRRESP,     -- For ACE
        M_AXI_CRREADY             => M0_AXI_CRREADY,    -- For ACE
        
        M_AXI_CDVALID             => M0_AXI_CDVALID,    -- For ACE
        M_AXI_CDDATA              => M0_AXI_CDDATA,     -- For ACE
        M_AXI_CDLAST              => M0_AXI_CDLAST,     -- For ACE
        M_AXI_CDREADY             => M0_AXI_CDREADY,    -- For ACE
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_rd_latency        => stat_be_rd_latency(0),
        stat_be_wr_latency        => stat_be_wr_latency(0),
        stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
        stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        M_IF_DEBUG                => M_IF_DEBUG(0)
      );
  
  end generate Use_ACE_Port_0;
  
  mst_snoop_mem_piperun_prt   <= (others=>mst_snoop_mem_piperun_i);
  mst_snoop_mem_info_prt      <= (others=>mst_snoop_mem_info_i(0));
  mst_snoop_check_piperun_prt <= (others=>mst_snoop_check_piperun_i);
  mst_snoop_check_info_prt    <= (others=>mst_snoop_check_info_i(0));
  
  mst_snoop_mem_piperun       <= mst_snoop_mem_piperun_i;
  mst_snoop_mem_info          <= mst_snoop_mem_info_i;
  mst_snoop_check_piperun     <= mst_snoop_check_piperun_i;
  mst_snoop_check_info        <= mst_snoop_check_info_i;
  
  
  -----------------------------------------------------------------------------
  -- Master AXI Interface #0
  -----------------------------------------------------------------------------
  
  Use_AXI_Port_0: if ( ( C_NUM_MASTER_PORTS > 0 ) and not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    M_AXI_INST: sc_m_axi_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        
        -- AXI4 Master Interface specific.
        C_M_AXI_THREAD_ID_WIDTH   => C_M0_AXI_THREAD_ID_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M0_AXI_DATA_WIDTH,
        C_M_AXI_ADDR_WIDTH        => C_M0_AXI_ADDR_WIDTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Out).
        
        write_req_ordered_info    => write_req_ordered_info(0),
        write_req_ordered_ready   => write_req_ordered_ready(0),
        
        write_data_ordered_info   => write_data_ordered_info(0),
        write_data_ordered_ready  => write_data_ordered_ready(0),
        
        read_req_ordered_info     => read_req_ordered_info(0),
        read_req_ordered_ready    => read_req_ordered_ready(0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (In).
        
        mst_if_wr_resp_info      => mst_if_wr_resp_info(0),
        mst_if_wr_resp_ready     => mst_if_wr_resp_ready(0),
        
        mst_if_rd_data_info      => mst_if_rd_data_info(0),
        mst_if_rd_data_ready     => mst_if_rd_data_ready(0),
        
        
        -- ---------------------------------------------------
        -- AXI4 Master Interface Signals.
        
        M_AXI_AWID                => M0_AXI_AWID,
        M_AXI_AWADDR              => M0_AXI_AWADDR,
        M_AXI_AWLEN               => M0_AXI_AWLEN,
        M_AXI_AWSIZE              => M0_AXI_AWSIZE,
        M_AXI_AWBURST             => M0_AXI_AWBURST,
        M_AXI_AWLOCK              => M0_AXI_AWLOCK,
        M_AXI_AWCACHE             => M0_AXI_AWCACHE,
        M_AXI_AWPROT              => M0_AXI_AWPROT,
        M_AXI_AWQOS               => M0_AXI_AWQOS,
        M_AXI_AWVALID             => M0_AXI_AWVALID,
        M_AXI_AWREADY             => M0_AXI_AWREADY,
        
        M_AXI_WDATA               => M0_AXI_WDATA,
        M_AXI_WSTRB               => M0_AXI_WSTRB,
        M_AXI_WLAST               => M0_AXI_WLAST,
        M_AXI_WVALID              => M0_AXI_WVALID,
        M_AXI_WREADY              => M0_AXI_WREADY,
        
        M_AXI_BRESP               => M0_AXI_BRESP,
        M_AXI_BID                 => M0_AXI_BID,
        M_AXI_BVALID              => M0_AXI_BVALID,
        M_AXI_BREADY              => M0_AXI_BREADY,
        
        M_AXI_ARID                => M0_AXI_ARID,
        M_AXI_ARADDR              => M0_AXI_ARADDR,
        M_AXI_ARLEN               => M0_AXI_ARLEN,
        M_AXI_ARSIZE              => M0_AXI_ARSIZE,
        M_AXI_ARBURST             => M0_AXI_ARBURST,
        M_AXI_ARLOCK              => M0_AXI_ARLOCK,
        M_AXI_ARCACHE             => M0_AXI_ARCACHE,
        M_AXI_ARPROT              => M0_AXI_ARPROT,
        M_AXI_ARQOS               => M0_AXI_ARQOS,
        M_AXI_ARVALID             => M0_AXI_ARVALID,
        M_AXI_ARREADY             => M0_AXI_ARREADY,
        
        M_AXI_RID                 => M0_AXI_RID,
        M_AXI_RDATA               => M0_AXI_RDATA,
        M_AXI_RRESP               => M0_AXI_RRESP,
        M_AXI_RLAST               => M0_AXI_RLAST,
        M_AXI_RVALID              => M0_AXI_RVALID,
        M_AXI_RREADY              => M0_AXI_RREADY,
      
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_rd_latency        => stat_be_rd_latency(0),
        stat_be_wr_latency        => stat_be_wr_latency(0),
        stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
        stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        M_IF_DEBUG                => M_IF_DEBUG(0)
      );
    
    -- Unused with AXI.
    M0_AXI_AWDOMAIN             <= (others=>'0');   -- For ACE
    M0_AXI_AWSNOOP              <= (others=>'0');   -- For ACE
    M0_AXI_AWBAR                <= (others=>'0');   -- For ACE
    M0_AXI_WACK                 <= '0';             -- For ACE
    M0_AXI_ARDOMAIN             <= (others=>'0');   -- For ACE
    M0_AXI_ARSNOOP              <= (others=>'0');   -- For ACE
    M0_AXI_ARBAR                <= (others=>'0');   -- For ACE
    M0_AXI_RACK                 <= '0';             -- For ACE
    M0_AXI_ACREADY              <= '0';             -- For ACE
    M0_AXI_CRVALID              <= '0';             -- For ACE
    M0_AXI_CRRESP               <= (others=>'0');   -- For ACE
    M0_AXI_CDVALID              <= '0';             -- For ACE
    M0_AXI_CDDATA               <= (others=>'0');   -- For ACE
    M0_AXI_CDLAST               <= '0';             -- For ACE
    
    ctrl_dvm_done(0)            <= '1';
    ctrl_backend_done(0)        <= '1';
    ctrl_bar_done(0)            <= '1';
    ctrl_insert_running(0)      <= '0';
    
    -- Unused internal interfaces.
    mst_snoop_fetch_piperun     <= '0';
    mst_snoop_fetch_info(0)     <= C_NULL_MST_SNOOP_REQ;
    mst_snoop_mem_piperun_i     <= '0';
    mst_snoop_mem_info_i(0)     <= C_NULL_MST_SNOOP_REQ;
    mst_snoop_check_piperun_i   <= '0';
    mst_snoop_check_info_i(0)   <= C_NULL_MST_SNOOP_REQ;
    
    mst_snoop_tag_valid         <= (others=>'0');
    mst_snoop_tag_way           <= 0;
    mst_snoop_tag_info          <= (others=>C_NULL_WAY_LINE_TAG);
    
    mst_snoop_sdr_push          <= (others=>'0');
    mst_snoop_sdr_info          <= (others=>C_NULL_MST_SNOOP_ADDR);
    
    mst_core_update_data_ready  <= (others=>'0');
    
    mst_core_be_data_info(0)    <= C_NULL_MST_SNOOP_DATA;
    mst_core_be_data_ready      <= (others=>'0');
    
  end generate Use_AXI_Port_0;
  
  No_Port_0: if ( C_NUM_MASTER_PORTS < 1 ) generate
  begin
    M0_AXI_AWID     <= (others=>'0');
    M0_AXI_AWADDR   <= (others=>'0');
    M0_AXI_AWLEN    <= (others=>'0');
    M0_AXI_AWSIZE   <= (others=>'0');
    M0_AXI_AWBURST  <= (others=>'0');
    M0_AXI_AWLOCK   <= '0';
    M0_AXI_AWCACHE  <= (others=>'0');
    M0_AXI_AWPROT   <= (others=>'0');
    M0_AXI_AWQOS    <= (others=>'0');
    M0_AXI_AWVALID  <= '0';
    M0_AXI_AWDOMAIN <= (others=>'0');   -- For ACE
    M0_AXI_AWSNOOP  <= (others=>'0');   -- For ACE
    M0_AXI_AWBAR    <= (others=>'0');   -- For ACE
    M0_AXI_WDATA    <= (others=>'0');
    M0_AXI_WSTRB    <= (others=>'0');
    M0_AXI_WLAST    <= '0';
    M0_AXI_WVALID   <= '0';
    M0_AXI_BREADY   <= '0';
    M0_AXI_WACK     <= '0';             -- For ACE
    M0_AXI_ARID     <= (others=>'0');
    M0_AXI_ARADDR   <= (others=>'0');
    M0_AXI_ARLEN    <= (others=>'0');
    M0_AXI_ARSIZE   <= (others=>'0');
    M0_AXI_ARBURST  <= (others=>'0');
    M0_AXI_ARLOCK   <= '0';
    M0_AXI_ARCACHE  <= (others=>'0');
    M0_AXI_ARPROT   <= (others=>'0');
    M0_AXI_ARQOS    <= (others=>'0');
    M0_AXI_ARVALID  <= '0';
    M0_AXI_ARDOMAIN <= (others=>'0');   -- For ACE
    M0_AXI_ARSNOOP  <= (others=>'0');   -- For ACE
    M0_AXI_ARBAR    <= (others=>'0');   -- For ACE
    M0_AXI_RREADY   <= '0';
    M0_AXI_RACK     <= '0';             -- For ACE
    M0_AXI_ACREADY  <= '0';             -- For ACE
    M0_AXI_CRVALID  <= '0';             -- For ACE
    M0_AXI_CRRESP   <= (others=>'0');   -- For ACE
    M0_AXI_CDVALID  <= '0';             -- For ACE
    M0_AXI_CDDATA   <= (others=>'0');   -- For ACE
    M0_AXI_CDLAST   <= '0';             -- For ACE
    
  end generate No_Port_0;
  
  
  -----------------------------------------------------------------------------
  -- Master AXI Interface #1
  -----------------------------------------------------------------------------
  
  Use_Port_1: if ( C_NUM_MASTER_PORTS > 1 ) generate
  begin
    M_AXI_INST: sc_m_axi_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        
        -- AXI4 Master Interface specific.
        C_M_AXI_THREAD_ID_WIDTH   => C_M1_AXI_THREAD_ID_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M1_AXI_DATA_WIDTH,
        C_M_AXI_ADDR_WIDTH        => C_M1_AXI_ADDR_WIDTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Out).
        
        write_req_ordered_info    => write_req_ordered_info(1),
        write_req_ordered_ready   => write_req_ordered_ready(1),
        
        write_data_ordered_info   => write_data_ordered_info(1),
        write_data_ordered_ready  => write_data_ordered_ready(1),
        
        read_req_ordered_info     => read_req_ordered_info(1),
        read_req_ordered_ready    => read_req_ordered_ready(1),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (In).
        
        mst_if_wr_resp_info      => mst_if_wr_resp_info(1),
        mst_if_wr_resp_ready     => mst_if_wr_resp_ready(1),
        
        mst_if_rd_data_info      => mst_if_rd_data_info(1),
        mst_if_rd_data_ready     => mst_if_rd_data_ready(1),
        
        
        -- ---------------------------------------------------
        -- AXI4 Master Interface Signals.
        
        M_AXI_AWID                => M1_AXI_AWID,
        M_AXI_AWADDR              => M1_AXI_AWADDR,
        M_AXI_AWLEN               => M1_AXI_AWLEN,
        M_AXI_AWSIZE              => M1_AXI_AWSIZE,
        M_AXI_AWBURST             => M1_AXI_AWBURST,
        M_AXI_AWLOCK              => M1_AXI_AWLOCK,
        M_AXI_AWCACHE             => M1_AXI_AWCACHE,
        M_AXI_AWPROT              => M1_AXI_AWPROT,
        M_AXI_AWQOS               => M1_AXI_AWQOS,
        M_AXI_AWVALID             => M1_AXI_AWVALID,
        M_AXI_AWREADY             => M1_AXI_AWREADY,
        
        M_AXI_WDATA               => M1_AXI_WDATA,
        M_AXI_WSTRB               => M1_AXI_WSTRB,
        M_AXI_WLAST               => M1_AXI_WLAST,
        M_AXI_WVALID              => M1_AXI_WVALID,
        M_AXI_WREADY              => M1_AXI_WREADY,
        
        M_AXI_BRESP               => M1_AXI_BRESP,
        M_AXI_BID                 => M1_AXI_BID,
        M_AXI_BVALID              => M1_AXI_BVALID,
        M_AXI_BREADY              => M1_AXI_BREADY,
        
        M_AXI_ARID                => M1_AXI_ARID,
        M_AXI_ARADDR              => M1_AXI_ARADDR,
        M_AXI_ARLEN               => M1_AXI_ARLEN,
        M_AXI_ARSIZE              => M1_AXI_ARSIZE,
        M_AXI_ARBURST             => M1_AXI_ARBURST,
        M_AXI_ARLOCK              => M1_AXI_ARLOCK,
        M_AXI_ARCACHE             => M1_AXI_ARCACHE,
        M_AXI_ARPROT              => M1_AXI_ARPROT,
        M_AXI_ARQOS               => M1_AXI_ARQOS,
        M_AXI_ARVALID             => M1_AXI_ARVALID,
        M_AXI_ARREADY             => M1_AXI_ARREADY,
        
        M_AXI_RID                 => M1_AXI_RID,
        M_AXI_RDATA               => M1_AXI_RDATA,
        M_AXI_RRESP               => M1_AXI_RRESP,
        M_AXI_RLAST               => M1_AXI_RLAST,
        M_AXI_RVALID              => M1_AXI_RVALID,
        M_AXI_RREADY              => M1_AXI_RREADY,
      
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_rd_latency        => stat_be_rd_latency(1),
        stat_be_wr_latency        => stat_be_wr_latency(1),
        stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
        stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        M_IF_DEBUG                => M_IF_DEBUG(1)
      );
    
    ctrl_dvm_done(1)        <= '1';
    ctrl_backend_done(1)    <= '1';
    ctrl_bar_done(1)        <= '1';
    ctrl_insert_running(1)  <= '0';
    
  end generate Use_Port_1;
  
  No_Port_1: if ( C_NUM_MASTER_PORTS < 2 ) generate
  begin
    M1_AXI_AWID     <= (others=>'0');
    M1_AXI_AWADDR   <= (others=>'0');
    M1_AXI_AWLEN    <= (others=>'0');
    M1_AXI_AWSIZE   <= (others=>'0');
    M1_AXI_AWBURST  <= (others=>'0');
    M1_AXI_AWLOCK   <= '0';
    M1_AXI_AWCACHE  <= (others=>'0');
    M1_AXI_AWPROT   <= (others=>'0');
    M1_AXI_AWQOS    <= (others=>'0');
    M1_AXI_AWVALID  <= '0';
    M1_AXI_WDATA    <= (others=>'0');
    M1_AXI_WSTRB    <= (others=>'0');
    M1_AXI_WLAST    <= '0';
    M1_AXI_WVALID   <= '0';
    M1_AXI_BREADY   <= '0';
    M1_AXI_ARID     <= (others=>'0');
    M1_AXI_ARADDR   <= (others=>'0');
    M1_AXI_ARLEN    <= (others=>'0');
    M1_AXI_ARSIZE   <= (others=>'0');
    M1_AXI_ARBURST  <= (others=>'0');
    M1_AXI_ARLOCK   <= '0';
    M1_AXI_ARCACHE  <= (others=>'0');
    M1_AXI_ARPROT   <= (others=>'0');
    M1_AXI_ARQOS    <= (others=>'0');
    M1_AXI_ARVALID  <= '0';
    M1_AXI_RREADY   <= '0';
    
  end generate No_Port_1;
  
  
  -----------------------------------------------------------------------------
  -- Master AXI Interface #2
  -----------------------------------------------------------------------------
  
  Use_Port_2: if ( C_NUM_MASTER_PORTS > 2 ) generate
  begin
    M_AXI_INST: sc_m_axi_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        
        -- AXI4 Master Interface specific.
        C_M_AXI_THREAD_ID_WIDTH   => C_M2_AXI_THREAD_ID_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M2_AXI_DATA_WIDTH,
        C_M_AXI_ADDR_WIDTH        => C_M2_AXI_ADDR_WIDTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Out).
        
        write_req_ordered_info    => write_req_ordered_info(2),
        write_req_ordered_ready   => write_req_ordered_ready(2),
        
        write_data_ordered_info   => write_data_ordered_info(2),
        write_data_ordered_ready  => write_data_ordered_ready(2),
        
        read_req_ordered_info     => read_req_ordered_info(2),
        read_req_ordered_ready    => read_req_ordered_ready(2),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (In).
        
        mst_if_wr_resp_info      => mst_if_wr_resp_info(2),
        mst_if_wr_resp_ready     => mst_if_wr_resp_ready(2),
        
        mst_if_rd_data_info      => mst_if_rd_data_info(2),
        mst_if_rd_data_ready     => mst_if_rd_data_ready(2),
        
        
        -- ---------------------------------------------------
        -- AXI4 Master Interface Signals.
        
        M_AXI_AWID                => M2_AXI_AWID,
        M_AXI_AWADDR              => M2_AXI_AWADDR,
        M_AXI_AWLEN               => M2_AXI_AWLEN,
        M_AXI_AWSIZE              => M2_AXI_AWSIZE,
        M_AXI_AWBURST             => M2_AXI_AWBURST,
        M_AXI_AWLOCK              => M2_AXI_AWLOCK,
        M_AXI_AWCACHE             => M2_AXI_AWCACHE,
        M_AXI_AWPROT              => M2_AXI_AWPROT,
        M_AXI_AWQOS               => M2_AXI_AWQOS,
        M_AXI_AWVALID             => M2_AXI_AWVALID,
        M_AXI_AWREADY             => M2_AXI_AWREADY,
        
        M_AXI_WDATA               => M2_AXI_WDATA,
        M_AXI_WSTRB               => M2_AXI_WSTRB,
        M_AXI_WLAST               => M2_AXI_WLAST,
        M_AXI_WVALID              => M2_AXI_WVALID,
        M_AXI_WREADY              => M2_AXI_WREADY,
        
        M_AXI_BRESP               => M2_AXI_BRESP,
        M_AXI_BID                 => M2_AXI_BID,
        M_AXI_BVALID              => M2_AXI_BVALID,
        M_AXI_BREADY              => M2_AXI_BREADY,
        
        M_AXI_ARID                => M2_AXI_ARID,
        M_AXI_ARADDR              => M2_AXI_ARADDR,
        M_AXI_ARLEN               => M2_AXI_ARLEN,
        M_AXI_ARSIZE              => M2_AXI_ARSIZE,
        M_AXI_ARBURST             => M2_AXI_ARBURST,
        M_AXI_ARLOCK              => M2_AXI_ARLOCK,
        M_AXI_ARCACHE             => M2_AXI_ARCACHE,
        M_AXI_ARPROT              => M2_AXI_ARPROT,
        M_AXI_ARQOS               => M2_AXI_ARQOS,
        M_AXI_ARVALID             => M2_AXI_ARVALID,
        M_AXI_ARREADY             => M2_AXI_ARREADY,
        
        M_AXI_RID                 => M2_AXI_RID,
        M_AXI_RDATA               => M2_AXI_RDATA,
        M_AXI_RRESP               => M2_AXI_RRESP,
        M_AXI_RLAST               => M2_AXI_RLAST,
        M_AXI_RVALID              => M2_AXI_RVALID,
        M_AXI_RREADY              => M2_AXI_RREADY,
      
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_rd_latency        => stat_be_rd_latency(2),
        stat_be_wr_latency        => stat_be_wr_latency(2),
        stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
        stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        M_IF_DEBUG                => M_IF_DEBUG(2)
      );
    
    ctrl_dvm_done(2)        <= '1';
    ctrl_backend_done(2)    <= '1';
    ctrl_bar_done(2)        <= '1';
    ctrl_insert_running(2)  <= '0';
    
  end generate Use_Port_2;
  
  No_Port_2: if ( C_NUM_MASTER_PORTS < 3 ) generate
  begin
    M2_AXI_AWID     <= (others=>'0');
    M2_AXI_AWADDR   <= (others=>'0');
    M2_AXI_AWLEN    <= (others=>'0');
    M2_AXI_AWSIZE   <= (others=>'0');
    M2_AXI_AWBURST  <= (others=>'0');
    M2_AXI_AWLOCK   <= '0';
    M2_AXI_AWCACHE  <= (others=>'0');
    M2_AXI_AWPROT   <= (others=>'0');
    M2_AXI_AWQOS    <= (others=>'0');
    M2_AXI_AWVALID  <= '0';
    M2_AXI_WDATA    <= (others=>'0');
    M2_AXI_WSTRB    <= (others=>'0');
    M2_AXI_WLAST    <= '0';
    M2_AXI_WVALID   <= '0';
    M2_AXI_BREADY   <= '0';
    M2_AXI_ARID     <= (others=>'0');
    M2_AXI_ARADDR   <= (others=>'0');
    M2_AXI_ARLEN    <= (others=>'0');
    M2_AXI_ARSIZE   <= (others=>'0');
    M2_AXI_ARBURST  <= (others=>'0');
    M2_AXI_ARLOCK   <= '0';
    M2_AXI_ARCACHE  <= (others=>'0');
    M2_AXI_ARPROT   <= (others=>'0');
    M2_AXI_ARQOS    <= (others=>'0');
    M2_AXI_ARVALID  <= '0';
    M2_AXI_RREADY   <= '0';
    
  end generate No_Port_2;
  
  
  -----------------------------------------------------------------------------
  -- Master AXI Interface #3
  -----------------------------------------------------------------------------
  
  Use_Port_3: if ( C_NUM_MASTER_PORTS > 3 ) generate
  begin
    M_AXI_INST: sc_m_axi_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
        C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        
        -- Data type and settings specific.
        C_ADDR_VALID_HI           => C_ADDR_VALID_HI,
        C_ADDR_VALID_LO           => C_ADDR_VALID_LO,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_HI,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_LO,
        
        -- AXI4 Master Interface specific.
        C_M_AXI_THREAD_ID_WIDTH   => C_M3_AXI_THREAD_ID_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M3_AXI_DATA_WIDTH,
        C_M_AXI_ADDR_WIDTH        => C_M3_AXI_ADDR_WIDTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Out).
        
        write_req_ordered_info    => write_req_ordered_info(3),
        write_req_ordered_ready   => write_req_ordered_ready(3),
        
        write_data_ordered_info   => write_data_ordered_info(3),
        write_data_ordered_ready  => write_data_ordered_ready(3),
        
        read_req_ordered_info     => read_req_ordered_info(3),
        read_req_ordered_ready    => read_req_ordered_ready(3),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (In).
        
        mst_if_wr_resp_info      => mst_if_wr_resp_info(3),
        mst_if_wr_resp_ready     => mst_if_wr_resp_ready(3),
        
        mst_if_rd_data_info      => mst_if_rd_data_info(3),
        mst_if_rd_data_ready     => mst_if_rd_data_ready(3),
        
        
        -- ---------------------------------------------------
        -- AXI4 Master Interface Signals.
        
        M_AXI_AWID                => M3_AXI_AWID,
        M_AXI_AWADDR              => M3_AXI_AWADDR,
        M_AXI_AWLEN               => M3_AXI_AWLEN,
        M_AXI_AWSIZE              => M3_AXI_AWSIZE,
        M_AXI_AWBURST             => M3_AXI_AWBURST,
        M_AXI_AWLOCK              => M3_AXI_AWLOCK,
        M_AXI_AWCACHE             => M3_AXI_AWCACHE,
        M_AXI_AWPROT              => M3_AXI_AWPROT,
        M_AXI_AWQOS               => M3_AXI_AWQOS,
        M_AXI_AWVALID             => M3_AXI_AWVALID,
        M_AXI_AWREADY             => M3_AXI_AWREADY,
        
        M_AXI_WDATA               => M3_AXI_WDATA,
        M_AXI_WSTRB               => M3_AXI_WSTRB,
        M_AXI_WLAST               => M3_AXI_WLAST,
        M_AXI_WVALID              => M3_AXI_WVALID,
        M_AXI_WREADY              => M3_AXI_WREADY,
        
        M_AXI_BRESP               => M3_AXI_BRESP,
        M_AXI_BID                 => M3_AXI_BID,
        M_AXI_BVALID              => M3_AXI_BVALID,
        M_AXI_BREADY              => M3_AXI_BREADY,
        
        M_AXI_ARID                => M3_AXI_ARID,
        M_AXI_ARADDR              => M3_AXI_ARADDR,
        M_AXI_ARLEN               => M3_AXI_ARLEN,
        M_AXI_ARSIZE              => M3_AXI_ARSIZE,
        M_AXI_ARBURST             => M3_AXI_ARBURST,
        M_AXI_ARLOCK              => M3_AXI_ARLOCK,
        M_AXI_ARCACHE             => M3_AXI_ARCACHE,
        M_AXI_ARPROT              => M3_AXI_ARPROT,
        M_AXI_ARQOS               => M3_AXI_ARQOS,
        M_AXI_ARVALID             => M3_AXI_ARVALID,
        M_AXI_ARREADY             => M3_AXI_ARREADY,
        
        M_AXI_RID                 => M3_AXI_RID,
        M_AXI_RDATA               => M3_AXI_RDATA,
        M_AXI_RRESP               => M3_AXI_RRESP,
        M_AXI_RLAST               => M3_AXI_RLAST,
        M_AXI_RVALID              => M3_AXI_RVALID,
        M_AXI_RREADY              => M3_AXI_RREADY,
      
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_be_rd_latency        => stat_be_rd_latency(3),
        stat_be_wr_latency        => stat_be_wr_latency(3),
        stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
        stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        M_IF_DEBUG                => M_IF_DEBUG(3)
      );
    
    ctrl_dvm_done(3)        <= '1';
    ctrl_backend_done(3)    <= '1';
    ctrl_bar_done(3)        <= '1';
    ctrl_insert_running(3)  <= '0';
    
  end generate Use_Port_3;
  
  No_Port_3: if ( C_NUM_MASTER_PORTS < 4 ) generate
  begin
    M3_AXI_AWID     <= (others=>'0');
    M3_AXI_AWADDR   <= (others=>'0');
    M3_AXI_AWLEN    <= (others=>'0');
    M3_AXI_AWSIZE   <= (others=>'0');
    M3_AXI_AWBURST  <= (others=>'0');
    M3_AXI_AWLOCK   <= '0';
    M3_AXI_AWCACHE  <= (others=>'0');
    M3_AXI_AWPROT   <= (others=>'0');
    M3_AXI_AWQOS    <= (others=>'0');
    M3_AXI_AWVALID  <= '0';
    M3_AXI_WDATA    <= (others=>'0');
    M3_AXI_WSTRB    <= (others=>'0');
    M3_AXI_WLAST    <= '0';
    M3_AXI_WVALID   <= '0';
    M3_AXI_BREADY   <= '0';
    M3_AXI_ARID     <= (others=>'0');
    M3_AXI_ARADDR   <= (others=>'0');
    M3_AXI_ARLEN    <= (others=>'0');
    M3_AXI_ARSIZE   <= (others=>'0');
    M3_AXI_ARBURST  <= (others=>'0');
    M3_AXI_ARLOCK   <= '0';
    M3_AXI_ARCACHE  <= (others=>'0');
    M3_AXI_ARPROT   <= (others=>'0');
    M3_AXI_ARQOS    <= (others=>'0');
    M3_AXI_ARVALID  <= '0';
    M3_AXI_RREADY   <= '0';
    
  end generate No_Port_3;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_CROSS_ERROR)      <= cross_assert when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_CROSS_ERROR) /= '1' 
      report "Backend: Error detected in CrossBar."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_ram_module.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2006-2009,2014,2017 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_ram_module.vhd
--
-- Description:     This file contains instantiations of various block RAM
--                  and an HDL implementation of distributed RAM.
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:
--              sc_ram_module.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_com"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity sc_ram_module is
  generic (
    C_TARGET        : TARGET_FAMILY_TYPE;
    C_RECURSIVE_INST: boolean               := false;
    C_WE_A_WIDTH    : positive              := 1;
    C_DATA_A_WIDTH  : positive              := 18;  -- No upper limit
    C_ADDR_A_WIDTH  : natural range 1 to 18 := 11;
    C_WE_B_WIDTH    : positive              := 1;
    C_DATA_B_WIDTH  : positive              := 18;  -- No upper limit
    C_ADDR_B_WIDTH  : natural range 1 to 18 := 11;
    C_FORCE_BRAM    : boolean               := true;
    C_FORCE_LUTRAM  : boolean               := false
  );
  port (
    -- PORT A
    CLKA            : in  std_logic;
    ENA             : in  std_logic;
    WEA             : in  std_logic_vector(C_WE_A_WIDTH-1 downto 0);
    ADDRA           : in  std_logic_vector(C_ADDR_A_WIDTH-1 downto 0);
    DATA_INA        : in  std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
    DATA_OUTA       : out std_logic_vector(C_DATA_A_WIDTH-1 downto 0):= (others=>'0');
    -- PORT B
    CLKB            : in  std_logic;
    ENB             : in  std_logic;
    WEB             : in  std_logic_vector(C_WE_B_WIDTH-1 downto 0);
    ADDRB           : in  std_logic_vector(C_ADDR_B_WIDTH-1 downto 0);
    DATA_INB        : in  std_logic_vector(C_DATA_B_WIDTH-1 downto 0);
    DATA_OUTB       : out std_logic_vector(C_DATA_B_WIDTH-1 downto 0):= (others=>'0')
  );
end entity sc_ram_module;

library IEEE;
use IEEE.numeric_std.all;

architecture IMP of sc_ram_module is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------


  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------

  component sc_ram_module is
    generic (
      C_TARGET        : TARGET_FAMILY_TYPE;
      C_RECURSIVE_INST: boolean               := false;
      C_WE_A_WIDTH    : positive              := 1;
      C_DATA_A_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_A_WIDTH  : natural range 1 to 18 := 11;
      C_WE_B_WIDTH    : positive              := 1;
      C_DATA_B_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_B_WIDTH  : natural range 1 to 18 := 11;
      C_FORCE_BRAM    : boolean               := true;
      C_FORCE_LUTRAM  : boolean               := false
    );
    port (
      -- PORT A
      CLKA            : in  std_logic;
      ENA             : in  std_logic;
      WEA             : in  std_logic_vector(C_WE_A_WIDTH-1 downto 0);
      ADDRA           : in  std_logic_vector(C_ADDR_A_WIDTH-1 downto 0);
      DATA_INA        : in  std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      DATA_OUTA       : out std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      -- PORT B
      CLKB            : in  std_logic;
      ENB             : in  std_logic;
      WEB             : in  std_logic_vector(C_WE_B_WIDTH-1 downto 0);
      ADDRB           : in  std_logic_vector(C_ADDR_B_WIDTH-1 downto 0);
      DATA_INB        : in  std_logic_vector(C_DATA_B_WIDTH-1 downto 0);
      DATA_OUTB       : out std_logic_vector(C_DATA_B_WIDTH-1 downto 0)
    );
  end component sc_ram_module;


  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------

  constant write_mode             : string := "READ_FIRST";
  constant port_ratio             : natural := max_of(C_DATA_A_WIDTH, C_DATA_B_WIDTH) /
                                               min_of(C_DATA_A_WIDTH, C_DATA_B_WIDTH);
  constant port_a_is_wide         : natural := boolean'pos(C_DATA_A_WIDTH > C_DATA_B_WIDTH);
  constant port_b_is_wide         : natural := boolean'pos(C_DATA_B_WIDTH > C_DATA_A_WIDTH);

begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- Check valid configurations
  -----------------------------------------------------------------------------

  assert not( ( port_ratio > 4 ) and
              ( ( port_a_is_wide = 1 and C_WE_A_WIDTH > 1 ) or
                ( port_b_is_wide = 1 and C_WE_B_WIDTH > 1 ) ) )
    report   "sc_ram_module: illegal combination of C_WE_WIDTH and C_DATA_WIDTH ratios."
    severity failure;

  assert C_DATA_A_WIDTH * 2**C_ADDR_A_WIDTH = C_DATA_B_WIDTH * 2**C_ADDR_B_WIDTH
    report   "sc_ram_module: Port A and B define different memory size"
    severity failure;

  Not_Using_XPM : if not Has_Target(C_Target, BRAM_XPM) generate

    -----------------------------------------------------------------------------
    -- Custom types and Constants
    -----------------------------------------------------------------------------

    -- Constants for selected memory.
    constant using_parity           : boolean := ( C_DATA_A_WIDTH = C_DATA_B_WIDTH ) and
                                                 ( C_WE_A_WIDTH   = C_WE_B_WIDTH ) and
                                                 ( ( ( C_DATA_A_WIDTH / C_WE_A_WIDTH ) /= 8 ) or
                                                   ( ( C_DATA_B_WIDTH / C_WE_B_WIDTH ) /= 8 ) );
    constant max_data_width         : natural := max_of(C_DATA_A_WIDTH, C_DATA_B_WIDTH);
    constant target_addr_width      : natural := min_of(C_ADDR_A_WIDTH, C_ADDR_B_WIDTH);


    -- Constants for architecture properties.
    constant arch_36kbit_bram       : boolean := Has_Target(C_TARGET, BRAM_36k);
    constant sim_check_mode         : string := "NONE";


    -- Constants/Types for memory types and properties.
    type bram_kind is (DISTRAM, B36_Sx, B72_S1);
    subtype allowed_addr_bits is natural range 1 to 18;

    type BRAM_TYPE is record
      What_Kind   : bram_kind;
      Data_size   : natural;
      No_WE       : natural;
      Addr_size   : natural;
      Parity_size : natural;
      Par_Padding : natural;
    end record BRAM_TYPE;

    type ramb36_index_vector_type   is array (boolean) of natural;
    constant ramb36_index_vector    : ramb36_index_vector_type := (false => 0, true => 10);
    constant is_ram36               : natural                  := ramb36_index_vector(arch_36kbit_bram);

    type maddr_index_vector_type    is array (bram_kind) of allowed_addr_bits;
    constant bram_max_addr_size     : maddr_index_vector_type := (DISTRAM => 7,
                                                                  B36_Sx  => 15,
                                                                  B72_S1  => 16);


    -- Constants/Types for size dependencies.
    type ram_addr_vector        is array (allowed_addr_bits) of natural;
    type kind_type              is (mixed, bram, lutram);
    type ram_select_vector      is array (kind_type) of ram_addr_vector;
    constant ram_select_lookup : ram_select_vector :=
      (mixed  => (1, 2, 3, 4, 5, 6, 7, 8, 9+is_ram36, 10+is_ram36, 11+is_ram36, 12+is_ram36,
                  13+is_ram36, 14+is_ram36, 15+is_ram36, 16+is_ram36, 17+is_ram36, 18+is_ram36),
       bram   => (9+is_ram36, 9+is_ram36, 9+is_ram36, 9+is_ram36, 9+is_ram36, 9+is_ram36,
                  9+is_ram36, 9+is_ram36, 9+is_ram36, 10+is_ram36, 11+is_ram36, 12+is_ram36,
                  13+is_ram36, 14+is_ram36, 15+is_ram36, 16+is_ram36, 17+is_ram36, 18+is_ram36),
       lutram => (1, 2, 3, 4, 5, 6, 7, 8, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38));

    type bram_type_vector is array (natural range 1 to 38) of BRAM_TYPE;
    constant bram_type_lookup : bram_type_vector :=
      (1  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 1,  Parity_size => 0, Par_Padding => 0),
       2  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 2,  Parity_size => 0, Par_Padding => 0),
       3  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 3,  Parity_size => 0, Par_Padding => 0),
       4  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 4,  Parity_size => 0, Par_Padding => 0),
       5  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 5,  Parity_size => 0, Par_Padding => 0),
       6  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 6,  Parity_size => 0, Par_Padding => 0),
       7  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 7,  Parity_size => 0, Par_Padding => 0),
       8  => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 8,  Parity_size => 0, Par_Padding => 0),

       9  => (what_kind => B36_Sx,  Data_size => 32, No_WE => 4, Addr_size => 10, Parity_size => 4, Par_Padding => 0),
       10 => (what_kind => B36_Sx,  Data_size => 32, No_WE => 4, Addr_size => 10, Parity_size => 4, Par_Padding => 0),
       11 => (what_kind => B36_Sx,  Data_size => 16, No_WE => 2, Addr_size => 11, Parity_size => 2, Par_Padding => 0),
       12 => (what_kind => B36_Sx,  Data_size => 8,  No_WE => 1, Addr_size => 12, Parity_size => 1, Par_Padding => 0),
       13 => (what_kind => B36_Sx,  Data_size => 4,  No_WE => 1, Addr_size => 13, Parity_size => 0, Par_Padding => 1),
       14 => (what_kind => B36_Sx,  Data_size => 2,  No_WE => 1, Addr_size => 14, Parity_size => 0, Par_Padding => 1),
       15 => (what_kind => B36_Sx,  Data_size => 1,  No_WE => 1, Addr_size => 15, Parity_size => 0, Par_Padding => 1),
       16 => (what_kind => B36_Sx,  Data_size => 1,  No_WE => 1, Addr_size => 16, Parity_size => 0, Par_Padding => 1),
       17 => (what_kind => B36_Sx,  Data_size => 1,  No_WE => 1, Addr_size => 17, Parity_size => 0, Par_Padding => 1),
       18 => (what_kind => B36_Sx,  Data_size => 1,  No_WE => 1, Addr_size => 18, Parity_size => 0, Par_Padding => 1),

       19 => (what_kind => B36_Sx,  Data_size => 32, No_WE => 4, Addr_size => 10, Parity_size => 4, Par_Padding => 0),
       20 => (what_kind => B36_Sx,  Data_size => 32, No_WE => 4, Addr_size => 10, Parity_size => 4, Par_Padding => 0),
       21 => (what_kind => B36_Sx,  Data_size => 16, No_WE => 2, Addr_size => 11, Parity_size => 2, Par_Padding => 0),
       22 => (what_kind => B36_Sx,  Data_size => 8,  No_WE => 1, Addr_size => 12, Parity_size => 1, Par_Padding => 0),
       23 => (what_kind => B36_Sx,  Data_size => 4,  No_WE => 1, Addr_size => 13, Parity_size => 0, Par_Padding => 1),
       24 => (what_kind => B36_Sx,  Data_size => 2,  No_WE => 1, Addr_size => 14, Parity_size => 0, Par_Padding => 1),
       25 => (what_kind => B36_Sx,  Data_size => 1,  No_WE => 1, Addr_size => 15, Parity_size => 0, Par_Padding => 1),
       26 => (what_kind => B72_S1,  Data_size => 1,  No_WE => 1, Addr_size => 16, Parity_size => 0, Par_Padding => 1),
       27 => (what_kind => B72_S1,  Data_size => 1,  No_WE => 1, Addr_size => 17, Parity_size => 0, Par_Padding => 1),
       28 => (what_kind => B72_S1,  Data_size => 1,  No_WE => 1, Addr_size => 18, Parity_size => 0, Par_Padding => 1),

       29 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 9,  Parity_size => 0, Par_Padding => 0),
       30 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 10, Parity_size => 0, Par_Padding => 0),
       31 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 11, Parity_size => 0, Par_Padding => 0),
       32 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 12, Parity_size => 0, Par_Padding => 0),
       33 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 13, Parity_size => 0, Par_Padding => 0),
       34 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 14, Parity_size => 0, Par_Padding => 0),
       35 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 15, Parity_size => 0, Par_Padding => 0),
       36 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 16, Parity_size => 0, Par_Padding => 0),
       37 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 17, Parity_size => 0, Par_Padding => 0),
       38 => (what_kind => DISTRAM, Data_size => 1,  No_WE => 1, Addr_size => 18, Parity_size => 0, Par_Padding => 0)
     );


    -----------------------------------------------------------------------------
    -- Function declaration
    -----------------------------------------------------------------------------

    -- Function to detect how to select memory settings.
    function select_kind (force_bram : boolean; force_lutram : boolean) return kind_type is
    begin
      if force_bram then
        return bram;
      elsif force_lutram then
        return lutram;
      end if;
      return mixed;
    end function select_kind;


    -- Function to return the maximum number of address bits to be use.
    function select_max_addr (ratio : natural; kind : kind_type) return natural is
      constant wide_has_we        : natural := boolean'pos(( port_a_is_wide = 1 and C_WE_A_WIDTH > 1 ) or
                                                           ( port_b_is_wide = 1 and C_WE_B_WIDTH > 1 ));
      variable best_addr_so_far   : natural := 0;
    begin
      -- Filter impossible configurations.
      if( ( port_ratio > 4 ) and
          ( ( port_a_is_wide = 1 and C_WE_A_WIDTH > 1 ) or
            ( port_b_is_wide = 1 and C_WE_B_WIDTH > 1 ) ) )then
        return 0;
      end if;

      -- Search for best fit.
      for I in allowed_addr_bits'low to allowed_addr_bits'high loop
        if( ( ( ratio               ) <= bram_type_lookup(ram_select_lookup(kind)(I)).Data_size ) and
            ( ( wide_has_we*8*ratio ) <= bram_type_lookup(ram_select_lookup(kind)(I)).Data_size ) and
            ( ( B72_S1              ) /= bram_type_lookup(ram_select_lookup(kind)(I)).what_kind ) ) then
          if( target_addr_width <= bram_type_lookup(ram_select_lookup(kind)(I)).Addr_size ) then
            -- Optimal found.
            return bram_type_lookup(ram_select_lookup(kind)(I)).Addr_size;
          elsif( best_addr_so_far < bram_type_lookup(ram_select_lookup(kind)(I)).Addr_size ) then
            -- Possible candidate.
            best_addr_so_far  := bram_type_lookup(ram_select_lookup(kind)(I)).Addr_size;
          end if;
        end if;
      end loop;

      -- Return best option available.
      return best_addr_so_far;
    end function select_max_addr;


    -- Calculate amount of RAMs needed to satisfy depth, width and we settings.
    function calc_nr_of_brams (What_BRAM : BRAM_TYPE;
                               data_size : natural; we_size : natural; using_parity : boolean) return natural is
      constant ram_full_data_width  : natural := What_BRAM.Data_size + What_BRAM.Parity_size;
      constant ram_data_per_we      : natural := ram_full_data_width / What_BRAM.No_WE;
      constant data_per_we          : natural := data_size / we_size;
      constant ram_we_per_we        : natural := ( data_per_we + ram_data_per_we - 1 ) / ram_data_per_we;
      constant total_ram_we         : natural := ram_we_per_we * we_size;
    begin
      if using_parity then
        return (total_ram_we + What_BRAM.No_WE - 1) / What_BRAM.No_WE;
      else
        return (data_size + What_BRAM.Data_size - 1) / What_BRAM.Data_size;
      end if;
    end function calc_nr_of_brams;


    -- Procedure to handle assignment of vectors with different sizes.
    procedure assign (signal output : out std_logic_vector; signal input : in std_logic_vector) is
    begin
      if input'length = 1 then
        output <= (output'range => input(input'right));
      elsif input'length > output'length then
        output <= input(input'right + output'length - 1 downto input'right);
      else
        output <= (output'range => '0');
        output(output'right + input'length - 1 downto output'right) <= input;
      end if;
    end procedure assign;


    -----------------------------------------------------------------------------
    -- Custom types
    -----------------------------------------------------------------------------



    -----------------------------------------------------------------------------
    -- Constant declaration
    -----------------------------------------------------------------------------


    constant What_Kind              : kind_type := select_kind(C_FORCE_BRAM, C_FORCE_LUTRAM);

    type addr_index_vector_type     is array (boolean) of natural;
    constant addr_index_vector      : addr_index_vector_type := (false  => C_ADDR_A_WIDTH,
                                                                 true   => select_max_addr(port_ratio, What_Kind));
    constant max_allowed_addr_bits  : natural                  := addr_index_vector(port_ratio /= 1);

    constant What_BRAM              : BRAM_TYPE :=
                                        bram_type_lookup(ram_select_lookup(What_Kind)(max_allowed_addr_bits));
    constant nr_of_brams            : natural :=
                                        calc_nr_of_brams(What_BRAM, max_data_width, C_WE_A_WIDTH, using_parity);
    constant just_data_bits_size    : natural := nr_of_brams * What_BRAM.Data_size;
    constant just_par_bits_size     : natural := nr_of_brams * What_BRAM.Parity_size + What_BRAM.Par_Padding;
    constant rs                     : natural := What_BRAM.Data_size;
    constant wers                   : natural := rs / 8;
    constant ws                     : natural := just_data_bits_size / port_ratio;
    constant wews                   : natural := ws / 8;
    constant no_ws_ram              : natural := ws / rs;
    constant cs                     : natural := rs / port_ratio;
    constant wecs                   : natural := cs / 8;
    constant no_cs                  : natural := ws / cs;

    constant addr_size_a            : natural := max_of(What_BRAM.Addr_size, C_ADDR_A_WIDTH);
    constant addr_size_b            : natural := max_of(What_BRAM.Addr_size, C_ADDR_B_WIDTH);

    constant a_raw_data_width       : natural := What_BRAM.Data_size / sel(port_b_is_wide = 1, port_ratio, 1);
    constant b_raw_data_width       : natural := What_BRAM.Data_size / sel(port_a_is_wide = 1, port_ratio, 1);

    constant a_just_data_bits_size  : natural := nr_of_brams * a_raw_data_width;
    constant b_just_data_bits_size  : natural := nr_of_brams * b_raw_data_width;



    -----------------------------------------------------------------------------
    -- Signal declaration
    -----------------------------------------------------------------------------


    -- ----------------------------------------
    -- local signals for padding if the size doesn't match perfectly

    signal addra_i        : std_logic_vector(addr_size_a-1 downto 0);
    signal addrb_i        : std_logic_vector(addr_size_b-1 downto 0);

    signal wea_i          : std_logic_vector((a_just_data_bits_size+7)/8-1 downto 0);
    signal data_ina_i     : std_logic_vector(a_just_data_bits_size-1 downto 0);
    signal data_ina_ii    : std_logic_vector(a_just_data_bits_size-1 downto 0);
    signal data_outa_i    : std_logic_vector(a_just_data_bits_size-1 downto 0) := (others => '0');
    signal data_outa_ii   : std_logic_vector(a_just_data_bits_size-1 downto 0) := (others => '0');
    signal web_i          : std_logic_vector((b_just_data_bits_size+7)/8-1 downto 0);
    signal data_inb_i     : std_logic_vector(b_just_data_bits_size-1 downto 0);
    signal data_inb_ii    : std_logic_vector(b_just_data_bits_size-1 downto 0);
    signal data_outb_i    : std_logic_vector(b_just_data_bits_size-1 downto 0) := (others => '0');
    signal data_outb_ii   : std_logic_vector(b_just_data_bits_size-1 downto 0) := (others => '0');

    signal data_inpa_i    : std_logic_vector(just_par_bits_size-1 downto 0);
    signal data_inpb_i    : std_logic_vector(just_par_bits_size-1 downto 0);
    signal data_inpa_ii   : std_logic_vector(just_par_bits_size-1 downto 0);
    signal data_inpb_ii   : std_logic_vector(just_par_bits_size-1 downto 0);
    signal data_outpa_i   : std_logic_vector(just_par_bits_size-1 downto 0) := (others => '0');
    signal data_outpb_i   : std_logic_vector(just_par_bits_size-1 downto 0) := (others => '0');
    signal data_outpa_ii  : std_logic_vector(just_par_bits_size-1 downto 0) := (others => '0');
    signal data_outpb_ii  : std_logic_vector(just_par_bits_size-1 downto 0) := (others => '0');

  begin  -- Not_Using_XPM

    -----------------------------------------------------------------------------
    -- Padding and Splitting of Buses
    -----------------------------------------------------------------------------

    Padding_Addr_Vectors : process(ADDRA, ADDRB) is
    begin  -- process Padding_Addr_Vectors
      addra_i              <= (others => '1');
      addra_i(ADDRA'range) <= ADDRA;
      addrb_i              <= (others => '1');
      addrb_i(ADDRB'range) <= ADDRB;
    end process Padding_Addr_Vectors;


    Divide_Data_Bus: if ( using_parity ) generate
      constant ram_full_data_width  : natural := What_BRAM.Data_size + What_BRAM.Parity_size;
      constant data_size            : natural := What_BRAM.Data_size;
      constant par_size             : natural := What_BRAM.Parity_size;
      constant pure_ram_data_per_we : natural := What_BRAM.Data_size / What_BRAM.No_WE;
      constant pure_ram_par_per_we  : natural := What_BRAM.Parity_size / What_BRAM.No_WE;
      constant ram_data_per_we      : natural := ram_full_data_width / What_BRAM.No_WE;
      constant data_per_we          : natural := C_DATA_A_WIDTH / C_WE_A_WIDTH;
      constant ram_we_per_we        : natural := ( data_per_we + ram_data_per_we - 1 ) / ram_data_per_we;
      constant total_ram_we         : natural := ram_we_per_we * C_WE_A_WIDTH;
      constant ram_all_data_per_we  : natural := ram_we_per_we * pure_ram_data_per_we;
      constant ram_all_par_per_we   : natural := ram_we_per_we * pure_ram_par_per_we;
      constant data_part            : natural := min_of(data_per_we, ram_all_data_per_we);
      constant par_part             : integer := data_per_we - data_part;

    begin
      padding_vectors : process(DATA_INA, DATA_INB, WEA, WEB, data_outa_ii,
                                data_outb_ii, data_outpa_ii, data_outpb_ii) is
      begin  -- process padding_vectors
        -- Default
        data_ina_ii  <= (others => '0');
        data_inb_ii  <= (others => '0');
        data_inpa_ii <= (others => '0');
        data_inpb_ii <= (others => '0');
        wea_i        <= (others => '0');
        web_i        <= (others => '0');

        if (What_BRAM.What_Kind = DISTRAM) then
          assign(wea_i, WEA);
          assign(web_i, WEB);
        end if;

        -- Assign.
        for I in 0 to C_WE_A_WIDTH-1 loop
          if (What_BRAM.What_Kind /= DISTRAM) then
            wea_i((I+1)*ram_we_per_we - 1 downto I*ram_we_per_we) <= (others=>WEA(I));
            web_i((I+1)*ram_we_per_we - 1 downto I*ram_we_per_we) <= (others=>WEB(I));
          end if;

          data_ina_ii(I*ram_all_data_per_we + data_part - 1 downto I*ram_all_data_per_we) <=
            DATA_INA(I*data_per_we + data_part - 1 downto I*data_per_we);
          data_inb_ii(I*ram_all_data_per_we + data_part - 1 downto I*ram_all_data_per_we) <=
            DATA_INB(I*data_per_we + data_part - 1 downto I*data_per_we);

          DATA_OUTA(I*data_per_we + data_part - 1 downto I*data_per_we) <=
            data_outa_ii(I*ram_all_data_per_we + data_part - 1 downto I*ram_all_data_per_we);
          DATA_OUTB(I*data_per_we + data_part - 1 downto I*data_per_we) <=
            data_outb_ii(I*ram_all_data_per_we + data_part - 1 downto I*ram_all_data_per_we);

          if( par_part > 0 ) then
            data_inpa_ii(I*ram_all_par_per_we + par_part - 1 downto I*ram_all_par_per_we) <=
              DATA_INA((I+1)*data_per_we - 1 downto I*data_per_we + data_part);
            data_inpb_ii(I*ram_all_par_per_we + par_part - 1 downto I*ram_all_par_per_we) <=
              DATA_INB((I+1)*data_per_we - 1 downto I*data_per_we + data_part);

            DATA_OUTA((I+1)*data_per_we - 1 downto I*data_per_we + data_part) <=
              data_outpa_ii(I*ram_all_par_per_we + par_part - 1 downto I*ram_all_par_per_we);
            DATA_OUTB((I+1)*data_per_we - 1 downto I*data_per_we + data_part) <=
              data_outpb_ii(I*ram_all_par_per_we + par_part - 1 downto I*ram_all_par_per_we);
          end if;
        end loop;
      end process padding_vectors;

    end generate Divide_Data_Bus;

    No_Divide_Data_Bus: if ( not using_parity ) generate
    begin
      Data_Size_Less_Than_Bram_Size_A: if (C_DATA_A_WIDTH < just_data_bits_size) generate
      begin
        padding_vectors : process(DATA_INA, data_outa_i) is
        begin  -- process padding_vectors
          -- Default drive the parity inputs to '0'
          data_inpa_i <= (others => '0');

          data_ina_i                 <= (others => '0');
          data_ina_i(DATA_INA'range) <= DATA_INA;
          DATA_OUTA                  <= data_outa_i(DATA_OUTA'range);
        end process padding_vectors;
      end generate Data_Size_Less_Than_Bram_Size_A;

      Data_Size_Less_Than_Bram_Size_B: if (C_DATA_B_WIDTH < just_data_bits_size) generate
      begin
        padding_vectors : process(DATA_INB, data_outb_i) is
        begin  -- process padding_vectors
          -- Default drive the parity inputs to '0'
          data_inpb_i <= (others => '0');

          data_inb_i                 <= (others => '0');
          data_inb_i(DATA_INB'range) <= DATA_INB;
          DATA_OUTB                  <= data_outb_i(DATA_OUTB'range);
        end process padding_vectors;
      end generate Data_Size_Less_Than_Bram_Size_B;

      Data_Size_Equal_To_BRAM_Size_A: if (C_DATA_A_WIDTH = just_data_bits_size) generate
      begin
        padding_vectors : process(DATA_INA, data_outa_i) is
        begin  -- process padding_vectors
          -- Default drive the parity inputs to '0'
          data_inpa_i <= (others => '0');

          data_ina_i <= DATA_INA;
          DATA_OUTA  <= data_outa_i;
        end process padding_vectors;
      end generate Data_Size_Equal_To_BRAM_Size_A;

      Data_Size_Equal_To_BRAM_Size_B: if (C_DATA_B_WIDTH = just_data_bits_size) generate
      begin
        padding_vectors : process(DATA_INB, data_outb_i) is
        begin  -- process padding_vectors
          -- Default drive the parity inputs to '0'
          data_inpb_i <= (others => '0');

          data_inb_i <= DATA_INB;
          DATA_OUTB  <= data_outb_i;
        end process padding_vectors;
      end generate Data_Size_Equal_To_BRAM_Size_B;

      Reorder_Data_Bus_A: if ( ( port_ratio /= 1 ) and
                               ( C_DATA_A_WIDTH > C_DATA_B_WIDTH ) and
                               not C_RECURSIVE_INST ) generate
      begin
        assign(web_i, WEB);
        data_inb_ii <= data_inb_i;
        data_outb_i <= data_outb_ii;

        The_Src: for I in 0 to port_ratio-1 generate
        begin
          The_Dst: for J in 0 to no_cs-1 generate
          begin
            A_Small_WE: if( C_WE_A_WIDTH = 1 ) generate
            begin
              assign(wea_i, WEA);
            end generate A_Small_WE;
            A_Wide_WE: if( C_WE_A_WIDTH /= 1 ) generate
            begin
              wea_i((I+1)*wecs + J*wers - 1 downto I*wecs + J*wers) <=
                WEA(I*wews + (J+1)*wecs - 1 downto I*wews + J*wecs);
            end generate A_Wide_WE;
            data_ina_ii((I+1)*cs + J*rs - 1 downto I*cs + J*rs) <=
              data_ina_i(I*ws + (J+1)*cs - 1 downto I*ws + J*cs);
            data_outa_i(I*ws + (J+1)*cs - 1 downto I*ws + J*cs) <=
              data_outa_ii((I+1)*cs + J*rs - 1 downto I*cs + J*rs);
          end generate The_Dst;
        end generate The_Src;

      end generate Reorder_Data_Bus_A;

      Reorder_Data_Bus_B: if ( ( port_ratio /= 1 ) and
                               ( C_DATA_A_WIDTH < C_DATA_B_WIDTH ) and
                               not C_RECURSIVE_INST ) generate
      begin
        assign(wea_i, WEA);
        data_ina_ii <= data_ina_i;
        data_outa_i <= data_outa_ii;

        The_Src: for I in 0 to port_ratio-1 generate
        begin
          The_Dst: for J in 0 to no_cs-1 generate
          begin
            B_Small_WE: if( C_WE_B_WIDTH = 1 ) generate
            begin
              assign(web_i, WEB);
            end generate B_Small_WE;
            B_Wide_WE: if( C_WE_B_WIDTH /= 1 ) generate
            begin
              web_i((I+1)*wecs + J*wers - 1 downto I*wecs + J*wers) <=
                WEB(I*wews + (J+1)*wecs - 1 downto I*wews + J*wecs);
            end generate B_Wide_WE;
            data_inb_ii((I+1)*cs + J*rs - 1 downto I*cs + J*rs) <=
              data_inb_i(I*ws + (J+1)*cs - 1 downto I*ws + J*cs);
            data_outb_i(I*ws + (J+1)*cs - 1 downto I*ws + J*cs) <=
              data_outb_ii((I+1)*cs + J*rs - 1 downto I*cs + J*rs);
          end generate The_Dst;
        end generate The_Src;

      end generate Reorder_Data_Bus_B;

      No_Reorder_Data_Bus: if ( port_ratio = 1 or C_RECURSIVE_INST ) generate
      begin
        assign(wea_i, WEA);
        assign(web_i, WEB);

        data_ina_ii <= data_ina_i;
        data_inb_ii <= data_inb_i;

        data_outa_i <= data_outa_ii;
        data_outb_i <= data_outb_ii;
      end generate No_Reorder_Data_Bus;

    end generate No_Divide_Data_Bus;


    -----------------------------------------------------------------------------
    -- BlockRAM
    -----------------------------------------------------------------------------

    Using_BRAM : if (What_BRAM.What_Kind /= DISTRAM) generate
      constant native_max_addr_size   : natural := min_of(max_allowed_addr_bits,
                                                          bram_max_addr_size(What_BRAM.What_Kind));
      constant native_max_addr_size_a : natural := native_max_addr_size + port_b_is_wide * Log2(port_ratio);
      constant native_max_addr_size_b : natural := native_max_addr_size + port_a_is_wide * Log2(port_ratio);
    begin
      Recursive : if (target_addr_width > native_max_addr_size) generate

        constant num_ram_modules : integer:= 2 ** ( target_addr_width - native_max_addr_size );
        type ram_a_output is array (0 to num_ram_modules - 1) of std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
        type ram_b_output is array (0 to num_ram_modules - 1) of std_logic_vector(C_DATA_B_WIDTH-1 downto 0);

        signal addra_cmb  : std_logic_vector(target_addr_width - native_max_addr_size - 1 downto 0);
        signal addrb_cmb  : std_logic_vector(target_addr_width - native_max_addr_size - 1 downto 0);
        signal addra_q    : std_logic_vector(target_addr_width - native_max_addr_size - 1 downto 0);
        signal addrb_q    : std_logic_vector(target_addr_width - native_max_addr_size - 1 downto 0);
        signal data_a     : ram_a_output;
        signal data_b     : ram_b_output;

      begin
        -- Extract module address.
        addra_cmb <= addra_i(addra_i'left downto addra_i'right + native_max_addr_size_a);
        addrb_cmb <= addrb_i(addrb_i'left downto addrb_i'right + native_max_addr_size_b);

        -- Instantiate all modules needed for the memory.
        The_RAM_INSTs : for J in 0 to num_ram_modules-1 generate
          signal wea_masked : std_logic_vector(C_WE_A_WIDTH-1 downto 0);
          signal web_masked : std_logic_vector(C_WE_B_WIDTH-1 downto 0);
        begin

          -- Generate local write enable
          wea_masked <= wea_i(C_WE_A_WIDTH-1 downto 0) when to_integer(unsigned(addra_cmb)) = J else (others=>'0');
          web_masked <= web_i(C_WE_B_WIDTH-1 downto 0) when to_integer(unsigned(addrb_cmb)) = J else (others=>'0');

          RAM_Inst: sc_ram_module
            generic map (
              C_TARGET          => C_TARGET,
              C_RECURSIVE_INST  => true,
              C_WE_A_WIDTH      => C_WE_A_WIDTH,
              C_DATA_A_WIDTH    => C_DATA_A_WIDTH,
              C_ADDR_A_WIDTH    => native_max_addr_size_a,
              C_WE_B_WIDTH      => C_WE_B_WIDTH,
              C_DATA_B_WIDTH    => C_DATA_B_WIDTH,
              C_ADDR_B_WIDTH    => native_max_addr_size_b,
              C_FORCE_BRAM      => C_FORCE_BRAM,
              C_FORCE_LUTRAM    => C_FORCE_LUTRAM)
            port map(
              -- PORT A
              CLKA      => CLKA,
              WEA       => wea_masked,
              ENA       => ENA,
              ADDRA     => addra_i(addra_i'right + native_max_addr_size_a - 1 downto addra_i'right),
              DATA_INA  => data_ina_ii(C_DATA_A_WIDTH - 1 downto 0),
              DATA_OUTA => data_a(J),
              -- PORT B
              CLKB      => CLKB,
              WEB       => web_masked,
              ENB       => ENB,
              ADDRB     => addrb_i(addrb_i'right + native_max_addr_size_b - 1 downto addrb_i'right),
              DATA_INB  => data_inb_ii(C_DATA_B_WIDTH - 1 downto 0),
              DATA_OUTB => data_b(J)
              );
        end generate The_RAM_INSTs;

        -- Clock address for multiplexing the delayed memory data.
        PortA : process(CLKA)
        begin
          if CLKA'event and CLKA = '1' then
            if ENA = '1' then
              addra_q <= addra_cmb;
            end if;
          end if;
        end process PortA;

        PortB : process(CLKB)
        begin
          if CLKB'event and CLKB = '1' then
            if ENB = '1' then
              addrb_q <= addrb_cmb;
            end if;
          end if;
        end process PortB;

        -- Multiplex data from memory.
        data_outa_ii  <= data_a(to_integer(unsigned(addra_q)));
        data_outb_ii  <= data_b(to_integer(unsigned(addrb_q)));

      end generate Recursive;

      Native : if (target_addr_width <= native_max_addr_size) generate
      begin
        -----------------------------------------------------------------------------
        -- BlockRAM 36kbit
        -----------------------------------------------------------------------------

        Using_B36_Sx : if (What_BRAM.What_Kind = B36_Sx) generate
          constant a_data_width     : natural := a_raw_data_width + a_raw_data_width/8;
          constant b_data_width     : natural := b_raw_data_width + b_raw_data_width/8;
          constant a_we_data_width  : natural := max_of(1, a_raw_data_width / 8);
          constant b_we_data_width  : natural := max_of(1, b_raw_data_width / 8);
          signal addra_ii : std_logic_vector(15 downto 0);
          signal addrb_ii : std_logic_vector(15 downto 0);

        begin

          Pad_RAMB36_Addresses : process (addra_i, addrb_i) is
            begin  -- process Pad_RAMB36_Addresses
              -- Address bit 15 is only used when BRAMs are cascaded
              addra_ii                              <= (others => '1');
              addra_ii(14-native_max_addr_size_a+C_ADDR_A_WIDTH downto 15-native_max_addr_size_a) <=
                addra_i(C_ADDR_A_WIDTH - 1 downto 0);
              addrb_ii                              <= (others => '1');
              addrb_ii(14-native_max_addr_size_b+C_ADDR_B_WIDTH downto 15-native_max_addr_size_b) <=
                addrb_i(C_ADDR_B_WIDTH - 1 downto 0);
          end process Pad_RAMB36_Addresses;

          The_BRAMs : for I in 0 to nr_of_brams-1 generate
            signal wea_ii : std_logic_vector( 3 downto 0);
            signal dia_i  : std_logic_vector(31 downto 0);
            signal diap_i : std_logic_vector( 3 downto 0);
            signal doa_i  : std_logic_vector(31 downto 0);
            signal doap_i : std_logic_vector( 3 downto 0);
            signal web_ii : std_logic_vector( 7 downto 0);
            signal dib_i  : std_logic_vector(31 downto 0);
            signal dibp_i : std_logic_vector( 3 downto 0);
            signal dob_i  : std_logic_vector(31 downto 0);
            signal dobp_i : std_logic_vector( 3 downto 0);
          begin

            Pad_RAMB36_Data : process (wea_i, web_i, data_ina_ii, data_inb_ii, data_inpa_ii, data_inpb_ii) is
            begin  -- process Pad_RAMB36_Data
              wea_ii          <= (others => '0');
              web_ii          <= (others => '0');
              dia_i           <= (others => '0');
              dib_i           <= (others => '0');
              diap_i          <= (others => '0');
              dibp_i          <= (others => '0');

              wea_ii(a_we_data_width - 1 downto 0)  <=
                wea_i(max_of((I+1)*a_raw_data_width/8 - 1, (I+0)*a_raw_data_width/8) downto
                                                                    (I+0)*a_raw_data_width/8);
              web_ii(b_we_data_width - 1 downto 0)  <=
                web_i(max_of((I+1)*b_raw_data_width/8 - 1, (I+0)*b_raw_data_width/8) downto
                                                                    (I+0)*b_raw_data_width/8);
              dia_i(a_raw_data_width - 1 downto 0)  <= data_ina_ii((I+1)*a_raw_data_width - 1 downto
                                                                   (I+0)*a_raw_data_width);
              dib_i(b_raw_data_width - 1 downto 0)  <= data_inb_ii((I+1)*b_raw_data_width - 1 downto
                                                                   (I+0)*b_raw_data_width);
              if ( using_parity ) then
                diap_i(a_we_data_width - 1 downto 0)  <=
                  data_inpa_ii(max_of((I+1)*a_raw_data_width/8 - 1, (I+0)*a_raw_data_width/8) downto
                                                                             (I+0)*a_raw_data_width/8);
                dibp_i(b_we_data_width - 1 downto 0)  <=
                  data_inpb_ii(max_of((I+1)*b_raw_data_width/8 - 1, (I+0)*b_raw_data_width/8) downto
                                                                             (I+0)*b_raw_data_width/8);
              end if;

              -- Disable bits depending on width.
              if( b_data_width > 18 ) then
                web_ii(7 downto 4)  <= (others => '0');
              elsif( b_data_width > 9 ) then
                web_ii(7 downto 2)  <= (others => '0');
              else
                web_ii(7 downto 1)  <= (others => '0');
              end if;
            end process Pad_RAMB36_Data;

            data_outa_ii((I+1)*a_raw_data_width - 1 downto (I+0)*a_raw_data_width) <=
                              doa_i(a_raw_data_width - 1 downto 0);

            data_outb_ii((I+1)*b_raw_data_width - 1 downto (I+0)*b_raw_data_width) <=
                              dob_i(b_raw_data_width - 1 downto 0);

            Parity_Bus: if ( using_parity ) generate
            begin
              data_outpa_ii(max_of((I+1)*a_raw_data_width/8 - 1, (I+0)*a_raw_data_width/8) downto
                                   (I+0)*a_raw_data_width/8) <= doap_i(max_of(a_raw_data_width/8 - 1, 0) downto 0);

              data_outpb_ii(max_of((I+1)*b_raw_data_width/8 - 1, (I+0)*b_raw_data_width/8) downto
                                   (I+0)*b_raw_data_width/8) <= dobp_i(max_of(b_raw_data_width/8 - 1, 0) downto 0);
            end generate Parity_Bus;

            RAMB36_I1: RAMB36E1
              generic map(
                 DOA_REG                    => 0,               -- [integer]
                 DOB_REG                    => 0,               -- [integer]
                 RAM_EXTENSION_A            => "NONE",          -- [string]
                 RAM_EXTENSION_B            => "NONE",          -- [string]
                 RAM_MODE                   => "TDP",           -- [string]
                 READ_WIDTH_A               => a_data_width,    -- [integer]
                 READ_WIDTH_B               => b_data_width,    -- [integer]
                 SIM_COLLISION_CHECK        => sim_check_mode,  -- [string]
                 SIM_DEVICE                 => "7SERIES",       -- [string]
                 WRITE_MODE_A               => write_mode,      -- [string]
                 WRITE_MODE_B               => write_mode,      -- [string]
                 WRITE_WIDTH_A              => a_data_width,    -- [integer]
                 WRITE_WIDTH_B              => b_data_width     -- [integer]
              )
              port map(
                 CASCADEOUTA                => open,            -- [out std_ulogic]
                 CASCADEOUTB                => open,            -- [out std_ulogic]
                 DBITERR                    => open,            -- [out std_ulogic]
                 DOADO                      => doa_i,           -- [out std_logic_vector(31 downto 0)]
                 DOBDO                      => dob_i,           -- [out std_logic_vector(31 downto 0)]
                 DOPADOP                    => doap_i,          -- [out std_logic_vector(3 downto 0)]
                 DOPBDOP                    => dobp_i,          -- [out std_logic_vector(3 downto 0)]
                 ECCPARITY                  => open,            -- [out std_logic_vector(7 downto 0)]
                 RDADDRECC                  => open,            -- [out std_logic_vector(8 downto 0)]
                 SBITERR                    => open,            -- [out std_ulogic]
                 ADDRARDADDR                => addra_ii,        -- [in std_logic_vector(15 downto 0)]
                 ADDRBWRADDR                => addrb_ii,        -- [in std_logic_vector(15 downto 0)]
                 CASCADEINA                 => '0',             -- [in std_ulogic]
                 CASCADEINB                 => '0',             -- [in std_ulogic]
                 CLKARDCLK                  => CLKA,            -- [in std_ulogic]
                 CLKBWRCLK                  => CLKB,            -- [in std_ulogic]
                 DIADI                      => dia_i,           -- [in std_logic_vector(31 downto 0)]
                 DIBDI                      => dib_i,           -- [in std_logic_vector(31 downto 0)]
                 DIPADIP                    => diap_i,          -- [in std_logic_vector(3 downto 0)]
                 DIPBDIP                    => dibp_i,          -- [in std_logic_vector(3 downto 0)]
                 ENARDEN                    => ENA,             -- [in std_ulogic]
                 ENBWREN                    => ENB,             -- [in std_ulogic]
                 INJECTDBITERR              => '0',             -- [in std_ulogic]
                 INJECTSBITERR              => '0',             -- [in std_ulogic]
                 REGCEAREGCE                => '1',             -- [in std_ulogic]
                 REGCEB                     => '1',             -- [in std_ulogic]
                 RSTRAMARSTRAM              => '0',             -- [in std_ulogic]
                 RSTRAMB                    => '0',             -- [in std_ulogic]
                 RSTREGARSTREG              => '0',             -- [in std_ulogic]
                 RSTREGB                    => '0',             -- [in std_ulogic]
                 WEA                        => wea_ii,          -- [in std_logic_vector(3 downto 0)]
                 WEBWE                      => web_ii           -- [in std_logic_vector(7 downto 0)]
              );
          end generate The_BRAMs;
        end generate Using_B36_Sx;


        -----------------------------------------------------------------------------
        -- BlockRAM 72kbit
        -----------------------------------------------------------------------------

        Using_B72_S1 : if (What_BRAM.What_Kind = B72_S1) generate
          signal addra_ii : std_logic_vector(15 downto 0);
          signal addrb_ii : std_logic_vector(15 downto 0);
        begin
          Pad_RAMB36_Addresses : process (addra_i, addrb_i) is
            begin  -- process Pad_RAMB36_Addresses
              -- Address bit 15 is only used when BRAMs are cascaded
              addra_ii                              <= (others => '1');
              addra_ii(15-native_max_addr_size_a+C_ADDR_A_WIDTH downto 16-native_max_addr_size_a) <=
                addra_i(C_ADDR_A_WIDTH - 1 downto 0);
              addrb_ii                              <= (others => '1');
              addrb_ii(15-native_max_addr_size_b+C_ADDR_B_WIDTH downto 16-native_max_addr_size_b) <=
                addrb_i(C_ADDR_B_WIDTH - 1 downto 0);
          end process Pad_RAMB36_Addresses;

          The_BRAMs : for I in 0 to nr_of_brams-1 generate
            signal wea_ii : std_logic_vector( 3 downto 0);
            signal dia_i  : std_logic_vector(31 downto 0);
            signal diap_i : std_logic_vector( 3 downto 0);
            signal doa_i  : std_logic_vector(31 downto 0);
            signal doap_i : std_logic_vector( 3 downto 0);

            signal web_ii : std_logic;
            signal web_iii: std_logic_vector( 7 downto 0);
            signal dib_i  : std_logic_vector(31 downto 0);
            signal dibp_i : std_logic_vector( 3 downto 0);
            signal dob_i  : std_logic_vector(31 downto 0);
            signal dobp_i : std_logic_vector( 3 downto 0);

            signal cascade_a    : std_logic;
            signal cascade_b    : std_logic;

          begin

            wea_ii          <= (others => wea_i(I/8));
            dia_i           <= "0000000000000000000000000000000" & data_ina_ii(I);
            diap_i          <= "0000";
            data_outa_ii(I) <= doa_i(0);

            web_ii          <= web_i(I/8);
            dib_i           <= "0000000000000000000000000000000" & data_inb_ii(I);
            dibp_i          <= "0000";
            data_outb_ii(I) <= dob_i(0);

            web_iii         <= "0000000" & web_ii;

            RAMB36_I1: RAMB36E1
              generic map(
                 DOA_REG                    => 0,               -- [integer]
                 DOB_REG                    => 0,               -- [integer]
                 RAM_EXTENSION_A            => "UPPER",         -- [string]
                 RAM_EXTENSION_B            => "UPPER",         -- [string]
                 RAM_MODE                   => "TDP",           -- [string]
                 READ_WIDTH_A               => 1,               -- [integer]
                 READ_WIDTH_B               => 1,               -- [integer]
                 SIM_COLLISION_CHECK        => sim_check_mode,  -- [string]
                 SIM_DEVICE                 => "7SERIES",       -- [string]
                 WRITE_MODE_A               => write_mode,      -- [string]
                 WRITE_MODE_B               => write_mode,      -- [string]
                 WRITE_WIDTH_A              => 1,               -- [integer]
                 WRITE_WIDTH_B              => 1                -- [integer]
              )
              port map(
                 CASCADEOUTA                => open,            -- [out std_ulogic]
                 CASCADEOUTB                => open,            -- [out std_ulogic]
                 DBITERR                    => open,            -- [out std_ulogic]
                 DOADO                      => doa_i,           -- [out std_logic_vector(31 downto 0)]
                 DOBDO                      => dob_i,           -- [out std_logic_vector(31 downto 0)]
                 DOPADOP                    => doap_i,          -- [out std_logic_vector(3 downto 0)]
                 DOPBDOP                    => dobp_i,          -- [out std_logic_vector(3 downto 0)]
                 ECCPARITY                  => open,            -- [out std_logic_vector(7 downto 0)]
                 RDADDRECC                  => open,            -- [out std_logic_vector(8 downto 0)]
                 SBITERR                    => open,            -- [out std_ulogic]
                 ADDRARDADDR                => addra_ii,        -- [in std_logic_vector(15 downto 0)]
                 ADDRBWRADDR                => addrb_ii,        -- [in std_logic_vector(15 downto 0)]
                 CASCADEINA                 => cascade_a,       -- [in std_ulogic]
                 CASCADEINB                 => cascade_b,       -- [in std_ulogic]
                 CLKARDCLK                  => CLKA,            -- [in std_ulogic]
                 CLKBWRCLK                  => CLKB,            -- [in std_ulogic]
                 DIADI                      => dia_i,           -- [in std_logic_vector(31 downto 0)]
                 DIBDI                      => dib_i,           -- [in std_logic_vector(31 downto 0)]
                 DIPADIP                    => diap_i,          -- [in std_logic_vector(3 downto 0)]
                 DIPBDIP                    => dibp_i,          -- [in std_logic_vector(3 downto 0)]
                 ENARDEN                    => ENA,             -- [in std_ulogic]
                 ENBWREN                    => ENB,             -- [in std_ulogic]
                 INJECTDBITERR              => '0',             -- [in std_ulogic]
                 INJECTSBITERR              => '0',             -- [in std_ulogic]
                 REGCEAREGCE                => '1',             -- [in std_ulogic]
                 REGCEB                     => '1',             -- [in std_ulogic]
                 RSTRAMARSTRAM              => '0',             -- [in std_ulogic]
                 RSTRAMB                    => '0',             -- [in std_ulogic]
                 RSTREGARSTREG              => '0',             -- [in std_ulogic]
                 RSTREGB                    => '0',             -- [in std_ulogic]
                 WEA                        => wea_ii,          -- [in std_logic_vector(3 downto 0)]
                 WEBWE                      => web_iii          -- [in std_logic_vector(7 downto 0)]
              );

            RAMB36_I2: RAMB36E1
              generic map(
                 DOA_REG                    => 0,               -- [integer]
                 DOB_REG                    => 0,               -- [integer]
                 RAM_EXTENSION_A            => "LOWER",         -- [string]
                 RAM_EXTENSION_B            => "LOWER",         -- [string]
                 RAM_MODE                   => "TDP",           -- [string]
                 READ_WIDTH_A               => 1,               -- [integer]
                 READ_WIDTH_B               => 1,               -- [integer]
                 SIM_COLLISION_CHECK        => sim_check_mode,  -- [string]
                 SIM_DEVICE                 => "7SERIES",       -- [string]
                 WRITE_MODE_A               => write_mode,      -- [string]
                 WRITE_MODE_B               => write_mode,      -- [string]
                 WRITE_WIDTH_A              => 1,               -- [integer]
                 WRITE_WIDTH_B              => 1                -- [integer]
              )
              port map(
                 CASCADEOUTA                => cascade_a,       -- [out std_ulogic]
                 CASCADEOUTB                => cascade_b,       -- [out std_ulogic]
                 DBITERR                    => open,            -- [out std_ulogic]
                 DOADO                      => open,            -- [out std_logic_vector(31 downto 0)]
                 DOBDO                      => open,            -- [out std_logic_vector(31 downto 0)]
                 DOPADOP                    => open,            -- [out std_logic_vector(3 downto 0)]
                 DOPBDOP                    => open,            -- [out std_logic_vector(3 downto 0)]
                 ECCPARITY                  => open,            -- [out std_logic_vector(7 downto 0)]
                 RDADDRECC                  => open,            -- [out std_logic_vector(8 downto 0)]
                 SBITERR                    => open,            -- [out std_ulogic]
                 ADDRARDADDR                => addra_ii,        -- [in std_logic_vector(15 downto 0)]
                 ADDRBWRADDR                => addrb_ii,        -- [in std_logic_vector(15 downto 0)]
                 CASCADEINA                 => '0',             -- [in std_ulogic]
                 CASCADEINB                 => '0',             -- [in std_ulogic]
                 CLKARDCLK                  => CLKA,            -- [in std_ulogic]
                 CLKBWRCLK                  => CLKB,            -- [in std_ulogic]
                 DIADI                      => dia_i,           -- [in std_logic_vector(31 downto 0)]
                 DIBDI                      => dib_i,           -- [in std_logic_vector(31 downto 0)]
                 DIPADIP                    => diap_i,          -- [in std_logic_vector(3 downto 0)]
                 DIPBDIP                    => dibp_i,          -- [in std_logic_vector(3 downto 0)]
                 ENARDEN                    => ENA,             -- [in std_ulogic]
                 ENBWREN                    => ENB,             -- [in std_ulogic]
                 INJECTDBITERR              => '0',             -- [in std_ulogic]
                 INJECTSBITERR              => '0',             -- [in std_ulogic]
                 REGCEAREGCE                => '1',             -- [in std_ulogic]
                 REGCEB                     => '1',             -- [in std_ulogic]
                 RSTRAMARSTRAM              => '0',             -- [in std_ulogic]
                 RSTRAMB                    => '0',             -- [in std_ulogic]
                 RSTREGARSTREG              => '0',             -- [in std_ulogic]
                 RSTREGB                    => '0',             -- [in std_ulogic]
                 WEA                        => wea_ii,          -- [in std_logic_vector(3 downto 0)]
                 WEBWE                      => web_iii          -- [in std_logic_vector(7 downto 0)]
              );

          end generate The_BRAMs;
        end generate Using_B72_S1;
      end generate Native;
    end generate Using_BRAM;


    -----------------------------------------------------------------------------
    -- Distributed LUTRAM
    -----------------------------------------------------------------------------

    Using_DistRAM : if (What_BRAM.What_Kind = DISTRAM) generate
      constant native_max_addr_size : integer := 7;
    begin
      Recursive : if (What_BRAM.Addr_size > native_max_addr_size) generate
        constant num_ram_modules : integer:= 2 ** ( What_BRAM.Addr_size - native_max_addr_size );
        type ram_output is array (0 to num_ram_modules - 1) of std_logic_vector(just_data_bits_size-1 downto 0);

        signal addra_cmb  : std_logic_vector(What_BRAM.Addr_size - native_max_addr_size - 1 downto 0);
        signal addrb_cmb  : std_logic_vector(What_BRAM.Addr_size - native_max_addr_size - 1 downto 0);
        signal addra_q    : std_logic_vector(What_BRAM.Addr_size - native_max_addr_size - 1 downto 0);
        signal addrb_q    : std_logic_vector(What_BRAM.Addr_size - native_max_addr_size - 1 downto 0);
        signal data_a     : ram_output;
        signal data_b     : ram_output;
      begin
        -- Extract module address.
        addra_cmb <= addra_i(addra_i'left downto addra_i'right + native_max_addr_size);
        addrb_cmb <= addrb_i(addrb_i'left downto addrb_i'right + native_max_addr_size);

        -- Instantiate all modules needed for the memory.
        The_RAM_INSTs : for J in 0 to num_ram_modules-1 generate
          signal wea_masked : std_logic_vector(C_WE_A_WIDTH-1 downto 0);
          signal web_masked : std_logic_vector(C_WE_B_WIDTH-1 downto 0);
        begin

          -- Generate local write enable
          wea_masked <= WEA(C_WE_A_WIDTH-1 downto 0) when to_integer(unsigned(addra_cmb)) = J else (others=>'0');
          web_masked <= WEB(C_WE_B_WIDTH-1 downto 0) when to_integer(unsigned(addrb_cmb)) = J else (others=>'0');

          RAM_Inst: sc_ram_module
            generic map (
              C_TARGET          => C_TARGET,
              C_RECURSIVE_INST  => true,
              C_DATA_A_WIDTH    => just_data_bits_size,
              C_WE_A_WIDTH      => C_WE_A_WIDTH,
              C_ADDR_A_WIDTH    => native_max_addr_size,
              C_DATA_B_WIDTH    => just_data_bits_size,
              C_WE_B_WIDTH      => C_WE_B_WIDTH,
              C_ADDR_B_WIDTH    => native_max_addr_size,
              C_FORCE_BRAM      => false,
              C_FORCE_LUTRAM    => true)
            port map(
              -- PORT A
              CLKA      => CLKA,
              WEA       => wea_masked,
              ENA       => ENA,
              ADDRA     => addra_i(addra_i'right + native_max_addr_size - 1 downto addra_i'right),
              DATA_INA  => data_ina_ii,
              DATA_OUTA => data_a(J),
              -- PORT B
              CLKB      => CLKB,
              WEB       => web_masked,
              ENB       => ENB,
              ADDRB     => addrb_i(addrb_i'right + native_max_addr_size - 1 downto addrb_i'right),
              DATA_INB  => data_inb_ii,
              DATA_OUTB => data_b(J)
              );
        end generate The_RAM_INSTs;

        -- Clock address for multiplexing the delayed memory data.
        PortA : process(CLKA)
        begin
          if CLKA'event and CLKA = '1' then
            if ENA = '1' then
              addra_q <= addra_cmb;
            end if;
          end if;
        end process PortA;

        PortB : process(CLKB)
        begin
          if CLKB'event and CLKB = '1' then
            if ENB = '1' then
              addrb_q <= addrb_cmb;
            end if;
          end if;
        end process PortB;

        -- Multiplex data from memory.
        data_outa_ii  <= data_a(to_integer(unsigned(addra_q)));
        data_outb_ii  <= data_b(to_integer(unsigned(addrb_q)));

      end generate Recursive;

      Native : if (What_BRAM.Addr_size <= native_max_addr_size) generate
        constant native_data_size : integer := just_data_bits_size / C_WE_B_WIDTH;
      begin
        The_DistRAMs : for I in 0 to C_WE_B_WIDTH-1 generate
        begin

          Block_DistRAM : block
            type RAM_Type is
              array (0 to 2**C_ADDR_B_WIDTH - 1) of std_logic_vector(native_data_size - 1 downto 0);

            signal RAM : RAM_Type := (others => (others=>'0'));

            attribute ram_style        : string;
            attribute ram_style of RAM : signal is "distributed";
          begin

            PortA : process(CLKA)
            begin
              if CLKA'event and CLKA = '1' then
                -- Assume that write port A is not used
                if ENA = '1' then
                  data_outa_ii((I+1)*native_data_size-1 downto I*native_data_size) <=
                    RAM(to_integer(unsigned(addra_i)));
                end if;
              end if;
            end process PortA;

            PortB : process(CLKB)
            begin
              if CLKB'event and CLKB = '1' then
                if ENB = '1' and WEB(I) = '1' then
                  RAM(to_integer(unsigned(addrb_i))) <=
                    data_inb_ii((I+1)*native_data_size-1 downto I*native_data_size);
                  data_outb_ii((I+1)*native_data_size-1 downto I*native_data_size) <=
                    RAM(to_integer(unsigned(addrb_i)));
                elsif ENB = '1' then
                  data_outb_ii((I+1)*native_data_size-1 downto I*native_data_size) <=
                    RAM(to_integer(unsigned(addrb_i)));
                end if;
              end if;
            end process PortB;

          end block Block_DistRAM;
        end generate The_DistRAMS;
      end generate Native;
    end generate Using_DistRAM;

  end generate Not_Using_XPM;

  Using_XPM : if Has_Target(C_Target, BRAM_XPM) generate

    -----------------------------------------------------------------------------
    -- Component declaration
    -----------------------------------------------------------------------------

    component xpm_memory_tdpram is
    generic (
      MEMORY_SIZE         : integer := 4096*32;
      MEMORY_PRIMITIVE    : string  := "auto";
      CLOCKING_MODE       : string  := "common_clock";
      ECC_MODE            : string  := "no_ecc";
      MEMORY_INIT_FILE    : string  := "none";
      MEMORY_INIT_PARAM   : string  := "";
      WAKEUP_TIME         : string  := "disable_sleep";
      MESSAGE_CONTROL     : integer :=  0;

      WRITE_DATA_WIDTH_A  : integer := 32;
      READ_DATA_WIDTH_A   : integer := 32;
      BYTE_WRITE_WIDTH_A  : integer :=  8;
      ADDR_WIDTH_A        : integer := 12;
      READ_RESET_VALUE_A  : string  := "0";
      READ_LATENCY_A      : integer :=  1;
      WRITE_MODE_A        : string  :=  "read_first";

      WRITE_DATA_WIDTH_B  : integer := 32;
      READ_DATA_WIDTH_B   : integer := 32;
      BYTE_WRITE_WIDTH_B  : integer :=  8;
      ADDR_WIDTH_B        : integer := 12;
      READ_RESET_VALUE_B  : string  := "0";
      READ_LATENCY_B      : integer :=  1;
      WRITE_MODE_B        : string  :=  "read_first"
    );
    port (
      -- Common module ports
      sleep              : in std_logic;

      -- Port A module ports
      clka               : in std_logic;
      rsta               : in std_logic;
      ena                : in std_logic;
      regcea             : in std_logic;
      wea                : in std_logic_vector(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A-1 downto 0);
      addra              : in std_logic_vector(ADDR_WIDTH_A-1 downto 0);
      dina               : in std_logic_vector(WRITE_DATA_WIDTH_A-1 downto 0);
      injectsbiterra     : in std_logic;
      injectdbiterra     : in std_logic;
      douta              : out std_logic_vector(READ_DATA_WIDTH_A-1 downto 0);
      sbiterra           : out std_logic;
      dbiterra           : out std_logic;

     -- Port B module ports
      clkb               : in std_logic;
      rstb               : in std_logic;
      enb                : in std_logic;
      regceb             : in std_logic;
      web                : in std_logic_vector(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B-1 downto 0);
      addrb              : in std_logic_vector(ADDR_WIDTH_B-1 downto 0);
      dinb               : in std_logic_vector(WRITE_DATA_WIDTH_B-1 downto 0);
      injectsbiterrb     : in std_logic;
      injectdbiterrb     : in std_logic;
      doutb              : out std_logic_vector(READ_DATA_WIDTH_B-1 downto 0);
      sbiterrb           : out std_logic;
      dbiterrb           : out std_logic
    );
    end component;


    -----------------------------------------------------------------------------
    -- Function declaration
    -----------------------------------------------------------------------------

    function memory_primitive (force_bram : boolean; force_lutram : boolean) return string is
    begin
      if force_bram then
        return "block";
      elsif force_lutram then
        return "distributed";
      else
        return "auto";
      end if;
    end function memory_primitive;

    function we_bits_size (data_width, we_width : natural) return natural is
    begin
      -- Only one WE: Keep WE Width
      if we_width = 1 then
        return we_width;
      end if;
      -- More data than 8 bits per WE: Use 1 WE per 9 bits data to utilize parity bit
      if (data_width + we_width - 1) / we_width > 8 then
        return (data_width + 8) / 9;
      end if;
      -- Less data than 8 bits per WE: Keep WE width
      return we_width;
    end function we_bits_size;

    function data_bits_size (data_width, we_width : natural) return natural is
    begin
      -- Only one WE: Keep data width
      if we_width = 1 then
        return data_width;
      end if;
      -- More data than 8 bits per WE: Extend data width to WE * 9 bits to utilize parity bit
      if (data_width + we_width - 1) / we_width > 8 then
        return 9 * we_bits_size(data_width, we_width);
      end if;
      -- Less data than 8 bits per WE: Extend data width to WE * 8 bits
      return 8 * we_width;
    end function data_bits_size;

    function data_in_align (signal data : std_logic_vector;
                            data_width, we_width : natural;
                            data_bits_size, we_bits_size : natural) return std_logic_vector is
      constant data_bits_per_we   : natural := data_width / we_width;
      constant result_bits_per_we : natural := data_bits_size / we_bits_size;
      variable result             : std_logic_vector(data_bits_size-1 downto 0) := (others => '0');
      variable result_index       : natural;
    begin
      for data_index in 0 to data_width - 1 loop
        result(result_index) := data(data_index);
        if result_index mod result_bits_per_we = data_bits_per_we - 1 then
          result_index := result_index + result_bits_per_we - data_bits_per_we + 1;
        else
          result_index := result_index + 1;
        end if;
      end loop;

      return result;
    end function data_in_align;

    function data_out_align (signal data : std_logic_vector;
                             data_width, we_width : natural;
                             data_bits_size, we_bits_size : natural) return std_logic_vector is
      constant result_bits_per_we : natural := data_width / we_width;
      constant data_bits_per_we   : natural := data_bits_size / we_bits_size;
      variable result             : std_logic_vector(data_width-1 downto 0) := (others => '0');
      variable data_index         : natural;
    begin
      for result_index in 0 to data_width - 1 loop
        result(result_index) := data(data_index);
        if data_index mod data_bits_per_we = result_bits_per_we - 1 then
          data_index := data_index + data_bits_per_we - result_bits_per_we + 1;
        else
          data_index := data_index + 1;
        end if;
      end loop;

      return result;
    end function data_out_align;

    function distribute(signal we : std_logic_vector; size : natural) return std_logic_vector is
      constant item_size : natural := size / we'length;
      variable result    : std_logic_vector(size - 1 downto 0);
    begin
      for I in we'range loop
        result(item_size * I + item_size - 1 downto item_size * I) := (others => we(I));
      end loop;

      return result;
    end function distribute;

    -----------------------------------------------------------------------------
    -- Constant declaration
    -----------------------------------------------------------------------------

    constant C_MEMORY_PRIMITIVE : string := memory_primitive(C_FORCE_BRAM, C_FORCE_LUTRAM);

    constant a_we_bits_size   : natural := we_bits_size(C_DATA_A_WIDTH, C_WE_A_WIDTH);
    constant a_data_bits_size : natural := data_bits_size(C_DATA_A_WIDTH, C_WE_A_WIDTH);

    constant b_we_bits_size   : natural := we_bits_size(C_DATA_B_WIDTH, C_WE_B_WIDTH);
    constant b_data_bits_size : natural := data_bits_size(C_DATA_B_WIDTH, C_WE_B_WIDTH);


    -----------------------------------------------------------------------------
    -- Signal declaration
    -----------------------------------------------------------------------------

    signal wea_i       : std_logic_vector(a_we_bits_size-1   downto 0);
    signal data_ina_i  : std_logic_vector(a_data_bits_size-1 downto 0);
    signal data_outa_i : std_logic_vector(a_data_bits_size-1 downto 0) := (others => '0');

    signal web_i       : std_logic_vector(b_we_bits_size-1   downto 0);
    signal data_inb_i  : std_logic_vector(b_data_bits_size-1 downto 0);
    signal data_outb_i : std_logic_vector(b_data_bits_size-1 downto 0) := (others => '0');

  begin  -- Using_XPM

    wea_i <= distribute(WEA, a_we_bits_size);
    web_i <= distribute(WEB, b_we_bits_size);

    data_ina_i <= data_in_align(DATA_INA, C_DATA_A_WIDTH, C_WE_A_WIDTH, a_data_bits_size, a_we_bits_size);
    data_inb_i <= data_in_align(DATA_INB, C_DATA_B_WIDTH, C_WE_B_WIDTH, b_data_bits_size, b_we_bits_size);

    DATA_OUTA  <= data_out_align(data_outa_i, C_DATA_A_WIDTH, C_WE_A_WIDTH, a_data_bits_size, a_we_bits_size);
    DATA_OUTB  <= data_out_align(data_outb_i, C_DATA_B_WIDTH, C_WE_B_WIDTH, b_data_bits_size, b_we_bits_size);

    xpm : xpm_memory_tdpram
      generic map (
        MEMORY_SIZE             => a_data_bits_size * 2**C_ADDR_A_WIDTH,
        MEMORY_PRIMITIVE        => C_MEMORY_PRIMITIVE,
        CLOCKING_MODE           => "common_clock",
        ECC_MODE                => "no_ecc",
        MEMORY_INIT_FILE        => "none",
        MEMORY_INIT_PARAM       => "",
        WAKEUP_TIME             => "disable_sleep",
        MESSAGE_CONTROL         => 0,

        WRITE_DATA_WIDTH_A      => a_data_bits_size,
        READ_DATA_WIDTH_A       => a_data_bits_size,
        BYTE_WRITE_WIDTH_A      => a_data_bits_size / a_we_bits_size,
        ADDR_WIDTH_A            => C_ADDR_A_WIDTH,
        READ_RESET_VALUE_A      => "0",
        READ_LATENCY_A          => 1,
        WRITE_MODE_A            => write_mode,

        WRITE_DATA_WIDTH_B      => b_data_bits_size,
        READ_DATA_WIDTH_B       => b_data_bits_size,
        BYTE_WRITE_WIDTH_B      => b_data_bits_size / b_we_bits_size,
        ADDR_WIDTH_B            => C_ADDR_B_WIDTH,
        READ_RESET_VALUE_B      => "0",
        READ_LATENCY_B          => 1,
        WRITE_MODE_B            => write_mode
      )
      port map (
        -- Common module ports
        sleep                   =>  '0',

        -- Port A module ports
        clka                    => CLKA,
        rsta                    => '0',
        ena                     => ENA,
        regcea                  => '1',
        wea                     => wea_i,
        addra                   => ADDRA,
        dina                    => data_ina_i,
        injectsbiterra          => '0',
        injectdbiterra          => '0',
        douta                   => data_outa_i,
        sbiterra                => open,
        dbiterra                => open,

        -- Port B module ports
        clkb                    => CLKB,
        rstb                    => '0',
        enb                     => ENB,
        regceb                  => '1',
        web                     => web_i,
        addrb                   => ADDRB,
        dinb                    => data_inb_i,
        injectsbiterrb          => '0',
        injectdbiterrb          => '0',
        doutb                   => data_outb_i,
        sbiterrb                => open,
        dbiterrb                => open
      );
  end generate Using_XPM;

end architecture IMP;


-------------------------------------------------------------------------------
-- sc_lru_module.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        lru.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              lru.vhd
--
-------------------------------------------------------------------------------
-- Author:          goran
--
-- History:
--   goran  2008-10-20    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity sc_lru_calculate is
  generic (
    C_TREE_SIZE       : natural := 2;
    C_LINE_SIZE_LOG2  : natural := 2
  );
  port (
    Used_Line     : in  std_logic_vector(C_LINE_SIZE_LOG2-1 downto 0);
    Current_Tree  : in  std_logic_vector(C_TREE_SIZE-1 downto 0);
    Base_Tree     : in  std_logic_vector(C_TREE_SIZE-1 downto 0);
    New_Tree      : out std_logic_vector(C_TREE_SIZE-1 downto 0);
    LRU           : out std_logic_vector(C_LINE_SIZE_LOG2-1 downto 0)
  );
end entity sc_lru_calculate;

architecture RTL of sc_lru_calculate is

begin  -- architecture sc_lru_calculate

  ---------------------------------------------------------------------------------------------------
  -- With two lines, it's always the other line from the MRU that is the LRU
  ---------------------------------------------------------------------------------------------------
  Two_Lines: if (C_LINE_SIZE_LOG2 = 1) generate
  begin
   
    New_Tree(0) <= not(Used_Line(0));
    LRU(0) <= Current_Tree(0);
   
  end generate Two_Lines;

  --------------------------------------------------------------------------------------------------
  -- With four lines, start using pseudo-lru binary algorithm
  -- Maintain a binary tree stored in 3 bits
  --        0
  --      /  \
  --     1    2
  --------------------------------------------------------------------------------------------------
  Four_Lines: if (C_LINE_SIZE_LOG2 = 2) generate
  begin

    Update_Bin_Tree: process (Used_Line, Base_Tree) is
    begin  -- process Update_Bin_Tree
      New_Tree    <= Base_Tree;
    
      New_Tree(0) <= not(Used_Line(0));
      if (Used_Line(0) = '0') then
        New_Tree(1) <= not(Used_Line(1));
      else
        New_Tree(2) <= not(Used_Line(1));
      end if;
    end process Update_Bin_Tree;
    
    LRU(0) <= Current_Tree(0);
    LRU(1) <= Current_Tree(1) when Current_Tree(0) = '0' else Current_Tree(2);

  end generate Four_Lines;

  --------------------------------------------------------------------------------------------------
  -- With eight lines, start using pseudo-lru binary algorithm
  -- Maintain a binary tree stored in 7 bits
  --               0
  --            /    \
  --           1      4
  --         /  \    /  \
  --        2   3   5   6
  --------------------------------------------------------------------------------------------------
  Eight_Lines: if (C_LINE_SIZE_LOG2 = 3) generate
  begin

    Update_Bin_Tree: process (Used_Line, Base_Tree) is
    begin  -- process Update_Bin_Tree
      New_Tree    <= Base_Tree;
    
      New_Tree(0) <= not(Used_Line(0));
      if (Used_Line(0) = '0') then
        New_Tree(1) <= not(Used_Line(1));
        if (Used_Line(1) = '0') then
          New_Tree(2) <= not Used_Line(2);
        else
          New_Tree(3) <= not Used_Line(2);                
        end if;
      else
        New_Tree(4) <= not(Used_Line(1));
        if (Used_Line(1) = '0') then
          New_Tree(5) <= not Used_Line(2);
        else
          New_Tree(6) <= not Used_Line(2);                
        end if;
      end if;            
    end process Update_Bin_Tree;
        
    LRU(0) <= Current_Tree(0);
    LRU(1) <= Current_Tree(1) when Current_Tree(0) = '0' else Current_Tree(4);
    LRU(2) <= Current_Tree(2) when (Current_Tree(0) = '0' and Current_Tree(1) = '0') else
              Current_Tree(3) when (Current_Tree(0) = '0' and Current_Tree(1) = '1') else
              Current_Tree(5) when (Current_Tree(0) = '1' and Current_Tree(4) = '0') else
              Current_Tree(6);

  end generate Eight_Lines;

  --------------------------------------------------------------------------------------------------
  -- With sixteen lines, start using pseudo-lru binary algorithm
  -- Maintain a binary tree stored in 15 bits
  --                0
  --            /      \
  --           1         8
  --        /   \      /   \
  --      2     5     9     12
  --     / \   / \   / \   / \
  --    3  4  6  7  10 11 13 14
  --------------------------------------------------------------------------------------------------
  
  Sixteen_Lines: if (C_LINE_SIZE_LOG2 = 4) generate
  begin
  
    Update_Bin_Tree: process (Used_Line, Base_Tree) is
    begin  -- process Update_Bin_Tree
      New_Tree    <= Base_Tree;
    
      New_Tree(0) <= not(Used_Line(0));
      if (Used_Line(0) = '0') then
        New_Tree(1) <= not(Used_Line(1));
        if (Used_Line(1) = '0') then
          New_Tree(2) <= not Used_Line(2);
          if (Used_Line(2) = '0') then
            New_Tree(3) <= not Used_Line(3);
          else
            New_Tree(4) <= not Used_Line(3);
          end if;
        else
          New_Tree(5) <= not Used_Line(2);                
          if (Used_Line(2) = '0') then
            New_Tree(6) <= not Used_Line(3);
          else
            New_Tree(7) <= not Used_Line(3);                
          end if;
        end if;
      else
        New_Tree(8) <= not(Used_Line(1));
        if (Used_Line(1) = '0') then
          New_Tree(9) <= not Used_Line(2);
          if (Used_Line(2) = '0') then
            New_Tree(10) <= not Used_Line(3);
          else
            New_Tree(11) <= not Used_Line(3);                
          end if;
        else
          New_Tree(12) <= not Used_Line(2);                
          if (Used_Line(2) = '0') then
            New_Tree(13) <= not Used_Line(3);
          else
            New_Tree(14) <= not Used_Line(3);                
          end if;
        end if;
      end if;            
    end process Update_Bin_Tree;
        
    LRU(0) <= Current_Tree(0);
    LRU(1) <= Current_Tree(1)  when Current_Tree(0) = '0' else 
              Current_Tree(8);
    LRU(2) <= Current_Tree(2)  when (Current_Tree(0) = '0' and Current_Tree(1) = '0') else
              Current_Tree(5)  when (Current_Tree(0) = '0' and Current_Tree(1) = '1') else
              Current_Tree(9)  when (Current_Tree(0) = '1' and Current_Tree(8) = '0') else
              Current_Tree(12);
    LRU(3) <= Current_Tree(3)  when (Current_Tree(0) = '0' and Current_Tree(1) = '0' and Current_Tree(2)  = '0') else
              Current_Tree(4)  when (Current_Tree(0) = '0' and Current_Tree(1) = '0' and Current_Tree(2)  = '1') else
              Current_Tree(6)  when (Current_Tree(0) = '0' and Current_Tree(1) = '1' and Current_Tree(5)  = '0') else
              Current_Tree(7)  when (Current_Tree(0) = '0' and Current_Tree(1) = '1' and Current_Tree(5)  = '1') else
              Current_Tree(10) when (Current_Tree(0) = '1' and Current_Tree(8) = '0' and Current_Tree(9)  = '0') else
              Current_Tree(11) when (Current_Tree(0) = '1' and Current_Tree(8) = '0' and Current_Tree(9)  = '1') else
              Current_Tree(13) when (Current_Tree(0) = '1' and Current_Tree(8) = '1' and Current_Tree(12) = '0') else
              Current_Tree(14);
  end generate Sixteen_Lines;

end architecture RTL;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


entity sc_lru_module is
  generic (
    C_TARGET        : TARGET_FAMILY_TYPE;
    C_ADDR_SIZE_LOG2          : natural := 5;
    C_LINE_SIZE_LOG2          : natural := 2
  );
  port (
    -- Global signals.
    Clk                       : in  std_logic;
    Reset                     : in  std_logic;
    
    -- Pipe control.
    lookup_fetch_piperun      : in  std_logic;
    lookup_mem_piperun        : in  std_logic;
    
    -- Peek LRU.
    lru_fetch_line_addr       : in  std_logic_vector(C_ADDR_SIZE_LOG2 - 1 downto 0);
    lru_check_next_way        : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
    lru_check_next_hot_way    : out std_logic_vector(2**C_LINE_SIZE_LOG2 - 1 downto 0);
    
    -- Control LRU.
    lru_check_use_lru         : in  std_logic;
    lru_check_line_addr       : in  std_logic_vector(C_ADDR_SIZE_LOG2 - 1 downto 0);
    lru_check_used_way        : in  std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
    
    -- After refresh.
    lru_update_prev_lru_way   : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
    lru_update_new_lru_way    : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0)
  );
end entity sc_lru_module;

architecture IMP of sc_lru_module is

  constant C_TREE_SIZE  : natural := 2 ** C_LINE_SIZE_LOG2 - 1;
  
  constant C_LRU_FORCE_BRAM           : boolean := C_ADDR_SIZE_LOG2 >= 7;
  
  component sc_lru_calculate is
    generic (
      C_TREE_SIZE      : natural := 2;
      C_LINE_SIZE_LOG2 : natural := 2
    );
    port (
      Used_Line     : in  std_logic_vector(C_LINE_SIZE_LOG2-1 downto 0);
      Current_Tree  : in  std_logic_vector(C_TREE_SIZE-1 downto 0);
      Base_Tree     : in  std_logic_vector(C_TREE_SIZE-1 downto 0);
      New_Tree      : out std_logic_vector(C_TREE_SIZE-1 downto 0);
      LRU           : out std_logic_vector(C_LINE_SIZE_LOG2-1 downto 0)
    );
  end component sc_lru_calculate;
  
  component sc_ram_module is
    generic (
      C_TARGET        : TARGET_FAMILY_TYPE;
      C_WE_A_WIDTH    : positive              := 1;
      C_DATA_A_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_A_WIDTH  : natural range 1 to 18 := 11;
      C_WE_B_WIDTH    : positive              := 1;
      C_DATA_B_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_B_WIDTH  : natural range 1 to 18 := 11;
      C_FORCE_BRAM    : boolean               := true;
      C_FORCE_LUTRAM  : boolean               := false
    );
    port (
      -- PORT A
      CLKA            : in  std_logic;
      ENA             : in  std_logic;
      WEA             : in  std_logic_vector(C_WE_A_WIDTH-1 downto 0);
      ADDRA           : in  std_logic_vector(C_ADDR_A_WIDTH-1 downto 0);
      DATA_INA        : in  std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      DATA_OUTA       : out std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      -- PORT B
      CLKB            : in  std_logic;
      ENB             : in  std_logic;
      WEB             : in  std_logic_vector(C_WE_B_WIDTH-1 downto 0);
      ADDRB           : in  std_logic_vector(C_ADDR_B_WIDTH-1 downto 0);
      DATA_INB        : in  std_logic_vector(C_DATA_B_WIDTH-1 downto 0);
      DATA_OUTB       : out std_logic_vector(C_DATA_B_WIDTH-1 downto 0)
    );
  end component sc_ram_module;
  
  -- RAM type and signal
  subtype TREE_TYPE   is std_logic_vector(C_TREE_SIZE-1 downto 0);
  type RAM_Type       is array (0 to 2**C_ADDR_SIZE_LOG2-1) of TREE_TYPE;
  signal RAM          : RAM_Type:= (others=>(others=>'0'));
  attribute ram_style : string;
  attribute ram_style of RAM : signal is "distributed";

  signal mem_current_tree     : TREE_TYPE;
  
  signal check_current_tree   : TREE_TYPE;
  signal lru_check_next_way_i : std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
  
  signal update_current_tree  : TREE_TYPE;
  
  signal new_tree             : TREE_TYPE;
  signal next_way             : std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
  signal lru_check_use_lru_i  : std_logic_vector(0 downto 0);
  
begin  -- architecture IMP

  Calc_LRU: sc_lru_calculate 
    generic map(
      C_TREE_SIZE      => C_TREE_SIZE,
      C_LINE_SIZE_LOG2 => C_LINE_SIZE_LOG2
    )
    port map(
      Used_Line     => lru_check_used_way,
      Current_Tree  => mem_current_tree,
      Base_Tree     => check_current_tree,
      New_Tree      => new_tree,
      LRU           => next_way
    );
  
  lru_check_use_lru_i <= (others=>lru_check_use_lru);
  
  LRU: sc_ram_module 
    generic map(
      C_TARGET                  => C_TARGET,
      C_WE_A_WIDTH              => 1,
      C_DATA_A_WIDTH            => C_TREE_SIZE,
      C_ADDR_A_WIDTH            => C_ADDR_SIZE_LOG2,
      C_WE_B_WIDTH              => 1,
      C_DATA_B_WIDTH            => C_TREE_SIZE,
      C_ADDR_B_WIDTH            => C_ADDR_SIZE_LOG2,
      C_FORCE_BRAM              => C_LRU_FORCE_BRAM,
      C_FORCE_LUTRAM            => false
    )
    port map(
      -- PORT A
      CLKA                      => Clk,
      ENA                       => lookup_fetch_piperun,
      WEA                       => (others=>'0'),
      ADDRA                     => lru_fetch_line_addr,
      DATA_INA                  => (others=>'0'),
      DATA_OUTA                 => mem_current_tree,
      -- PORT B
      CLKB                      => Clk,
      ENB                       => lru_check_use_lru,
      WEB                       => lru_check_use_lru_i,
      ADDRB                     => lru_check_line_addr,
      DATA_INB                  => new_tree,
      DATA_OUTB                 => open
    );
  
  -- Clock generated number.
  Data_Register: process (Clk) is
  begin  -- process Data_Register
    if Clk'event and Clk = '1' then     -- rising clock edge
      if( Reset = '1' ) then
        lru_check_next_way_i    <= (others=>'0');
        lru_check_next_hot_way  <= (others=>'0');
        
      elsif( lookup_mem_piperun = '1' ) then
        lru_check_next_way_i    <= next_way;
        lru_check_next_hot_way  <= std_logic_vector(to_unsigned(2**to_integer(unsigned(next_way)), 
                                                                2**C_LINE_SIZE_LOG2));
      end if;
    end if;
  end process Data_Register;
  
  lru_check_next_way  <= lru_check_next_way_i;
  
  -- Clock generated number.
  Pipeline_Register: process (Clk) is
  begin  -- process Pipeline_Register
    if Clk'event and Clk = '1' then     -- rising clock edge
      if( Reset = '1' ) then
        check_current_tree    <= (others=>'0');
        
      elsif( lookup_mem_piperun = '1' ) then
        check_current_tree  <= mem_current_tree;
        
      end if;
    end if;
  end process Pipeline_Register;
  
  -- Clock generated new tree.
  Pipeline_Register_2: process (Clk) is
  begin  -- process Pipeline_Register_2
    if Clk'event and Clk = '1' then     -- rising clock edge
      if( Reset = '1' ) then
        lru_update_prev_lru_way <= (others=>'0');
        update_current_tree     <= (others=>'0');
        
      elsif( lru_check_use_lru = '1' ) then
        lru_update_prev_lru_way <= lru_check_next_way_i;
        update_current_tree     <= new_tree;
        
      end if;
    end if;
  end process Pipeline_Register_2;
  
  Calc_New_LRU: sc_lru_calculate 
    generic map(
      C_TREE_SIZE      => C_TREE_SIZE,
      C_LINE_SIZE_LOG2 => C_LINE_SIZE_LOG2
    )
    port map(
      Used_Line     => (lru_check_used_way'range=>'0'),
      Current_Tree  => update_current_tree,
      Base_Tree     => update_current_tree,
      New_Tree      => open,
      LRU           => lru_update_new_lru_way
    );
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_update.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_update.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_update.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_update is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
    C_NUM_WAYS                : natural range  1 to    8      :=  2;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    
    -- Data type and settings specific.
    C_TAG_SIZE                : natural range  3 to   63      := 15;
    C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_EXT_DATA_HI        : natural range  2 to   63      := 14;
    C_ADDR_EXT_DATA_LO        : natural range  2 to   63      :=  2;
    C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
    C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
    C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
    C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
    C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
    C_ADDR_EXT_BYTE_HI        : natural range  0 to   63      :=  1;
    C_ADDR_EXT_BYTE_LO        : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
    C_WAY_BIT_LO              : natural range  0 to    0      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- Access signals.
    
    access_valid              : in  std_logic;
    
    access_data_info          : in  DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
  
    
    -- ---------------------------------------------------
    -- Lookup signals.
    
    -- Tag Addr Check.
    lookup_new_addr           : in  AXI_ADDR_TYPE;
    lookup_stall_addr         : in  AXI_ADDR_TYPE;
    
    -- Write Miss
    lookup_push_write_miss    : in  std_logic;
    lookup_wm_allocate        : in  std_logic;
    lookup_wm_evict           : in  std_logic;
    lookup_wm_will_use        : in  std_logic;
    lookup_wm_info            : in  ACCESS_TYPE;
    lookup_wm_use_bits        : in  std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
    lookup_wm_stp_bits        : in  std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
    lookup_wm_allow_write     : in  std_logic;
    lookup_wm_create          : in  std_logic;
    
    -- Update transaction.
    update_valid              : in  std_logic;
    update_way                : in  natural range C_NUM_WAYS - 1 downto 0;
    update_info               : in  ACCESS_TYPE;
    update_hit                : in  std_logic;
    update_miss               : in  std_logic;
    update_read_hit           : in  std_logic;
    update_read_miss          : in  std_logic;
    update_read_miss_dirty    : in  std_logic;
    update_write_hit          : in  std_logic;
    update_write_miss         : in  std_logic;
    update_write_miss_dirty   : in  std_logic;
    update_locked_write_hit   : in  std_logic;
    update_locked_read_hit    : in  std_logic;
    update_first_write_hit    : in  std_logic;
    update_evict_hit          : in  std_logic;
    update_exclusive_hit      : in  std_logic;
    update_create_bresp       : in  std_logic;
    update_early_bresp        : in  std_logic;
    update_failed_allocation  : in  std_logic;
    update_whl_rejected       : in  std_logic;
    update_snoop_made_clean   : in  std_logic;
    update_snoop_made_shared  : in  std_logic;
    update_snoop_made_invalid : in  std_logic;
    update_snoop_altered_delayed_txn : in  std_logic;
    update_snoop_made_txn_clean      : in  std_logic;
    update_snoop_made_txn_shared     : in  std_logic;
    update_snoop_made_txn_invalid    : in  std_logic;
    update_need_bs            : in  std_logic;
    update_need_ar            : in  std_logic;
    update_need_aw            : in  std_logic;
    update_need_evict         : in  std_logic;
    update_need_tag_write     : in  std_logic;
    update_inserted_trans     : in  std_logic;
    update_reused_tag         : in  std_logic;
    update_old_tag            : in  WAY_LINE_TAG_TYPE;
    update_refreshed_lru      : in  std_logic;
    update_all_tags           : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    update_inserted_rd_done   : out std_logic;
    update_inserted_ex_ok     : out std_logic;
    update_inserted_wr_done   : out std_logic;
    update_pushing_writeunique: out std_logic;
    update_pushing_writeback  : out std_logic;
    update_lock_release       : out std_logic;
    update_lock_way           : out natural range C_NUM_WAYS - 1 downto 0;
    update_release_tag        : out WAY_LINE_TAG_TYPE;
    
    update_whl_pop            : out std_logic;
    update_whl_exist          : in  std_logic;
    update_whl_strb           : in  std_logic_vector(C_CACHE_LINE_LENGTH * 32/8 - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- LRU signals.
    
    lru_update_prev_lru_way   : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
    lru_update_new_lru_way    : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
    
    
    -- ---------------------------------------------------
    -- Automatic Clean Information.
    
    update_auto_clean_push    : out std_logic;
    update_auto_clean_addr    : out AXI_ADDR_TYPE;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_update_done          : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Backend signals.
    
    backend_wr_resp_info      : in  WRITE_RESP_TYPE;
    backend_wr_resp_ready     : out std_logic;
    backend_wr_resp_conf      : out WRITE_CONF_TYPE;
    
    backend_rd_data_info      : in  READ_RESP_TYPE;
    backend_rd_data_ready     : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Update signals (to Frontend).
    
    -- Read miss
    update_read_data_info     : out READ_MISS_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    update_read_data_ready    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    -- Write Miss
    update_write_data_ready   : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    -- Write miss response
    update_ext_bresp_info     : out WRITE_RESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    update_ext_bresp_ready    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (to Lookup).
    
    update_tag_conflict       : out std_logic;
    update_piperun            : out std_logic;
    
    update_write_miss_full    : out std_logic;
    update_write_miss_busy    : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    update_allocate_conflict  : out std_logic;
    update_allocate_error     : out std_logic;
    
    update_error_freeze       : out std_logic;
    update_error_evict_insert : out std_logic;
    update_error_evict_way    : out natural range C_NUM_WAYS - 1 downto 0;
    update_error_evict_info   : out ACCESS_TYPE;
    update_error_wait         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Update signals (to Tag & Data).
    
    update_tag_addr           : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
    update_tag_en             : out std_logic;
    update_tag_we             : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
    update_tag_new_word       : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    update_tag_current_word   : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    
    update_data_addr          : out std_logic_vector(C_ADDR_EXT_DATA_HI downto C_ADDR_EXT_DATA_LO);
    update_data_en            : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
    update_data_we            : out std_logic_vector(0 downto 0);
    update_data_new_word      : out std_logic_vector(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
    update_data_current_word  : in  AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
    
    ud_snoop_tag_addr         : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
    ud_snoop_tag_en           : out std_logic;
    ud_snoop_tag_we           : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
    ud_snoop_tag_new_word     : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    ud_snoop_tag_current_word : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (to Backend).
    
    read_req_info             : out READ_REQ_TYPE;
    read_req_ready            : in  std_logic;
    
    write_req_info            : out WRITE_REQ_TYPE;
    write_req_ready           : in  std_logic;
    
    write_data_info           : out DATA_PORT_TYPE;
    write_data_ready          : in  std_logic;
    write_data_almost_full    : in  std_logic;
    write_data_full           : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Master Snoop Interface Signals.
    
    mst_snoop_fetch_piperun   : in  std_logic;
    mst_snoop_fetch_info      : in  MST_SNOOP_REQ_TYPE;
    mst_snoop_mem_piperun     : in  std_logic;
    mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
    mst_snoop_check_piperun   : in  std_logic;
    mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
    
    mst_snoop_fetch_ack_info  : out RMST_SNOOP_ACK_TYPE;
    mst_snoop_mem_ack_info    : out RMST_SNOOP_ACK_TYPE;
    mst_snoop_check_ack_info  : out RMST_SNOOP_ACK_TYPE;
    mst_snoop_update_ack_info : out RMST_SNOOP_ACK_TYPE;
    
    mst_core_update_hazard    : out RMST_SNOOP_HAZ_TYPE;
    
    mst_snoop_mem_rm_alloc    : out std_logic;
    mst_snoop_check_rm_alloc  : out std_logic;
    
    mst_snoop_tag_valid       : in  std_logic;
    mst_snoop_tag_way         : in  natural range C_NUM_WAYS - 1 downto 0;
    mst_snoop_tag_info        : in  WAY_LINE_TAG_TYPE;
    mst_snoop_tag_stall       : out std_logic;
    
    mst_snoop_sdr_push        : in  std_logic;
    mst_snoop_sdr_info        : in  MST_SNOOP_ADDR_TYPE;
    mst_snoop_sdr_empty       : out std_logic;
    mst_snoop_sdr_full        : out std_logic;
    
    mst_core_update_data_info : out MST_SNOOP_DATA_TYPE;
    mst_core_update_data_ready: in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_ud_stall             : out STAT_POINT_TYPE;    -- Time transactions are stalled
    stat_ud_tag_free          : out STAT_POINT_TYPE;    -- Cycles tag is free
    stat_ud_data_free         : out STAT_POINT_TYPE;    -- Cycles data is free
    stat_ud_ri                : out STAT_FIFO_TYPE;     -- Read Information
    stat_ud_r                 : out STAT_FIFO_TYPE;     -- Read data (optional)
    stat_ud_e                 : out STAT_FIFO_TYPE;     -- Evict
    stat_ud_bs                : out STAT_FIFO_TYPE;     -- BRESP Source
    stat_ud_wm                : out STAT_FIFO_TYPE;     -- Write Miss
    stat_ud_wma               : out STAT_FIFO_TYPE;     -- Write Miss Allocate (reserved)
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    UPDATE_DEBUG1             : out MAX_DEBUG_TYPE;
    UPDATE_DEBUG2             : out MAX_DEBUG_TYPE
  );
end entity sc_update;

library IEEE;
use IEEE.numeric_std.all;

architecture IMP of sc_update is

  
  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_RI_QUEUE_ERROR            : natural :=  0;
  constant C_ASSERT_R_QUEUE_ERROR             : natural :=  1;
  constant C_ASSERT_E_QUEUE_ERROR             : natural :=  2;
  constant C_ASSERT_BS_QUEUE_ERROR            : natural :=  3;
  constant C_ASSERT_WM_QUEUE_ERROR            : natural :=  4;
  constant C_ASSERT_WMA_QUEUE_ERROR           : natural :=  5;
  constant C_ASSERT_WMAD_QUEUE_ERROR          : natural :=  6;
  constant C_ASSERT_NO_RI_INFO                : natural :=  7;
  constant C_ASSERT_NO_BS_INFO                : natural :=  8;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  9;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_NATIVE_SIZE_BITS         : std_logic_vector(C_ADDR_WORD_HI downto C_ADDR_BYTE_LO) :=
                                                   std_logic_vector(to_unsigned((C_EXTERNAL_DATA_WIDTH/8) - 1, 
                                                   C_ADDR_WORD_HI - C_ADDR_BYTE_LO + 1));
  
  constant C_RRESP_WIDTH              : integer := sel(is_slv_coherent(C_ENABLE_COHERENCY), 4, 2);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  type BS_SRC_ACTION_TYPE             is (Src_End, Src_WMA, Src_Ext, Src_WMA_Ext);
  type BS_SLAVE_ACTION_TYPE           is (Slv_None, Slv_Propagate);
  type BS_MASTER_ACTION_TYPE          is (Mst_Drop, Mst_Propagate);
  
  -- Data related.
  subtype C_TAG_POS                   is natural range C_TAG_SIZE - 1                 downto 0;
  subtype C_BE_POS                    is natural range C_CACHE_DATA_WIDTH/8 - 1       downto 0;
  subtype C_DATA_POS                  is natural range C_CACHE_DATA_WIDTH - 1         downto 0;
  subtype C_CACHE_DATA_ADDR_POS       is natural range C_CACHE_DATA_ADDR_WIDTH - 1    downto 0;
  subtype C_EXT_BE_POS                is natural range C_EXTERNAL_DATA_WIDTH/8 - 1    downto 0;
  subtype C_EXT_DATA_POS              is natural range C_EXTERNAL_DATA_WIDTH - 1      downto 0;
  subtype C_EXT_DATA_ADDR_POS         is natural range C_EXTERNAL_DATA_ADDR_WIDTH - 1 downto 0;
  subtype C_RRESP_POS                 is natural range C_RRESP_WIDTH - 1              downto 0;
  subtype TAG_TYPE                    is std_logic_vector(C_TAG_POS);
  subtype BE_TYPE                     is std_logic_vector(C_BE_POS);
  subtype DATA_TYPE                   is std_logic_vector(C_DATA_POS);
  subtype EXT_BE_TYPE                 is std_logic_vector(C_EXT_BE_POS);
  subtype EXT_DATA_TYPE               is std_logic_vector(C_EXT_DATA_POS);
  subtype RRESP_TYPE                  is std_logic_vector(C_RRESP_POS);
  
  -- Line related.
  constant C_CACHE_LINE_WORDS         : integer:= 32 * C_CACHE_LINE_LENGTH / C_CACHE_DATA_WIDTH;
  subtype C_CACHE_WORD_POS            is natural range C_CACHE_LINE_WORDS - 1         downto 0;
  type CACHE_LINE_BE_TYPE             is array(C_CACHE_WORD_POS) of BE_TYPE;
  
  -- Port related.
  subtype C_PORT_POS                  is natural range C_NUM_PORTS - 1 downto 0;
  subtype C_INT_PORT_POS              is natural range C_NUM_INTERNAL_PORTS - 1 downto 0;
  subtype PORT_TYPE                   is std_logic_vector(C_PORT_POS);
  subtype INT_PORT_TYPE               is std_logic_vector(C_INT_PORT_POS);
  type PORT_BE_TYPE                   is array(C_PORT_POS) of BE_TYPE;
  type PORT_DATA_TYPE                 is array(C_PORT_POS) of DATA_TYPE;
  
  -- Set related.
  subtype C_WAY_POS                   is natural  range C_NUM_WAYS - 1          downto 0;
  subtype C_WAY_BIT_POS               is natural  range C_WAY_BIT_HI            downto C_WAY_BIT_LO;
  
  subtype WAY_TYPE                    is std_logic_vector(C_WAY_POS);
  
  type SET_EXT_DATA_TYPE              is array(C_WAY_POS) of EXT_DATA_TYPE;
  
  -- Address related.
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI   downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  subtype C_ADDR_EXT_DATA_POS         is natural range C_ADDR_EXT_DATA_HI   downto C_ADDR_EXT_DATA_LO;
  subtype C_ADDR_TAG_POS              is natural range C_ADDR_TAG_HI        downto C_ADDR_TAG_LO;
  subtype C_ADDR_FULL_LINE_POS        is natural range C_ADDR_FULL_LINE_HI  downto C_ADDR_FULL_LINE_LO;
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI     downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_EXT_WORD_POS         is natural range C_ADDR_EXT_WORD_HI   downto C_ADDR_EXT_WORD_LO;
  subtype C_ADDR_WORD_POS             is natural range C_ADDR_WORD_HI       downto C_ADDR_WORD_LO;
  subtype C_ADDR_EXT_BYTE_POS         is natural range C_ADDR_EXT_BYTE_HI   downto C_ADDR_EXT_BYTE_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_DIRECT_TYPE            is std_logic_vector(C_ADDR_DIRECT_POS);
  subtype ADDR_EXT_DATA_TYPE          is std_logic_vector(C_ADDR_EXT_DATA_POS);
  subtype ADDR_TAG_TYPE               is std_logic_vector(C_ADDR_TAG_POS);
  subtype ADDR_FULL_LINE_TYPE         is std_logic_vector(C_ADDR_FULL_LINE_POS);
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_EXT_WORD_TYPE          is std_logic_vector(C_ADDR_EXT_WORD_POS);
  subtype ADDR_WORD_TYPE              is std_logic_vector(C_ADDR_WORD_POS);
  subtype ADDR_EXT_BYTE_TYPE          is std_logic_vector(C_ADDR_EXT_BYTE_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);

  constant addr_line_zero_vec : ADDR_LINE_TYPE := (others => '0');
  constant addr_word_zero_vec : ADDR_WORD_TYPE := (others => '0');
  constant addr_byte_zero_vec : ADDR_BYTE_TYPE := (others => '0');
  
  -- Ranges for TAG information parts.
  constant C_NUM_ADDR_TAG_BITS        : natural := C_TAG_SIZE - C_NUM_STATUS_BITS;
  subtype C_TAG_ADDR_POS              is natural range C_NUM_ADDR_TAG_BITS - 1 downto 0;
  subtype TAG_ADDR_TYPE               is std_logic_vector(C_TAG_ADDR_POS);
  
  constant C_ADDR_LINE_BITS           : natural := C_ADDR_LINE_HI - C_ADDR_LINE_LO + 1;
  
  constant C_ADDR_INTERNAL_BITS       : natural := C_ADDR_INTERNAL_HI - C_ADDR_INTERNAL_LO + 1;
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Types for Queue Length.
  constant C_DATA_QUEUE_LINE_LENGTH   : integer:= 32 * C_CACHE_LINE_LENGTH / C_EXTERNAL_DATA_WIDTH;
  constant C_DATA_QUEUE_LENGTH        : integer:= max_of(16, 2 * C_DATA_QUEUE_LINE_LENGTH);
  constant C_DATA_QUEUE_LENGTH_BITS   : integer:= log2(C_DATA_QUEUE_LENGTH);
  subtype DATA_QUEUE_ADDR_POS         is natural range C_DATA_QUEUE_LENGTH - 1 downto 0;
  subtype DATA_QUEUE_ADDR_TYPE        is std_logic_vector(C_DATA_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_BIG_QUEUE_LENGTH        : integer:= 32 * C_DATA_QUEUE_LINE_LENGTH;
  constant C_BIG_QUEUE_LENGTH_BITS   : integer:= log2(C_BIG_QUEUE_LENGTH);
  subtype BIG_QUEUE_ADDR_POS         is natural range C_BIG_QUEUE_LENGTH - 1 downto 0;
  subtype BIG_QUEUE_ADDR_TYPE        is std_logic_vector(C_BIG_QUEUE_LENGTH_BITS - 1 downto 0);
  
  
  -- Custom data structures.
  type E_TYPE is record
    Way               : C_WAY_POS;
    Offset            : ADDR_LINE_TYPE;
    Failed            : std_logic;
    WriteHitLast      : std_logic;
    Cancelled         : std_logic;
  end record E_TYPE;
  
  type WM_TYPE is record
    Port_Num          : natural range 0 to C_NUM_INTERNAL_PORTS - 1;
    Offset            : ADDR_OFFSET_TYPE;
    Use_Bits          : ADDR_OFFSET_TYPE;
    Stp_Bits          : ADDR_OFFSET_TYPE;
    Evict             : std_logic;
    Will_Use          : std_logic;
    Kind              : std_logic;
    Allocate          : std_logic;
    Allow             : std_logic;
    Create            : std_logic;
  end record WM_TYPE;
  
  type WMA_TYPE is record
    Last              : std_logic;
    Strb              : EXT_BE_TYPE;
    Data              : EXT_DATA_TYPE;
  end record WMA_TYPE;
  
  type BS_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
    Internal          : std_logic;
    Insert            : std_logic;
    Src               : BS_SRC_ACTION_TYPE;
    Slv               : BS_SLAVE_ACTION_TYPE;
    Addr              : ADDR_INTERNAL_TYPE;
    Lookup            : std_logic;
    Set_ExOk          : std_logic;
    Create            : std_logic;
  end record BS_TYPE;
  
  type BP_TYPE is record
    BRESP             : AXI_BRESP_TYPE;
  end record BP_TYPE;
  
  type RI_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
    Hot_Port          : PORT_TYPE;
    Way               : C_WAY_POS;
    Addr              : ADDR_INTERNAL_TYPE;
    Use_Bits          : ADDR_OFFSET_TYPE;
    Stp_Bits          : ADDR_OFFSET_TYPE;
    Kind              : std_logic;
    Len               : AXI_LENGTH_TYPE;
    Secure            : std_logic;
    Lookup            : std_logic;
    Allocate          : std_logic;
    Evicted_Line      : std_logic;
    Write_Merge       : std_logic;
    PassDirty         : std_logic;
    IsShared          : std_logic;
    Exclusive         : std_logic;
  end record RI_TYPE;
  
  type R_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
    Hot_Port          : PORT_TYPE;
    Last              : std_logic;
    Data              : EXT_DATA_TYPE;
    RResp             : RRESP_TYPE;
    Addr              : ADDR_INTERNAL_TYPE;
    Use_Bits          : ADDR_OFFSET_TYPE;
    Stp_Bits          : ADDR_OFFSET_TYPE;
    Kind              : std_logic;
    Len               : AXI_LENGTH_TYPE;
    Allocate          : std_logic;
    PassDirty         : std_logic;
    IsShared          : std_logic;
  end record R_TYPE;
  
  -- Empty data structures.
  constant C_NULL_E                   : E_TYPE    := (Way=>0,  Offset=>(others=>'0'), Failed=>'0', 
                                                      WriteHitLast=>'0', Cancelled=>'0');
  constant C_NULL_WM                  : WM_TYPE   := (Port_Num=>0, Offset=>(others=>'0'), Use_Bits=>(others=>'0'),  
                                                      Stp_Bits=>(others=>'0'), Evict=>'0', Will_Use=>'0', 
                                                      Kind=>'0', Allocate=>'0', Allow=>'1', Create=>'0');
  constant C_NULL_WMA                 : WMA_TYPE  := (Last=>'0', Strb=>(others=>'0'), Data=>(others=>'0'));
  constant C_NULL_BS                  : BS_TYPE   := (Port_Num=>0, Internal=>'0', Insert=>'0', Addr=>(others=>'0'),
                                                      Lookup=>'0', Set_ExOk=>'0', Create=>'0', 
                                                      Src=>Src_End, Slv=>Slv_None);
  constant C_NULL_BP                  : BP_TYPE   := (BRESP=>(others=>'0'));
  constant C_NULL_RI                  : RI_TYPE   := (Port_Num=>0, Hot_Port=>(others=>'0'), Way=>0, 
                                                      Addr=>(others=>'0'),
                                                      Use_Bits=>(others=>'0'), Stp_Bits=>(others=>'0'), 
                                                      Kind=>'0', Len=>(others=>'0'), Secure=>'0', Allocate=>'0', 
                                                      Evicted_Line=>'0', Write_Merge=>'0', Lookup=>'0',
                                                      PassDirty=>'0', IsShared=>'0', Exclusive => '0');
  constant C_NULL_R                   : R_TYPE    := (Port_Num=>0, Hot_Port=>(others=>'0'), Last=>'0', 
                                                      Data=>(others=>'0'), RResp=>(others=>'0'), Addr=>(others=>'0'), 
                                                      Use_Bits=>(others=>'0'), Stp_Bits=>(others=>'0'), 
                                                      Kind=>'0', Len=>(others=>'0'), Allocate=>'0', 
                                                      PassDirty=>'0', IsShared=>'0');
  constant C_NULL_WMAL                : CACHE_LINE_BE_TYPE  
                                                  := (others=>(others=>'0'));
  
  -- Types for information queue storage.
  type E_FIFO_MEM_TYPE                is array(QUEUE_ADDR_POS)      of E_TYPE;
  type WM_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS)      of WM_TYPE;
  type WMA_FIFO_MEM_TYPE              is array(BIG_QUEUE_ADDR_POS)  of WMA_TYPE;
  type WMAL_FIFO_MEM_TYPE             is array(QUEUE_ADDR_POS)      of CACHE_LINE_BE_TYPE;
  type BS_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS)      of BS_TYPE;
  type BP_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS)      of BP_TYPE;
  type RI_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS)      of RI_TYPE;
  type R_FIFO_MEM_TYPE                is array(DATA_QUEUE_ADDR_POS) of R_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_select_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural
    );
    port (
      Carry_In  : in  std_logic;
      No        : in  natural range 0 to C_SIZE-1;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_Out : out std_logic
    );
  end component carry_select_and;
  
  component carry_latch_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and_n;
  
  component carry_compare is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_SIZE    : natural
    );
    port (
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      B_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In  : in  std_logic;
      Carry_Out : out std_logic
    );
  end component carry_compare;
  
  component carry_piperun_step is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      Need      : in  std_logic;
      Stall     : in  std_logic;
      Done      : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_piperun_step;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component sc_stat_event is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Probe Interface
      
      probe                     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_event;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Detect Address Conflicts
  
  signal update_match_addr          : std_logic;
  signal update_tag_conflict_i      : std_logic;
  
  
  -- ----------------------------------------
  -- Update Pipeline Stage: Update
  
  signal update_piperun_pre5        : std_logic;
  signal update_piperun_pre4        : std_logic;
  signal update_piperun_pre3        : std_logic;
  signal update_piperun_pre2        : std_logic;
  signal update_piperun_pre1        : std_logic;
  signal update_piperun_i           : std_logic;
  signal update_stall               : std_logic;
  signal update_port_rd             : natural range 0 to C_NUM_PORTS - 1;
  signal update_port_wr             : natural range 0 to C_NUM_INTERNAL_PORTS - 1;
  signal update_allocate_write_miss : std_logic;
  signal update_need_tag_write_pre5 : std_logic;
  signal update_need_tag_write_pre4 : std_logic;
  signal update_need_tag_write_pre3 : std_logic;
  signal update_need_tag_write_pre2 : std_logic;
  signal update_need_tag_write_pre1 : std_logic;
  signal update_need_tag_write_carry: std_logic;
  signal update_done_bs             : std_logic;
  signal update_done_ar             : std_logic;
  signal update_done_aw             : std_logic;
  signal update_done_evict          : std_logic;
  signal update_done_tag_write      : std_logic;
  signal update_stall_bs            : std_logic;
  signal update_stall_ar            : std_logic;
  signal update_stall_aw            : std_logic;
  signal update_stall_evict         : std_logic;
  signal update_stall_tag_write     : std_logic;
  signal update_tag_write_ignore    : std_logic;
  signal update_write_cancelled     : std_logic;
  signal read_req_valid_i           : std_logic;
  signal read_req_exclusive_i       : std_logic;
  signal read_req_kind_i            : std_logic;
  signal update_evict               : std_logic;
  signal update_tag_write_raw       : std_logic;
  signal update_tag_write_raw_lvec  : WAY_TYPE;
  signal update_tag_write_raw_vec   : WAY_TYPE;
  signal update_tag_write           : std_logic;
  signal update_block_lookup        : std_logic;
  signal update_new_tag_valid       : std_logic;
  signal update_new_tag_secure      : std_logic;
  signal update_new_tag_unique      : std_logic;
  signal update_new_tag_reused      : std_logic;
  signal update_new_tag_locked      : std_logic;
  signal update_new_tag_dirty       : std_logic;
  signal update_new_tag_addr        : TAG_ADDR_TYPE;
  signal write_req_valid_i          : std_logic;
  
  signal ud_new_tag_valid           : std_logic;
  signal ud_new_tag_secure          : std_logic;
  signal ud_new_tag_unique          : std_logic;
  signal ud_new_tag_reused          : std_logic;
  signal ud_new_tag_locked          : std_logic;
  signal ud_new_tag_dirty           : std_logic;
  signal ud_new_tag_addr            : TAG_ADDR_TYPE;
  
  signal rb_new_tag_valid           : std_logic;
  signal rb_new_tag_secure          : std_logic;
  signal rb_new_tag_unique          : std_logic;
  signal rb_new_tag_reused          : std_logic;
  signal rb_new_tag_locked          : std_logic;
  signal rb_new_tag_dirty           : std_logic;
  signal rb_new_tag_addr            : TAG_ADDR_TYPE;
  
  
  -- ----------------------------------------
  -- Detect LRU Changes
  
  signal lru_update_prev_lru_way_i  : C_WAY_POS;
  signal lru_update_new_lru_way_i   : C_WAY_POS;
  signal update_all_tag_valid       : WAY_TYPE;
  
  
  -- ----------------------------------------
  -- Generate Data for Write Request
  
  signal write_req_exclusive_i      : std_logic;
  signal write_req_kind_i           : std_logic;
  signal write_req_line_only_i      : std_logic;
  
  
  -- ----------------------------------------
  -- End of Transaction
  
  signal update_read_done_i : std_logic;
  signal update_write_done_i : std_logic;
  
  
  -----------------------------------------------------------------------------
  -- Set Handling
  
  signal update_tag_trans_addr      : ADDR_FULL_LINE_TYPE;
  signal update_tag_unlock_addr     : ADDR_FULL_LINE_TYPE;
  signal update_data_line           : ADDR_FULL_LINE_TYPE;
  signal update_cur_tag_way         : C_WAY_POS;
  signal update_cur_tag_rd_way      : C_WAY_POS;
  signal update_cur_data_way        : C_WAY_POS;
  signal update_cur_evict_way_d1    : C_WAY_POS;
  
  
  -- ----------------------------------------
  -- Check Locked Tag
  
  signal update_readback_tag_en     : std_logic;
  signal update_readback_allowed    : std_logic;
  signal update_readback_possible   : std_logic;
  signal update_readback_available  : std_logic;
  signal update_readback_done       : std_logic;
  signal update_readback_tag        : WAY_LINE_TAG_TYPE;
  signal update_locked_tag_sec_chk  : std_logic;
  signal update_locked_tag_match    : std_logic;
  signal update_locked_tag_is_dead  : std_logic;
  signal update_remove_locked       : std_logic;
  signal update_remove_locked_safe  : std_logic;
  signal update_remove_locked_2nd_cycle : std_logic;
  signal update_rb_pos_phase        : std_logic;
  signal update_first_word_safe     : std_logic;
  
  
  -- ----------------------------------------
  -- Control Update TAG
  
  signal update_tag_addr_i          : ADDR_FULL_LINE_TYPE;
  signal update_tag_en_i            : std_logic;
  signal update_select_readback     : WAY_TYPE;
  signal update_sel_readback_tag    : WAY_TYPE;
  signal update_tag_match           : WAY_TYPE;
  signal update_tag_match_pre       : WAY_TYPE;
  signal update_tag_is_alive        : WAY_TYPE;
  signal update_tag_remove_lock     : WAY_TYPE;
  signal update_tag_we_i            : WAY_TYPE;
  signal update_new_tag             : WAY_LINE_TAG_TYPE;
  
  
  -- ----------------------------------------
  -- Control Update DATA
  
  signal update_data_addr_i         : ADDR_EXT_DATA_TYPE;
  signal update_data_en_ii          : std_logic_vector(C_NUM_WAYS downto 0);
  signal update_data_en_sel_n       : WAY_TYPE;
  signal update_data_en_i           : WAY_TYPE;
  signal update_data_current_word_i : SET_EXT_DATA_TYPE;
  
  
  -- ----------------------------------------
  -- Queue for Data Eviction (Read Miss Dirty and Evict)
  
  signal update_e_push              : std_logic;
  signal update_e_pop               : std_logic;
  signal e_read_fifo_addr           : QUEUE_ADDR_TYPE;
  signal e_fifo_mem                 : E_FIFO_MEM_TYPE;
  signal e_fifo_full                : std_logic;
  signal e_fifo_empty               : std_logic;
  signal e_way                      : C_WAY_POS;
  signal e_offset                   : ADDR_LINE_TYPE;
  signal e_failed                   : std_logic;
  signal e_whl                      : std_logic;
  signal e_cancelled                : std_logic;
  signal e_assert                   : std_logic;
  
  
  -- ----------------------------------------
  -- Queue for Evict Done
  
  signal ed_push                    : std_logic;
  signal ed_pop                     : std_logic;
  signal ed_fifo_full               : std_logic;
  signal ed_fifo_empty              : std_logic;
  signal ed_assert                  : std_logic;
  
  
  -- ----------------------------------------
  -- Update Data Pointer
  
  signal update_rd_cnt_en           : std_logic;
  signal update_wr_cnt_en           : std_logic;
  signal update_word_cnt_en         : std_logic;
  signal update_word_cnt            : ADDR_EXT_WORD_TYPE;
  signal update_word_cnt_next       : ADDR_EXT_WORD_TYPE;
  signal update_word_cnt_len        : ADDR_EXT_WORD_TYPE;
  signal update_data_base_line      : ADDR_LINE_TYPE;
  signal update_word_cnt_first      : std_logic;
  signal update_word_cnt_almost_last: std_logic;
  signal update_word_cnt_last       : std_logic;
  signal update_read_miss_safe      : std_logic;
  signal update_read_miss_wma_safe  : std_logic;
  signal update_snoop_safe          : std_logic;
  signal update_read_miss_start_ok  : std_logic;
  signal update_read_miss_start     : std_logic;
  signal update_evict_start         : std_logic;
  signal update_read_miss_stop      : std_logic;
  signal update_evict_stop          : std_logic;
  signal update_evict_ongoing       : std_logic;
  signal update_evict_busy          : std_logic;
  signal update_evict_failed        : std_logic;
  signal update_evict_whl           : std_logic;
  signal update_evict_cancelled     : std_logic;
  signal update_read_miss_ongoing   : std_logic;
  signal update_rm_alloc_ongoing    : std_logic;
  signal update_evict_valid         : std_logic;
  signal update_evict_last          : std_logic;
  signal update_evict_word          : EXT_DATA_TYPE;
  signal write_data_full_d1         : std_logic;
  signal update_evict_stop_d1       : std_logic;
  signal update_read_miss_use_ok    : std_logic;
  signal update_read_miss_use_bypass: std_logic;
  
  
  -- ----------------------------------------
  -- Optimized Read Miss Use OK:
  
  signal ud_rm_available_sel        : std_logic;
  signal ud_rm_available            : std_logic;
  signal ud_rm_use_sel              : std_logic;
  signal ud_rm_use_pre_safe         : std_logic;
  signal ud_rm_use_safe             : std_logic;
  signal ud_rm_use_and_lock_safe    : std_logic;
  signal ud_rm_use_and_lock_safe_or_int : std_logic;
  signal ud_rm_sel_wr_cnt_en        : std_logic;
  
  signal ud_rm_resize_part_sel      : std_logic;
  signal ud_rm_use_resize_part_ok   : std_logic;
  signal ud_rm_port_forward         : PORT_TYPE;
  signal update_read_miss_resize_ok : std_logic;
  signal update_read_resize_selected_vec : PORT_TYPE;
  signal update_read_resize_finish_vec   : PORT_TYPE;
  
  
  -- ----------------------------------------
  -- Queue for Write Extraction (Write Miss)
  
  signal update_write_miss_busy_i   : std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
  signal update_wm_push             : std_logic; 
  signal update_wm_pop_evict        : std_logic; 
  signal update_wm_pop_evict_hold   : std_logic;
  signal update_wm_pop_normal       : std_logic; 
  signal update_wm_pop_normal_hold  : std_logic;
  signal update_wm_pop_allocate     : std_logic;
  signal update_wm_pop              : std_logic; 
  signal wm_read_fifo_addr          : QUEUE_ADDR_TYPE;
  signal wm_fifo_mem                : WM_FIFO_MEM_TYPE;
  signal wm_fifo_full               : std_logic; 
  signal wm_fifo_almost_empty       : std_logic; 
  signal wm_fifo_empty              : std_logic;
  signal wm_exist                   : std_logic;
  signal wm_refresh_reg             : std_logic;
  signal wm_port                    : natural range 0 to C_NUM_INTERNAL_PORTS - 1;
  signal wm_allocate                : std_logic;
  signal wm_evict                   : std_logic;
  signal wm_create                  : std_logic;
  signal wm_will_use                : std_logic;
  signal wm_kind                    : std_logic;
  signal wm_offset                  : ADDR_OFFSET_TYPE;
  signal wm_use_bits                : ADDR_OFFSET_TYPE;
  signal wm_stp_bits                : ADDR_OFFSET_TYPE;
  signal wm_local_wrap              : std_logic;
  signal wm_remove_unaligned        : ADDR_OFFSET_TYPE;
  signal wm_allow                   : std_logic;
  signal wm_allow_vec               : BE_TYPE;
  signal wm_assert                  : std_logic;
  signal update_use_write_word      : std_logic; 
  signal update_write_miss_ongoing  : std_logic; 
  signal update_write_port_i        : C_INT_PORT_POS; 
  signal update_ack_write_ext       : std_logic; 
  signal update_ack_write_alloc     : std_logic; 
  signal update_ack_write_word      : std_logic; 
  signal update_ack_write_word_vec  : INT_PORT_TYPE;
  signal update_write_data_ready_i  : std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
  signal update_wr_miss_valid       : std_logic; 
  signal update_wr_miss_last        : std_logic; 
  signal update_wr_miss_be          : BE_TYPE; 
  signal update_wr_miss_word        : DATA_TYPE; 
  
  
  -- ----------------------------------------
  -- Write Size Conversion
  
  signal update_wr_miss_word_done   : std_logic; 
  signal update_wr_miss_throttle    : std_logic; 
  signal update_wr_miss_restart_word: std_logic;
  signal update_wr_miss_rs_valid    : std_logic;
  signal update_wr_miss_rs_last     : std_logic;
  signal update_wr_miss_rs_be       : EXT_BE_TYPE;
  signal update_wr_miss_rs_word     : EXT_DATA_TYPE;
  signal update_wr_offset           : ADDR_OFFSET_TYPE;
  signal update_wr_offset_cnt       : ADDR_OFFSET_TYPE;
  signal update_wr_offset_cnt_cmb   : ADDR_OFFSET_TYPE;
  signal update_wr_next_word_addr   : ADDR_OFFSET_TYPE;
  
  
  -- ----------------------------------------
  -- Write Miss Allocate Data Processing
  
  signal update_wma_insert_dummy    : std_logic;
  signal update_wma_select_port     : std_logic;
  signal update_wma_data_valid      : std_logic;
  signal update_wma_fifo_stall      : std_logic;
  signal update_wma_throttle        : std_logic;
  signal update_wma_last            : std_logic;
  signal update_wma_strb            : EXT_BE_TYPE;
  signal update_wma_data            : EXT_DATA_TYPE;
  signal wma_word_done              : std_logic;
  signal wma_word_done_d1           : std_logic;
  
  
  -- ----------------------------------------
  -- Queue for Write Miss Allocate
  
  signal wma_push                   : std_logic;
  signal wma_sel_pop_n              : std_logic;
  signal wma_pop                    : std_logic;
  signal wma_fifo_almost_full       : std_logic;
  signal wma_fifo_full              : std_logic;
  signal wma_fifo_empty             : std_logic;
  signal wma_read_fifo_addr         : BIG_QUEUE_ADDR_TYPE:= (others=>'1');
  signal wma_fifo_mem               : WMA_FIFO_MEM_TYPE; -- := (others=>C_NULL_WMA);
  signal wma_last                   : std_logic;
  signal wma_strb                   : EXT_BE_TYPE;
  signal wma_data                   : EXT_DATA_TYPE;
  signal wma_done                   : std_logic;
  signal wma_merge_done             : std_logic;
  signal wma_assert                 : std_logic;
  
  
  -- ----------------------------------------
  -- Write Hit Last
  
  signal update_whl_strb_i          : CACHE_LINE_BE_TYPE;
  signal update_whl_strb_word       : BE_TYPE;
  
  
  -- ----------------------------------------
  -- Write Miss Allocate Last
  
  signal wmal_push                  : std_logic;
  signal wmal_pop                   : std_logic;
  signal wmal_fifo_full             : std_logic;
  signal wmal_fifo_empty            : std_logic;
  signal wmal_read_fifo_addr        : QUEUE_ADDR_TYPE:= (others=>'1');
  signal wmal_fifo_mem              : WMAL_FIFO_MEM_TYPE; -- := (others=>C_NULL_WMAL);
  signal wmal_strb                  : CACHE_LINE_BE_TYPE;
  
  signal wmal_assert                : std_logic;
  signal stat_ud_wmal               : STAT_FIFO_TYPE;
  
  signal update_wmal_strb           : CACHE_LINE_BE_TYPE;
  signal evict_wmal_strb            : BE_TYPE;
  
  signal update_wmal_failed         : std_logic;
  signal update_error_evict_insert_i: std_logic;
  
  
  -- ----------------------------------------
  -- Queue for Write Miss Allocate Done
  
  signal wmad_push                  : std_logic;
  signal wmad_pop                   : std_logic;
  signal wmad_fifo_full             : std_logic;
  signal wmad_fifo_empty            : std_logic;
  signal wmad_read_fifo_addr        : QUEUE_ADDR_TYPE;
  signal wmad_bresp                 : AXI_BRESP_TYPE;
  signal wmad_assert                : std_logic;
  
  
  -- ----------------------------------------
  -- Write Data Mux
  
  signal write_data_valid_i         : std_logic;
  signal write_data_last_i          : std_logic;
  
  
  -- ----------------------------------------
  -- Read Information Buffer
  
  signal ri_push                    : std_logic;
  signal ri_pop                     : std_logic;
  signal ri_refresh_reg             : std_logic;
  signal ri_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
  signal ri_fifo_mem                : RI_FIFO_MEM_TYPE; -- := (others=>C_NULL_RI);
  signal ri_fifo_full               : std_logic;
  signal ri_fifo_empty              : std_logic;
  signal ri_exist                   : std_logic;
  signal ri_port                    : natural range 0 to C_NUM_PORTS - 1;
  signal ri_hot_port                : PORT_TYPE;
  signal ri_way                     : C_WAY_POS;
  signal ri_addr                    : ADDR_INTERNAL_TYPE;
  signal ri_use                     : ADDR_OFFSET_TYPE;
  signal ri_stp                     : ADDR_OFFSET_TYPE;
  signal ri_kind                    : std_logic;
  signal ri_len                     : AXI_LENGTH_TYPE;
  signal ri_secure                  : std_logic;
  signal ri_lookup                  : std_logic;
  signal ri_allocate                : std_logic;
  signal ri_evicted                 : std_logic;
  signal ri_merge                   : std_logic;
  signal ri_isshared                : std_logic;
  signal ri_passdirty               : std_logic;
  signal ri_assert                  : std_logic;
  signal ri_exclusive               : std_logic;
  
  
  -- ----------------------------------------
  -- Read Data Forwarding
  
  
  signal backend_rd_data_last_n     : std_logic;
  signal backend_rd_data_use_ii     : std_logic;
  signal backend_rd_data_use_i      : std_logic;
  signal backend_rd_data_use        : std_logic;
  signal backend_rd_data_pop        : std_logic;
  signal backend_rd_data_real_rresp : AXI_SHORT_RRESP_TYPE;
  signal backend_rd_data_ready_i    : std_logic;
  signal backend_rd_filtered_valid  : std_logic;
  signal update_read_forward_ready  : std_logic;
  signal update_read_resize_valid   : std_logic;
  signal update_read_resize_last    : std_logic;
  signal update_read_resize_port    : rinteger range 0 to C_NUM_PORTS - 1;
  signal update_read_resize_hot_port: PORT_TYPE; 
  signal update_read_resize_addr    : ADDR_INTERNAL_TYPE;
  signal update_read_resize_offset  : ADDR_OFFSET_TYPE;
  signal update_read_resize_use_bits: ADDR_OFFSET_TYPE;
  signal update_read_resize_stp_bits: ADDR_OFFSET_TYPE;
  signal update_read_resize_kind    : std_logic;
  signal update_read_resize_len     : AXI_LENGTH_TYPE;
  signal update_read_resize_allocate: std_logic;
  signal update_read_resize_word    : EXT_DATA_TYPE;
  signal update_read_resize_rresp   : RRESP_TYPE;
  signal update_read_resize_used    : std_logic;
  signal update_read_resize_ready   : std_logic;
  signal r_assert                   : std_logic;
  
  signal backend_rd_data_final      : std_logic;
  
  signal update_read_resize_failed  : std_logic;
  signal update_read_hold_fail      : std_logic;
  signal update_read_hold_rresp     : AXI_BRESP_TYPE;
  signal update_read_failed         : std_logic;
  
  signal update_allocate_error_i    : std_logic;
  
  
  -- ----------------------------------------
  -- Read Size Conversion
  
  signal update_rd_offset           : ADDR_OFFSET_TYPE;
  signal update_rd_offset_cnt       : ADDR_OFFSET_TYPE;
  signal update_rd_offset_cnt_next  : ADDR_OFFSET_TYPE;
  signal update_rd_len              : AXI_LENGTH_TYPE;
  signal update_rd_len_cnt          : AXI_LENGTH_TYPE;
  signal update_rd_len_cnt_next     : AXI_LENGTH_TYPE;
  signal update_read_resize_first   : std_logic;
  signal update_read_resize_finish  : std_logic;
  signal update_read_resize_selected: std_logic;
  signal update_read_resize_sel_wrap: std_logic;
  signal update_rd_incr_ok          : std_logic;
  signal update_rd_wrap_ok          : std_logic;
  signal update_rd_miss_th_incr     : std_logic;
  signal update_rd_miss_th_wrap     : std_logic;
  signal update_rd_miss_throttle    : std_logic;
  signal update_read_data_valid_i   : std_logic;
  signal update_read_data_valid_vec : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal update_read_data_valid_ii  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal update_read_data_last_i    : std_logic;
  signal update_read_data_resp_i    : std_logic_vector(C_MAX_RRESP_WIDTH - 1 downto 0);
  signal update_read_data_word_i    : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Write Response Handling
  
  signal update_bs_push             : std_logic;
  signal update_bs_pop              : std_logic;
  signal bs_refresh_reg             : std_logic;
  signal backend_wr_resp_valid      : std_logic;
  signal backend_wr_resp_valid_hold : std_logic;
  signal update_wr_resp_port_ready  : std_logic;
  signal update_wr_resp_port_pop    : std_logic;
  signal backend_wr_resp_pop        : std_logic;
  signal backend_wr_resp_wma_valid  : std_logic;
  signal backend_wr_resp_wma_ready  : std_logic;
  signal backend_wr_resp_wma_pop    : std_logic;
  signal backend_wr_resp_ready_i    : std_logic;
  signal bs_read_fifo_addr          : QUEUE_ADDR_TYPE;
  signal bs_fifo_mem                : BS_FIFO_MEM_TYPE;
  signal bs_fifo_full               : std_logic;
  signal bs_fifo_empty              : std_logic;
  signal bs_exist                   : std_logic;
  signal bs_is_ext                  : std_logic;
  signal bs_is_wma                  : std_logic;
  signal new_bs_src                 : BS_SRC_ACTION_TYPE;
  signal new_bs_slv                 : BS_SLAVE_ACTION_TYPE;
  signal new_bs_mst                 : BS_MASTER_ACTION_TYPE;
  signal bs_src                     : BS_SRC_ACTION_TYPE;
  signal bs_slv                     : BS_SLAVE_ACTION_TYPE;
  signal bs_mst                     : BS_MASTER_ACTION_TYPE;
  signal bs_lookup                  : std_logic;
  signal bs_port_num                : natural range 0 to C_NUM_PORTS - 1;
  signal bs_addr                    : ADDR_INTERNAL_TYPE;
  signal bs_exok                    : std_logic;
  signal bs_assert                  : std_logic;
  signal update_ext_bresp_wma       : std_logic;
  signal update_ext_bresp_normal    : std_logic;
  signal update_ext_bresp_any_raw   : std_logic;
  signal update_ext_bresp_any       : std_logic;
  signal update_ext_bresp_any_vec   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal update_ext_bresp_valid_i   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  signal bp_push                    : std_logic;
  signal bp_pop                     : std_logic;
  signal bp_read_fifo_addr          : QUEUE_ADDR_TYPE;
  signal bp_fifo_mem                : BP_FIFO_MEM_TYPE;
  signal bp_fifo_full               : std_logic;
  signal bp_fifo_empty              : std_logic;
  signal bp_bresp                   : AXI_BRESP_TYPE;
  signal stat_ud_bp                 : STAT_FIFO_TYPE;
  signal bp_assert                  : std_logic;
  
  
  -- ----------------------------------------
  -- Master coherency
  
  -- Snoop data queue.
  signal sdr_fifo_empty             : std_logic;
  signal sdr_way                    : rinteger range C_MAX_WAYS_POS'low to C_MAX_WAYS_POS'high;
  signal sdr_line_addr              : ADDR_FULL_LINE_TYPE;
  signal sdr_word_addr              : ADDR_EXT_WORD_TYPE;
  
  -- Snoop data sequence handling.
  signal update_snoop_start         : std_logic;
  signal update_snoop_ongoing       : std_logic;
  signal update_snoop_data_stall    : std_logic;
  
  signal su_new_tag_valid           : std_logic;
  signal su_new_tag_secure          : std_logic;
  signal su_new_tag_unique          : std_logic;
  signal su_new_tag_reused          : std_logic;
  signal su_new_tag_locked          : std_logic;
  signal su_new_tag_dirty           : std_logic;
  signal su_new_tag_addr            : TAG_ADDR_TYPE;
  
  signal snoop_need_tag_write       : std_logic;
  signal snoop_tag_trans_addr       : ADDR_FULL_LINE_TYPE;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
  -----------------------------------------------------------------------------
  -- Attributes
  -----------------------------------------------------------------------------
  
  
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Detect Address Conflicts
  -- 
  -- Detect any address conflicts with current transactions against earlier
  -- Updates.
  -----------------------------------------------------------------------------
  
  -- Conflict because of current TAG Update, i.e. hit/miss move here or removal of Locked.
--  update_tag_conflict_i       <= access_valid and update_need_tag_write 
--                                        when lookup_new_addr = update_info.Addr(C_ADDR_LINE_POS) else 
--                                 '0';
  UD_TagConf_Compare_Inst1: carry_compare
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_ADDR_LINE_BITS
    )
    port map(
      Carry_In  => update_need_tag_write_carry,
      A_Vec     => lookup_new_addr(C_ADDR_LINE_POS),
      B_Vec     => update_info.Addr(C_ADDR_LINE_POS),
      Carry_Out => update_match_addr
    );
  
  UD_TagConf_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_match_addr,
      A         => access_valid,
      Carry_OUT => update_tag_conflict_i
    );
  
  -- Detect any Update TAG update conflicts with Access.
  update_tag_conflict         <= update_tag_conflict_i;
  
  
  update_allocate_conflict    <= b2s( lookup_stall_addr(C_ADDR_LINE_POS) = ri_addr(C_ADDR_LINE_POS) ) and 
                                 b2s( lookup_stall_addr(C_ADDR_TAG_POS)  = ri_addr(C_ADDR_TAG_POS)  ) and 
                                    ( ri_exist and ri_allocate ) and 
                                 b2s(C_ENABLE_ERROR_HANDLING > 0);
  
  
  -----------------------------------------------------------------------------
  -- Update Pipeline Stage: Update
  -- 
  -- Handle all events that are passed on from Lookup to Update by manipulating:
  --  * BP  - BRESP Port queue(s)
  --  * BS  - BREPS Source queue
  --  * AR  - Read Address queue
  --  * AW  - Write Address queue
  --  * E   - Evict queue
  --  * Tag - Update Tag bit(s)
  -- 
  -- Actions taken per event:
  --  * Write Miss      - Push to BP and BS queue
  --  * Write Hit       - Push to BP queue, Set Dirty bit in Tag
  --  * Write Hit Dirty - Push to BP queue
  --  * Evict           - Write data if dirty (and push to BS queue), 
  --                      Always Invalidate Tag
  --  * WriteBack       - Write data if dirty (and push to BS queue), 
  --                      Remove dirty bit from Tag (if set)
  --  * Read Hit        - N/A
  --  * Read Miss       - Set Locked Valid in Tag
  --                      Remove Locked when data is returned 
  --  * Read Miss Dirty - Push to BS queue, Write data if dirty, 
  --                      Set Locked Valid in Tag
  --                      Remove Locked when data is returned 
  -- 
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
  update_piperun          <= update_piperun_i;
--  update_piperun_i        <= not update_stall;
  
  -- Stall Update stage if not ready.
  update_stall            <= ( update_valid and 
                               ( ( update_need_bs        and update_stall_bs        and not update_done_bs        ) or
                                 ( update_need_ar        and update_stall_ar        and not update_done_ar        ) or
                                 ( update_need_aw        and update_stall_aw        and not update_done_aw        ) or
                                 ( update_need_evict     and update_stall_evict     and not update_done_evict     ) or
                                 ( update_need_tag_write and update_stall_tag_write and not update_done_tag_write ) ) ) or 
                              ( update_block_lookup );
  
  -- Create PipeRun on carry chain.
  UD_PR_Comp_Inst1: carry_piperun_step
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => '1',
      Need      => update_need_tag_write,
      Stall     => update_stall_tag_write,
      Done      => update_done_tag_write,
      Carry_OUT => update_piperun_pre5
    );
  UD_PR_Comp_Inst2: carry_piperun_step
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => update_piperun_pre5,
      Need      => update_need_evict,
      Stall     => update_stall_evict,
      Done      => update_done_evict,
      Carry_OUT => update_piperun_pre4
    );
  UD_PR_Comp_Inst4: carry_piperun_step
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => update_piperun_pre4,
      Need      => update_need_bs,
      Stall     => update_stall_bs,
      Done      => update_done_bs,
      Carry_OUT => update_piperun_pre3
    );
  UD_PR_Comp_Inst5: carry_piperun_step
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => update_piperun_pre3,
      Need      => update_need_aw,
      Stall     => update_stall_aw,
      Done      => update_done_aw,
      Carry_OUT => update_piperun_pre2
    );
  UD_PR_Comp_Inst6: carry_piperun_step
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => update_piperun_pre2,
      Need      => update_need_ar,
      Stall     => update_stall_ar,
      Done      => update_done_ar,
      Carry_OUT => update_piperun_pre1
    );
  UD_PR_Comp_Inst7: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_piperun_pre1,
      A_N       => update_block_lookup,
      Carry_OUT => update_piperun_i
    );
  
  -- Select way depending on current actions.
  update_cur_tag_way      <= ri_way       when ( update_readback_possible or update_readback_available ) = '1' else 
                             update_way   when ( update_need_tag_write and not update_done_tag_write )   = '1' else
                             mst_snoop_tag_way;
  
  -- Get current port.
  update_port_rd          <= get_port_num(update_info.Port_Num, C_NUM_PORTS);
  update_port_wr          <= get_port_num(update_info.Port_Num, C_NUM_INTERNAL_PORTS);
  
  -- Extra Need Tag Write decoding for quicker tag conflict.
  update_allocate_write_miss  <= ( update_write_miss and update_info.Allocate );
  UD_TagWrite_Or_Inst1: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => '0',
      A         => update_info.Allocate,
      Carry_OUT => update_need_tag_write_pre5
    );
  UD_TagWrite_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_need_tag_write_pre5,
      A         => update_read_miss,
      Carry_OUT => update_need_tag_write_pre4
    );
  UD_TagWrite_Or_Inst2: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_need_tag_write_pre4,
      A         => update_info.Evict,
      Carry_OUT => update_need_tag_write_pre3
    );
  UD_TagWrite_Or_Inst3: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_need_tag_write_pre3,
      A         => update_first_write_hit,
      Carry_OUT => update_need_tag_write_pre2
    );
  UD_TagWrite_Or_Inst4: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_need_tag_write_pre2,
      A         => update_allocate_write_miss,
      Carry_OUT => update_need_tag_write_pre1
    );
  UD_TagWrite_And_Inst2: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_need_tag_write_pre1,
      A         => update_valid,
      Carry_OUT => update_need_tag_write_carry
    );
  
  -- Stall conditions.
  update_stall_bs           <= bs_fifo_full;
  update_stall_ar           <= not read_req_ready or ri_fifo_full;
  update_stall_aw           <= not write_req_ready;
  update_stall_evict        <= e_fifo_full;
  update_stall_tag_write    <= update_readback_available;
  
  -- Allowed actions. 
  update_bs_push            <= ( update_need_bs        and not update_done_bs        and not update_stall_bs );
  read_req_valid_i          <= ( update_need_ar        and not update_done_ar        and not update_stall_ar );
  write_req_valid_i         <= ( update_need_aw        and not update_done_aw        and not update_stall_aw );
  update_evict              <= ( update_need_evict     and not update_done_evict     and not update_stall_evict );
  update_tag_write_raw      <= ( ( ( update_need_tag_write and not update_done_tag_write ) or
                                   ( snoop_need_tag_write                                ) ) and not update_stall_tag_write );
  update_tag_write          <= update_tag_write_raw or
                               update_remove_locked;
  
  -- Ignore or completed. 
  update_tag_write_ignore   <= ( ( update_need_tag_write and ( update_done_tag_write or update_stall_tag_write ) ) or 
                                 not update_need_tag_write ) and
                               ( update_readback_available or not snoop_need_tag_write );
  
  -- Vectorize Raw Tag write.
  update_tag_write_raw_lvec <= (others => update_tag_write_raw);
  update_tag_write_raw_vec  <= update_tag_write_raw_lvec and 
                               std_logic_vector(to_unsigned(2 ** update_cur_tag_way, C_NUM_WAYS));
  
  -- Handle Update action Done status.
  Pipeline_Stage_Done_Handle : process (ACLK) is
  begin  -- process Pipeline_Stage_Done_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        update_done_bs        <= '0';
        update_done_ar        <= '0';
        update_done_aw        <= '0';
        update_done_evict     <= '0';
        update_done_tag_write <= '0';
      else
        if( update_piperun_i = '1' ) then
          update_done_bs        <= '0';
        elsif( update_bs_push = '1' ) then
          update_done_bs        <= '1';
        end if;
        
        if( update_piperun_i = '1' ) then
          update_done_ar        <= '0';
        elsif( read_req_valid_i = '1' ) then
          update_done_ar        <= '1';
        end if;
        
        if( update_piperun_i = '1' ) then
          update_done_aw        <= '0';
        elsif( write_req_valid_i = '1' ) then
          update_done_aw        <= '1';
        end if;
        
        if( update_piperun_i = '1' ) then
          update_done_evict     <= '0';
        elsif( update_evict = '1' ) then
          update_done_evict     <= '1';
        end if;
        
        if( update_piperun_i = '1' ) then
          update_done_tag_write <= '0';
        elsif( ( update_tag_write and update_tag_write_raw ) = '1' ) then
          update_done_tag_write <= '1';
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Done_Handle;
  
  -- Detect when a write is cancelled.
  update_write_cancelled    <= update_snoop_made_invalid or update_snoop_made_clean;
  
  
  -----------------------------------------------------------------------------
  -- Detect LRU Changes
  -----------------------------------------------------------------------------
  
  -- Split tag information to array.
  Gen_Tag: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    -- Vectorize Tag.
    update_all_tag_valid(K)   <= update_all_tags(K).Valid;
  end generate Gen_Tag;
  
  -- Convert to integer.
  lru_update_prev_lru_way_i <= to_integer(unsigned(lru_update_prev_lru_way));
  lru_update_new_lru_way_i  <= to_integer(unsigned(lru_update_new_lru_way));
  
  -- Check if all Ways are Valid.
  
  -- Detect if Line needs to be scheduled for referesh.
  -- Autoclean if new LRU line is Valid and Dirty, it is only needed if the new LRU is actually different from 
  -- the last LRU. 
  -- Issuing a write-back of this line will remove any need for evict when there is a Miss on this Way.
  update_auto_clean_push    <= update_refreshed_lru and 
                               reduce_and(update_all_tag_valid) and
                               update_all_tags(lru_update_new_lru_way_i).Dirty when 
                                      ( lru_update_prev_lru_way_i /= lru_update_new_lru_way_i ) else
                               '0';
  
  -- Create address to be automatically refreshed.
  process (update_all_tags, lru_update_new_lru_way_i, update_info) is 
  begin  
    update_auto_clean_addr    <= (others=>'0');
    update_auto_clean_addr(C_ADDR_INTERNAL_HI downto C_ADDR_INTERNAL_LO)
                              <= ( update_all_tags(lru_update_new_lru_way_i).Addr(C_ADDR_TAG_POS) & 
                                   update_info.Addr(C_ADDR_LINE_POS) & 
                                   addr_word_zero_vec & 
                                   addr_byte_zero_vec );
  end process;
    
    
  -----------------------------------------------------------------------------
  -- ACE Downstream Barrier Request.
  -----------------------------------------------------------------------------
   
  ctrl_update_done  <= ( not update_valid  ) and
                       (     ri_fifo_empty ) and
                       ( not ri_exist      ) and
                       (     wm_fifo_empty ) and
                       ( not wm_exist      ) and
                       (     bs_fifo_empty ) and
                       ( not bs_exist      );
    
    
  -----------------------------------------------------------------------------
  -- New Tag Settings
  -----------------------------------------------------------------------------
  
  -- Tag contents for normal transaction flow.
  ud_new_tag_valid        <= not ( update_valid and update_info.Evict and not update_info.Allocate ) and
                             not ( update_snoop_altered_delayed_txn and update_snoop_made_txn_invalid );
  ud_new_tag_secure       <= update_info.Prot(C_PROT_SECURE_POS);
  ud_new_tag_unique       <= update_write_hit and 
                             not ( update_snoop_altered_delayed_txn and update_snoop_made_txn_shared );
  ud_new_tag_reused       <= update_reused_tag;
  ud_new_tag_locked       <= update_miss;
  ud_new_tag_dirty        <= ( ( update_first_write_hit                     ) or
                               ( update_write_miss and update_info.Allocate ) ) and
                             not ( update_snoop_altered_delayed_txn and update_snoop_made_txn_clean );
  ud_new_tag_addr         <= update_info.Addr(C_ADDR_TAG_POS);
  
  -- Tag contents after read-back.
  rb_new_tag_valid        <= not update_read_failed;
  rb_new_tag_secure       <= ri_secure;
  rb_new_tag_unique       <= '0';
  rb_new_tag_reused       <= '0';
  rb_new_tag_locked       <= '0';
  rb_new_tag_dirty        <= ( ri_merge and update_readback_available );
  rb_new_tag_addr         <= ri_addr(C_ADDR_TAG_POS);
  
  
  -- Compile current Tag that shall be written depending on source.
  update_new_tag_valid    <= rb_new_tag_valid   when ( update_readback_available ) = '1' else
                             ud_new_tag_valid   when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_valid;
  update_new_tag_secure   <= rb_new_tag_secure  when ( update_readback_available ) = '1' else
                             ud_new_tag_secure  when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_secure;
  update_new_tag_unique   <= rb_new_tag_unique  when ( update_readback_available ) = '1' else
                             ud_new_tag_unique  when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_unique;
  update_new_tag_reused   <= rb_new_tag_reused  when ( update_readback_available ) = '1' else
                             ud_new_tag_reused  when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_reused;
  update_new_tag_locked   <= rb_new_tag_locked  when ( update_readback_available ) = '1' else
                             ud_new_tag_locked  when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_locked;
  update_new_tag_dirty    <= rb_new_tag_dirty   when ( update_readback_available ) = '1' else
                             ud_new_tag_dirty   when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_dirty;
  update_new_tag_addr     <= rb_new_tag_addr    when ( update_readback_available ) = '1' else
                             ud_new_tag_addr    when ( update_need_tag_write and not update_done_tag_write ) = '1' else
                             su_new_tag_addr;
  -----------------------------------------------------------------------------
  -- Generate Data for Read Request
  -----------------------------------------------------------------------------
  
  -- Unmodified signals.
  read_req_info.Exclusive <= read_req_exclusive_i;
  read_req_info.Kind      <= read_req_kind_i;
  read_req_info.Port_Num  <= std_logic_vector(to_unsigned(update_port_rd, C_MAX_NUM_PORT_WIDTH));
  read_req_info.Snoop     <= C_ARSNOOP_ReadUnique when ( s2b(update_info.Wr) and s2b(update_info.Allocate) ) else
                             update_info.Snoop;
  read_req_info.Domain    <= update_info.Domain;
  read_req_info.Prot      <= update_info.Prot when ( C_ENABLE_NON_SECURE > 0) else
                             NULL_AXI_PROT;
  
  -- Generate adjusted read length and size.
  Gen_Read_Request: process (update_info, read_req_valid_i) is
  begin  -- process Gen_Read_Request
    -- Default values (allocating).
    read_req_info.Valid     <= read_req_valid_i;
    read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH);
    read_req_info.Len       <= std_logic_vector(to_unsigned((4*C_CACHE_LINE_LENGTH) / (C_EXTERNAL_DATA_WIDTH/8)-1, 8));
    read_req_info.Size      <= std_logic_vector(to_unsigned(Log2(C_EXTERNAL_DATA_WIDTH/8), 3));
    read_req_exclusive_i    <= C_LOCK_NORMAL;
    if( C_EXTERNAL_DATA_WIDTH = ( 32 * C_CACHE_LINE_LENGTH ) ) then
      read_req_kind_i         <= C_KIND_INCR;
    else
      read_req_kind_i         <= C_KIND_WRAP;
    end if;
    
    if( is_mst_coherent(C_ENABLE_COHERENCY) or 
        ( ( update_info.Allocate = '0' ) and not ( is_slv_coherent(C_ENABLE_COHERENCY) or has_ex_mon(C_ENABLE_EX_MON) ) ) ) then
      read_req_exclusive_i    <= update_info.Exclusive;
    end if;
    
    if( update_info.Allocate = '0' ) then
      -- Non Allocating transaction, propagate information from original transaction.
      read_req_kind_i         <= update_info.Kind;
      read_req_info.Len       <= update_info.Len;
      read_req_info.Size      <= update_info.Size;
      if( ( to_integer(unsigned(update_info.Len)) = 0 ) and ( update_info.Kind = C_KIND_WRAP ) ) then
        read_req_kind_i         <= C_KIND_INCR;
        case update_info.Size is
          when C_BYTE_SIZE          =>
            null;
          when C_HALF_WORD_SIZE     =>
            if( C_CACHE_DATA_WIDTH >= 16 ) then
              read_req_info.Addr     <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE - 1,        
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when C_WORD_SIZE          =>
            if( C_CACHE_DATA_WIDTH >= 32 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_WORD_STEP_SIZE - 1,             
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when C_DOUBLE_WORD_SIZE   =>
            if( C_CACHE_DATA_WIDTH >= 64 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE - 1,      
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when C_QUAD_WORD_SIZE     =>
            if( C_CACHE_DATA_WIDTH >= 128 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE - 1,        
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when C_OCTA_WORD_SIZE     =>
            if( C_CACHE_DATA_WIDTH >= 256 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE - 1,        
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when C_HEXADECA_WORD_SIZE =>
            if( C_CACHE_DATA_WIDTH >= 512 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE - 1,    
                                                                          C_MAX_ADDR_WIDTH));
            end if;
          when others               =>
            if( C_CACHE_DATA_WIDTH >= 1024 ) then
              read_req_info.Addr      <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH) and
                                         not std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE - 1, 
                                                                          C_MAX_ADDR_WIDTH));
            end if;
        end case;
      end if;
    else
      -- Default wrap transactions shall be aligned to native size boundary.
      read_req_info.Addr(C_EXT_DATA_ADDR_POS)  <= (others=>'0');
    end if;
  end process Gen_Read_Request;
  
  
  -----------------------------------------------------------------------------
  -- Generate Data for Write Request
  -----------------------------------------------------------------------------
  
  -- Unmodified signals.
  write_req_info.Port_Num     <= std_logic_vector(to_unsigned(update_port_wr, C_MAX_NUM_PORT_WIDTH));
  write_req_info.Internal     <= update_need_evict;
  write_req_info.Exclusive    <= write_req_exclusive_i;
  write_req_info.Kind         <= write_req_kind_i;
  write_req_info.Line_Only    <= write_req_line_only_i;
  write_req_info.Cancelled    <= update_write_cancelled;
  write_req_info.Stall_Snoop  <= b2s(is_mst_coherent(C_ENABLE_COHERENCY))
                                     when ( update_info.Snoop(write_req_info.Snoop'range) = C_AWSNOOP_WriteClean ) or
                                          ( update_info.Snoop(write_req_info.Snoop'range) = C_AWSNOOP_WriteBack  ) or
                                          ( update_info.Snoop(write_req_info.Snoop'range) = C_AWSNOOP_WriteEvict ) or
                                          ( update_info.Snoop(write_req_info.Snoop'range) = C_AWSNOOP_Evict      ) or
                                          s2b(update_read_miss_dirty)                                              else
                                 '0';
  write_req_info.Snoop        <= C_AWSNOOP_WriteBack                          when ( s2b(update_read_miss_dirty) ) else
                                 update_info.Snoop(write_req_info.Snoop'range);
  write_req_info.Domain       <= update_info.Domain;
  
  -- Generate adjusted read length and size.
  Gen_Write_Request: process (update_need_evict, update_info, update_old_tag, write_req_valid_i) is
  begin  -- process Gen_Write_Request
    write_req_info.Valid             <= write_req_valid_i;
    -- Default values (evicting).
    if( update_info.Evict = '1' ) then
      write_req_info.Addr                   <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH);
      write_req_info.Addr(C_ADDR_WORD_POS)  <= addr_word_zero_vec;
      write_req_info.Addr(C_ADDR_BYTE_POS)  <= addr_byte_zero_vec;
      if( C_ENABLE_NON_SECURE > 0 ) then
        write_req_info.Prot                   <= update_info.Prot;
      else
        write_req_info.Prot                   <= NULL_AXI_PROT;
      end if;
      write_req_line_only_i                 <= '1';
    else
-- TODO: make the address complete?
      write_req_info.Addr                   <= fit_vec((update_old_tag.Addr(C_ADDR_TAG_POS) & 
                                                        update_info.Addr(C_ADDR_LINE_POS) & 
                                                        addr_word_zero_vec & 
                                                        addr_byte_zero_vec ), C_MAX_ADDR_WIDTH);
      if( ( C_ENABLE_NON_SECURE > 0 ) and ( update_old_tag.Secure = '0' ) ) then
        write_req_info.Prot                   <= (others=>'0');
      else
        write_req_info.Prot                   <= NULL_AXI_PROT;
      end if;
      write_req_line_only_i                 <= '0';
    end if;
    write_req_info.Len              <= std_logic_vector(to_unsigned((4*C_CACHE_LINE_LENGTH) / (C_EXTERNAL_DATA_WIDTH/8)-1, 8));
    write_req_info.Size             <= std_logic_vector(to_unsigned(Log2(C_EXTERNAL_DATA_WIDTH/8), 3));
    write_req_exclusive_i   <= C_LOCK_NORMAL;
    write_req_kind_i        <= C_KIND_INCR;
    
    if( is_mst_coherent(C_ENABLE_COHERENCY) or 
        ( ( update_info.Allocate = '0' ) and not ( is_slv_coherent(C_ENABLE_COHERENCY) or has_ex_mon(C_ENABLE_EX_MON) ) ) ) then
      write_req_exclusive_i   <= update_info.Exclusive;
    end if;
    
    if( update_need_evict = '0' ) then
      -- Non Evicting transaction, propagate information from original transaction.
      write_req_info.Addr     <= fit_vec(update_info.Addr(C_ADDR_INTERNAL_POS), C_MAX_ADDR_WIDTH);
      if( C_ENABLE_NON_SECURE > 0 ) then
        write_req_info.Prot                   <= update_info.Prot;
      else
        write_req_info.Prot                   <= NULL_AXI_PROT;
      end if;
      write_req_kind_i        <= update_info.Kind;
      
      -- Adjust transaction for external interface.
      case update_info.Size is
        when C_BYTE_SIZE          =>
          write_req_info.Len      <= update_info.Len;
          write_req_info.Size     <= update_info.Size;
        when C_HALF_WORD_SIZE     =>
          write_req_info.Len      <= update_info.Len;
          write_req_info.Size     <= update_info.Size;
        when C_WORD_SIZE          =>
          write_req_info.Len      <= update_info.Len;
          write_req_info.Size     <= update_info.Size;
        when C_DOUBLE_WORD_SIZE   =>
          if( C_EXTERNAL_DATA_WIDTH < C_DOUBLE_WORD_WIDTH ) then
            write_req_info.Len      <= 
                update_info.Len(AXI_LENGTH_TYPE'left - Log2(C_DOUBLE_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) downto 0) & 
                (Log2(C_DOUBLE_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) - 1 downto 0=>'1');
          else
            write_req_info.Len      <= update_info.Len;
            write_req_info.Size     <= update_info.Size;
          end if;
        when C_QUAD_WORD_SIZE     =>
          if( C_EXTERNAL_DATA_WIDTH < C_QUAD_WORD_WIDTH ) then
            write_req_info.Len      <= 
                update_info.Len(AXI_LENGTH_TYPE'left - Log2(C_QUAD_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) downto 0) & 
                (Log2(C_QUAD_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) - 1 downto 0=>'1');
          else
            write_req_info.Len      <= update_info.Len;
            write_req_info.Size     <= update_info.Size;
          end if;
        when C_OCTA_WORD_SIZE     =>
          if( C_EXTERNAL_DATA_WIDTH < C_OCTA_WORD_WIDTH ) then
            write_req_info.Len      <= 
                update_info.Len(AXI_LENGTH_TYPE'left - Log2(C_OCTA_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) downto 0) & 
                (Log2(C_OCTA_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) - 1 downto 0=>'1');
          else
            write_req_info.Len      <= update_info.Len;
            write_req_info.Size     <= update_info.Size;
          end if;
        when C_HEXADECA_WORD_SIZE =>
          if( C_EXTERNAL_DATA_WIDTH < C_HEXADECA_WORD_WIDTH ) then
            write_req_info.Len      <= 
                update_info.Len(AXI_LENGTH_TYPE'left - Log2(C_HEXADECA_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) downto 0) & 
                (Log2(C_HEXADECA_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) - 1 downto 0=>'1');
          else
            write_req_info.Len      <= update_info.Len;
            write_req_info.Size     <= update_info.Size;
          end if;
        when others               =>
          if( C_EXTERNAL_DATA_WIDTH < C_TRIACONTADI_WORD_WIDTH ) then
            write_req_info.Len      <= 
                update_info.Len(AXI_LENGTH_TYPE'left - Log2(C_TRIACONTADI_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) downto 0) & 
                (Log2(C_TRIACONTADI_WORD_WIDTH/C_EXTERNAL_DATA_WIDTH) - 1 downto 0=>'1');
          else
            write_req_info.Len      <= update_info.Len;
            write_req_info.Size     <= update_info.Size;
          end if;
      end case;
    end if;
  end process Gen_Write_Request;
  
  
  -----------------------------------------------------------------------------
  -- End of Transaction
  -----------------------------------------------------------------------------
  
  -- Determine when it is done.
  update_read_done_i  <= update_read_resize_valid and update_read_resize_last and update_read_resize_ready;
  update_write_done_i <= update_wm_pop_normal;
  
  
  -----------------------------------------------------------------------------
  -- Set Handling
  -- 
  -- Manipulate address and Set information to create/extract relevant
  -- addresses to Tag and Data.
  -----------------------------------------------------------------------------
  
  update_tag_trans_addr   <= update_info.Addr(C_ADDR_LINE_POS);
  update_tag_unlock_addr  <= ri_addr(C_ADDR_LINE_POS);
  update_data_line        <= update_data_base_line;
  
  
  -----------------------------------------------------------------------------
  -- Check Locked Tag
  -- 
  -- Control the readback of the Tag to check that it is still supposed to go 
  -- into the Cache and Tag.
  -----------------------------------------------------------------------------
  
  Single_External_Beat: if( C_EXTERNAL_DATA_WIDTH = 32 * C_CACHE_LINE_LENGTH ) generate
  begin
    -- Enable Tag for read back.
    update_readback_tag_en    <= update_rb_pos_phase;
  
    -- Determine if the Tag interface is free for use.
    update_rb_pos_phase       <= ri_exist and ri_allocate and not update_remove_locked_2nd_cycle;
    
    -- Determine if it is ok to proceed with read.
-- TODO: Snoop block to prevent loosing remove of lock.
    update_remove_locked_safe <= ( ri_exist and not ri_allocate ) or
                                 ( ri_exist and     ri_allocate and update_remove_locked_2nd_cycle );
    
    -- Sequence handler for allocating
    Readback_Handle : process (ACLK) is
    begin  -- process Readback_Handle
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          update_remove_locked_2nd_cycle <= '0';
        else
          update_remove_locked_2nd_cycle <= backend_rd_filtered_valid and update_readback_possible and ri_exist and  
                                            ri_allocate and not update_remove_locked_2nd_cycle;
        end if;
      end if;
    end process Readback_Handle;
    
    -- Unused signal.
    update_first_word_safe          <= '1';
    
  end generate Single_External_Beat;
  
  Short_External_Burst: if( update_word_cnt_len'length < 2 ) and ( C_EXTERNAL_DATA_WIDTH < 32 * C_CACHE_LINE_LENGTH ) generate
  begin
    -- Enable Tag for read back.
    update_readback_tag_en    <= update_rb_pos_phase;
  
    -- Determine if the Tag interface is free for use.
    update_rb_pos_phase       <= update_read_miss_start and not update_readback_available;
    
    -- First word is also safe if one cacheline is two words.
    update_first_word_safe    <= update_read_miss_start_ok and update_readback_allowed when 
                                      ( C_EXTERNAL_DATA_WIDTH / C_CACHE_DATA_WIDTH > 1 ) else 
                                 '0';
    
    -- Determine if it is ok to proceed with read.
-- TODO: Snoop block to prevent loosing remove of lock.
    update_remove_locked_safe <= ( ri_exist and not ri_allocate ) or
                                 ( ri_exist and     ri_allocate and 
                                   ( update_readback_available or update_first_word_safe ) );
    
    -- Unused signal.
    update_remove_locked_2nd_cycle  <= '0';
    
  end generate Short_External_Burst;
  
  Long_External_Burst: if( update_word_cnt_len'length >= 2 ) generate
  begin
    -- Enable Tag for read back.
    update_readback_tag_en    <= update_word_cnt_almost_last;
  
    -- Determine if the Tag interface is free for use.
    Update_Word_Cnt_Handle : process (ACLK) is
    begin  -- process Update_Word_Cnt_Handle
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if ARESET_I = '1' then                      -- synchronous reset (active high)
          update_rb_pos_phase <= '0';
          
        elsif( update_word_cnt_en = '1' ) then
          -- Detect if this was the last word for this evict/read miss.
          if( update_word_cnt_len = std_logic_vector(to_unsigned(2, update_word_cnt_len'length)) ) then
            update_rb_pos_phase <= ri_allocate and update_read_miss_ongoing;
          else
            update_rb_pos_phase <= '0';
          end if;
          
        end if;
      end if;
    end process Update_Word_Cnt_Handle;
    
    -- Determine if it is ok to proceed with read.
    update_remove_locked_safe <= ( ( update_readback_possible or update_readback_available or 
                                     update_tag_write_ignore or not update_word_cnt_almost_last ) and
                                   ( update_rm_alloc_ongoing ) ) or
                                 not update_rm_alloc_ongoing;
    
    -- Unused signal.
    update_first_word_safe          <= '1';
    update_remove_locked_2nd_cycle  <= '0';
  
  end generate Long_External_Burst;
  
  -- Determine if the Tag interface is free for use.
  update_readback_allowed   <= ( ( update_valid and not update_need_tag_write ) or 
                                 update_tag_write_ignore or not update_valid ) and 
                               ( update_readback_available or not snoop_need_tag_write );
  update_readback_possible  <= update_readback_allowed and update_rb_pos_phase;
  
  -- Determine when the readback Tag is available.
  Tag_Readback_Handle : process (ACLK) is
  begin  -- process Tag_Readback_Handle
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_readback_available <= '0';
        update_readback_done      <= '0';
        update_cur_tag_rd_way     <= 0;
      else
        if( update_readback_possible = '1' ) then
          update_readback_available <= '1';
          update_cur_tag_rd_way     <= update_cur_tag_way;
        elsif( backend_rd_data_pop = '1' ) then
          update_readback_available <= '0';
        end if;
        
        if( backend_rd_data_pop = '1' ) then
          update_readback_done      <= '0';
        elsif( update_remove_locked = '1' ) then
          update_readback_done      <= '1';
        end if;
      end if;
    end if;
  end process Tag_Readback_Handle;
  
  -- Get the current Tag.
  update_readback_tag       <= update_tag_current_word(update_cur_tag_rd_way);
  
  -- Check if Tag in the current Way matches the returned data.
  update_locked_tag_sec_chk <= not ( update_readback_tag.Secure xor ri_secure )
                                    when ( C_ENABLE_NON_SECURE > 0 ) else 
                               '1';
  update_locked_tag_match   <= update_locked_tag_sec_chk
                                    when ri_addr(C_ADDR_TAG_POS) = update_readback_tag.Addr(C_ADDR_TAG_POS) else 
                               '0';
  update_locked_tag_is_dead <= update_readback_available and not update_locked_tag_match;
  
  -- Determine when it is ok to remove a lock for readback Tag.
  update_remove_locked      <= ( update_readback_available and not update_locked_tag_is_dead ) and
                               ( ri_allocate ) and
                               ( backend_rd_data_pop );
  Gen_Unlock_Info : process (ACLK) is
  begin  -- process Gen_Unlock_Info
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_lock_release                           <= '0';
        update_lock_way                               <= 0;
        update_release_tag                            <= C_NULL_WAY_LINE_TAG;
        
      else
        update_lock_release                           <= update_remove_locked;
        update_lock_way                               <= ri_way;
        update_release_tag                            <= C_NULL_WAY_LINE_TAG;
        update_release_tag.Valid                      <= rb_new_tag_valid;
        update_release_tag.Unique                     <= rb_new_tag_unique;
        update_release_tag.Dirty                      <= rb_new_tag_dirty;
        update_release_tag.Locked                     <= rb_new_tag_locked;
        update_release_tag.Reused                     <= rb_new_tag_reused;
        update_release_tag.Secure                     <= rb_new_tag_secure;
        update_release_tag.Addr                       <= C_BASEADDR;
        update_release_tag.Addr(C_ADDR_TAG_POS)       <= ri_addr(C_ADDR_TAG_POS);
        update_release_tag.Addr(C_ADDR_LINE_POS)      <= ri_addr(C_ADDR_LINE_POS);
        update_release_tag.Addr(C_ADDR_EXT_WORD_POS)  <= update_word_cnt(C_ADDR_EXT_WORD_POS);
        
      end if;
    end if;
  end process Gen_Unlock_Info;
  
  -- Insert read updates when safe.
  update_block_lookup       <= ( update_readback_possible and update_read_miss_ongoing );
  
  
  -----------------------------------------------------------------------------
  -- Control Update TAG
  -- 
  -- Refresh Tag when needed and readback old Tag for Locked checks.
  -----------------------------------------------------------------------------
  
  -- Create the new tag contents.
  update_new_tag.Valid   <= update_new_tag_valid;
  update_new_tag.Unique  <= update_new_tag_unique;
  update_new_tag.Reused  <= update_new_tag_reused;
  update_new_tag.Dirty   <= update_new_tag_dirty;
  update_new_tag.Locked  <= update_new_tag_locked;
  update_new_tag.Secure  <= update_new_tag_secure;
  update_new_tag.Addr    <= fit_vec(( update_new_tag_addr & 
                                      addr_line_zero_vec  & 
                                      addr_word_zero_vec  & 
                                      addr_byte_zero_vec ), C_MAX_ADDR_WIDTH);
  
  -- Assign external signals.
  update_tag_addr_i     <= update_tag_unlock_addr when ( update_readback_possible or update_readback_available ) = '1' else
                           update_tag_trans_addr  when ( update_need_tag_write and not update_done_tag_write )   = '1' else
                           snoop_tag_trans_addr;
  Gen_Clean_Tag_Addr: for N in update_tag_addr'range generate
  begin
    update_tag_addr(N)    <= '1' when update_tag_addr_i(N) = '1' else '0';
  end generate Gen_Clean_Tag_Addr;
  update_tag_en         <= update_tag_en_i;
  update_tag_en_i       <= update_tag_write_raw or update_readback_available or update_readback_tag_en;
  update_tag_we         <= update_tag_we_i;
--  update_tag_we_i       <= (C_WAY_POS=>update_tag_write) and 
--                           std_logic_vector(to_unsigned(2 ** update_cur_tag_way, C_NUM_WAYS));
  
  Gen_Set_Tag: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    -- Is this the selected read-back way?
--    update_sel_readback_tag(K)  <= ri_allocate when ( update_cur_tag_rd_way = K ) else
--                                   '0';
    update_select_readback(K) <= '1' when ( update_cur_tag_rd_way = K ) else '0';
    UD_Tag_And_Inst1: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => ri_allocate,
        A         => update_select_readback(K),
        Carry_OUT => update_sel_readback_tag(K)
      );
    
    -- Does the address still match?
--    update_tag_match(K)         <= update_sel_readback_tag(K) when ri_addr(C_ADDR_TAG_POS) = 
--                                                                   update_tag_current_word(K).Addr(C_ADDR_TAG_POS) else
--                                   '0';
    UD_Tag_Compare_Inst1: carry_compare
      generic map(
        C_TARGET  => C_TARGET,
        C_SIZE    => C_NUM_ADDR_TAG_BITS
      )
      port map(
        A_Vec     => ri_addr(C_ADDR_TAG_POS),
        B_Vec     => update_tag_current_word(K).Addr(C_ADDR_TAG_POS),
        Carry_In  => update_sel_readback_tag(K),
        Carry_Out => update_tag_match_pre(K)
      );
    Use_Secure: if ( C_ENABLE_NON_SECURE > 0 ) generate
      signal local_secure_check : std_logic;
    begin
      local_secure_check  <= not ( update_tag_current_word(K).Secure xor ri_secure );
      
      LU_Tag_Compare_Inst2: carry_and
        generic map(
          C_TARGET  => C_TARGET
        )
        port map(
          Carry_IN  => update_tag_match_pre(K),
          A         => local_secure_check,
          Carry_OUT => update_tag_match(K)
        );
        
    end generate Use_Secure;
    No_Secure: if ( C_ENABLE_NON_SECURE = 0 ) generate
    begin
      update_tag_match(K) <= update_tag_match_pre(K);
      
    end generate No_Secure;
    
    
    -- Are this the right phase?
--    update_tag_is_alive(K)      <= update_tag_match(K) and update_readback_available;
    UD_Tag_And_Inst2: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => update_tag_match(K),
        A         => update_readback_available,
        Carry_OUT => update_tag_is_alive(K)
      );
    
    -- Is the last word used?
--    update_tag_remove_lock(K)   <= update_tag_is_alive(K) and backend_rd_data_pop;
    UD_Tag_And_Inst3: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => update_tag_is_alive(K),
        A         => backend_rd_data_pop,
        Carry_OUT => update_tag_remove_lock(K)
      );
    
    -- Merge with normal tag write.
--    update_tag_we_i(K)          <= update_tag_remove_lock(K) or update_tag_write_raw_vec(K);
    UD_Tag_Or_Inst1: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => update_tag_remove_lock(K),
        A         => update_tag_write_raw_vec(K),
        Carry_OUT => update_tag_we_i(K)
      );
        
    -- Concatenate new Tag.
    update_tag_new_word(K)  <= update_new_tag;
    
  end generate Gen_Set_Tag;

  
  -----------------------------------------------------------------------------
  -- Control Update DATA
  -- 
  -- Enable the Way pointed out by the current operation.
  -- 
  -- Concatenate to form new Data to be written for Read Miss, and vectorize
  -- current data for Evict.
  -----------------------------------------------------------------------------
  
  update_data_addr_i    <= update_data_line & update_word_cnt;
  Gen_Clean_Data_Addr: for N in update_data_addr'range generate
  begin
    update_data_addr(N)     <= '1' when update_data_addr_i(N) = '1' else '0';
  end generate Gen_Clean_Data_Addr;
  update_data_en_ii(0)  <= update_word_cnt_en;
--  update_data_en_i      <= (C_WAY_POS=>update_data_en_ii) and
--                           std_logic_vector(to_unsigned(2 ** update_cur_data_way, C_NUM_WAYS));
  Gen_Set_Data_En: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    update_data_en_sel_n(K) <= '0' when ( update_cur_data_way = K ) else
                               '1';
    
    UD_RD_And_Inst10: carry_latch_and_n
      generic map(
        C_TARGET  => C_TARGET,
        C_NUM_PAD => min_of(4, 2 + K * 4),
        C_INV_C   => false
      )
      port map(
        Carry_IN  => update_data_en_ii(K),
        A_N       => update_data_en_sel_n(K),
        O         => update_data_en_i(K),
        Carry_OUT => update_data_en_ii(K+1)
      );
  end generate Gen_Set_Data_En;
  
  update_data_en        <= update_data_en_i;

  update_data_we        <= (others=>update_wr_cnt_en);
  
  Gen_Merged_Data: for N in wma_strb'range generate
  begin
    update_data_new_word((N+1)*8 -1 downto N*8)  <= backend_rd_data_info.Data((N+1)*8 -1 downto N*8) 
                                                          when ( ri_merge       = '0' ) or 
                                                               ( wma_strb(N)    = '0' ) or 
                                                               ( wma_merge_done = '1' ) else
                                                    wma_data((N+1)*8 -1 downto N*8);
  end generate Gen_Merged_Data;
  
  Gen_Set_Data: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    -- Vectorize Data.
    update_data_current_word_i(K) <= update_data_current_word(K)(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
    
  end generate Gen_Set_Data;
  
  
  -----------------------------------------------------------------------------
  -- Queue for Data Eviction (Read Miss Dirty and Evict)
  --
  -- Store Way and Offset information in the Evict queue in order to free up
  -- the more critical part that relies on Tag access.
  -- 
  -- The que will be used by the data pointer controller in order to push
  -- data into the Write Data buffer. This is synchronized with Write Miss.
  -----------------------------------------------------------------------------
  
  -- Generate control signals.
  update_e_push     <= update_evict;
  update_e_pop      <= update_evict_stop and not e_fifo_empty;
  
  FIFO_E_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => update_e_push,
      queue_pop                 => update_e_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => e_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => e_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => e_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_e,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => e_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Evict FIFO.
  FIFO_Evict_Memory : process (ACLK) is
  begin  -- process FIFO_Evict_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( update_e_push = '1' ) then
        -- Insert new item.
        e_fifo_mem(0).Way           <= update_way;
        e_fifo_mem(0).Offset        <= update_info.Addr(C_ADDR_LINE_POS);
        e_fifo_mem(0).Failed        <= update_failed_allocation;
        e_fifo_mem(0).WriteHitLast  <= update_whl_rejected;
        e_fifo_mem(0).Cancelled     <= update_write_cancelled;
        
        -- Shift FIFO contents.
        e_fifo_mem(e_fifo_mem'left downto 1) <= e_fifo_mem(e_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_Evict_Memory;
  
  -- Rename signals.
  e_way                 <= e_fifo_mem(to_integer(unsigned(e_read_fifo_addr))).Way;
  e_offset              <= e_fifo_mem(to_integer(unsigned(e_read_fifo_addr))).Offset;
  e_failed              <= e_fifo_mem(to_integer(unsigned(e_read_fifo_addr))).Failed;
  e_whl                 <= e_fifo_mem(to_integer(unsigned(e_read_fifo_addr))).WriteHitLast;
  e_cancelled           <= e_fifo_mem(to_integer(unsigned(e_read_fifo_addr))).Cancelled;
  
  
  -----------------------------------------------------------------------------
  -- Queue for Evict Done
  -- 
  -----------------------------------------------------------------------------
  
  -- Control Queue of completed WMA.
  ed_push <= update_e_pop and wm_evict and wm_will_use;
  ed_pop  <= ri_pop and ri_evicted;
  
  FIFO_ED_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => ed_push,
      queue_pop                 => ed_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => ed_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => ed_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => open,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => ed_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
  
  
  -----------------------------------------------------------------------------
  -- Update Data Pointer
  -- 
  -- Select if Evict or Read Miss (highest priority) shall have access to the 
  -- Data port.
  -- Current Way and Line information is used from respective command.
  -- 
  -- Evict data is read and pushed to the Write Data buffer as quickly as 
  -- possible. Evict has to be synchronized with the Write Miss queue in order 
  -- to maintain the order relative to Write Address.
  -- 
  -- Read Miss data is written to the Data memory in the speed permitted by the 
  -- slave that provides it, and possibly throttled by any size conversions 
  -- needed.
  -----------------------------------------------------------------------------
  
  -- Generate control signals for counter.
  update_rd_cnt_en    <= ( ( ( wm_evict and wm_exist ) and (not e_fifo_empty) ) and 
                           ( not ( update_read_miss_start or update_read_miss_ongoing ) ) and
                           ( not update_wm_pop_evict_hold ) and 
                           ( not ( backend_rd_filtered_valid and ri_evicted and not ed_fifo_empty and 
                                   not update_evict_ongoing) ) and 
                           ( ( not write_data_almost_full and not write_data_full ) or 
                             ( write_data_full_d1         and not write_data_full ) ) ) or
                         ( (  update_snoop_start or update_snoop_ongoing ) and
                           ( not update_snoop_data_stall ) );
  
  -- Select the current word offset to the Data memory.
  Update_Word_Cnt_Gen: process (update_word_cnt_first, backend_rd_data_info, ri_addr, 
                                update_word_cnt_next, update_evict_ongoing, ri_way, 
                                e_way, e_offset, update_read_miss_wma_safe, sdr_fifo_empty, update_snoop_safe,
                                update_read_miss_safe, ri_allocate, backend_rd_filtered_valid, 
                                update_snoop_start, update_snoop_ongoing, sdr_way, sdr_line_addr, sdr_word_addr) is
  begin  -- process Update_Word_Cnt_Gen
    -- Determine base address for this transaction.
    if ( update_word_cnt_first = '1' ) then
      if ( ( backend_rd_filtered_valid and ri_allocate and update_read_miss_safe and update_read_miss_wma_safe and sdr_fifo_empty ) = '1' ) then
        update_word_cnt <= ri_addr(C_ADDR_EXT_WORD_POS);
        
      elsif( update_snoop_start = '1' ) then
        update_word_cnt <= sdr_word_addr(C_ADDR_EXT_WORD_POS);
        
      else
        update_word_cnt <= (others=>'0');
        
      end if;
    else
      update_word_cnt <= update_word_cnt_next;
    end if;
    
    if ( ( backend_rd_filtered_valid and ri_allocate and update_read_miss_safe and not update_evict_ongoing and update_read_miss_wma_safe and update_snoop_safe ) = '1' ) then
      -- Use Line and Way for read miss.
      update_cur_data_way   <= ri_way;
      update_data_base_line <= ri_addr(C_ADDR_LINE_POS);
      
    elsif ( ( update_snoop_start or update_snoop_ongoing ) = '1' ) then
      update_cur_data_way   <= sdr_way;
      update_data_base_line <= sdr_line_addr;
      
    else
      -- Use evict queue information when not running read miss data.
      update_cur_data_way   <= e_way;
      update_data_base_line <= e_offset;
      
    end if;
  end process Update_Word_Cnt_Gen;
  
  -- Handle counter and flags.
  Update_Word_Cnt_Handle : process (ACLK) is
  begin  -- process Update_Word_Cnt_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        update_word_cnt_first       <= '1';
        update_word_cnt_last        <= '0';
        update_word_cnt_almost_last <= sel(update_word_cnt_len'length = 1, '1', '0');
        update_word_cnt_next        <= (others => '0');
        update_word_cnt_len         <= (others => '1');
        
      elsif( update_word_cnt_en = '1' ) then
        -- Handle first word status. Next is marked as first when last beat is used.
        if( update_word_cnt_last = '1' ) then
          update_word_cnt_first   <= '1';
        else
          update_word_cnt_first   <= '0';
        end if;
        
        -- Detect if this was the last word for this evict/read miss.
        if( update_word_cnt_len = std_logic_vector(to_unsigned(2, update_word_cnt_len'length)) ) then
          update_word_cnt_almost_last <= '1';
        else
          update_word_cnt_almost_last <= '0';
        end if;
        if( update_word_cnt_len = std_logic_vector(to_unsigned(1, update_word_cnt_len'length)) ) then
          update_word_cnt_last    <= '1';
        else
          update_word_cnt_last    <= '0';
        end if;
        
        -- Update remaining length and counter.
        update_word_cnt_next  <= std_logic_vector(unsigned(update_word_cnt) + 1);
        update_word_cnt_len   <= std_logic_vector(unsigned(update_word_cnt_len) - 1);
        
      end if;
    end if;
  end process Update_Word_Cnt_Handle;
  
  -- Track when it safe to handle Read Miss from a Snoop Data perspective.
  update_snoop_safe         <= sdr_fifo_empty                  or 
                               update_read_miss_ongoing        or
                               ( ri_exist and not ri_allocate );
  
  -- Detect when it is safe to start to use read miss data.
  update_read_miss_safe     <= ( ( ri_evicted and not ed_fifo_empty ) or not ri_evicted or update_read_miss_ongoing );
  update_read_miss_wma_safe <= ( ( ri_merge and ( wma_merge_done or not wma_fifo_empty ) ) or not ri_merge );
  
  -- Detect when a read miss is allowed to start.
  update_read_miss_start    <= backend_rd_filtered_valid and update_read_miss_start_ok;
  
  -- Start Evict counting when there is no read miss data available and there is available evict request.
  update_evict_start        <= (wm_evict and wm_exist) and (not e_fifo_empty) and 
                               ( not ( backend_rd_filtered_valid and ri_evicted and not ed_fifo_empty ) ) and
                               ( not update_wm_pop_evict_hold ) and 
                               (     sdr_fifo_empty ) and
                               ( not update_snoop_ongoing ) and
                               ( ((not backend_rd_filtered_valid) and (not update_read_miss_ongoing)) or
                                 ( ri_exist and ri_merge and wma_fifo_empty and not update_read_miss_ongoing) or
                                 ( ri_evicted and not update_read_miss_ongoing ) or
                                 not ri_allocate );
  
  -- Stop when last element has been processed.
  update_read_miss_stop     <= update_word_cnt_last and update_wr_cnt_en and update_read_miss_ongoing
                                      when ( C_EXTERNAL_DATA_WIDTH < 32 * C_CACHE_LINE_LENGTH ) else
                               update_word_cnt_last and update_wr_cnt_en;
  update_evict_stop         <= update_word_cnt_last and update_rd_cnt_en and update_evict_ongoing
                                      when ( C_EXTERNAL_DATA_WIDTH < 32 * C_CACHE_LINE_LENGTH ) else
                               update_word_cnt_last and update_rd_cnt_en and update_evict_start;
  
  -- Control the evict and read miss states.
  Update_Word_State_Handle : process (ACLK) is
  begin  -- process Update_Word_State_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        update_read_miss_ongoing  <= '0';
        update_rm_alloc_ongoing   <= '0';
        update_evict_ongoing      <= '0';
        update_evict_busy         <= '0';
        update_evict_failed       <= '0';
        update_evict_whl          <= '0';
        update_evict_cancelled    <= '0';
        
      elsif( update_word_cnt_en = '1' ) then
        -- Start and stop of Read Miss Ongoing.
        if( update_read_miss_stop = '1' ) then
          update_read_miss_ongoing  <= '0';
          update_rm_alloc_ongoing   <= '0';
        elsif( update_read_miss_start = '1' ) then
          update_read_miss_ongoing  <= '1';
          update_rm_alloc_ongoing   <= ri_allocate;
        end if;
        
        -- Start and stop of Evict Ongoing.
        if( update_evict_stop = '1' ) then
          update_evict_ongoing      <= '0';
        elsif( update_evict_start = '1' ) then
          update_evict_ongoing      <= '1';
        end if;
        
        update_evict_failed       <= e_failed;
        update_evict_whl          <= e_whl;
        update_evict_cancelled    <= e_cancelled;
        
      end if;
        
      -- Start and stop of Evict Busy.
      if( C_EXTERNAL_DATA_WIDTH < 32 * C_CACHE_LINE_LENGTH ) then
        if( ( update_evict_stop_d1 = '1' ) and not ( ( update_evict_start and update_word_cnt_en ) = '1' )  )then
          update_evict_busy         <= '0';
        elsif( update_evict_start = '1' ) and ( update_word_cnt_en = '1' ) then
          update_evict_busy         <= '1';
        end if;
      else
        update_evict_busy         <= update_evict_start and update_word_cnt_en;
      end if;
    end if;
  end process Update_Word_State_Handle;
  
  
  -- Set up Evict data stream to Write buffer.
  Update_Evict_Data_Handle : process (ACLK) is
  begin  -- process Update_Evict_Data_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        update_evict_valid      <= '0';
        update_evict_last       <= '0';
        write_data_full_d1      <= '0';
        update_evict_stop_d1    <= '0';
        update_cur_evict_way_d1 <= 0;
        
      else
        update_evict_valid      <= update_rd_cnt_en;
        update_evict_last       <= update_evict_stop;
        write_data_full_d1      <= write_data_full;
        update_evict_stop_d1    <= update_evict_stop;
        update_cur_evict_way_d1 <= e_way;
        
      end if;
    end if;
  end process Update_Evict_Data_Handle;
  
  -- Assign data from the correct way.
  update_evict_word           <= update_data_current_word_i(update_cur_evict_way_d1);
  
  -- Signal when the read miss data has been used.
  update_read_miss_use_bypass <= ( not ri_allocate ) when ri_exist = '1' else '0';
  
  
  -----------------------------------------------------------------------------
  -- Optimized Read Miss Use OK:
  -----------------------------------------------------------------------------
  
  -- Detect when a read miss is allowed to start.
  update_read_miss_start_ok <= (     ri_allocate and not update_evict_ongoing ) and 
                               ( not ri_lookup )                                and
                               (     update_read_miss_safe )                    and 
                               (     update_read_miss_wma_safe )                and
                               ( not update_snoop_ongoing )                     and
                               (     sdr_fifo_empty )
                                    when ri_exist = '1' else 
                               '0';
  ud_rm_available_sel       <= ri_exist and ri_allocate and not update_evict_ongoing and not update_snoop_ongoing and sdr_fifo_empty;
  UD_RD_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => '1',
      A         => ud_rm_available_sel,
      Carry_OUT => ud_rm_available
    );
  
--  update_read_miss_use_ok     <= ( update_read_miss_start_ok or update_read_miss_ongoing ) or 
--                                 update_read_miss_use_bypass;
  ud_rm_use_sel <= update_read_miss_ongoing or update_read_miss_use_bypass;
  UD_RD_Or_Inst1: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ud_rm_available,
      A         => ud_rm_use_sel,
      Carry_OUT => update_read_miss_use_ok
    );
  
  --
  -- Carry-chain continues and returns from R Queue region (for part of update_read_forward_ready).  
  --
  -- Leaves as: update_read_miss_use_ok
  -- Return as: update_read_miss_resize_ok
  --
    
  UD_RD_And_Inst4: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_read_miss_resize_ok,
      A         => update_read_miss_wma_safe,
      Carry_OUT => ud_rm_use_pre_safe
    );
  
  UD_RD_And_Inst5: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ud_rm_use_pre_safe,
      A         => update_read_miss_safe,
      Carry_OUT => ud_rm_use_safe
    );
  
  UD_RD_And_Inst6: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ud_rm_use_safe,
      A         => update_remove_locked_safe,
      Carry_OUT => ud_rm_use_and_lock_safe
    );
  
  Use_RM_Ready_Coherent: if(     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
  UD_RD_Or_Inst2: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ud_rm_use_and_lock_safe,
      A         => ri_lookup,
      Carry_OUT => ud_rm_use_and_lock_safe_or_int
    );

  end generate Use_RM_Ready_Coherent;
  No_RM_Ready_Coherent: if( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    ud_rm_use_and_lock_safe_or_int  <= ud_rm_use_and_lock_safe;
    
  end generate No_RM_Ready_Coherent;
  
  -- Acknowledge external data.
--  backend_rd_data_ready_i <= update_read_miss_use_ok and update_read_forward_ready;
  UD_RD_And_Inst7: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => ud_rm_use_and_lock_safe_or_int,
      A_N       => ARESET_I,
      Carry_OUT => backend_rd_data_ready_i
    );
  
  --
  -- Carry-chain continues and returns from Read Data Forwarding.  
  --
  -- Leaves as: backend_rd_data_ready_i
  -- Return as: backend_rd_data_use
  --
    
--  update_wr_cnt_en    <= ri_allocate and backend_rd_data_use and not update_evict_ongoing;
  ud_rm_sel_wr_cnt_en <= ri_allocate and not update_evict_ongoing;
  UD_RD_And_Inst9: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => backend_rd_data_use,
      A         => ud_rm_sel_wr_cnt_en,
      Carry_OUT => update_wr_cnt_en
    );
  
--  update_word_cnt_en  <= update_rd_cnt_en or update_wr_cnt_en;
  UD_RD_Or_Inst3: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => update_wr_cnt_en,
      A         => update_rd_cnt_en,
      Carry_OUT => update_word_cnt_en
    );
  
  
  -----------------------------------------------------------------------------
  -- Queue for Write Extraction (Write Miss)
  -- 
  -- Write Miss transactions are queued so that Lookup doesn't stall.
  -- 
  -- Sequentially transfers data from ports according to queue order.
  -- Read Miss Dirty (evict bit) is used to synchronize the Evicted data with
  -- Write Miss data in the Write queues.
  -----------------------------------------------------------------------------
  
  
  -- Generate control signals.
  update_wm_push        <= lookup_push_write_miss;
  update_wm_pop_evict   <= update_evict_stop      and wm_exist;
  update_wm_pop_normal  <= update_use_write_word and access_data_info(update_write_port_i).Last;
  update_wm_pop_allocate<= ( ( wm_evict and ( update_wm_pop_evict or update_wm_pop_evict_hold ) ) or not wm_evict ) and 
                           ( update_wm_pop_normal or update_wm_pop_normal_hold );
  update_wm_pop         <= ( update_wm_pop_evict    and not wm_allocate ) or 
                           ( update_wm_pop_normal   and not wm_allocate ) or
                           ( update_wm_pop_allocate );
  
  -- Keep track of busy status per port.
  Write_Miss_Handle : process (ACLK) is
  begin  -- process Write_Miss_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        update_write_miss_busy_i  <= (others=>'0');
      else
        for I in update_write_miss_busy_i'range loop
          if( update_wm_push = '1' and I = get_port_num(lookup_wm_info.Port_Num, C_NUM_INTERNAL_PORTS) ) then
            update_write_miss_busy_i(I) <= '1';
          elsif( ( wm_exist and wm_fifo_empty and update_wm_pop ) = '1' ) then
            update_write_miss_busy_i(I) <= '0';
          end if;
        end loop;
      end if;
    end if;
  end process Write_Miss_Handle;
  
  update_write_miss_busy  <= update_write_miss_busy_i;
  
  FIFO_WM_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => update_wm_push,
      queue_pop                 => update_wm_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => wm_refresh_reg,
      
      queue_almost_full         => open,
      queue_full                => wm_fifo_full,
      queue_almost_empty        => wm_fifo_almost_empty,
      queue_empty               => wm_fifo_empty,
      queue_exist               => wm_exist,
      queue_line_fit            => open,
      queue_index               => wm_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_wm,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => wm_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Miss FIFO.
  FIFO_WM_Memory : process (ACLK) is
  begin  -- process FIFO_WM_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( update_wm_push = '1' ) then
        -- Insert new item.
        wm_fifo_mem(0).Port_Num <= get_port_num(lookup_wm_info.Port_Num, C_NUM_INTERNAL_PORTS);
        wm_fifo_mem(0).Allocate <= lookup_wm_allocate;
        wm_fifo_mem(0).Evict    <= lookup_wm_evict;
        wm_fifo_mem(0).Will_Use <= lookup_wm_will_use;
        wm_fifo_mem(0).Kind     <= lookup_wm_info.Kind;
        wm_fifo_mem(0).Offset   <= lookup_wm_info.Addr(C_ADDR_OFFSET_POS);
        wm_fifo_mem(0).Use_Bits <= lookup_wm_use_bits;
        wm_fifo_mem(0).Stp_Bits <= lookup_wm_stp_bits;
        wm_fifo_mem(0).Allow    <= lookup_wm_allow_write;
        wm_fifo_mem(0).Create   <= lookup_wm_create;
        
        -- Shift FIFO contents.
        wm_fifo_mem(wm_fifo_mem'left downto 1) <= wm_fifo_mem(wm_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_WM_Memory;
  
  -- Extract current Write Miss information.
  -- Store WM in register for good timing.
  WM_Data_Registers : process (ACLK) is
  begin  -- process WM_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        wm_port             <= C_NULL_WM.Port_Num;
        wm_allocate         <= C_NULL_WM.Allocate;
        wm_evict            <= C_NULL_WM.Evict;
        wm_will_use         <= C_NULL_WM.Will_Use;
        wm_offset           <= C_NULL_WM.Offset;
        wm_kind             <= C_NULL_WM.Kind;
        wm_use_bits         <= C_NULL_WM.Use_Bits;
        wm_stp_bits         <= C_NULL_WM.Stp_Bits;
        wm_local_wrap       <= '0';
        wm_allow            <= C_NULL_WM.Allow;
        wm_create           <= C_NULL_WM.Create;
        wm_remove_unaligned <= (others=>'1');
        
      elsif( wm_refresh_reg = '1' ) then
        wm_port             <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Port_Num;
        wm_allocate         <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Allocate;
        wm_evict            <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Evict;
        wm_will_use         <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Will_Use;
        wm_offset           <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Offset;
        wm_kind             <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Kind;
        wm_use_bits         <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Use_Bits;
        wm_stp_bits         <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Stp_Bits;
        if( ( to_integer(unsigned(wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Use_Bits)) <
              (  C_EXTERNAL_DATA_WIDTH / 8 ) ) or 
            ( C_EXTERNAL_DATA_WIDTH = ( 32 * C_CACHE_LINE_LENGTH ) ) ) then
          wm_local_wrap       <= '1';
        else
          wm_local_wrap       <= '0';
        end if;
        wm_allow      <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Allow;
        wm_create     <= wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Create;
        if( ( wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Kind     = C_KIND_INCR ) and
            ( wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Allocate = '1'         ) )then
          wm_remove_unaligned <= not std_logic_vector(unsigned(wm_fifo_mem(to_integer(unsigned(wm_read_fifo_addr))).Stp_Bits) - 1);
        else
          wm_remove_unaligned <= (others=>'1');
        end if;
        
      end if;
    end if;
  end process WM_Data_Registers;
  
  -- Prevent new WM from entering the queue.
  update_write_miss_full  <= wm_fifo_full or 
                             ( update_wmal_failed and not update_error_evict_insert_i );
  
  -- Handle Status of Write Miss Data popping.
  Write_Miss_Sequence_Handler : process (ACLK) is
  begin  -- process Write_Miss_Sequence_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_write_miss_ongoing <= '0';
      else
        if ( update_wm_pop_normal = '1' ) then
          update_write_miss_ongoing <= '0';
        elsif ( update_use_write_word = '1' ) then
          update_write_miss_ongoing <= '1';
        end if;
      end if;
    end if;
  end process Write_Miss_Sequence_Handler;
  
  -- Get the current port.
  update_write_port_i       <= wm_port;
  
  -- Determine when a data word is used.
  update_use_write_word     <= access_data_info(update_write_port_i).Valid and update_ack_write_word;
  
  -- Control popping of Write Miss data.
  update_ack_write_ext      <= ( not wm_allocate and not update_wr_miss_throttle );
  update_ack_write_alloc    <= (     wm_allocate and not update_wma_throttle );
  update_ack_write_word     <= ( wm_allocate or not wm_evict ) and 
                               ( not update_wm_pop_normal_hold ) and
                               ( wm_exist ) and 
                               ( wm_allocate or not update_evict_busy ) and 
                               ( update_ack_write_ext or update_ack_write_alloc );
  update_write_data_ready   <= update_write_data_ready_i;
  update_ack_write_word_vec <= (others => update_ack_write_word);
  update_write_data_ready_i <= update_ack_write_word_vec and 
                               std_logic_vector(to_unsigned(2 ** update_write_port_i, C_NUM_INTERNAL_PORTS));
  
  -- Forward the write data for size manipulation.
  update_wr_miss_valid      <= update_use_write_word;
  
  wm_allow_vec              <= (others => wm_allow);

  -- Generate mux structures for write data.
  update_wr_miss_last       <= access_data_info(update_write_port_i).Last;
  update_wr_miss_be         <= access_data_info(update_write_port_i).BE(C_CACHE_DATA_WIDTH/8 - 1 downto 0) and wm_allow_vec;
  update_wr_miss_word       <= access_data_info(update_write_port_i).Data(C_CACHE_DATA_WIDTH - 1 downto 0);
  
  
  -----------------------------------------------------------------------------
  -- Write Size Conversion
  -- 
  -- Depending on the internal and interface data widths it is sometimes 
  -- necessary to perform width conversion:
  -- 
  -- Internal < Interface
  --   Write data mirroring and steering of the BE bit. No Data compression.
  -- 
  -- Internal = Interface
  --   Pass-through
  -- 
  -- Internal > Interface
  --   Multiplex data in sequence. The transaction also needs modification on  
  --   the AW channel.
  -- 
  -----------------------------------------------------------------------------
  
  -- Select current offset.
  update_wr_offset        <= wm_offset when ( update_write_miss_ongoing = '0' ) else update_wr_offset_cnt;
  
  -- Handle next offset that should be used.
  Write_Miss_Part_Handler : process (ACLK) is
  begin  -- process Write_Miss_Part_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_wr_offset_cnt <= (others=>'0');
      elsif( ( ( update_wr_miss_rs_valid ) = '1' ) or
             ( ( update_wma_insert_dummy ) = '1' ) ) then
        update_wr_offset_cnt <= update_wr_offset_cnt_cmb;
      end if;
    end if;
  end process Write_Miss_Part_Handler;
  
  -- Generate next value.
  -- Also, compensate for unaligned incr with native size.
  WM_Offset_Select: process (update_wr_offset, wm_offset, wm_use_bits, wm_stp_bits, wm_kind, wm_allocate,
                             wm_remove_unaligned) is
    variable update_wr_offset_cnt_next  : ADDR_OFFSET_TYPE;
  begin  -- process WM_Offset_Select
    update_wr_offset_cnt_next  := std_logic_vector(unsigned(update_wr_offset) + unsigned(wm_stp_bits));
    
    for N in update_wr_offset_cnt_cmb'range loop
      if( ( wm_use_bits(N) = '0' ) and 
          ( wm_kind = C_KIND_WRAP ) and
          ( ( C_CACHE_DATA_WIDTH < C_EXTERNAL_DATA_WIDTH ) or
            ( C_CACHE_DATA_WIDTH = C_EXTERNAL_DATA_WIDTH and ( wm_allocate = '0' ) ) ) ) then
        update_wr_offset_cnt_cmb(N) <= wm_offset(N);
      else
        update_wr_offset_cnt_cmb(N) <= update_wr_offset_cnt_next(N) and wm_remove_unaligned(N);
      end if;
    end loop;
  end process WM_Offset_Select;
  
  -- Detect if next word will be first part of next larger word.
  update_wr_next_word_addr    <= update_wr_offset_cnt_cmb and C_NATIVE_SIZE_BITS;
  update_wr_miss_restart_word <= '1' when ( to_integer(unsigned(update_wr_next_word_addr)) = 0 ) and 
                                          ( ( wm_kind = C_KIND_INCR ) or 
                                            ( wm_kind = C_KIND_WRAP and wm_local_wrap = '0' ) ) else 
                                 '0';
  
  Write_Internal_Same: if( C_CACHE_DATA_WIDTH = C_EXTERNAL_DATA_WIDTH ) generate
  begin
    -- No Throttle needed (besides FIFO full).
    update_wr_miss_word_done    <= '1';
    update_wr_miss_throttle     <= write_data_full;
    
    -- No translation needed.
    update_wr_miss_rs_valid     <= update_wr_miss_valid;
    update_wr_miss_rs_last      <= update_wr_miss_last;
    update_wr_miss_rs_be        <= update_wr_miss_be;
    update_wr_miss_rs_word      <= update_wr_miss_word;
    
  end generate Write_Internal_Same;
  
  Write_Internal_Different: if( C_CACHE_DATA_WIDTH /= C_EXTERNAL_DATA_WIDTH ) generate
    constant C_RATIO          : natural := max_of(C_CACHE_DATA_WIDTH, C_EXTERNAL_DATA_WIDTH) / 
                                           min_of(C_CACHE_DATA_WIDTH, C_EXTERNAL_DATA_WIDTH);
    subtype C_RATIO_POS       is natural range 0 to C_RATIO - 1;
    subtype RATIO_TYPE        is std_logic_vector(C_RATIO_POS);
    constant C_RATIO_BITS     : natural := Log2(C_RATIO);
    
    signal update_wr_miss_sel       : rinteger range 0 to C_RATIO - 1;
  begin
    -- Specialized part for upsizing.
    Write_Internal_Narrow: if( C_CACHE_DATA_WIDTH < C_EXTERNAL_DATA_WIDTH ) generate
      subtype C_RATIO_BITS_POS  is natural range C_ADDR_EXT_BYTE_HI downto C_ADDR_EXT_BYTE_HI - C_RATIO_BITS + 1;
      subtype RATIO_BITS_TYPE   is std_logic_vector(C_RATIO_BITS_POS);
      
      signal update_wr_miss_sel_s     : RATIO_BITS_TYPE;
    begin
      -- Word selector.
      update_wr_miss_sel_s    <= update_wr_offset(C_RATIO_BITS_POS);
      update_wr_miss_sel      <= to_integer(unsigned(update_wr_miss_sel_s));
      
      -- Forward data valid.
      update_wr_miss_rs_valid <= update_wr_miss_valid;
      
      -- No Throttle needed.
      update_wr_miss_word_done<= '1';
      update_wr_miss_throttle <= write_data_full;
      
      -- Untouched last signal.
      update_wr_miss_rs_last  <= update_wr_miss_last;
      
      Gen_Mirror: for N in 0 to C_EXTERNAL_DATA_WIDTH / C_CACHE_DATA_WIDTH - 1 generate
      begin
        -- Generate mirrored data and steer byte enable.
        update_wr_miss_rs_be((N+1) * C_CACHE_DATA_WIDTH/8 - 1 downto N * C_CACHE_DATA_WIDTH/8)
                          <= update_wr_miss_be when ( update_wr_miss_sel = N ) 
                             else (others=>'0');
        update_wr_miss_rs_word((N+1) * C_CACHE_DATA_WIDTH - 1 downto N * C_CACHE_DATA_WIDTH)
                          <= update_wr_miss_word;
      end generate Gen_Mirror;
      
    end generate Write_Internal_Narrow;
    
    -- Specialized part for downsizing.
    Write_Internal_Wide: if( C_CACHE_DATA_WIDTH > C_EXTERNAL_DATA_WIDTH ) generate
      
      type RATIO_BE_TYPE               is array(C_RATIO_POS) of BE_TYPE;
      type RATIO_DATA_TYPE             is array(C_RATIO_POS) of DATA_TYPE;
      
      subtype C_RATIO_BITS_POS  is natural range C_ADDR_BYTE_HI downto C_ADDR_BYTE_HI - C_RATIO_BITS + 1;
      subtype RATIO_BITS_TYPE   is std_logic_vector(C_RATIO_BITS_POS);

      constant ratio_bits_one_vec : RATIO_BITS_TYPE := (others => '1');
      
      signal update_wr_miss_sel_s   : RATIO_BITS_TYPE;
      signal update_wr_miss_be_i    : RATIO_BE_TYPE; 
      signal update_wr_miss_word_i  : RATIO_DATA_TYPE; 
    begin
      -- Word selector.
      update_wr_miss_sel_s    <= update_wr_offset(C_RATIO_BITS_POS);
      update_wr_miss_sel      <= to_integer(unsigned(update_wr_miss_sel_s));
      
      -- Forward data valid.
      update_wr_miss_rs_valid <= update_wr_miss_valid;
      
      -- Throttle until last part of word.
      update_wr_miss_word_done<= '1' when (update_wr_miss_sel_s = ratio_bits_one_vec ) else '0';
      update_wr_miss_throttle <= write_data_full or not update_wr_miss_word_done;
      
      -- Mask last signal.
      update_wr_miss_rs_last  <= update_wr_miss_last when (update_wr_miss_sel_s = ratio_bits_one_vec ) else '0';
      
      -- Vectorize input.
      Gen_Vectorization: for N in 0 to C_EXTERNAL_DATA_WIDTH / C_CACHE_DATA_WIDTH - 1 generate
      begin
        -- Generate mirrored data and steer byte enable.
        update_wr_miss_be_i(N)    <= update_wr_miss_be((N+1) * C_EXTERNAL_DATA_WIDTH/8 - 1 downto 
                                                           N * C_EXTERNAL_DATA_WIDTH/8);
        update_wr_miss_word_i(N)  <= update_wr_miss_word((N+1) * C_EXTERNAL_DATA_WIDTH - 1 downto 
                                                             N * C_EXTERNAL_DATA_WIDTH);
      end generate Gen_Vectorization;
      
      -- Select be and data parts.
      update_wr_miss_rs_be    <= update_wr_miss_be_i(update_wr_miss_sel);
      update_wr_miss_rs_word  <= update_wr_miss_word_i(update_wr_miss_sel);
      
    end generate Write_Internal_Wide;
    
  end generate Write_Internal_Different;
  
  
  -----------------------------------------------------------------------------
  -- Write Miss Allocate Data Processing
  -- 
  -----------------------------------------------------------------------------
  
  -- Keep track if dummy data should be inserted.
  update_wma_select_port <= '1' when ( wm_kind = C_KIND_WRAP ) and
                                     ( ( ( update_wr_offset and not wm_use_bits ) = 
                                         ( wm_offset        and not wm_use_bits ) ) or
                                       ( wm_local_wrap = '1' ) ) else
                            '1' when ( wm_kind = C_KIND_INCR ) else
                            '0';
                            
  -- Insert dummy words.
  update_wma_insert_dummy <= ( wm_allocate and wm_exist and not update_wma_select_port ) and
                             ( not update_wma_fifo_stall );
  
  -- WMA data piece available.
  update_wma_data_valid   <= ( update_wr_miss_rs_valid and wm_allocate and update_wma_select_port ) or 
                             update_wma_insert_dummy;
  
  -- Throttle WM because FIFO is full.
  update_wma_fifo_stall   <= wma_fifo_almost_full or wma_fifo_full;
  update_wma_throttle     <= update_wma_fifo_stall or not update_wr_miss_word_done or 
                             not update_wma_select_port;
  
  -- Merge data into a word with full external width.
  WMA_Assembly_Handler : process (ACLK) is
  begin  -- process WMA_Assembly_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        wma_word_done_d1  <= '0';
        update_wma_last   <= '0';
        update_wma_strb   <= (others=>'0');
        update_wma_data   <= (others=>'0');
        
      else
        wma_word_done_d1  <= '0';
        
        -- Prepare for next word.
        if ( wma_word_done_d1 = '1' ) then
          update_wma_strb <= (others=>'0');
        end if;
        
        if( update_wma_data_valid = '1' ) then
          -- Delay done signal to clear next cycle.
          wma_word_done_d1  <= wma_word_done;
          
          -- Update last flag.
          update_wma_last   <= update_wr_miss_rs_last and update_wma_select_port;
          
          -- Insert new data, one byte at the time.
          for N in update_wr_miss_rs_be'range loop
            if( update_wr_miss_rs_be(N) = '1' ) then
              update_wma_strb(N)                      <= update_wr_miss_rs_be(N) and update_wma_select_port;
              update_wma_data((N+1)*8 -1 downto N*8)  <= update_wr_miss_rs_word((N+1)*8 -1 downto N*8);
            end if;
          end loop;
        end if;
      end if;
    end if;
  end process WMA_Assembly_Handler;
  
  -- Detect when word is complete.
  wma_word_done   <= update_wr_miss_restart_word or update_wr_miss_rs_last;
  
  -- Generate control signals.
  wma_push        <= wma_word_done_d1;
  
  
  -----------------------------------------------------------------------------
  -- Queue for Write Miss Allocate
  -- 
  -----------------------------------------------------------------------------
  
  -- Use data for merge.
--  wma_pop   <= backend_rd_data_use and ri_merge and not wma_fifo_empty and not wma_merge_done;
  wma_sel_pop_n <= not ( ri_merge and not wma_fifo_empty and not wma_merge_done );
  UD_RD_And_Inst8c: carry_latch_and_n
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 4,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => backend_rd_data_use_i,
      A_N       => wma_sel_pop_n,
      O         => wma_pop,
      Carry_OUT => backend_rd_data_use
    );
  
  
  FIFO_WMA_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_BIG_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => C_DATA_QUEUE_LINE_LENGTH
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wma_push,
      queue_pop                 => wma_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => wma_fifo_almost_full,
      queue_full                => wma_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => wma_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => wma_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_wma,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => wma_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Miss Allocate FIFO.
  FIFO_WMA_Memory : process (ACLK) is
  begin  -- process FIFO_WMA_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( wma_push = '1' ) then
        -- Insert new item.
        wma_fifo_mem(0).Last  <= update_wma_last;
        wma_fifo_mem(0).Strb  <= update_wma_strb;
        wma_fifo_mem(0).Data  <= update_wma_data;
        
        -- Shift FIFO contents.
        wma_fifo_mem(wma_fifo_mem'left downto 1) <= wma_fifo_mem(wma_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_WMA_Memory;
  
  -- Extract current Write Miss information.
  wma_last  <= wma_fifo_mem(to_integer(unsigned(wma_read_fifo_addr))).Last;
  wma_strb  <= wma_fifo_mem(to_integer(unsigned(wma_read_fifo_addr))).Strb;
  wma_data  <= wma_fifo_mem(to_integer(unsigned(wma_read_fifo_addr))).Data;
  
  -- Handle merge sequence.
  WMA_Merge_Sequence_Handler : process (ACLK) is
  begin  -- process WMA_Merge_Sequence_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        wma_merge_done  <= '0';
        
      else
        if( (backend_rd_data_pop ) = '1' ) then
          -- Last word of read burst releases end of merge.
          wma_merge_done  <= '0';
          
        elsif( wma_done = '1' ) then
          -- Last word in write data burst sets end of merge.
          wma_merge_done  <= '1';
          
        end if;
      end if;
    end if;
  end process WMA_Merge_Sequence_Handler;
  
  --
  WM_Pop_Handler : process (ACLK) is
  begin  -- process WM_Pop_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_wm_pop_evict_hold  <= '0';
        update_wm_pop_normal_hold <= '0';
        
      else
        if( update_wm_pop = '1' ) then
          -- All relevant sources has occured, go back to idle state.
          update_wm_pop_evict_hold  <= '0';
          
        elsif( ( update_wm_pop_evict ) = '1' ) then
          -- Evict is completed but still waiting for WMA data to complete.
          update_wm_pop_evict_hold  <= '1';
          
        end if;
        
        if( update_wm_pop = '1' ) then
          -- All relevant sources has occured, go back to idle state.
          update_wm_pop_normal_hold <= '0';
          
        elsif( ( update_wm_pop_normal ) = '1' ) then
          -- WMA burst has completed but still waiting for Evict to complete.
          update_wm_pop_normal_hold <= '1';
          
        end if;
        
      end if;
    end if;
  end process WM_Pop_Handler;
  
    
  -----------------------------------------------------------------------------
  -- Write Hit Last
  -- 
  -- Coherency events has caused an ongoing write to be forced out as a 
  -- write to make sure no data is lost.
  -----------------------------------------------------------------------------
  
  -- Pop queue when evict is done.
  update_whl_pop  <= update_e_pop and e_whl;
  
  -- Split complete line into segmented words.
  WriteHit_Wordify: for N in C_CACHE_WORD_POS generate
  begin
    update_whl_strb_i(N)  <= update_whl_strb(C_CACHE_DATA_WIDTH/8 * (N+1) - 1 downto C_CACHE_DATA_WIDTH/8 * N);
  end generate WriteHit_Wordify;
  
  -- Extract the current word that is being evicted.
  WHL_OneBeat: if( C_CACHE_LINE_WORDS = 1 ) generate
  begin
    WHL_Evict_Align : process (ACLK) is
    begin  -- process WHL_Evict_Align
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          update_whl_strb_word  <= (others=>'0');
        else
          -- Delay to align with data from BRAMs.
          update_whl_strb_word  <= update_whl_strb_i(0);
        end if;
      end if;
    end process WHL_Evict_Align;
  end generate WHL_OneBeat;
  
  WHL_MultiBeat: if( C_CACHE_LINE_WORDS > 1 ) generate
  
    signal update_word_idx            : natural range 0 to 2 ** (C_ADDR_EXT_WORD_HI - C_ADDR_EXT_WORD_LO + 1) - 1;
    
  begin
    update_word_idx <= to_integer(unsigned(update_word_cnt));
    
    WHL_Assembly_Handler : process (ACLK) is
    begin  -- process WHL_Assembly_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          update_whl_strb_word    <= (others=>'0');
          
        else
          -- Delay to align with data from BRAMs.
          update_whl_strb_word  <= update_whl_strb_i(update_word_idx);
        end if;
      end if;
    end process WHL_Assembly_Handler;
  end generate WHL_MultiBeat;
  
  
  -----------------------------------------------------------------------------
  -- Write Miss Allocate Last
  -- 
  -- Each WMA (WSTRB) is pushed into the WMAL queue to be remove by 
  -- next matching Evict.
  -----------------------------------------------------------------------------
  
  WMAL_OneBeat: if( C_CACHE_LINE_WORDS = 1 ) generate
  begin
    update_wmal_strb(0) <= fit_vec(wma_strb, 32 * C_CACHE_LINE_LENGTH / 8);
    
    WMAL_Evict_Align : process (ACLK) is
    begin  -- process WMAL_Evict_Align
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          evict_wmal_strb       <= (others=>'0');
        else
          evict_wmal_strb       <= wmal_strb(0);
        end if;
      end if;
    end process WMAL_Evict_Align;
    
  end generate WMAL_OneBeat;
  
  WMAL_MultiBeat: if( C_CACHE_LINE_WORDS > 1 ) generate
  
    signal update_word_idx            : natural range 0 to 2 ** (C_ADDR_EXT_WORD_HI - C_ADDR_EXT_WORD_LO + 1) - 1;
    signal update_wmal_strb_hold      : CACHE_LINE_BE_TYPE;
    
  begin
    update_word_idx <= to_integer(unsigned(update_word_cnt));
    
    WMAL_Cmb_Handler : process (wma_strb, update_wmal_strb_hold, update_word_idx) is
    begin  -- process WMAL_Cmb_Handler
      update_wmal_strb                  <= update_wmal_strb_hold;
      update_wmal_strb(update_word_idx) <= wma_strb;
      
    end process WMAL_Cmb_Handler;
    
    WMAL_Assembly_Handler : process (ACLK) is
    begin  -- process WMAL_Assembly_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          update_wmal_strb_hold   <= (others=>(others=>'0'));
          evict_wmal_strb         <= (others=>'0');
          
        else
          -- Merge STRBs to rest of line.
          for N in C_CACHE_WORD_POS loop
            if( s2b(backend_rd_data_final) ) then
              update_wmal_strb_hold(N)  <= (others=>'0');
              
            elsif( update_word_idx = N ) then
              update_wmal_strb_hold(N)  <= wma_strb;
              
            end if;
          end loop;
          
          -- Delay to align with data from BRAMs.
          evict_wmal_strb       <= wmal_strb(update_word_idx);
        end if;
      end if;
    end process WMAL_Assembly_Handler;
    
  end generate WMAL_MultiBeat;
  
  wmal_push <= backend_rd_data_final and ri_merge and update_read_failed and b2s(C_ENABLE_ERROR_HANDLING > 1);
  wmal_pop  <= update_e_pop and e_failed;
  
  FIFO_WMAL_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wmal_push,
      queue_pop                 => wmal_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => wmal_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => wmal_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => wmal_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_wmal,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => wmal_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Miss Allocate Last FIFO.
  FIFO_WMAL_Memory : process (ACLK) is
  begin  -- process FIFO_WMAL_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( wmal_push = '1' ) then
        -- Insert new item.
        wmal_fifo_mem(0)                           <= update_wmal_strb;
        
        -- Shift FIFO contents.
        wmal_fifo_mem(wmal_fifo_mem'left downto 1) <= wmal_fifo_mem(wmal_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_WMAL_Memory;
  
  -- Extract current Write Miss Allocate Last information.
  wmal_strb <= wmal_fifo_mem(to_integer(unsigned(wmal_read_fifo_addr)));
  
  WMAL_Handle: process (ACLK) is
  begin  -- process WMAL_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        update_wmal_failed                                <= '0';
        update_error_evict_insert_i                       <= '0';
        update_error_evict_way                            <= 0;
        update_error_evict_info                           <= C_NULL_ACCESS;
        
      else
        -- Default assignment.
        update_error_evict_insert_i                       <= '0';
        
        -- Track the status of the WMAL.
        if( s2b(update_error_evict_insert_i) ) then
          update_wmal_failed                                <= '0';
          
        elsif( s2b(wmal_push) ) then
          update_wmal_failed                                <= update_read_failed;
          update_error_evict_way                            <= ri_way;
          update_error_evict_info                           <= C_NULL_ACCESS;
          update_error_evict_info.Port_Num                  <= int_to_std(ri_port, C_MAX_NUM_PORT_WIDTH);
          update_error_evict_info.Allocate                  <= '0';
          update_error_evict_info.Evict                     <= '1';
          update_error_evict_info.Wr                        <= '0';
          update_error_evict_info.Addr                      <= C_BASEADDR;
          update_error_evict_info.Addr(C_ADDR_INTERNAL_POS) <= ri_addr;
          update_error_evict_info.Prot(C_PROT_SECURE_POS)   <= ri_secure;
          update_error_evict_info.Snoop                     <= fit_vec(C_AWSNOOP_WriteUnique, 4);
          update_error_evict_info.Domain                    <= C_DOMAIN_OUTER_SHAREABLE;
          
        end if;
        
        -- One cycle to insert Evict of failed allocation.
        if( s2b(    update_wmal_failed          and 
                not update_valid                and 
                not update_error_wait           and 
                not update_error_evict_insert_i) ) then
          update_error_evict_insert_i                       <= '1';
          
        end if;
        
      end if;
    end if;
  end process WMAL_Handle;
  
  -- Assign external signals.
  update_error_freeze       <= update_wmal_failed;
  update_error_evict_insert <= update_error_evict_insert_i;
  
  
  -----------------------------------------------------------------------------
  -- Queue for Write Miss Allocate Done
  -- 
  -----------------------------------------------------------------------------
  
  -- Control Queue of completed WMA.
  wma_done  <= ( wma_pop and wma_last );
  wmad_push <= ri_pop and ri_merge                  when is_mst_coherent(C_ENABLE_COHERENCY) and
                                                         ( C_ENABLE_EARLY_BRESP = 0 )        else
               update_wm_pop_normal and wm_allocate;
  wmad_pop  <= update_bs_pop and backend_wr_resp_wma_pop;
  
  FIFO_WMAD_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wmad_push,
      queue_pop                 => wmad_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => wmad_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => wmad_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => wmad_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => wmad_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
  
  
  -- Handle memory for Write Response Source FIFO.
  Use_WMAD_BRESP_Queue: if( ( is_mst_coherent(C_ENABLE_COHERENCY) and ( C_ENABLE_EARLY_BRESP = 0 ) ) ) generate
    signal wmad_fifo_mem              : BP_FIFO_MEM_TYPE;
  begin
    FIFO_WMAD_Memory : process (ACLK) is
    begin  -- process FIFO_WMAD_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( wmad_push = '1' ) then
          -- Insert new item.
          if( update_read_hold_fail = '1' ) then
            wmad_fifo_mem(0).BRESP  <= update_read_hold_rresp;
          elsif( update_read_failed = '1' ) then
            wmad_fifo_mem(0).BRESP  <= update_read_resize_rresp(C_AXI_BRESP_POS);
          else
            wmad_fifo_mem(0).BRESP  <= C_BRESP_OKAY;
          end if;
          
          -- Shift FIFO contents.
          wmad_fifo_mem(wmad_fifo_mem'left downto 1) <= wmad_fifo_mem(wmad_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_WMAD_Memory;
    
    wmad_bresp  <= wmad_fifo_mem(to_integer(unsigned(wmad_read_fifo_addr))).BRESP;
  end generate Use_WMAD_BRESP_Queue;
  
  No_WMAD_BRESP_Queue: if( not ( is_mst_coherent(C_ENABLE_COHERENCY) and ( C_ENABLE_EARLY_BRESP = 0 ) ) ) generate
  begin
    wmad_bresp  <= C_BRESP_OKAY;
  end generate No_WMAD_BRESP_Queue;
  
  
  -----------------------------------------------------------------------------
  -- Write Data Mux
  -- 
  -- Select if the Write Miss data or Evicted data should be forwarded to the
  -- Write data queue.
  -----------------------------------------------------------------------------
  
  -- Select data source for Write Data buffer.
  write_data_valid_i    <= ( update_wr_miss_rs_valid and not wm_allocate )     when s2b(not update_evict_busy)  else 
                           update_evict_valid;
  write_data_info.Valid <= write_data_valid_i;
  write_data_last_i     <= update_wr_miss_rs_last                              when s2b(not update_evict_busy)  else 
                           update_evict_last;
  write_data_info.Last  <= write_data_last_i;
  write_data_info.BE    <= fit_vec(update_wr_miss_rs_be, C_MAX_DATA_WIDTH / 8) when s2b(not update_evict_busy)  else 
                           fit_vec(evict_wmal_strb, C_MAX_DATA_WIDTH / 8)      when s2b(update_evict_failed)    else 
                           fit_vec(update_whl_strb_word, C_MAX_DATA_WIDTH / 8) when s2b(update_evict_whl)       else 
                           (C_MAX_DATA_WIDTH / 8 - 1 downto 0=>'0')            when s2b(update_evict_cancelled) else 
                           (C_MAX_DATA_WIDTH / 8 - 1 downto 0=>'1');
  write_data_info.Data  <= fit_vec(update_wr_miss_rs_word, C_MAX_DATA_WIDTH)   when s2b(not update_evict_busy)  else 
                           fit_vec(update_evict_word, C_MAX_DATA_WIDTH);
  
    
  -----------------------------------------------------------------------------
  -- Read Information Buffer
  -----------------------------------------------------------------------------
  
  -- Control signals for read data info buffer.
  ri_push           <= read_req_valid_i;
  ri_pop            <= backend_rd_data_info.Valid and backend_rd_data_info.Last and backend_rd_data_ready_i;
  
  FIFO_RI_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => ri_push,
      queue_pop                 => ri_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => ri_refresh_reg,
      
      queue_almost_full         => open,
      queue_full                => ri_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => ri_fifo_empty,
      queue_exist               => ri_exist,
      queue_line_fit            => open,
      queue_index               => ri_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_ri,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => ri_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for RI Channel FIFO.
  FIFO_RI_Memory : process (ACLK) is
  begin  -- process FIFO_RI_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( ri_push = '1' ) then
        -- Insert new item.
        ri_fifo_mem(0).Port_Num     <= get_port_num(update_info.Port_Num, C_NUM_PORTS);
        ri_fifo_mem(0).Way          <= update_way;
        ri_fifo_mem(0).Addr         <= update_info.Addr(C_ADDR_INTERNAL_POS);
        ri_fifo_mem(0).Use_Bits     <= update_info.Addr_Use(C_ADDR_OFFSET_POS);
        ri_fifo_mem(0).Stp_Bits     <= update_info.Addr_Stp(C_ADDR_OFFSET_POS);
        ri_fifo_mem(0).Kind         <= update_info.Kind;
        ri_fifo_mem(0).Len          <= update_info.Len;
        ri_fifo_mem(0).Secure       <= update_info.Prot(C_PROT_SECURE_POS);
        ri_fifo_mem(0).Lookup       <= update_inserted_trans;
        ri_fifo_mem(0).Allocate     <= update_info.Allocate;
        ri_fifo_mem(0).Evicted_Line <= update_need_evict;
        ri_fifo_mem(0).Write_Merge  <= update_info.Wr;
        ri_fifo_mem(0).IsShared     <= update_info.IsShared;
        ri_fifo_mem(0).PassDirty    <= update_info.PassDirty;
        ri_fifo_mem(0).Exclusive    <= update_info.Exclusive;
        
        -- Shift FIFO contents.
        ri_fifo_mem(ri_fifo_mem'left downto 1) <= ri_fifo_mem(ri_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_RI_Memory;

  -- Store RI in register for good timing.
  RI_Data_Registers : process (ACLK) is
  begin  -- process RI_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        ri_port       <= C_NULL_RI.Port_Num;
        ri_hot_port   <= C_NULL_RI.Hot_Port;
        ri_way        <= C_NULL_RI.Way;
        ri_addr       <= C_NULL_RI.Addr;
        ri_use        <= C_NULL_RI.Use_Bits;
        ri_stp        <= C_NULL_RI.Stp_Bits;
        ri_kind       <= C_NULL_RI.Kind;
        ri_len        <= C_NULL_RI.Len;
        ri_secure     <= C_NULL_RI.Secure;
        ri_lookup     <= C_NULL_RI.Lookup;
        ri_allocate   <= C_NULL_RI.Allocate;
        ri_evicted    <= C_NULL_RI.Evicted_Line;
        ri_merge      <= C_NULL_RI.Write_Merge;
        ri_isshared   <= C_NULL_RI.IsShared;
        ri_passdirty  <= C_NULL_RI.PassDirty;
        ri_exclusive  <= C_NULL_RI.Exclusive;
        
      elsif( ri_refresh_reg = '1' ) then
        ri_port     <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Port_Num;
        ri_hot_port <= std_logic_vector(to_unsigned(2 ** ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Port_Num, 
                                                    C_NUM_PORTS));
        ri_way        <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Way;
        ri_addr       <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Addr;
        ri_use        <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Use_Bits;
        ri_stp        <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Stp_Bits;
        ri_kind       <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Kind;
        ri_len        <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Len;
        ri_secure     <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Secure;
        ri_lookup     <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Lookup;
        ri_allocate   <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Allocate;
        ri_evicted    <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Evicted_Line;
        ri_merge      <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Write_Merge;
        ri_isshared   <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).IsShared;
        ri_passdirty  <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).PassDirty;
        ri_exclusive  <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Exclusive;
        
      end if;
    end if;
  end process RI_Data_Registers;
  
  
  -----------------------------------------------------------------------------
  -- Read Data Forwarding
  -- 
  -- Handle the forwarding of data to both the Data memory and the source port
  -- via any potential resizing.
  -- 
  -- Wider external data is buffered in order to stall the Data memory.
  -----------------------------------------------------------------------------
  
  -- Flow control for read miss data.
--  backend_rd_data_use     <= backend_rd_data_info.Valid and backend_rd_data_ready_i and not ri_lookup;
   backend_rd_filtered_valid  <= backend_rd_data_info.Valid and not ri_lookup;
  UD_RD_And_Inst8: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => backend_rd_data_ready_i,
      A         => backend_rd_filtered_valid,
      Carry_OUT => backend_rd_data_use_ii
    );
  
--  backend_rd_data_pop     <= backend_rd_data_use and backend_rd_data_info.Last;
  backend_rd_data_last_n  <= not backend_rd_data_info.Last;
  UD_RD_And_Inst8b: carry_latch_and_n
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => backend_rd_data_use_ii,
      A_N       => backend_rd_data_last_n,
      O         => backend_rd_data_pop,
      Carry_OUT => backend_rd_data_use_i
    );
  
  -- Acknowledge external data.
  backend_rd_data_ready   <= backend_rd_data_ready_i;
  
  -- Handle RRESP.
  backend_rd_data_real_rresp  <= C_RRESP_EXOKAY(C_AXI_SHORT_RRESP_POS) when 
                                         ( ( ri_exclusive = '1' ) and
                                           ( backend_rd_data_info.RRESP(C_AXI_SHORT_RRESP_POS) /= C_RRESP_DECERR(C_AXI_SHORT_RRESP_POS) ) and 
                                           ( backend_rd_data_info.RRESP(C_AXI_SHORT_RRESP_POS) /= C_RRESP_SLVERR(C_AXI_SHORT_RRESP_POS) ) and 
                                           ( is_slv_coherent(C_ENABLE_COHERENCY) or 
                                             has_ex_mon(C_ENABLE_EX_MON) ) ) else
                                 backend_rd_data_info.RRESP(C_AXI_SHORT_RRESP_POS);
  
  -- Buffer read data stream.
  Use_Read_FIFO: if( C_CACHE_DATA_WIDTH < C_EXTERNAL_DATA_WIDTH ) generate
  
    signal r_push                     : std_logic;
    signal r_pop                      : std_logic;
    signal r_read_fifo_addr           : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
    signal r_fifo_mem                 : R_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
    signal r_fifo_almost_full         : std_logic;
    signal r_fifo_full                : std_logic;
    signal r_fifo_almost_empty        : std_logic;
    signal r_fifo_empty               : std_logic;
    
    
  begin
    -- Control signals for read data queue.
    r_push            <= backend_rd_data_use and not ri_merge;
    r_pop             <= update_read_resize_valid and update_read_resize_ready;
    
    FIFO_R_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_DATA_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => C_DATA_QUEUE_LINE_LENGTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => r_push,
        queue_pop                 => r_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => r_fifo_full,
        queue_almost_empty        => open,
        queue_empty               => r_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => r_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_r,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => r_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for R Channel FIFO.
    FIFO_R_Memory : process (ACLK) is
    begin  -- process FIFO_R_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( r_push = '1') then
          -- Insert new item.
          r_fifo_mem(0).Last                          <= backend_rd_data_info.Last;
          r_fifo_mem(0).Port_Num                      <= ri_port;
          r_fifo_mem(0).Hot_Port                      <= ri_hot_port;
          r_fifo_mem(0).Addr                          <= ri_addr;
          r_fifo_mem(0).Data                          <= backend_rd_data_info.Data(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
          r_fifo_mem(0).Rresp(C_AXI_SHORT_RRESP_POS)  <= backend_rd_data_real_rresp;
          if( is_slv_coherent(C_ENABLE_COHERENCY) ) then
            r_fifo_mem(0).Rresp(C_RRESP_ISSHARED_POS)   <= ri_isshared;
            r_fifo_mem(0).Rresp(C_RRESP_PASSDIRTY_POS)  <= ri_passdirty;
          end if;
          r_fifo_mem(0).Use_Bits                      <= ri_use;
          r_fifo_mem(0).Stp_Bits                      <= ri_stp;
          r_fifo_mem(0).Kind                          <= ri_kind;
          r_fifo_mem(0).Len                           <= ri_len;
          r_fifo_mem(0).Allocate                      <= ri_allocate;
          
          -- Shift FIFO contents.
          r_fifo_mem(r_fifo_mem'left downto 1) <= r_fifo_mem(r_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_R_Memory;
    
    -- FIFO output.
    update_read_resize_valid    <= not r_fifo_empty;
    update_read_resize_last     <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Last;
    update_read_resize_port     <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Port_Num;
    update_read_resize_hot_port <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Hot_Port;
    update_read_resize_addr     <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Addr;
    update_read_resize_offset   <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Addr(C_ADDR_OFFSET_POS);
    update_read_resize_use_bits <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Use_Bits;
    update_read_resize_stp_bits <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Stp_Bits;
    update_read_resize_kind     <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Kind;
    update_read_resize_len      <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Len;
    update_read_resize_allocate <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Allocate;
    update_read_resize_word     <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Data;
    update_read_resize_rresp    <= r_fifo_mem(to_integer(unsigned(r_read_fifo_addr))).Rresp;
    
    -- Throttle data with FIFO Full.
    update_read_forward_ready   <= update_remove_locked_safe and update_read_miss_safe and update_read_miss_wma_safe and 
                                   not r_fifo_full;
    
    -- Enter as: update_read_miss_use_ok
    -- Leave as: update_read_miss_resize_ok
    
    UD_RD_USE_R_And_Inst1: carry_and_n
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => update_read_miss_use_ok,
        A_N       => r_fifo_full,
        Carry_OUT => update_read_miss_resize_ok
      );
    
  end generate Use_Read_FIFO;
  
  -- No FIFO used to prevent slowing down write to Data BRAM.
  No_Read_FIFO: if( C_CACHE_DATA_WIDTH >= C_EXTERNAL_DATA_WIDTH ) generate
  begin
    -- Forward read data untouched.
    update_read_resize_valid    <=     backend_rd_filtered_valid                and 
                                       update_remove_locked_safe                and 
                                       update_read_miss_safe                    and 
                                       update_snoop_safe                        and
                                   not ( ri_allocate and update_evict_ongoing ) and 
                                   not ri_merge;
    update_read_resize_last     <= backend_rd_data_info.Last;
    update_read_resize_port     <= ri_port;
    update_read_resize_hot_port <= ri_hot_port;
    update_read_resize_addr     <= ri_addr;
    update_read_resize_offset   <= ri_addr(C_ADDR_OFFSET_POS);
    update_read_resize_use_bits <= ri_use;
    update_read_resize_stp_bits <= ri_stp;
    update_read_resize_kind     <= ri_kind;
    update_read_resize_len      <= ri_len;
    update_read_resize_allocate <= ri_allocate;
    update_read_resize_word     <= backend_rd_data_info.Data(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
    update_read_resize_rresp(backend_rd_data_real_rresp'range) <= backend_rd_data_real_rresp;
    Use_RRESP_Extra_Bits: if( is_slv_coherent(C_ENABLE_COHERENCY) ) generate
    begin
      update_read_resize_rresp(C_RRESP_ISSHARED_POS)  <= ri_isshared;
      update_read_resize_rresp(C_RRESP_PASSDIRTY_POS) <= ri_passdirty;
    end generate Use_RRESP_Extra_Bits;
    
    -- Directly return ready.
    update_read_forward_ready   <= update_remove_locked_safe and update_read_miss_safe and 
                                   update_read_miss_wma_safe and update_read_resize_ready;
    
    -- No FIFO.
    stat_ud_r <= C_NULL_STAT_FIFO;
    r_assert  <= '0';
    
    -- Enter as: update_read_miss_use_ok
    -- Leave as: update_read_miss_resize_ok
    
--    update_read_resize_used     <= ( ( update_read_resize_selected and update_read_data_ready(update_read_resize_port) ) or
--                                     ( not update_read_resize_selected ) or 
--                                     ( update_read_resize_finish ) ) ;
--    update_read_resize_ready    <= ( update_read_resize_used and 
--                                     ( update_read_resize_finish or 
--                                       not update_read_resize_allocate or 
--                                       not update_rd_miss_throttle ) );
    ud_rm_resize_part_sel <= ( update_read_resize_finish or 
                               not update_read_resize_allocate or 
                               not update_rd_miss_throttle );
    update_read_resize_selected_vec <= (others => update_read_resize_selected);
    update_read_resize_finish_vec   <= (others => update_read_resize_finish);
    ud_rm_port_forward  <= ( ( update_read_resize_selected_vec and update_read_data_ready ) or
                             not update_read_resize_selected_vec or 
                             update_read_resize_finish_vec );
    
    UD_RD_NO_R_And_Inst1: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => update_read_miss_use_ok,
        A         => ud_rm_resize_part_sel,
        Carry_OUT => ud_rm_use_resize_part_ok
      );
    
    UD_RD_NO_R_And_Inst2: carry_select_and
      generic map(
        C_TARGET  => C_TARGET,
        C_SIZE    => C_NUM_PORTS
      )
      port map(
        Carry_In  => ud_rm_use_resize_part_ok,
        No        => update_read_resize_port,
        A_Vec     => ud_rm_port_forward,
        Carry_Out => update_read_miss_resize_ok
      );
    
  end generate No_Read_FIFO;
  
  -- Use a resized element internally.
  backend_rd_data_final       <= backend_rd_data_use and backend_rd_data_info.Last;
  
  -- Propagate detected errors.
  update_allocate_error       <= update_allocate_error_i;
  update_allocate_error_i     <= backend_rd_data_use and update_read_resize_failed;
  
  update_read_failed          <= update_read_resize_failed or update_read_hold_fail;
  update_read_resize_failed   <= b2s( ( update_read_resize_rresp(C_AXI_SHORT_RRESP_POS) = 
                                                  C_RRESP_DECERR(C_AXI_SHORT_RRESP_POS) ) or 
                                      ( update_read_resize_rresp(C_AXI_SHORT_RRESP_POS) = 
                                                  C_RRESP_SLVERR(C_AXI_SHORT_RRESP_POS) ) ) and 
                                 b2s(C_ENABLE_ERROR_HANDLING > 0); 
  
  -- Handle error hold for transaction.
  Read_Error_Handler : process (ACLK) is
  begin  -- process Read_Error_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_read_hold_fail   <= '0';
        update_read_hold_rresp  <= (others=>'0');
        
      else
        if( s2b(backend_rd_data_final) ) then
          update_read_hold_fail   <= '0';
          
        elsif( s2b(backend_rd_data_use) and s2b(update_read_resize_failed) and ( C_CACHE_LINE_WORDS > 1) ) then
          -- Need to hold error if a line consist of more than one data beat.
          update_read_hold_fail   <= '1';
          update_read_hold_rresp  <= update_read_resize_rresp(C_AXI_BRESP_POS);
          
        end if;
      end if;
    end if;
  end process Read_Error_Handler;
  
  
  -----------------------------------------------------------------------------
  -- Read Size Conversion
  -- 
  -- Depending on the internal and interface data widths it is sometimes 
  -- necessary to perform width conversion:
  -- 
  -- Internal < Interface
  --   Multiplex data in sequence. The transaction also needs modification on  
  --   the AR channel.
  -- 
  -- Internal = Interface
  --   Pass-through
  -- 
  -- Internal > Interface
  --   Read data mirroring.
  -- 
  -----------------------------------------------------------------------------
  
  -- Select current offset.
  update_rd_offset          <= update_read_resize_offset when ( update_read_resize_first = '1' ) else 
                               update_rd_offset_cnt;
  
  -- Select current length.
  update_rd_len             <= update_read_resize_len    when ( update_read_resize_first = '1' ) else 
                               update_rd_len_cnt;
  
  -- Calculate next offset.
  RM_Offset_Select: process (update_rd_offset, update_read_resize_offset, 
                                 update_read_resize_kind, update_read_resize_allocate, 
                                 update_read_resize_use_bits, update_read_resize_stp_bits) is
    variable update_rd_offset_cnt_next_cmb  : ADDR_OFFSET_TYPE;
  begin  -- process RM_Offset_Select
    update_rd_offset_cnt_next_cmb     := std_logic_vector(unsigned(update_rd_offset) + 
                                                          unsigned(update_read_resize_stp_bits));
    
    for N in update_rd_offset_cnt_next'range loop
      if( ( update_read_resize_use_bits(N) = '0' )  and 
          ( update_read_resize_kind = C_KIND_WRAP ) and 
          ( ( C_CACHE_DATA_WIDTH < C_EXTERNAL_DATA_WIDTH ) or
            ( C_CACHE_DATA_WIDTH = C_EXTERNAL_DATA_WIDTH and ( update_read_resize_allocate = '0' ) ) ) ) then
        update_rd_offset_cnt_next(N)  <= update_read_resize_offset(N);
        
      else
        update_rd_offset_cnt_next(N)  <= update_rd_offset_cnt_next_cmb(N);
        
      end if;
    end loop;
  end process RM_Offset_Select;
  
  -- Calculate next length.
  update_rd_len_cnt_next    <= std_logic_vector(unsigned(update_rd_len) - 1);
  
  -- Handle next offset that should be used.
  Read_Miss_Part_Handler : process (ACLK) is
  begin  -- process Read_Miss_Part_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_rd_offset_cnt      <= (others=>'0');
        update_read_resize_first  <= '1';
        update_read_resize_finish <= '0';
        
      elsif ( ( update_read_resize_valid and     update_read_resize_selected and update_read_resize_used ) = '1' ) or 
            ( ( update_read_resize_valid and not update_read_resize_selected ) = '1' ) then
        update_rd_offset_cnt      <= update_rd_offset_cnt_next;
        update_read_resize_first  <= update_read_resize_last and update_read_resize_ready;
        
        if( update_read_resize_last = '1' ) then
          update_read_resize_finish <= '0';
          
        elsif( update_read_data_last_i = '1' ) and 
             ( ( update_read_resize_kind /= C_KIND_WRAP ) or 
               ( update_read_resize_selected = '1' and update_read_resize_kind = C_KIND_WRAP ) ) then
          update_read_resize_finish <= '1';
          
        end if;
      end if;
    end if;
  end process Read_Miss_Part_Handler;
  
  -- Handle next length that should be used.
  Read_Miss_Length_Handler : process (ACLK) is
  begin  -- process Read_Miss_Length_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_rd_len_cnt         <= (others=>'0');
        
      elsif ( update_read_resize_valid and update_read_resize_selected and update_read_resize_used ) = '1' then
        update_rd_len_cnt         <= update_rd_len_cnt_next;
        
      end if;
    end if;
  end process Read_Miss_Length_Handler;
  
  -- Handle data for Incr.
  Read_Incr_Handler : process (ACLK) is
  begin  -- process Read_Incr_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_rd_incr_ok <= '1';
        
      elsif( update_read_resize_valid = '1' ) then
        if( ( update_read_resize_last and update_read_resize_ready ) = '1' ) then
          update_rd_incr_ok <= '1';
          
        elsif( ( update_read_data_last_i and update_read_resize_ready ) = '1' ) then
          update_rd_incr_ok <= '0';
          
        end if;
      end if;
    end if;
  end process Read_Incr_Handler;
  
  -- Handle data for Wrap.
  Read_Wrap_Handler : process (ACLK) is
  begin  -- process Read_Wrap_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_rd_wrap_ok <= '1';
        
      elsif( ( update_read_resize_valid and update_read_resize_ready ) = '1' ) then
        if( ( update_read_resize_sel_wrap or update_read_resize_last ) = '1' ) then
          update_rd_wrap_ok <= '1';
          
        elsif( update_read_resize_sel_wrap = '0' ) then
          update_rd_wrap_ok <= '0';
          
        end if;
      end if;
    end if;
  end process Read_Wrap_Handler;
  
  -- Response handling.
  No_Rd_Coherent: if( not is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    update_read_data_resp_i(3 downto 2)  <= (others=>'0');
  end generate No_Rd_Coherent;
  update_read_data_resp_i(update_read_resize_rresp'range)  <= update_read_resize_rresp;
  
  -- Determine if this word shall be forwarded as a valid read miss data.
  update_read_resize_sel_wrap <= not update_read_resize_finish when
                                   ( update_read_resize_kind = C_KIND_WRAP ) and
                                   ( ( update_rd_offset_cnt_next and not update_read_resize_use_bits ) = 
                                     ( update_read_resize_offset and not update_read_resize_use_bits ) ) else
                                 '0';
--  update_read_resize_selected <= update_rd_incr_ok when ( update_read_resize_kind = C_KIND_INCR ) else 
--                                 update_rd_wrap_ok;
  -- Handle data for Wrap.
  Read_Select_Handler : process (ACLK) is
  begin  -- process Read_Select_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        update_read_resize_selected <= '1';
        
      elsif( ( update_read_resize_valid and update_read_resize_ready ) = '1' ) then
        if( update_read_resize_kind = C_KIND_INCR ) then
          -- Incr
          if( ( update_read_resize_last ) = '1' ) then
            update_read_resize_selected <= '1';
            
          elsif( ( update_read_data_last_i ) = '1' ) then
            update_read_resize_selected <= '0';
            
          end if;
          
        else
          -- Wrap
          if( ( update_read_resize_sel_wrap or update_read_resize_last ) = '1' ) then
            update_read_resize_selected <= '1';
            
          elsif( update_read_resize_sel_wrap = '0' ) then
            update_read_resize_selected <= '0';
            
          end if;
        end if;
      end if;
    end if;
  end process Read_Select_Handler;
  
  -- Size matches, just forward all signals.
  update_read_data_valid_i    <= ( update_read_resize_selected and update_read_resize_valid and 
                                   not update_read_resize_finish);
  update_read_data_valid_vec  <= (others => update_read_data_valid_i);
  update_read_data_valid_ii   <= update_read_data_valid_vec and 
                                 update_read_resize_hot_port;
  
  -- Generate RRESP queues per port.
  Gen_Port_RRESP_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    update_read_data_info(I).Valid  <= update_read_data_valid_ii(I);
    update_read_data_info(I).Last   <= update_read_data_last_i;
    update_read_data_info(I).RRESP  <= fit_vec(update_read_data_resp_i, C_MAX_RRESP_WIDTH);
    update_read_data_info(I).Data   <= fit_vec(update_read_data_word_i, C_MAX_DATA_WIDTH);
    
  end generate Gen_Port_RRESP_Array;
  
  -- Generate last bit.
  update_read_data_last_i     <= '1' when to_integer(unsigned(update_rd_len)) = 0 else '0';
  
  -- Data throttling.
  update_read_resize_used     <= ( ( update_read_resize_selected and update_read_data_ready(update_read_resize_port) ) or
                                   ( not update_read_resize_selected ) or 
                                   ( update_read_resize_finish ) ) ;
  update_read_resize_ready    <= ( update_read_resize_used and 
                                   ( update_read_resize_finish or 
                                     not update_read_resize_allocate or 
                                     not update_rd_miss_throttle ) );
  
  
  -- Handle read miss data sequence.
  Read_Internal_Same_Or_Wide: if( C_CACHE_DATA_WIDTH >= C_EXTERNAL_DATA_WIDTH ) generate
  begin
    -- Data forward including mirroring when necessary.
    Gen_Mirror: for N in 0 to C_CACHE_DATA_WIDTH / C_EXTERNAL_DATA_WIDTH - 1 generate
    begin
      -- Generate mirrored data and steer byte enable.
      update_read_data_word_i((N+1) * C_EXTERNAL_DATA_WIDTH - 1 downto N * C_EXTERNAL_DATA_WIDTH)
                        <= update_read_resize_word;
    end generate Gen_Mirror;
    
    -- Data word throttling.
    update_rd_miss_throttle   <= '0';
    
    -- Unused.
    update_rd_miss_th_incr  <= '0';
    update_rd_miss_th_wrap  <= '0';
    
  end generate Read_Internal_Same_Or_Wide;
  
  
  Read_Internal_Narrow: if( C_CACHE_DATA_WIDTH < C_EXTERNAL_DATA_WIDTH ) generate
  
    constant C_RATIO          : natural := max_of(C_CACHE_DATA_WIDTH, C_EXTERNAL_DATA_WIDTH) / 
                                           min_of(C_CACHE_DATA_WIDTH, C_EXTERNAL_DATA_WIDTH);
    subtype C_RATIO_POS       is natural range 0 to C_RATIO - 1;
    subtype RATIO_TYPE        is std_logic_vector(C_RATIO_POS);
    constant C_RATIO_BITS     : natural := Log2(C_RATIO);
    subtype C_RATIO_BITS_POS  is natural range C_ADDR_EXT_BYTE_HI downto C_ADDR_EXT_BYTE_HI - C_RATIO_BITS + 1;
    subtype RATIO_BITS_TYPE   is std_logic_vector(C_RATIO_BITS_POS);
    
    type RATIO_DATA_TYPE             is array(C_RATIO_POS) of DATA_TYPE;

    constant ratio_bits_one_vec : RATIO_BITS_TYPE := (others => '1');
    
    signal update_rd_miss_sel_s     : RATIO_BITS_TYPE;
    signal update_rd_miss_sel       : C_RATIO_POS;
    signal update_rd_miss_word_i    : RATIO_DATA_TYPE; 
    
  begin
    -- Vectorize input.
    Gen_Vectorization: for N in 0 to C_EXTERNAL_DATA_WIDTH / C_CACHE_DATA_WIDTH - 1 generate
    begin
      -- Generate vectorized data.
      update_rd_miss_word_i(N) <= update_read_resize_word((N+1) * C_CACHE_DATA_WIDTH - 1 downto N * C_CACHE_DATA_WIDTH);
    end generate Gen_Vectorization;
    
    -- Word selector.
    update_rd_miss_sel_s    <= update_rd_offset(C_RATIO_BITS_POS);
    update_rd_miss_sel      <= to_integer(unsigned(update_rd_miss_sel_s));
    
    -- Throttle until last part of word.
    update_rd_miss_th_incr  <= (not update_read_data_last_i) when (update_rd_miss_sel_s /= ratio_bits_one_vec ) else 
                               '0';
    update_rd_miss_th_wrap  <= not update_read_data_last_i;
    update_rd_miss_throttle <= update_rd_miss_th_wrap when ( update_read_resize_kind = C_KIND_WRAP ) else 
                               update_rd_miss_th_incr;
      
    -- Select current data part.
    update_read_data_word_i <= update_rd_miss_word_i(update_rd_miss_sel);
  
  end generate Read_Internal_Narrow;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Handling
  -- 
  -- Keep track of the source of the BRESP, i.e if it is internal or which port
  -- the response shall be forwarded to in the external case.
  -- 
  -- There are multiple sources and destinations that need too be handled BRESP
  -- handling:
  --  BS   - BRESP Source
  --  BE   - Backend (Valid, Ready)
  --  WMAD - Write Miss Allocate Done (Exist, Pop)
  --  Port - Active Port (Valid, Ready)
  -- 
  --  Insert | Internal | Valid     | Ready         | BS Pop    | WMAD Pop
  -- --------+----------+-----------+---------------+-----------+----------
  --       0 |        0 | BE        | Port          | BE & Port | '0'
  --       0 |        1 | '0'       | '1'           | BE        | '0'
  --       1 |        0 | '0'       | '0'           | '0'       | '0'       Note: Impossible because allocate set both
  --       1 |        1 | WMAD & BE | Port & done_n | BE & WMAD | BS Pop
  -- 
  -----------------------------------------------------------------------------
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  -- 
  
  Gen_BS_Event : process (update_info, update_need_aw, update_evict_hit,
                          update_write_hit, update_write_miss, update_read_miss, update_read_hit) is
  begin  -- process Gen_BS_Event
    -- Default assignment.
    new_bs_src  <= Src_Ext;
    new_bs_slv  <= Slv_None;
    new_bs_mst  <= Mst_Propagate;
    
    -- Slave port handling.
    if( s2b(update_info.Wr and not update_info.Early and not update_info.Internal_Cmd) ) then
      -- Only write that hasn't already got an early BRESP need the BS event propagated.
      -- Also, internally originating Write such as downstream Dirty snoop propagation need
      -- to be ignored (and terminate internally).
      new_bs_slv  <= Slv_Propagate;
    end if;
    
    -- Source handling.
    if( s2b(update_write_hit) ) then
      -- Write has hit on data.
      if( s2b(update_info.Keep) ) then
        -- Data is being kept so ended at once.
        new_bs_src  <= Src_End;
      else
        -- Data has to be thrown out.
        new_bs_src  <= Src_Ext;
      end if;
    elsif( s2b(update_write_miss) ) then
      -- Write has miss on data.
      if( s2b(update_need_aw and update_info.Allocate) ) then
        -- Data is evicted and new data allocated.
        new_bs_src  <= Src_WMA_Ext;
      elsif( s2b(update_info.Allocate) ) then
        -- New Data is allocated.
        new_bs_src  <= Src_WMA;
      elsif( s2b(update_need_aw) ) then
        -- Data is thrown out.
        new_bs_src  <= Src_Ext;
      else
        -- Data is propagating downstream.
        new_bs_src  <= Src_Ext;
      end if;
    elsif( s2b(update_evict_hit) ) then
      -- Evicting data.
      new_bs_src  <= Src_Ext;
    elsif( s2b(update_read_miss) ) then
      -- Read miss.
      if( s2b(update_need_aw) ) then
        -- Data is thrown out.
        new_bs_src  <= Src_Ext;
      end if;
    elsif( s2b(update_read_hit) ) then
      -- Not possible.
    end if;
  
  end process Gen_BS_Event;
  
  -- Properties of the current source of BRESP.
  bs_is_ext                   <= b2s( bs_src = Src_Ext ) or b2s( bs_src = Src_WMA_Ext );
  bs_is_wma                   <= b2s( bs_src = Src_WMA ) or b2s( bs_src = Src_WMA_Ext );
  
  -- Pop BS when all conditions are met for this configuration.
  update_bs_pop               <= update_wr_resp_port_pop and backend_wr_resp_wma_pop and backend_wr_resp_pop 
                                              when ( bs_src = Src_WMA_Ext ) else
                                 update_wr_resp_port_pop and backend_wr_resp_wma_pop 
                                              when ( bs_src = Src_WMA     ) else
                                 update_wr_resp_port_pop                             and backend_wr_resp_pop 
                                              when ( bs_src = Src_Ext     ) else
                                 update_wr_resp_port_pop                          
                                              when ( bs_src = Src_End     ) else
                                 '0';
  
  -- Slave port handshake.
  update_wr_resp_port_ready   <= bs_exist and update_ext_bresp_ready(bs_port_num) when ( bs_slv = Slv_Propagate ) else
                                 bs_exist;
  update_wr_resp_port_pop     <= update_ext_bresp_any_raw and update_wr_resp_port_ready;
                                 
  -- WMA source handshake.
  backend_wr_resp_wma_valid   <= bs_exist and bs_is_wma and not wmad_fifo_empty;
  backend_wr_resp_wma_ready   <= bs_exist and bs_is_wma;
  backend_wr_resp_wma_pop     <= backend_wr_resp_wma_valid and backend_wr_resp_wma_ready;
  
  -- External source handshake.
--  backend_wr_resp_valid       <= bs_exist and bs_is_ext and ( backend_wr_resp_info.Valid or backend_wr_resp_valid_hold );
  backend_wr_resp_valid       <= bs_exist and bs_is_ext and not bp_fifo_empty;
  backend_wr_resp_ready       <= backend_wr_resp_ready_i;
--  backend_wr_resp_ready_i     <= bs_exist and bs_is_ext and not backend_wr_resp_valid_hold;
  backend_wr_resp_ready_i     <= not bp_fifo_full;
--  backend_wr_resp_pop         <= backend_wr_resp_valid and ( backend_wr_resp_ready_i or backend_wr_resp_valid_hold );
  backend_wr_resp_pop         <= backend_wr_resp_valid and not bp_fifo_empty;
  
  FIFO_BS_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => update_bs_push,
      queue_pop                 => update_bs_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => bs_refresh_reg,
      
      queue_almost_full         => open,
      queue_full                => bs_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => bs_fifo_empty,
      queue_exist               => bs_exist,
      queue_line_fit            => open,
      queue_index               => bs_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_bs,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bs_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Response Source FIFO.
  FIFO_BS_Memory : process (ACLK) is
  begin  -- process FIFO_BS_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( update_bs_push = '1' ) then
        -- Insert new item.
        bs_fifo_mem(0).Port_Num <= update_port_rd;
        bs_fifo_mem(0).Internal <= -- Line has to be dropped because it is not 
                                   ( update_need_evict and not ( update_write_hit and not update_early_bresp ) ) or 
                                   -- 
                                   ( update_info.Wr and update_early_bresp ) or 
                                   -- Completely internally generated
                                   ( update_inserted_trans );
        bs_fifo_mem(0).Insert   <= -- 
                                   ( update_write_miss and update_info.Allocate );
        bs_fifo_mem(0).Src      <= new_bs_src;
        bs_fifo_mem(0).Slv      <= new_bs_slv;
        bs_fifo_mem(0).Lookup   <= update_inserted_trans;
        bs_fifo_mem(0).Addr     <= update_info.Addr(C_ADDR_INTERNAL_POS);
        if( is_mst_coherent(C_ENABLE_COHERENCY) or 
            ( C_ENABLE_EX_MON > 0 ) ) then
          bs_fifo_mem(0).Set_ExOk <= ( update_info.Exclusive and update_exclusive_hit );
        else
          bs_fifo_mem(0).Set_ExOk <= C_NULL_BS.Set_ExOk;
        end if;
        bs_fifo_mem(0).Create   <= update_create_bresp;
        
        -- Shift FIFO contents.
        bs_fifo_mem(bs_fifo_mem'left downto 1) <= bs_fifo_mem(bs_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BS_Memory;
  
  -- Store BS in register for good timing.
  BS_Data_Registers : process (ACLK) is
  begin  -- process BS_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        bs_src      <= C_NULL_BS.Src;
        bs_slv      <= C_NULL_BS.Slv;
        bs_port_num <= C_NULL_BS.Port_Num;
        bs_addr     <= C_NULL_BS.Addr;
        bs_exok     <= C_NULL_BS.Set_ExOk;
        bs_lookup   <= C_NULL_BS.Lookup;
      elsif( bs_refresh_reg = '1' ) then
        bs_src      <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Src;
        bs_slv      <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Slv;
        bs_port_num <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Port_Num;
        bs_addr     <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Addr;
        if( is_mst_coherent(C_ENABLE_COHERENCY) or 
            ( C_ENABLE_EX_MON > 0 ) ) then
          bs_exok     <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Set_ExOk;
        else
          bs_exok     <= C_NULL_BS.Set_ExOk;
        end if;
        bs_lookup   <= bs_fifo_mem(to_integer(unsigned(bs_read_fifo_addr))).Lookup;
      end if;
    end if;
  end process BS_Data_Registers;
  
  -- Forward information to Backend for Re-Ordering handling.
  backend_wr_resp_conf.Port_Num <= std_logic_vector(to_unsigned(bs_port_num, C_MAX_NUM_PORT_WIDTH));
  backend_wr_resp_conf.Internal <= '0';
  backend_wr_resp_conf.Addr     <= fit_vec(bs_addr, C_MAX_ADDR_WIDTH);
  
--  -- Generate valid BRESP
  update_ext_bresp_any_raw  <= backend_wr_resp_wma_valid and backend_wr_resp_valid when ( bs_src = Src_WMA_Ext ) else
                               backend_wr_resp_wma_valid                           when ( bs_src = Src_WMA     ) else
                                                             backend_wr_resp_valid when ( bs_src = Src_Ext     ) else
                               bs_exist                                            when ( bs_src = Src_End     ) else
                               '0';
  update_ext_bresp_any      <= update_ext_bresp_any_raw and b2s( bs_slv = Slv_Propagate );
  update_ext_bresp_any_vec  <= (others => update_ext_bresp_any);
  update_ext_bresp_valid_i  <= std_logic_vector(to_unsigned(2 ** bs_port_num, C_NUM_PORTS)) and 
                               update_ext_bresp_any_vec;
  
  -- Generate BRESP queues per port.
  Gen_Port_BRESP_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    update_ext_bresp_info(I).Valid  <= update_ext_bresp_valid_i(I);
    
    -- Forward RESP from Backend or insert OKAY from WMA.
    update_ext_bresp_info(I).BRESP  <= C_BRESP_EXOKAY when bs_exok   = '1' else
                                       wmad_bresp     when bs_is_wma = '1' else
                                       bp_bresp       when bs_is_ext = '1' else
                                       C_BRESP_OKAY;
    
  end generate Gen_Port_BRESP_Array;

  --
--  BS_Pop_Handler : process (ACLK) is
--  begin  -- process BS_Pop_Handler
--    if (ACLK'event and ACLK = '1') then   -- rising clock edge
--      if (ARESET_I = '1') then              -- synchronous reset (active high)
--        backend_wr_resp_valid_hold  <= '0';
--        
--      else
--        if( update_bs_pop = '1' ) then
--          -- BS has been forwarded, no need to hold.
--          backend_wr_resp_valid_hold  <= '0';
--          
--        elsif( ( backend_wr_resp_info.Valid and backend_wr_resp_ready_i ) = '1' ) then
--          -- Hold a fake internal Valid so that that the BRESP can be released quickly.
--          -- When WMA forced Evict the BRESP needs to be acknowledged quickly to not cause any
--          -- delay for ordering in Backend.
--          backend_wr_resp_valid_hold  <= '1';
--          
--        end if;
--      end if;
--    end if;
--  end process BS_Pop_Handler;
  
  
  -----------------------------------------------------------------------------
  -- 
  -- 
  -----------------------------------------------------------------------------
  
  bp_push <=  backend_wr_resp_info.Valid and not bp_fifo_full;
  bp_pop  <= update_bs_pop and backend_wr_resp_pop;
  
  FIFO_BP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => bp_push,
      queue_pop                 => bp_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => bp_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => bp_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => bp_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_ud_bp,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bp_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Response Source FIFO.
  FIFO_BP_Memory : process (ACLK) is
  begin  -- process FIFO_BP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( bp_push = '1' ) then
        -- Insert new item.
        bp_fifo_mem(0).BRESP  <= backend_wr_resp_info.BRESP;
        
        -- Shift FIFO contents.
        bp_fifo_mem(bp_fifo_mem'left downto 1) <= bp_fifo_mem(bp_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BP_Memory;
  
  bp_bresp  <= bp_fifo_mem(to_integer(unsigned(bp_read_fifo_addr))).BRESP;
  
  
  -----------------------------------------------------------------------------
  -- Master coherency
  -- 
  -----------------------------------------------------------------------------
  
  Use_Mst_Coherency: if (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  
    -- Snoop data queue.
    signal sdr_push                     : std_logic;
    signal sdr_pop                      : std_logic;
    signal sdr_fifo_full                : std_logic;
    signal sdr_read_fifo_addr           : QUEUE_ADDR_TYPE:= (others=>'1');
    signal sdr_fifo_mem                 : MST_SNOOP_ADDR_VECTOR_TYPE(QUEUE_ADDR_POS);
    signal sdr_assert                   : std_logic;
    signal stat_ud_sdr                  : STAT_FIFO_TYPE;
    
    -- Snoop data queue.
    signal sd_push                      : std_logic;
    signal sd_pop                       : std_logic;
    signal sd_fifo_empty                : std_logic;
    signal sd_fifo_line_fit             : std_logic;
    signal sd_read_fifo_addr            : DATA_QUEUE_ADDR_TYPE:= (others=>'1');
    signal sd_fifo_mem                  : MST_SNOOP_DATA_VECTOR_TYPE(DATA_QUEUE_ADDR_POS);
    signal mst_core_update_data_info_i  : MST_SNOOP_DATA_TYPE;
    signal sd_assert                    : std_logic;
    signal stat_ud_sd                   : STAT_FIFO_TYPE;
    
    -- Snoop data sequence handling
    signal update_snoop_stop            : std_logic;
    
    signal update_data_snoop_reg        : SET_EXT_DATA_TYPE;
    signal update_data_select_snoop_reg : EXT_DATA_TYPE;
    signal update_word_cnt_en_d1        : std_logic;
    signal update_word_cnt_last_d1      : std_logic;
    signal sdr_way_d1                   : C_MAX_WAYS_POS;
    signal update_word_cnt_en_d2        : std_logic;
    signal update_word_cnt_last_d2      : std_logic;
    signal sdr_way_d2                   : C_WAY_POS;
    
    -- Snoop Requested Address.
    signal mst_snoop_mem_tag_info       : MST_SNOOP_ACK_VECTOR_TYPE(C_WAY_POS);
    signal mst_snoop_mem_tag_hit        : WAY_TYPE;
    signal mst_snoop_check_tag_info     : MST_SNOOP_ACK_VECTOR_TYPE(C_WAY_POS);
    signal mst_snoop_check_tag_hit      : WAY_TYPE;
    
    signal mst_snoop_check_ack_info_i   : MST_SNOOP_ACK_TYPE;
    signal mst_core_update_hazard_i     : RMST_SNOOP_HAZ_TYPE;
    signal mst_snoop_mem_rm_alloc_i     : std_logic;
    signal mst_snoop_check_rm_alloc_i   : std_logic;
    
    
  begin
    -----------------------------------------------------------------------------
    -- Hazard Detection to stall pipeline when there is a conflict.
    -----------------------------------------------------------------------------
    
    Gen_Hazard_Detect : process (update_valid, update_info, mst_snoop_fetch_info,
                                 update_need_tag_write, update_done_tag_write) is
    begin  -- process Gen_Hazard_Detect
      -- Default assignments.
      mst_core_update_hazard_i        <= C_NULL_MST_SNOOP_HAZ;
      
      -- Simple decoding if information is valid.
      mst_core_update_hazard_i.Valid  <= update_valid and mst_snoop_fetch_info.Valid;
    
      if( s2b(update_valid and mst_snoop_fetch_info.Valid) and
          ( update_info.Addr(C_ADDR_LINE_POS) = mst_snoop_fetch_info.Addr(C_ADDR_LINE_POS) ) and
          s2b(update_need_tag_write and not update_done_tag_write) ) then
        mst_core_update_hazard_i.Hazard <= '1';
      end if;
      
    end process Gen_Hazard_Detect;
    
    mst_core_update_hazard  <= mst_core_update_hazard_i;
    
    -----------------------------------------------------------------------------
    -- Snoop Data Request queue.
    -----------------------------------------------------------------------------
    
    -- Handle push pop.
    sdr_push <= mst_snoop_sdr_push;
    sdr_pop  <= update_snoop_stop;
    
    -- Instantiate SnoopData Queue pointer handling.
    FIFO_SDR_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => sdr_push,
        queue_pop                 => sdr_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => sdr_fifo_full,
        queue_almost_empty        => open,
        queue_empty               => sdr_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => sdr_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_sdr,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => sdr_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for SD FIFO.
    FIFO_SDR_Memory : process (ACLK) is
    begin  -- process FIFO_SDR_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( sdr_push = '1' ) then
          -- Insert new item.
          sdr_fifo_mem(0)                         <= mst_snoop_sdr_info;
          
          -- Shift FIFO contents.
          sdr_fifo_mem(sdr_fifo_mem'left downto 1) <= sdr_fifo_mem(sdr_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_SDR_Memory;
    
    mst_snoop_sdr_empty <= sdr_fifo_empty and ( not update_word_cnt_en_d1 ) and ( not update_word_cnt_en_d2 ) and sd_fifo_empty;
    mst_snoop_sdr_full  <= sdr_fifo_full;
    
    sdr_way             <= sdr_fifo_mem(to_integer(unsigned(sdr_read_fifo_addr))).Way;
    sdr_line_addr       <= sdr_fifo_mem(to_integer(unsigned(sdr_read_fifo_addr))).Addr(C_ADDR_LINE_POS);
    sdr_word_addr       <= sdr_fifo_mem(to_integer(unsigned(sdr_read_fifo_addr))).Addr(C_ADDR_EXT_WORD_POS);
    
    
    -----------------------------------------------------------------------------
    -- Snoop data sequence handling
    -----------------------------------------------------------------------------
    
    -- Detect when it is ok to Snoop.
    update_snoop_start        <= ( not sdr_fifo_empty           ) and 
                                 ( not update_read_miss_ongoing ) and 
                                 ( not update_evict_ongoing     ) and
                                 ( not update_snoop_data_stall  );
    
    -- Stop when last element has been processed.
    update_snoop_stop         <= update_word_cnt_last and update_rd_cnt_en and update_snoop_ongoing
                                        when ( C_EXTERNAL_DATA_WIDTH < 32 * C_CACHE_LINE_LENGTH ) else
                                 update_word_cnt_last and update_rd_cnt_en and update_snoop_start;
    
    -- .
    update_snoop_data_stall   <= not sd_fifo_line_fit;
    
    -- Control the evict and read miss states.
    Update_Snoop_Sequence_Handle : process (ACLK) is
    begin  -- process Update_Snoop_Sequence_Handle
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if ARESET_I = '1' then                      -- synchronous reset (active high)
          update_snoop_ongoing  <= '0';
          
        elsif( update_word_cnt_en = '1' ) then
          -- Start and stop of Evict Ongoing.
          if( update_snoop_stop = '1' ) then
            update_snoop_ongoing  <= '0';
            
          elsif( update_snoop_start = '1' ) then
            update_snoop_ongoing  <= '1';
            
          end if;
        end if;
          
      end if;
    end process Update_Snoop_Sequence_Handle;
    
    
    -----------------------------------------------------------------------------
    -- Buffer requested data.
    -----------------------------------------------------------------------------
    
    Update_Snoop_Data_Buffer : process (ACLK) is
    begin  -- process Update_Snoop_Data_Buffer
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if ARESET_I = '1' then                      -- synchronous reset (active high)
          update_word_cnt_en_d1   <= '0';
          update_word_cnt_en_d2   <= '0';
          sdr_way_d1              <= 0;
          sdr_way_d2              <= 0;
          update_word_cnt_last_d1 <= '0';
          update_word_cnt_last_d2 <= '0';
          update_data_snoop_reg   <= (others=>(others=>'0'));
          
        else
          -- Data pipeline control.
          update_word_cnt_en_d1   <= update_word_cnt_en and
                                    ( update_snoop_start or update_snoop_ongoing );
          update_word_cnt_en_d2   <= update_word_cnt_en_d1;
          
          -- Way selection pipeline.
          sdr_way_d1              <= sdr_way;
          sdr_way_d2              <= ( sdr_way_d1 mod C_NUM_WAYS);
          
          -- Data pipeline.
          update_word_cnt_last_d1 <= update_word_cnt_last;
          update_word_cnt_last_d2 <= update_word_cnt_last_d1;
          update_data_snoop_reg   <= update_data_current_word_i;
          
        end if;
      end if;
    end process Update_Snoop_Data_Buffer;
    
    -- Select the requested Way data.
    update_data_select_snoop_reg  <= update_data_snoop_reg(sdr_way_d2);
    
    -- Handle push pop.
    sd_push <= update_word_cnt_en_d2;
    sd_pop  <= mst_core_update_data_ready and not sd_fifo_empty;
    
    -- Instantiate SnoopData Queue pointer handling.
    FIFO_SD_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_DATA_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => C_DATA_QUEUE_LINE_LENGTH
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => sd_push,
        queue_pop                 => sd_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => open,
        queue_almost_empty        => open,
        queue_empty               => sd_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => sd_fifo_line_fit,
        queue_index               => sd_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_sd,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => sd_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for SD FIFO.
    FIFO_SD_Memory : process (ACLK) is
    begin  -- process FIFO_SD_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( sd_push = '1' ) then
          -- Insert new item.
          sd_fifo_mem(0).Valid                    <= '0';
          sd_fifo_mem(0).Last                     <= update_word_cnt_last_d2;
          sd_fifo_mem(0).Data                     <= fit_vec(update_data_select_snoop_reg, C_MAX_DATA_WIDTH);
          
          -- Shift FIFO contents.
          sd_fifo_mem(sd_fifo_mem'left downto 1)  <= sd_fifo_mem(sd_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_SD_Memory;
    
    -- Assemble Snoop Data interface record.
    Compile_SD_Info: process(sd_fifo_empty, sd_fifo_mem, sd_read_fifo_addr) is
    begin
      mst_core_update_data_info_i.Valid <= not sd_fifo_empty;
      mst_core_update_data_info_i.Last  <= sd_fifo_mem(to_integer(unsigned(sd_read_fifo_addr))).Last;
      mst_core_update_data_info_i.Data  <= sd_fifo_mem(to_integer(unsigned(sd_read_fifo_addr))).Data;
      
    end process Compile_SD_Info;
    mst_core_update_data_info <= mst_core_update_data_info_i;
    
    -----------------------------------------------------------------------------
    -- Snoop Requested Address.
    -----------------------------------------------------------------------------
    
    -- Assign Tag interface signal from fetch phase.
    ud_snoop_tag_en           <= mst_snoop_fetch_piperun;
    ud_snoop_tag_we           <= (others=>'0');
    ud_snoop_tag_addr         <= mst_snoop_fetch_info.Addr(C_ADDR_FULL_LINE_POS);
    
    -- Not possible to get information at this stage.
    mst_snoop_fetch_ack_info  <= C_NULL_MST_SNOOP_ACK;
    
    -- Extract Tag information.
    Gen_Set_Tag: for K in 0 to C_NUM_WAYS - 1 generate
    begin
      -- Extract Tag information to 
      Extract_Tag_Info: process(ud_snoop_tag_current_word, mst_snoop_mem_info) is
      begin
        mst_snoop_mem_tag_info(K)                         <= C_NULL_MST_SNOOP_ACK;
        mst_snoop_mem_tag_info(K).Valid                   <= ud_snoop_tag_current_word(K).Valid;
        mst_snoop_mem_tag_info(K).Secure                  <= ud_snoop_tag_current_word(K).Secure;
        mst_snoop_mem_tag_info(K).Unique                  <= ud_snoop_tag_current_word(K).Unique;
        mst_snoop_mem_tag_info(K).Dirty                   <= ud_snoop_tag_current_word(K).Dirty;
        mst_snoop_mem_tag_info(K).Locked                  <= ud_snoop_tag_current_word(K).Locked;
        mst_snoop_mem_tag_info(K).Reused                  <= ud_snoop_tag_current_word(K).Reused;
        mst_snoop_mem_tag_info(K).Addr                    <= C_BASEADDR;
        mst_snoop_mem_tag_info(K).Addr(C_ADDR_TAG_POS)    <= ud_snoop_tag_current_word(K).Addr(C_ADDR_TAG_POS);
        mst_snoop_mem_tag_info(K).Addr(C_ADDR_LINE_POS)   <= mst_snoop_mem_info.Addr(C_ADDR_LINE_POS);
        mst_snoop_mem_tag_info(K).Addr(C_ADDR_OFFSET_POS) <= (others=>'0');
        
      end process Extract_Tag_Info;
      
      -- Detect if any 
      mst_snoop_mem_tag_hit(K)          <= mst_snoop_mem_tag_info(K).Valid when 
                                                ( mst_snoop_mem_info.Addr(C_ADDR_TAG_POS) = 
                                                  mst_snoop_mem_tag_info(K).Addr(C_ADDR_TAG_POS) ) and
                                                ( ( C_ENABLE_NON_SECURE = 0 ) or 
                                                  ( ud_snoop_tag_current_word(K).Secure = 
                                                    mst_snoop_mem_info.Prot(C_PROT_SECURE_POS) ) )  else
                                           '0';
      
    end generate Gen_Set_Tag;
    
    -- Move Tag info to next pipeline stage
    Handle_Mem_Snoop_Request : process (ACLK) is
    begin  -- process Handle_Mem_Snoop_Request
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          mst_snoop_check_tag_info  <= (others=>C_NULL_MST_SNOOP_ACK);
          mst_snoop_check_tag_hit   <= (others=>'0');
          
        elsif( mst_snoop_mem_piperun = '1' ) then
          mst_snoop_check_tag_info        <= mst_snoop_mem_tag_info;
          mst_snoop_check_tag_hit         <= mst_snoop_mem_tag_hit;
          
        end if;
      end if;
    end process Handle_Mem_Snoop_Request;
    
    -- Not possible to get information at this stage.
    mst_snoop_mem_ack_info    <= C_NULL_MST_SNOOP_ACK;
    
    -- Select Hit if available.
    Select_Tag_Info: process(mst_snoop_check_tag_hit, mst_snoop_check_tag_info) is
    begin
      mst_snoop_check_ack_info_i  <= C_NULL_MST_SNOOP_ACK;
      
      for K in 0 to C_NUM_WAYS - 1 loop
        if( mst_snoop_check_tag_hit(K) = '1' ) then
          mst_snoop_check_ack_info_i      <= mst_snoop_check_tag_info(K);
          mst_snoop_check_ack_info_i.Way  <= K;
        end if;
      end loop;
      
    end process Select_Tag_Info;
    
    mst_snoop_check_ack_info  <= mst_snoop_check_ack_info_i;
    
    -- Unused signal.
    mst_snoop_update_ack_info <= C_NULL_MST_SNOOP_ACK;
    
    -- Detect if the line is released
    mst_snoop_mem_rm_alloc      <= mst_snoop_mem_rm_alloc_i;
    mst_snoop_mem_rm_alloc_i    <= mst_snoop_mem_info.Valid and update_remove_locked when 
                                    ( mst_snoop_mem_info.Addr(C_ADDR_TAG_POS) = 
                                      ri_addr(C_ADDR_TAG_POS) ) else
                                  '0';
    mst_snoop_check_rm_alloc    <= mst_snoop_check_rm_alloc_i;
    mst_snoop_check_rm_alloc_i  <= mst_snoop_check_info.Valid and update_remove_locked when 
                                    ( mst_snoop_check_info.Addr(C_ADDR_TAG_POS) = 
                                      ri_addr(C_ADDR_TAG_POS) ) else
                                  '0';
    
    
    -----------------------------------------------------------------------------
    -- Tag Refresh Handling
    -----------------------------------------------------------------------------
    
    -- Determine if a write is desired.
    snoop_need_tag_write  <= mst_snoop_tag_valid;
    snoop_tag_trans_addr  <= mst_snoop_tag_info.Addr(C_ADDR_LINE_POS);
    
    -- Stall until Tag Update has been performed.
    mst_snoop_tag_stall   <= mst_snoop_tag_valid and 
                             ( ( update_need_tag_write and not update_done_tag_write ) or 
                               update_readback_available );
    
    -- Extract information
    su_new_tag_valid  <= mst_snoop_tag_info.Valid;
    su_new_tag_secure <= mst_snoop_tag_info.Secure;
    su_new_tag_unique <= mst_snoop_tag_info.Unique;
    su_new_tag_dirty  <= mst_snoop_tag_info.Dirty;
    su_new_tag_reused <= mst_snoop_tag_info.Reused;
    su_new_tag_locked <= mst_snoop_tag_info.Locked;
    su_new_tag_addr   <= mst_snoop_tag_info.Addr(C_ADDR_TAG_POS);
    
    -- Propagate that the internal transaction has been removed from the R channel.
    update_inserted_rd_done   <= backend_rd_data_info.Valid and 
                                 backend_rd_data_ready_i    and
                                 backend_rd_data_info.Last  and 
                                 ri_lookup;
    update_inserted_ex_ok     <= '1' when ( backend_rd_data_info.RRESP(C_AXI_SHORT_RRESP_POS) = 
                                            C_RRESP_EXOKAY(C_AXI_SHORT_RRESP_POS) ) else 
                                 '0';
    update_inserted_wr_done   <= update_bs_pop              and 
                                 bs_lookup;
    
    update_pushing_writeunique<= update_valid and update_need_aw and 
                                     ( b2s( update_info.Snoop(C_AXI_AWSNOOP_POS) = C_AWSNOOP_WriteUnique     ) or 
                                       b2s( update_info.Snoop(C_AXI_AWSNOOP_POS) = C_AWSNOOP_WriteLineUnique ) );
    update_pushing_writeback  <= update_valid and update_need_aw and 
                                 not ( b2s( update_info.Snoop(C_AXI_AWSNOOP_POS) = C_AWSNOOP_WriteUnique     ) or 
                                       b2s( update_info.Snoop(C_AXI_AWSNOOP_POS) = C_AWSNOOP_WriteLineUnique ) );
    
    -----------------------------------------------------------------------------
    -- Debug
    -----------------------------------------------------------------------------
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      UPDATE_DEBUG2(C_MAX_DEBUG_WIDTH - 1 downto 256) <= (others=>'0');
    end generate No_Debug;
    
    
    Use_Debug: if( C_USE_DEBUG ) generate
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            UPDATE_DEBUG2(C_MAX_DEBUG_WIDTH - 1 downto 256) <= (others=>'0');
          else
            -- Default assignment.
            UPDATE_DEBUG2(C_MAX_DEBUG_WIDTH - 1 downto 256) <= (others=>'0');
            
            -- Snoop data queue.
            UPDATE_DEBUG2(           256) <= sdr_push;
            UPDATE_DEBUG2(           257) <= sdr_pop;
            UPDATE_DEBUG2(           258) <= sdr_fifo_full;
            UPDATE_DEBUG2(           259) <= sdr_assert;
            UPDATE_DEBUG2(263 downto 260) <= fit_vec(sdr_read_fifo_addr, 4);
            
            -- Snoop data queue.
            UPDATE_DEBUG2(           264) <= sd_push;
            UPDATE_DEBUG2(           265) <= sd_pop;
            UPDATE_DEBUG2(           266) <= sd_fifo_empty;
            UPDATE_DEBUG2(           267) <= sd_fifo_line_fit;
            UPDATE_DEBUG2(272 downto 268) <= fit_vec(sd_read_fifo_addr, 5);
            UPDATE_DEBUG2(           273) <= sd_assert;
            
            -- Snoop data sequence handling
            UPDATE_DEBUG2(           274) <= update_snoop_stop;
            
            UPDATE_DEBUG2(           275) <= update_word_cnt_en_d1;
            UPDATE_DEBUG2(           276) <= update_word_cnt_last_d1;
            UPDATE_DEBUG2(           277) <= update_word_cnt_en_d2;
            UPDATE_DEBUG2(           278) <= update_word_cnt_last_d2;
            UPDATE_DEBUG2(281 downto 279) <= std_logic_vector(to_unsigned(sdr_way_d1, 3));
            UPDATE_DEBUG2(284 downto 282) <= std_logic_vector(to_unsigned(sdr_way_d2, 3));
--            UPDATE_DEBUG2(256 downto 256) <= update_data_snoop_reg        : SET_EXT_DATA_TYPE;
--            UPDATE_DEBUG2(256 downto 256) <= update_data_select_snoop_reg : EXT_DATA_TYPE;
            
            -- Snoop Requested Address.
            UPDATE_DEBUG2(292 downto 285) <= fit_vec(mst_snoop_mem_tag_hit, 8);
            UPDATE_DEBUG2(300 downto 293) <= fit_vec(mst_snoop_check_tag_hit, 8);
--            UPDATE_DEBUG2(256 downto 301) <= mst_snoop_mem_tag_info       : MST_SNOOP_ACK_VECTOR_TYPE(C_WAY_POS);
--            UPDATE_DEBUG2(256 downto 301) <= mst_snoop_check_tag_info     : MST_SNOOP_ACK_VECTOR_TYPE(C_WAY_POS);
            
            
--            mst_snoop_check_ack_info  : out RMST_SNOOP_ACK_TYPE;
            UPDATE_DEBUG2(           301) <= mst_snoop_check_ack_info_i.Valid;
            UPDATE_DEBUG2(           302) <= mst_snoop_check_ack_info_i.Secure;
            UPDATE_DEBUG2(           303) <= mst_snoop_check_ack_info_i.Unique;
            UPDATE_DEBUG2(351 downto 304) <= fit_vec(mst_snoop_check_ack_info_i.Addr, 48);
            UPDATE_DEBUG2(           352) <= mst_snoop_check_ack_info_i.Dirty;
            UPDATE_DEBUG2(           353) <= mst_snoop_check_ack_info_i.Locked;
            UPDATE_DEBUG2(           354) <= mst_snoop_check_ack_info_i.Reused;
            UPDATE_DEBUG2(357 downto 355) <= std_logic_vector(to_unsigned(mst_snoop_check_ack_info_i.Way, 3));
            
--            mst_core_update_hazard    : out RMST_SNOOP_HAZ_TYPE;
            UPDATE_DEBUG2(           358) <= mst_core_update_hazard_i.Valid;
            UPDATE_DEBUG2(           359) <= mst_core_update_hazard_i.Hazard;
            UPDATE_DEBUG2(           360) <= '0';
            UPDATE_DEBUG2(           361) <= '0';
            
            UPDATE_DEBUG2(           362) <= mst_snoop_mem_rm_alloc_i;
            UPDATE_DEBUG2(           363) <= mst_snoop_check_rm_alloc_i;
            
            UPDATE_DEBUG2(           364) <= mst_snoop_sdr_push;
            
--            mst_core_update_data_info : out MST_SNOOP_DATA_TYPE;
            UPDATE_DEBUG2(           365) <= mst_core_update_data_info_i.Valid;
            UPDATE_DEBUG2(           366) <= mst_core_update_data_info_i.Last;
            
            UPDATE_DEBUG2(           367) <= mst_core_update_data_ready;
            
            UPDATE_DEBUG2(           368) <= update_snoop_ongoing;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
  end generate Use_Mst_Coherency;

  No_Mst_Coherency: if  ( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    -- Tie-off unused signals.
    ud_snoop_tag_en           <= '0';
    ud_snoop_tag_we           <= (others=>'0');
    ud_snoop_tag_addr         <= (others=>'0');
    
    mst_snoop_fetch_ack_info  <= C_NULL_MST_SNOOP_ACK;
    mst_snoop_mem_ack_info    <= C_NULL_MST_SNOOP_ACK;
    mst_snoop_check_ack_info  <= C_NULL_MST_SNOOP_ACK;
    mst_snoop_update_ack_info <= C_NULL_MST_SNOOP_ACK;
    
    mst_core_update_hazard    <= C_NULL_MST_SNOOP_HAZ;
    
    mst_snoop_mem_rm_alloc    <= '0';
    mst_snoop_check_rm_alloc  <= '0';
    
    mst_snoop_tag_stall       <= '0';
    
    mst_snoop_sdr_empty       <= '1';
    mst_snoop_sdr_full        <= '0';
    
    mst_core_update_data_info <= C_NULL_MST_SNOOP_DATA;
    
    sdr_fifo_empty            <= '1';
    sdr_way                   <= 0;
    sdr_line_addr             <= (others=>'0');
    sdr_word_addr             <= (others=>'0');
    update_snoop_start        <= '0';
    update_snoop_ongoing      <= '0';
    update_snoop_data_stall   <= '0';
    
    su_new_tag_valid          <= '0';
    su_new_tag_secure         <= '0';
    su_new_tag_unique         <= '0';
    su_new_tag_reused         <= '0';
    su_new_tag_locked         <= '0';
    su_new_tag_dirty          <= '0';
    su_new_tag_addr           <= (others=>'0');
  
    snoop_need_tag_write      <= '0';
    snoop_tag_trans_addr      <= (others=>'0');
    
    update_inserted_rd_done   <= '0';
    update_inserted_ex_ok     <= '0';
    update_inserted_wr_done   <= '0';
    
    update_pushing_writeunique<= '0';
    update_pushing_writeback  <= '0';
    
    UPDATE_DEBUG2(C_MAX_DEBUG_WIDTH - 1 downto 256) <= (others=>'0');
    
  end generate No_Mst_Coherency;
  
  -- Unused signal.
  ud_snoop_tag_new_word     <= (others=>C_NULL_WAY_LINE_TAG);
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_ud_stall     <= C_NULL_STAT_POINT;
    stat_ud_tag_free  <= C_NULL_STAT_POINT;
    stat_ud_data_free <= C_NULL_STAT_POINT;
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal stat_tag_free  : std_logic;
    signal stat_data_free : std_logic;
    signal stat_stall     : std_logic;
  begin
    
    Stat_Handle : process (ACLK) is
    begin  -- process Stat_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          stat_tag_free   <= '0';
          stat_data_free  <= '0';
          stat_stall      <= '0';
          
        else
          stat_tag_free   <= not update_tag_en_i;
          stat_data_free  <= not update_data_en_ii(0);
          stat_stall      <= update_stall;
            
        end if;
      end if;
    end process Stat_Handle;
    
    Tag_Free_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => stat_tag_free,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
      
        stat_data                 => stat_ud_tag_free
      );
      
    Data_Free_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => stat_data_free,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_data_free
      );
      
    Stall_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => stat_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_stall
      );
      
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    UPDATE_DEBUG1               <= (others=>'0');
    UPDATE_DEBUG2(255 downto 0) <= (others=>'0');
  end generate No_Debug;
  
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_PORTS   : natural := min_of( 4, C_NUM_INTERNAL_PORTS);
    constant C_MY_WPORT   : natural := min_of( 2, Log2(C_NUM_INTERNAL_PORTS));
    constant C_MY_OFF     : natural := min_of( 6, C_ADDR_OFFSET_HI - C_ADDR_OFFSET_LO + 1);
    constant C_MY_LEN     : natural := min_of( 6, C_AXI_LENGTH_WIDTH);
    constant C_MY_TLINE   : natural := min_of(10, C_ADDR_FULL_LINE_HI - C_ADDR_FULL_LINE_LO + 1);
    constant C_MY_LINE    : natural := min_of(10, C_ADDR_LINE_HI - C_ADDR_LINE_LO + 1);
    constant C_MY_DLINE   : natural := min_of(14, C_ADDR_EXT_DATA_HI - C_ADDR_EXT_DATA_LO + 1);
    constant C_MY_WORD    : natural := min_of( 5, C_ADDR_EXT_WORD_HI - C_ADDR_EXT_WORD_LO + 1);
    constant C_MY_PWAY    : natural := min_of( 2, Log2(C_NUM_WAYS));
    constant C_MY_HOTWAY  : natural := min_of( 2, C_NUM_WAYS);
    constant C_MY_WAY     : natural := min_of( 2, C_WAY_BIT_HI - C_WAY_BIT_LO + 1);
    constant C_MY_TAG     : natural := min_of(18, C_TAG_SIZE);
    constant C_MY_QCNT    : natural := min_of( 4, C_QUEUE_LENGTH_BITS);
    constant C_MY_EXTBE   : natural := min_of(32, C_EXTERNAL_DATA_WIDTH)/8;
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          UPDATE_DEBUG1               <= (others=>'0');
          UPDATE_DEBUG2(255 downto 0) <= (others=>'0');
        else
          -- Default assignment.
          UPDATE_DEBUG1                                   <= (others=>'0');
          UPDATE_DEBUG2(255 downto 0)                     <= (others=>'0');
          
          -- Access signals.
          for I in 0 to C_MY_PORTS - 1 loop
            UPDATE_DEBUG1(  0 + I)  <= access_data_info(I).Valid;
            UPDATE_DEBUG1(  4 + I)  <= access_data_info(I).Last;
          end loop;
          
          -- Lookup signals.
          UPDATE_DEBUG1(                              8)  <= lookup_push_write_miss;
          UPDATE_DEBUG1(                              9)  <= lookup_wm_evict;
          UPDATE_DEBUG1( 10 + C_MY_OFF   - 1 downto  10)  <= fit_vec(lookup_wm_use_bits, C_MY_OFF);
          UPDATE_DEBUG1( 16 + C_MY_OFF   - 1 downto  16)  <= fit_vec(lookup_wm_stp_bits, C_MY_OFF);
          
          -- Update transaction.
          UPDATE_DEBUG1(                             22)  <= update_valid;
--          UPDATE_DEBUG1( 23 + C_MY_PWAY  - 1 downto  23)  <= update_way(C_MY_PWAY - 1 downto 0);
          UPDATE_DEBUG1( 25 + C_MY_OFF   - 1 downto  25)  <= fit_vec(update_info.Addr_Use, C_MY_OFF);
          UPDATE_DEBUG1( 31 + C_MY_OFF   - 1 downto  31)  <= fit_vec(update_info.Addr_Stp, C_MY_OFF);
          UPDATE_DEBUG1(                             37)  <= update_hit;
          UPDATE_DEBUG1(                             38)  <= update_miss;
          UPDATE_DEBUG1(                             39)  <= update_read_hit;
          UPDATE_DEBUG1(                             40)  <= update_read_miss;
          UPDATE_DEBUG1(                             41)  <= update_read_miss_dirty;
          UPDATE_DEBUG1(                             42)  <= update_write_hit;
          UPDATE_DEBUG1(                             43)  <= update_write_miss;
          UPDATE_DEBUG1(                             44)  <= update_locked_write_hit;
          UPDATE_DEBUG1(                             45)  <= update_locked_read_hit;
          UPDATE_DEBUG1(                             46)  <= update_first_write_hit;
          UPDATE_DEBUG1(                             47)  <= '0';
--          UPDATE_DEBUG1( 48 + C_MY_TAG   - 1 downto  48)  <= update_old_tag(C_MY_TAG - 1 downto 0);
          
          -- Backend signals.
          UPDATE_DEBUG1(                             64)  <= bp_fifo_empty;                            -- Was: backend_wr_resp_info.Valid;
          UPDATE_DEBUG1( 65 + C_MY_WPORT - 1 downto  65)  <= std_logic_vector(to_unsigned(bs_port_num, 
                                                                                         C_MY_WPORT)); -- backend_wr_resp_conf.Port_Num
          UPDATE_DEBUG1(                             67)  <= '0';
          UPDATE_DEBUG1(                             68)  <= backend_wr_resp_ready_i;
          UPDATE_DEBUG1(                             69)  <= backend_rd_data_info.Valid;
          UPDATE_DEBUG1(                             70)  <= backend_rd_data_info.Last;
          UPDATE_DEBUG1( 71 + 2          - 1 downto  71)  <= fit_vec(backend_rd_data_real_rresp, 2);
          UPDATE_DEBUG1(                             73)  <= backend_rd_data_ready_i;
          
          -- Update signals (to Arbiter).
          UPDATE_DEBUG1( 75                  downto  74)  <= std_logic_vector(to_unsigned(BS_SRC_ACTION_TYPE'pos(bs_src), 2));
          UPDATE_DEBUG1( 76 + C_MY_WPORT - 1 downto  76)  <= std_logic_vector(to_unsigned(update_write_port_i,
                                                                                         C_MY_WPORT));
          UPDATE_DEBUG1( 78 + C_MY_WPORT - 1 downto  78)  <= std_logic_vector(to_unsigned(update_port_wr,
                                                                                         C_MY_WPORT));
          UPDATE_DEBUG1(                             80)  <= update_read_done_i;
          UPDATE_DEBUG1(                             81)  <= update_write_done_i;
          
          -- Update signals (to Frontend).
          UPDATE_DEBUG1( 82 + C_MY_PORTS - 1 downto  82)  <= fit_vec(update_read_data_valid_ii, C_MY_PORTS);
          UPDATE_DEBUG1(                             86)  <= update_read_data_last_i;
          UPDATE_DEBUG1( 87 + 4          - 1 downto  87)  <= update_read_data_resp_i;
          UPDATE_DEBUG1( 91 + C_MY_PORTS - 1 downto  91)  <= fit_vec(update_read_data_ready, C_MY_PORTS);
          
          -- Write Miss
          UPDATE_DEBUG1( 95 + C_MY_PORTS - 1 downto  95)  <= fit_vec(update_write_data_ready_i, C_MY_PORTS);
          
          -- Write response
          UPDATE_DEBUG1(                             99)  <= update_wr_resp_port_pop;
          UPDATE_DEBUG1(                            100)  <= backend_wr_resp_pop;
          UPDATE_DEBUG1(                            101)  <= backend_wr_resp_wma_pop;
          UPDATE_DEBUG1(                            102)  <= wm_allow;
          UPDATE_DEBUG1(                            103)  <= update_evict_failed;
          UPDATE_DEBUG1(                            104)  <= update_evict_whl;
          UPDATE_DEBUG1(                            105)  <= update_evict_cancelled;
          UPDATE_DEBUG1(                            106)  <= '0';
          UPDATE_DEBUG1(                            107)  <= '0';
          
          -- Write miss response
          UPDATE_DEBUG1(108 + C_MY_PORTS - 1 downto 108)  <= fit_vec(update_ext_bresp_valid_i, C_MY_PORTS);
          UPDATE_DEBUG1(112 + 2          - 1 downto 112)  <= backend_wr_resp_info.BRESP; -- update_ext_bresp;
          UPDATE_DEBUG1(114 + C_MY_PORTS - 1 downto 114)  <= fit_vec(update_ext_bresp_ready, C_MY_PORTS);
          
          -- Update signals (to Lookup).
          UPDATE_DEBUG1(                            118)  <= update_tag_conflict_i;
          UPDATE_DEBUG1(                            119)  <= update_piperun_i;
          UPDATE_DEBUG1(                            120)  <= wm_fifo_full; -- update_write_miss_full;
          UPDATE_DEBUG1(121 + C_MY_PORTS - 1 downto 121)  <= fit_vec(update_write_miss_busy_i, C_MY_PORTS);
          
          -- Update signals (to Tag & Data).
          UPDATE_DEBUG1(125 + C_MY_TLINE - 1 downto 125)  <= update_tag_addr_i(C_ADDR_FULL_LINE_LO + C_MY_TLINE - 1 downto 
                                                                              C_ADDR_FULL_LINE_LO);
          UPDATE_DEBUG1(135 + C_MY_HOTWAY- 1 downto 135)  <= update_tag_we_i(C_MY_HOTWAY - 1 downto 0);
--          UPDATE_DEBUG1(137 + C_MY_TAG   - 1 downto 137)  <= update_new_tag(C_MY_TAG - 1 downto 0); 
--                                                            -- update_tag_new_word;
--          UPDATE_DEBUG1(155 + C_MY_TAG   - 1 downto 155)  <= update_readback_tag(C_MY_TAG - 1 downto 0); 
--                                                            -- update_tag_current_word_i(0)(C_MY_TAG - 1 downto 0);
          
          UPDATE_DEBUG1(173 + C_MY_DLINE - 1 downto 173)  <= update_data_addr_i(C_ADDR_EXT_DATA_LO + C_MY_DLINE - 1 downto 
                                                                               C_ADDR_EXT_DATA_LO);
          UPDATE_DEBUG1(187 + C_MY_HOTWAY- 1 downto 187)  <= update_data_en_i(C_MY_HOTWAY - 1 downto 0);
          UPDATE_DEBUG1(                            189)  <= update_wr_cnt_en; -- update_data_we(0);
          
          -- Update signals (to Backend).
          UPDATE_DEBUG1(                            190)  <= read_req_valid_i;
          UPDATE_DEBUG1(                            191)  <= read_req_exclusive_i;
          UPDATE_DEBUG1(                            192)  <= read_req_kind_i;
          UPDATE_DEBUG1(                            193)  <= read_req_ready;
          
          UPDATE_DEBUG1(                            194)  <= write_req_valid_i;
          UPDATE_DEBUG1(                            195)  <= write_req_line_only_i;
          UPDATE_DEBUG1(                            196)  <= write_req_exclusive_i;
          UPDATE_DEBUG1(                            197)  <= write_req_kind_i;
          UPDATE_DEBUG1(                            198)  <= write_req_ready;
          
          UPDATE_DEBUG1(                            199)  <= write_data_valid_i;
          UPDATE_DEBUG1(                            200)  <= write_data_last_i;
          UPDATE_DEBUG1(                            201)  <= write_data_ready;
          UPDATE_DEBUG1(                            202)  <= write_data_almost_full;
          UPDATE_DEBUG1(                            203)  <= write_data_full;
          
          -- Detect Address Conflicts: 1+1 = 2
          UPDATE_DEBUG1(                            204)  <= '0';
          
          -- Update Pipeline Stage: Update: 31
          UPDATE_DEBUG1(                            205)  <= update_stall;
--          UPDATE_DEBUG1(206 + C_MY_WAY   - 1 downto 206)  <= update_cur_tag_way(C_MY_WAY - 1 downto 0);
          UPDATE_DEBUG1(                            208)  <= update_snoop_safe;
          UPDATE_DEBUG1(                            209)  <= update_need_bs;
          UPDATE_DEBUG1(                            210)  <= update_need_ar;
          UPDATE_DEBUG1(                            211)  <= update_need_aw;
          UPDATE_DEBUG1(                            212)  <= update_need_evict;
          UPDATE_DEBUG1(                            213)  <= update_need_tag_write;
          UPDATE_DEBUG1(                            214)  <= update_inserted_trans;
          UPDATE_DEBUG1(                            215)  <= update_done_bs;
          UPDATE_DEBUG1(                            216)  <= update_done_ar;
          UPDATE_DEBUG1(                            217)  <= update_done_aw;
          UPDATE_DEBUG1(                            218)  <= update_done_evict;
          UPDATE_DEBUG1(                            219)  <= update_done_tag_write;
          UPDATE_DEBUG1(                            220)  <= update_new_tag_reused;
          UPDATE_DEBUG1(                            221)  <= update_stall_bs;
          UPDATE_DEBUG1(                            222)  <= update_stall_ar;
          UPDATE_DEBUG1(                            223)  <= update_stall_aw;
          UPDATE_DEBUG1(                            224)  <= update_stall_evict;
          UPDATE_DEBUG1(                            225)  <= update_stall_tag_write;
          UPDATE_DEBUG1(                            226)  <= update_evict;
          UPDATE_DEBUG1(                            227)  <= update_tag_write_raw;
          UPDATE_DEBUG1(                            228)  <= update_tag_write;
          UPDATE_DEBUG1(                            229)  <= update_block_lookup;
          UPDATE_DEBUG1(                            230)  <= update_new_tag_valid;
          UPDATE_DEBUG1(                            231)  <= update_new_tag_locked;
          UPDATE_DEBUG1(                            232)  <= update_new_tag_dirty;
          
          -- Check Locked Tag
          UPDATE_DEBUG1(                            233)  <= update_readback_possible;
          UPDATE_DEBUG1(                            234)  <= update_readback_available;
          UPDATE_DEBUG1(                            235)  <= update_readback_done;
          UPDATE_DEBUG1(                            236)  <= update_locked_tag_match;
          UPDATE_DEBUG1(                            237)  <= update_locked_tag_is_dead;
          UPDATE_DEBUG1(                            238)  <= update_remove_locked;
          UPDATE_DEBUG1(                            239)  <= update_remove_locked_safe;
          UPDATE_DEBUG1(                            240)  <= update_word_cnt_almost_last;
          UPDATE_DEBUG1(                            241)  <= update_rb_pos_phase;
          UPDATE_DEBUG1(                            242)  <= update_first_word_safe;
          UPDATE_DEBUG1(                            243)  <= update_read_miss_safe;
          UPDATE_DEBUG1(                            244)  <= ri_evicted;
          
          -- Queue for Data Eviction (Read Miss Dirty and Evict)
          UPDATE_DEBUG2(                              0)  <= update_e_push;
          UPDATE_DEBUG2(                              1)  <= update_e_pop;
          UPDATE_DEBUG2(                              2)  <= lookup_wm_allocate;
          UPDATE_DEBUG2(  3 + C_MY_QCNT  - 1 downto   3)  <= fit_vec(e_read_fifo_addr, C_MY_QCNT);
          UPDATE_DEBUG2(                              7)  <= e_fifo_full;
          UPDATE_DEBUG2(                              8)  <= e_fifo_empty;
--          UPDATE_DEBUG2(  9 + C_MY_WAY   - 1 downto   9)  <= e_way(C_MY_WAY - 1 downto 0);
          
          UPDATE_DEBUG2( 11 + C_MY_LINE  - 1 downto  11)  <= e_offset(C_ADDR_FULL_LINE_LO + C_MY_LINE - 1 downto 
                                                                      C_ADDR_FULL_LINE_LO);
          
          -- Update Data Pointer
          UPDATE_DEBUG2(                             21)  <= update_rd_cnt_en;
          UPDATE_DEBUG2(                             22)  <= update_word_cnt_en;
          UPDATE_DEBUG2( 23 + C_MY_WORD  - 1 downto  23)  <= update_word_cnt(C_ADDR_EXT_WORD_LO + C_MY_WORD - 1 downto
                                                                             C_ADDR_EXT_WORD_LO);
          UPDATE_DEBUG2( 28 + C_MY_WORD  - 1 downto  28)  <= update_word_cnt_len(C_ADDR_EXT_WORD_LO + C_MY_WORD - 1 downto
                                                                                 C_ADDR_EXT_WORD_LO);
--          UPDATE_DEBUG2( 33 + C_MY_WAY   - 1 downto  33)  <= update_cur_data_way(C_MY_WAY - 1 downto 0);
          UPDATE_DEBUG2(                             35)  <= update_word_cnt_first;
          UPDATE_DEBUG2(                             36)  <= update_word_cnt_last;
          UPDATE_DEBUG2(                             37)  <= update_read_miss_start_ok;
          UPDATE_DEBUG2(                             38)  <= update_read_miss_start;
          UPDATE_DEBUG2(                             39)  <= update_evict_start;
          UPDATE_DEBUG2(                             40)  <= update_read_miss_stop;
          UPDATE_DEBUG2(                             41)  <= update_evict_stop;
          UPDATE_DEBUG2(                             42)  <= update_evict_ongoing;
          UPDATE_DEBUG2(                             43)  <= update_evict_busy;
          UPDATE_DEBUG2(                             44)  <= update_read_miss_ongoing;
          UPDATE_DEBUG2(                             45)  <= update_evict_valid;
          UPDATE_DEBUG2(                             46)  <= update_evict_last;
          UPDATE_DEBUG2(                             47)  <= write_data_full_d1;
          UPDATE_DEBUG2(                             48)  <= update_evict_stop_d1;
          UPDATE_DEBUG2(                             49)  <= update_read_miss_use_ok;
          UPDATE_DEBUG2(                             50)  <= update_read_miss_use_bypass;
          
          -- Queue for Write Extraction (Write Miss)
          UPDATE_DEBUG2(                             51)  <= update_wm_push;
          UPDATE_DEBUG2(                             52)  <= update_wm_pop_evict;
          UPDATE_DEBUG2(                             53)  <= update_wm_pop_normal;
          UPDATE_DEBUG2(                             54)  <= update_wm_pop;
          UPDATE_DEBUG2(                             55)  <= update_wm_pop_allocate;
          UPDATE_DEBUG2( 56 + C_MY_QCNT  - 1 downto  56)  <= fit_vec(wm_read_fifo_addr, C_MY_QCNT);
          UPDATE_DEBUG2(                             60)  <= update_info.Allocate;
          UPDATE_DEBUG2(                             61)  <= wm_fifo_full; 
          UPDATE_DEBUG2(                             62)  <= wm_fifo_almost_empty;
          UPDATE_DEBUG2(                             63)  <= wm_exist;
          UPDATE_DEBUG2(                             64)  <= wm_evict;
          UPDATE_DEBUG2(                             65)  <= wm_kind;
          UPDATE_DEBUG2(                             66)  <= update_use_write_word;
          UPDATE_DEBUG2(                             67)  <= update_write_miss_ongoing;
          UPDATE_DEBUG2(                             68)  <= update_ack_write_word; 
          UPDATE_DEBUG2(                             69)  <= update_wr_miss_valid; 
          UPDATE_DEBUG2(                             70)  <= update_wr_miss_last; 
          
          -- Write Size Conversion
          UPDATE_DEBUG2(                             71)  <= update_wr_miss_throttle; 
          UPDATE_DEBUG2(                             72)  <= update_wr_miss_rs_valid;
          UPDATE_DEBUG2(                             73)  <= update_wr_miss_rs_last;
          UPDATE_DEBUG2( 74 + C_MY_OFF   - 1 downto  74)  <= fit_vec(update_wr_offset, C_MY_OFF);
          
          -- Read Information Buffer
          UPDATE_DEBUG2(                             80)  <= ri_push;
          UPDATE_DEBUG2(                             81)  <= ri_pop;
          UPDATE_DEBUG2(                             82)  <= ri_merge;
          UPDATE_DEBUG2(                             83)  <= ri_refresh_reg;
          UPDATE_DEBUG2( 84 + C_MY_QCNT  - 1 downto  84)  <= fit_vec(ri_read_fifo_addr, C_MY_QCNT);
          UPDATE_DEBUG2(                             88)  <= ri_exist;
          UPDATE_DEBUG2( 89 + C_MY_WPORT - 1 downto  89)  <= std_logic_vector(to_unsigned(ri_port,
                                                                                          C_MY_WPORT));
          UPDATE_DEBUG2(                             93)  <= ri_kind;
          UPDATE_DEBUG2(                             94)  <= ri_allocate;
          
          -- Read Data Forwarding
          UPDATE_DEBUG2(                             95)  <= backend_rd_data_use;
          UPDATE_DEBUG2(                             96)  <= backend_rd_data_pop;
          UPDATE_DEBUG2(                             97)  <= update_read_forward_ready;
          UPDATE_DEBUG2(                             98)  <= update_read_resize_valid;
          UPDATE_DEBUG2(                             99)  <= bs_lookup;
          UPDATE_DEBUG2(                            100)  <= '0';
          UPDATE_DEBUG2(                            101)  <= update_read_resize_last;
          UPDATE_DEBUG2(102 + C_MY_WPORT - 1 downto 102)  <= std_logic_vector(to_unsigned(update_read_resize_port,
                                                                                          C_MY_WPORT));
          UPDATE_DEBUG2(                            104)  <= update_read_resize_kind;
          UPDATE_DEBUG2(105 + C_MY_LEN   - 1 downto 105)  <= fit_vec(update_read_resize_len, C_MY_LEN);
          UPDATE_DEBUG2(                            111)  <= update_read_resize_allocate;
          UPDATE_DEBUG2(                            112)  <= update_read_resize_used;
          UPDATE_DEBUG2(                            113)  <= update_read_resize_ready;
          
          -- Read Size Conversion
          UPDATE_DEBUG2(114 + C_MY_OFF   - 1 downto 114)  <= fit_vec(update_rd_offset, C_MY_OFF);
          UPDATE_DEBUG2(                            120)  <= update_readback_tag_en;
          UPDATE_DEBUG2(                            121)  <= '0';
          UPDATE_DEBUG2(                            122)  <= '0';
          UPDATE_DEBUG2(124                  downto 123)  <= fit_vec(wmad_bresp, 2);
          UPDATE_DEBUG2(                            125)  <= update_create_bresp;
          UPDATE_DEBUG2(126 + C_MY_LEN   - 1 downto 126)  <= fit_vec(update_rd_len, C_MY_LEN);
          UPDATE_DEBUG2(                            132)  <= update_read_resize_first;
          UPDATE_DEBUG2(                            133)  <= update_read_resize_finish;
          UPDATE_DEBUG2(                            134)  <= update_read_resize_selected;
          UPDATE_DEBUG2(                            135)  <= update_rd_wrap_ok;
          UPDATE_DEBUG2(                            136)  <= update_read_resize_sel_wrap;
          UPDATE_DEBUG2(                            137)  <= update_rd_incr_ok;
          UPDATE_DEBUG2(                            138)  <= update_rd_miss_th_incr;
          UPDATE_DEBUG2(                            139)  <= update_rd_miss_th_wrap;
          UPDATE_DEBUG2(                            140)  <= update_rd_miss_throttle;
          
          -- Write Response Handling
          UPDATE_DEBUG2(                            141)  <= update_bs_push;
          UPDATE_DEBUG2(                            142)  <= update_bs_pop;
          UPDATE_DEBUG2(143 + C_MY_QCNT  - 1 downto 143)  <= fit_vec(bs_read_fifo_addr, C_MY_QCNT);
          UPDATE_DEBUG2(                            147)  <= bs_fifo_full;
          UPDATE_DEBUG2(                            148)  <= bs_exist;
          UPDATE_DEBUG2(                            149)  <= update_readback_possible;
          UPDATE_DEBUG2(                            150)  <= update_word_cnt_almost_last;
          UPDATE_DEBUG2(                            151)  <= update_remove_locked_safe;
          UPDATE_DEBUG2(                            152)  <= backend_rd_data_info.Valid;
          UPDATE_DEBUG2(                            153)  <= backend_rd_data_info.Last;
          UPDATE_DEBUG2(                            154)  <= backend_rd_data_ready_i;
          UPDATE_DEBUG2(                            155)  <= update_readback_available;
          UPDATE_DEBUG2(                            156)  <= update_rb_pos_phase;
          UPDATE_DEBUG2(                            157)  <= update_first_word_safe;
          UPDATE_DEBUG2(                            158)  <= update_readback_allowed;
          UPDATE_DEBUG2(                            159)  <= update_read_miss_safe;
          UPDATE_DEBUG2(                            160)  <= ri_evicted;
          UPDATE_DEBUG2(                            161)  <= update_write_miss_dirty;
          UPDATE_DEBUG2(                            162)  <= update_allocate_write_miss;
          UPDATE_DEBUG2(                            163)  <= update_ext_bresp_any_raw;
          UPDATE_DEBUG2(                            164)  <= update_read_miss_wma_safe;
          UPDATE_DEBUG2(                            165)  <= update_wm_pop_evict_hold;
          UPDATE_DEBUG2(                            166)  <= update_wm_pop_normal_hold;
          UPDATE_DEBUG2(                            167)  <= wm_allocate;
          UPDATE_DEBUG2(                            168)  <= wm_local_wrap;
          UPDATE_DEBUG2(                            169)  <= update_ack_write_ext; 
          UPDATE_DEBUG2(                            170)  <= update_ack_write_alloc; 
          UPDATE_DEBUG2(                            171)  <= update_wr_miss_word_done; 
          UPDATE_DEBUG2(                            172)  <= update_wr_miss_restart_word;
          UPDATE_DEBUG2(                            173)  <= bp_fifo_full;              -- Was: backend_wr_resp_valid_hold;
          UPDATE_DEBUG2(                            174)  <= update_wr_resp_port_ready; -- Was: backend_wr_resp_port_ready;
          UPDATE_DEBUG2(                            175)  <= backend_wr_resp_wma_ready;
          UPDATE_DEBUG2(176                  downto 176)  <= std_logic_vector(to_unsigned(BS_SLAVE_ACTION_TYPE'pos(bs_slv), 1));
          UPDATE_DEBUG2(                            177)  <= backend_wr_resp_wma_valid; -- Was: update_ext_bresp_wma;
          UPDATE_DEBUG2(                            178)  <= backend_wr_resp_valid;     -- Was: update_ext_bresp_normal;
          UPDATE_DEBUG2(                            179)  <= update_ext_bresp_any;
          UPDATE_DEBUG2(                            180)  <= update_wma_insert_dummy;
          UPDATE_DEBUG2(                            181)  <= update_wma_select_port;
          UPDATE_DEBUG2(                            182)  <= update_wma_data_valid;
          UPDATE_DEBUG2(                            183)  <= update_wma_fifo_stall;
          UPDATE_DEBUG2(                            184)  <= update_wma_throttle;
          UPDATE_DEBUG2(                            185)  <= update_wma_last;
          UPDATE_DEBUG2(                            186)  <= wma_word_done;
          UPDATE_DEBUG2(                            187)  <= wma_word_done_d1;
          UPDATE_DEBUG2(                            188)  <= wma_push;
          UPDATE_DEBUG2(                            189)  <= wma_pop;
          UPDATE_DEBUG2(                            190)  <= wma_fifo_almost_full;
          UPDATE_DEBUG2(                            191)  <= wma_fifo_full;
          UPDATE_DEBUG2(                            192)  <= wma_fifo_empty;
          UPDATE_DEBUG2(                            193)  <= wma_last;
          UPDATE_DEBUG2(                            194)  <= wma_merge_done;
          UPDATE_DEBUG2(                            195)  <= wmad_push;
          UPDATE_DEBUG2(                            196)  <= wmad_pop;
          UPDATE_DEBUG2(                            197)  <= wmad_fifo_full;
          UPDATE_DEBUG2(                            198)  <= wmad_fifo_empty;
          UPDATE_DEBUG2(199 + C_MY_OFF   - 1 downto 199)  <= fit_vec(update_wr_next_word_addr, C_MY_OFF);
          UPDATE_DEBUG2(205 + C_MY_QCNT  - 1 downto 205)  <= fit_vec(wma_read_fifo_addr, C_MY_QCNT);
          UPDATE_DEBUG2(209 + C_MY_EXTBE - 1 downto 209)  <= fit_vec(update_wma_strb, C_MY_EXTBE);
          UPDATE_DEBUG2(213 + C_MY_EXTBE - 1 downto 213)  <= fit_vec(wma_strb, C_MY_EXTBE);
          UPDATE_DEBUG2(                            217)  <= backend_wr_resp_info.Valid;
          UPDATE_DEBUG2(                            218)  <= update_write_cancelled;
          UPDATE_DEBUG2(                            219)  <= backend_wr_resp_ready_i;
          UPDATE_DEBUG2(                            220)  <= ed_push;
          UPDATE_DEBUG2(                            221)  <= ed_pop;
          UPDATE_DEBUG2(                            222)  <= ed_fifo_full;
          UPDATE_DEBUG2(                            223)  <= ed_fifo_empty;
          UPDATE_DEBUG2(                            224)  <= ed_assert;
          UPDATE_DEBUG2(                            225)  <= update_tag_write_ignore;
          UPDATE_DEBUG2(                            226)  <= update_remove_locked_2nd_cycle;
          UPDATE_DEBUG2(                            227)  <= wma_done;
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_RI_QUEUE_ERROR)   <= ri_assert   when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_R_QUEUE_ERROR)    <= r_assert    when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_E_QUEUE_ERROR)    <= e_assert    when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_BS_QUEUE_ERROR)   <= bs_assert   when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_WM_QUEUE_ERROR)   <= wm_assert   when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_WMA_QUEUE_ERROR)  <= wma_assert  when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_WMAD_QUEUE_ERROR) <= wmad_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_NO_RI_INFO)       <= backend_rd_data_info.Valid and not ri_exist when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_NO_BS_INFO)       <= backend_wr_resp_info.Valid and not bs_exist when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_RI_QUEUE_ERROR)   /= '1' 
      report "Update: Erroneous handling of RI Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_R_QUEUE_ERROR)    /= '1' 
      report "Update: Erroneous handling of R Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_E_QUEUE_ERROR)    /= '1' 
      report "Update: Erroneous handling of E Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BS_QUEUE_ERROR)   /= '1' 
      report "Update: Erroneous handling of BS Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_WM_QUEUE_ERROR)   /= '1' 
      report "Update: Erroneous handling of WM Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_WMA_QUEUE_ERROR)  /= '1' 
      report "Update: Erroneous handling of WMA Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_WMAD_QUEUE_ERROR) /= '1' 
      report "Update: Erroneous handling of WMAD Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_NO_RI_INFO)       /= '1' 
      report "Update: No RI Information available when read data arrives."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_NO_BS_INFO)       /= '1' 
      report "Update: No BS Information available when write response arrives."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;



-------------------------------------------------------------------------------
-- sc_lookup.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_lookup.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_lookup.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


entity sc_lookup is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean:= false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_NUM_WAYS                : natural range  1 to    8      :=  2;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_SUPPORT_SNOOP_FILTER    : natural range  0 to    1      :=  0;
    C_KEEP_SHARED_WRITE       : natural range  0 to    1      :=  1;
    C_READ_ONLY_UNIQUE        : natural range  0 to    1      :=  0;
    C_READ_EXCLUSIVE_CLEAN    : natural range  0 to    1      :=  1;
    C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
    
    
    -- Data type and settings specific.
    C_TAG_SIZE                : natural range  3 to   63      := 15;
    C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_DATA_HI            : natural range  2 to   63      := 14;
    C_ADDR_DATA_LO            : natural range  2 to   63      :=  2;
    C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
    C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
    C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
    C_WAY_BIT_LO              : natural range  0 to    0      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- Access signals.
    
    access_valid              : in  std_logic;
    access_info               : in  ACCESS_TYPE;
    
    access_data_info          : in  DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : out READ_SOURCE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : in  STAT_RI_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    read_data_status          : in  STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    update_tag_conflict       : in  std_logic;
    update_piperun            : in  std_logic;
    
    update_write_miss_full    : in  std_logic;
    update_write_miss_busy    : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    update_allocate_conflict  : in  std_logic;
    update_allocate_error     : in  std_logic;
    
    update_error_freeze       : in  std_logic;
    update_error_evict_insert : in  std_logic;
    update_error_evict_way    : in  natural range C_NUM_WAYS - 1 downto 0;
    update_error_evict_info   : in  ACCESS_TYPE;
    update_error_wait         : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Access).
    
    lookup_piperun            : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Frontend).
    
    lookup_read_data_info     : out READ_HIT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    lookup_write_data_ready   : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Tag & Data).
    
    lookup_tag_addr           : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
    lookup_tag_en             : out std_logic;
    lookup_tag_we             : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
    lookup_tag_new_word       : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    lookup_tag_current_word   : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    
    lookup_data_addr          : out std_logic_vector(C_ADDR_DATA_HI downto C_ADDR_DATA_LO);
    lookup_data_en            : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
    lookup_data_we            : out std_logic_vector(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
    lookup_data_new_word      : out std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
    lookup_data_current_word  : in  AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Arbiter).
    
    lookup_read_done          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to LRU).
    
    -- Pipe control.
    lookup_fetch_piperun      : out std_logic;
    lookup_mem_piperun        : out std_logic;
    
    -- Peek LRU.
    lru_fetch_line_addr       : out std_logic_vector(C_ADDR_LINE_HI downto C_ADDR_LINE_LO);
    lru_check_next_way        : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
    lru_check_next_hot_way    : in  std_logic_vector(C_NUM_WAYS - 1 downto 0);
    
    -- Control LRU.
    lru_check_use_lru         : out std_logic;
    lru_check_line_addr       : out std_logic_vector(C_ADDR_LINE_HI downto C_ADDR_LINE_LO);
    lru_check_used_way        : out std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Update).
    
    lookup_new_addr           : out AXI_ADDR_TYPE;
    lookup_stall_addr         : out AXI_ADDR_TYPE;
    
    lookup_push_write_miss    : out std_logic;
    lookup_wm_allocate        : out std_logic;
    lookup_wm_evict           : out std_logic;
    lookup_wm_will_use        : out std_logic;
    lookup_wm_info            : out ACCESS_TYPE;
    lookup_wm_use_bits        : out std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
    lookup_wm_stp_bits        : out std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
    lookup_wm_allow_write     : out std_logic;
    lookup_wm_create          : out std_logic;
    
    update_valid              : out std_logic;
    update_way                : out natural range C_NUM_WAYS - 1 downto 0;
    update_info               : out ACCESS_TYPE;
    update_hit                : out std_logic;
    update_miss               : out std_logic;
    update_read_hit           : out std_logic;
    update_read_miss          : out std_logic;
    update_read_miss_dirty    : out std_logic;
    update_write_hit          : out std_logic;
    update_write_miss         : out std_logic;
    update_write_miss_dirty   : out std_logic;
    update_locked_write_hit   : out std_logic;
    update_locked_read_hit    : out std_logic;
    update_first_write_hit    : out std_logic;
    update_evict_hit          : out std_logic;
    update_exclusive_hit      : out std_logic;
    update_create_bresp       : out std_logic;
    update_early_bresp        : out std_logic;
    update_failed_allocation  : out std_logic;
    update_whl_rejected       : out std_logic;
    update_snoop_made_clean   : out std_logic;
    update_snoop_made_shared  : out std_logic;
    update_snoop_made_invalid : out std_logic;
    update_snoop_altered_delayed_txn : out std_logic;
    update_snoop_made_txn_clean      : out std_logic;
    update_snoop_made_txn_shared     : out std_logic;
    update_snoop_made_txn_invalid    : out std_logic;
    update_need_bs            : out std_logic;
    update_need_ar            : out std_logic;
    update_need_aw            : out std_logic;
    update_need_evict         : out std_logic;
    update_need_tag_write     : out std_logic;
    update_inserted_trans     : out std_logic;
    update_reused_tag         : out std_logic;
    update_old_tag            : out WAY_LINE_TAG_TYPE;
    update_refreshed_lru      : out std_logic;
    update_all_tags           : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    update_inserted_rd_done   : in  std_logic;
    update_inserted_ex_ok     : in  std_logic;
    update_inserted_wr_done   : in  std_logic;
    update_pushing_writeunique: in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    update_pushing_writeback  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    update_lock_release       : in  std_logic;
    update_lock_way           : in  natural range C_NUM_WAYS - 1 downto 0;
    update_release_tag        : in  WAY_LINE_TAG_TYPE;
    
    update_whl_pop            : in  std_logic;
    update_whl_exist          : out std_logic;
    update_whl_strb           : out std_logic_vector(C_CACHE_LINE_LENGTH * 32/8 - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Status signals (to Lookup).
    
    be_writeunique_inflight   : in  std_logic;
    be_writeback_inflight     : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Master Snoop Interface Signals.
    
    mst_snoop_fetch_piperun   : in  std_logic;
    mst_snoop_fetch_info      : in  MST_SNOOP_REQ_TYPE;
    mst_snoop_mem_piperun     : in  std_logic;
    mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
    mst_snoop_check_piperun   : in  std_logic;
    mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
    
    mst_core_fetch_hazard     : out RMST_SNOOP_HAZ_TYPE;
    mst_core_mem_hazard       : out RMST_SNOOP_HAZ_TYPE;
    mst_core_check_hazard     : out RMST_SNOOP_HAZ_TYPE;
    
    mst_snoop_sdr_empty       : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_lookup_done          : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    -- Number of Transactions
    stat_lu_opt_write_hit         : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss        : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss_dirty  : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_hit          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss         : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss_dirty   : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_write_hit  : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_read_hit   : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_first_write_hit   : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    
    stat_lu_gen_write_hit         : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss        : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss_dirty  : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_hit          : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss         : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss_dirty   : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_write_hit  : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_read_hit   : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_first_write_hit   : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    
    stat_lu_stall             : out STAT_POINT_TYPE;    -- Time per occurance
    stat_lu_fetch_stall       : out STAT_POINT_TYPE;    -- Time per occurance
    stat_lu_mem_stall         : out STAT_POINT_TYPE;    -- Time per occurance
    stat_lu_data_stall        : out STAT_POINT_TYPE;    -- Time per occurance
    stat_lu_data_hit_stall    : out STAT_POINT_TYPE;    -- Time per occurance
    stat_lu_data_miss_stall   : out STAT_POINT_TYPE;    -- Time per occurance
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    LOOKUP_DEBUG              : out MAX_DEBUG_TYPE
  );
end entity sc_lookup;

library IEEE;
use IEEE.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

architecture IMP of sc_lookup is

  -----------------------------------------------------------------------------
  -- Phases for Lookup:
  --  ______________   _____________   ______________
  -- | Lookup Fetch | | Lookup Mem  | | Lookup Check |
  -- |______________| |_____________| |______________|
  -- 
  -- Access is used directly in Lookup Addr.
  -- 
  -- Lookup Fetch:
  --   Address for TAG RAM input: new access or tag write address.
  --   
  -- Lookup Memory:
  --   Tag information available from BRAM, not much left of the timing budget 
  --   left to do any thing beside some pre decoding for Hit/Miss detection.
  --   
  -- Lookup Check:
  --   All TAG information available with good timing.
  -- 
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_MULTIPLE_HIT              : natural :=  0;
  constant C_ASSERT_FIFO_FULL_VIOLATION       : natural :=  1;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  2;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_INT_LEN                  : natural := 8;
  constant C_WAY_BITS                 : natural := Log2(C_NUM_WAYS);
  constant C_SINGLE_BEAT              : std_logic_vector(C_INT_LEN-1 downto 0) := (others=>'0');
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Data related.
  subtype C_TAG_POS                   is natural range C_TAG_SIZE - 1              downto 0;
  subtype C_BE_POS                    is natural range C_CACHE_DATA_WIDTH/8 - 1    downto 0;
  subtype C_DATA_POS                  is natural range C_CACHE_DATA_WIDTH - 1      downto 0;
  subtype C_CACHE_DATA_ADDR_POS       is natural range C_CACHE_DATA_ADDR_WIDTH - 1 downto 0;
  subtype TAG_TYPE                    is std_logic_vector(C_TAG_POS);
  subtype BE_TYPE                     is std_logic_vector(C_BE_POS);
  subtype DATA_TYPE                   is std_logic_vector(C_DATA_POS);
  
  -- Port related.
  subtype C_PORT_POS                  is rinteger range C_NUM_PORTS - 1 downto 0;
  subtype C_INT_PORT_POS              is rinteger range C_NUM_INTERNAL_PORTS - 1 downto 0;
  subtype PORT_TYPE                   is std_logic_vector(C_PORT_POS);
  subtype INT_PORT_TYPE               is std_logic_vector(C_INT_PORT_POS);
  type PORT_BE_TYPE                   is array(C_PORT_POS)     of BE_TYPE;
  type INT_PORT_BE_TYPE               is array(C_INT_PORT_POS) of BE_TYPE;
  type PORT_DATA_TYPE                 is array(C_PORT_POS)     of DATA_TYPE;
  type INT_PORT_DATA_TYPE             is array(C_INT_PORT_POS) of DATA_TYPE;
  
  -- Set related.
  subtype C_WAY_POS                   is natural range C_NUM_WAYS - 1          downto 0;
  subtype C_WAY_BIT_POS               is natural range C_WAY_BIT_HI            downto C_WAY_BIT_LO;
  
  subtype WAY_TYPE                    is std_logic_vector(C_WAY_POS);
  subtype WAY_BIT_TYPE                is std_logic_vector(C_WAY_BIT_POS);
  
  constant way_pos_one_vec            : WAY_TYPE := (others => '1');

  -- Line related.
  constant C_CACHE_LINE_WORDS         : integer:= 32 * C_CACHE_LINE_LENGTH / C_CACHE_DATA_WIDTH;
  subtype C_CACHE_WORD_POS            is natural range C_CACHE_LINE_WORDS - 1         downto 0;
  type CACHE_LINE_BE_TYPE             is array(C_CACHE_WORD_POS) of BE_TYPE;

  type WHL_FIFO_MEM_TYPE              is array(QUEUE_ADDR_POS)      of CACHE_LINE_BE_TYPE;
  constant C_NULL_WHL                 : CACHE_LINE_BE_TYPE          := (others=>(others=>'0'));
  
  -- Address related.
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI   downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  subtype C_ADDR_DATA_POS             is natural range C_ADDR_DATA_HI       downto C_ADDR_DATA_LO;
  subtype C_ADDR_TAG_POS              is natural range C_ADDR_TAG_HI        downto C_ADDR_TAG_LO;
  subtype C_ADDR_FULL_LINE_POS        is natural range C_ADDR_FULL_LINE_HI  downto C_ADDR_FULL_LINE_LO;
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_WORD_HI       downto C_ADDR_BYTE_LO;
  subtype C_ADDR_WORD_POS             is natural range C_ADDR_WORD_HI       downto C_ADDR_WORD_LO;
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_DIRECT_TYPE            is std_logic_vector(C_ADDR_DIRECT_POS);
  subtype ADDR_DATA_TYPE              is std_logic_vector(C_ADDR_DATA_POS);
  subtype ADDR_TAG_TYPE               is std_logic_vector(C_ADDR_TAG_POS);
  subtype ADDR_FULL_LINE_TYPE         is std_logic_vector(C_ADDR_FULL_LINE_POS);
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_WORD_TYPE              is std_logic_vector(C_ADDR_WORD_POS);
  
  -- Internal AXI derived.
  subtype C_INT_LEN_POS               is natural range C_INT_LEN - 1 downto 0;
  subtype INT_LEN_TYPE                is std_logic_vector(C_INT_LEN_POS);
  
  -- Ranges for TAG information parts.
  constant C_NUM_ADDR_TAG_BITS        : natural := C_TAG_SIZE - C_NUM_STATUS_BITS;
  
  constant C_ADDR_LINE_BITS           : natural := C_ADDR_LINE_HI - C_ADDR_LINE_LO + 1;
  
  subtype ID_TYPE                     is std_logic_vector(C_ID_WIDTH - 1 downto 0);
  
  type EX_MON_TYPE is record
    Valid             : std_logic;
    ID                : ID_TYPE;
    Addr              : ADDR_INTERNAL_TYPE;
    Prot              : AXI_PROT_TYPE;
  end record EX_MON_TYPE;
  
  type PORT_EX_MON_TYPE               is array(C_PORT_POS) of EX_MON_TYPE;
  
  constant C_NULL_EX_MON              : EX_MON_TYPE := (Valid=>'0', ID=>(others=>'0'), Addr=>(others=>'0'), 
                                                        Prot=>NULL_AXI_PROT);
  
  constant C_NATIVE_SIZE              : AXI_SIZE_TYPE   := int_to_std(Log2(C_EXTERNAL_DATA_WIDTH / 8), 
                                                                      AXI_SIZE_TYPE'length);
  constant C_NATIVE_LEN               : AXI_LENGTH_TYPE := int_to_std(32*C_CACHE_LINE_LENGTH/C_EXTERNAL_DATA_WIDTH - 1, 
                                                                      AXI_LENGTH_TYPE'length);
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_and_di is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      DI        : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_di;
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or_n;
  
  component carry_latch_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and;
  
  component carry_latch_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_or;
  
  component carry_select_and is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural
    );
    port (
      Carry_In  : in  std_logic;
      No        : in  natural range 0 to C_SIZE-1;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_Out : out std_logic
    );
  end component carry_select_and;
  
  component carry_select_and_n is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural
    );
    port (
      Carry_In  : in  std_logic;
      No        : in  natural range 0 to C_SIZE-1;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_Out : out std_logic
    );
  end component carry_select_and_n;
  
  component carry_select_or is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural
    );
    port (
      Carry_In  : in  std_logic;
      No        : in  natural range 0 to C_SIZE-1;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_Out : out std_logic
    );
  end component carry_select_or;
  
  component carry_select_or_n is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural
    );
    port (
      Carry_In  : in  std_logic;
      No        : in  natural range 0 to C_SIZE-1;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_Out : out std_logic
    );
  end component carry_select_or_n;
  
  component carry_vec_or is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_INPUTS  : natural;
      C_SIZE    : natural
    );
    port (
      Carry_IN  : in  std_logic;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_OUT : out std_logic
    );
  end component carry_vec_or;
  
  component carry_compare_const is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIGNALS : natural := 1;
      C_SIZE   : natural;
      B_Vec    : std_logic_vector);
    port (
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In  : in  std_logic;
      Carry_Out : out std_logic);
  end component carry_compare_const;
  
  component carry_compare is
    generic (
      C_KEEP   : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_SIZE    : natural
    );
    port (
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      B_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In  : in  std_logic;
      Carry_Out : out std_logic
    );
  end component carry_compare;
  
  component reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic_vector;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural;
      C_SIZE    : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
      Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
    );
  end component reg_ce;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  component sc_stat_event is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Probe Interface
      
      probe                     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
    
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_event;
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  signal read_data_hit_full         : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Lookup Pipeline Stage: Access
  
  signal lookup_piperun_pre1        : std_logic;
  signal lookup_piperun_i           : std_logic;
  
  
  -- ----------------------------------------
  -- Lookup pipe stage: Fetch
  
  signal lu_fetch_piperun_pre3      : std_logic;
  signal lu_fetch_piperun_pre2      : std_logic;
  signal lu_fetch_piperun_pre1      : std_logic;
  signal lu_fetch_piperun           : std_logic;
  signal lu_fetch_piperun_i         : std_logic;
  signal lu_fetch_valid             : std_logic;
  signal lu_fetch_stall             : std_logic;
  signal lu_fetch_info              : ACCESS_TYPE;
  signal lu_fetch_protect_conflict  : std_logic;
  signal lu_fetch_tag_addr          : ADDR_FULL_LINE_TYPE;
  signal lu_fetch_restart_or_lck_wr_conf  : std_logic;
  signal lu_fetch_force_way         : rinteger range 0 to C_NUM_WAYS - 1;
  
  
  -- ----------------------------------------
  -- Lookup pipe stage: Memory
  
  signal lu_mem_piperun_pre3        : std_logic;
  signal lu_mem_piperun_pre2        : std_logic;
  signal lu_mem_piperun_pre1        : std_logic;
  signal lu_mem_piperun             : std_logic;
  signal lu_mem_piperun_i           : std_logic;
  signal lu_mem_piperun_vec         : std_logic_vector(0 downto 0);
  signal lu_mem_piperun_or_conflict : std_logic;
  signal lu_mem_piperun_or_conf_vec : std_logic_vector(0 downto 0);
  signal lu_mem_valid               : std_logic;
  signal lu_mem_first_cycle         : std_logic;
  signal lu_mem_second_cycle        : std_logic;
  signal lu_mem_stall               : std_logic;
  signal lu_mem_info                : ACCESS_TYPE;
  signal lu_mem_protect_conflict    : std_logic;
  signal lu_mem_protect_conflict_d1 : std_logic;
  signal lu_mem_prot_conf_edge      : std_logic;
  signal lu_mem_tag_addr            : ADDR_FULL_LINE_TYPE;
  signal lu_mem_data_addr           : ADDR_DATA_TYPE;
  signal lu_mem_read_port           : C_PORT_POS;
  signal lu_mem_single_beat         : std_logic;
  signal lu_mem_write_alloc         : std_logic;
  signal lu_mem_match_addr          : std_logic;
  signal lu_mem_tag_check_valid     : std_logic;
  signal lu_mem_force_way           : C_WAY_POS;
  
  
  -- ----------------------------------------
  -- Lookup pipe stage: Check
  
  signal lu_check_piperun_pre1      : std_logic;
  signal lu_check_piperun_pre2      : std_logic;
  signal lu_check_piperun           : std_logic;
  signal lu_check_piperun_i         : std_logic;
  signal lu_check_valid_cmb         : std_logic;
  signal lu_check_valid             : std_logic;
  signal lu_check_first_cycle       : std_logic;
  signal lu_check_second_cycle      : std_logic;
  signal lu_check_done              : std_logic;
  signal lu_check_valid_delayed     : std_logic;
  signal lu_check_stall             : std_logic;
  signal lu_check_insert_stall      : std_logic;
  signal lu_check_info              : ACCESS_TYPE;
  signal lu_check_info_delayed      : ACCESS_TYPE;
  signal lookup_read_hit_d1         : std_logic;
  signal lookup_locked_read_hit_d1  : std_logic;
  signal lu_check_wait_for_update_cmb : std_logic;
  signal lu_check_wait_for_update   : std_logic;
  signal lu_check_wr_already_pushed : std_logic;
  signal lu_check_need_move2update  : std_logic;
  signal lu_check_keep_allocate     : std_logic;
  signal lu_check_possible_evict    : std_logic;
  signal lu_check_is_barrier        : std_logic;
  signal lu_check_create_bresp      : std_logic;
  signal lu_check_early_bresp       : std_logic;
  signal lu_check_keep_allocation   : std_logic;
  signal lu_check_drop_allocation   : std_logic;
  signal lu_check_dropped_by_snoop  : std_logic;
  signal lu_check_missed_by_snoop     : std_logic;
  signal lu_check_missed_by_snoop_raw : std_logic;
  signal lu_check_killed_by_snoop     : std_logic;
  signal lu_check_killed_by_snoop_raw : std_logic;
  signal lu_check_snoop_missing_hold  : std_logic;
  signal lu_check_snoop_missing_raw   : std_logic;
  signal lu_check_snoop_killing_hold  : std_logic;
  signal lu_check_snoop_killing_raw   : std_logic;
  signal lu_check_snoop_dropping_hold : std_logic;
  signal lu_check_snoop_dropping_raw  : std_logic;
  signal lu_check_tag_addr          : ADDR_FULL_LINE_TYPE;
  signal lu_check_data_addr         : ADDR_DATA_TYPE;
  signal lu_check_lru_way           : rinteger range 0 to C_NUM_WAYS - 1;
  signal lu_check_way               : rinteger range 0 to C_NUM_WAYS - 1;
  signal lu_check_protected_way     : rinteger range 0 to C_NUM_WAYS - 1;
  signal lu_check_old_tag_idx       : C_WAY_POS;
  signal lu_check_tag               : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
  signal lu_check_read_port         : rinteger range 0 to C_NUM_PORTS - 1; -- Change type due to NCSim issues.
  signal lu_check_single_beat       : std_logic;
  signal lu_check_multi_beat        : std_logic;
  signal lu_check_port_one_hot      : PORT_TYPE;
  signal lu_check_allow_write       : std_logic;
  signal lu_check_write_alloc       : std_logic;
  signal lu_check_read_info_done    : std_logic;
  signal lu_check_enable_wr_lru     : std_logic;
  signal lu_check_match_addr        : std_logic;
  signal lu_check_tag_check_valid   : std_logic;
  signal lookup_next_data_late      : std_logic;
  signal lookup_access_data_late    : std_logic;
  signal lookup_access_data_late_d1 : std_logic;
  signal lookup_protect_conflict    : std_logic;
  signal lookup_restart_mem         : std_logic;
  signal lookup_restart_mem_done    : std_logic;
  signal lookup_push_write_miss_i   : std_logic;
  signal lookup_wm_allocate_i       : std_logic;
  signal lookup_wm_evict_i          : std_logic;
  
  
  -- ----------------------------------------
  -- Virtual Lookup Pipeline Stage: Check Insert
  
  signal lu_chk_start_piperun       : std_logic;
  signal lu_chkins_piperun          : std_logic;
  signal lu_chkins_valid            : std_logic;
  signal lu_chkins_read_snoop       : AXI_ARSNOOP_TYPE;
  signal lu_chkins_write_snoop      : AXI_AWSNOOP_TYPE;
  signal lu_chkins_insert_complete  : std_logic;
  signal lu_chkins_insert_done      : std_logic;
  signal lu_chkins_prohibit_insert  : std_logic;
  signal need_insert_read_trans     : std_logic;
  signal need_insert_write_trans    : std_logic;
  
  
  -- ----------------------------------------
  -- Optimized WM
  
  signal wm_sel                     : std_logic;
  signal whne_sel                   : std_logic;
  signal lu_wm_no_barrier           : std_logic;
  signal lookup_miss_dirty_no_clean : std_logic;
  signal lookup_md_or_wm            : std_logic;
  signal lookup_md_or_wm_or_whne    : std_logic;
  signal lookup_md_or_wm_or_whne2   : std_logic;
  signal lookup_md_wm_whne_valid    : std_logic;
  signal lookup_push_write_miss_pre : std_logic;
  
  signal lookup_push_wm_edrop_raw   : std_logic;
  signal lookup_push_wm_early_drop  : std_logic;
  
  
  -- ----------------------------------------
  -- Detect Dirty Miss
  
  signal lru_md_way                 : rinteger range 0 to C_NUM_WAYS - 1;
  signal lru_dirty_bit              : std_logic;
  signal dirty_bit_miss             : std_logic;
  signal dirty_bit_miss_valid       : std_logic;
  signal lu_check_valid_vec         : WAY_TYPE;
  signal md_valid_qualified         : WAY_TYPE;
  signal md_valid_alloc_miss        : std_logic;
  signal dirty_miss_valid           : std_logic;
  signal md_hit_dirty               : WAY_TYPE;
  signal dirty_bit                  : std_logic;
  signal lu_check_info_evict_vec    : WAY_TYPE;
  signal md_valid_hit_miss          : WAY_TYPE;
  signal md_check_valid             : std_logic;
  signal dirty_bit_valid            : std_logic;
  signal lookup_miss_dirty_pre      : std_logic;
  
  
  -- ----------------------------------------
  -- Detect Protected Conflict
  
  signal lru_pc_way                 : rinteger range 0 to C_NUM_WAYS - 1;
  signal lru_protected_bit          : std_logic;
  signal protected_bit_miss         : std_logic;
  signal protected_bit_miss_valid   : std_logic;
  signal pc_valid_alloc_miss        : std_logic;
  signal protected_miss_valid       : std_logic;
  signal pc_hit_protected           : WAY_TYPE;
  signal protected_bit              : std_logic;
  signal lu_mem_protect_conflict_d1_vec : WAY_TYPE;
  signal pc_filter                  : WAY_TYPE;
  signal filtered_protection_bit    : std_logic;
  signal protect_shared_write       : std_logic;
  signal protection_with_coherency  : std_logic;
  
  
  -- ----------------------------------------
  -- Update Pipeline Stage
  
  signal update_valid_cmb           : std_logic;
  signal update_need_bs_cmb         : std_logic;
  signal update_need_ar_cmb         : std_logic;
  signal update_need_aw_cmb         : std_logic;
  signal update_need_evict_cmb      : std_logic;
  signal update_need_tag_write_cmb  : std_logic;
  signal update_valid_i             : std_logic;
  signal update_need_bs_i           : std_logic;
  signal update_need_ar_i           : std_logic;
  signal update_need_aw_i           : std_logic;
  signal update_need_evict_i        : std_logic;
  signal update_need_tag_write_i    : std_logic;
  
  
  -- ----------------------------------------
  -- Read Transaction Properties
  
  signal lookup_read_data_new_i     : std_logic;
  signal lookup_read_data_hit_i     : std_logic;
  signal lookup_read_done_i         : std_logic;
  signal lookup_read_done_vec       : PORT_TYPE;
  
  
  -- ----------------------------------------
  -- Exclusive Monitor
  
  signal lookup_exclusive_monitor   : PORT_EX_MON_TYPE;
  signal lu_mem_ex_mon_match        : PORT_TYPE;
  signal ex_mon_lost_by_reuse       : PORT_TYPE;
  signal ex_mon_lost_by_evict       : PORT_TYPE;
  signal ex_mon_mst_snoop_kill      : PORT_TYPE;
  signal lu_mem_ex_mon_hit          : std_logic;
  
  
  -- ----------------------------------------
  -- LRU Handling
  
  signal lru_check_use_lru_i        : std_logic;
  signal lookup_invalid_exist       : std_logic;
  signal lookup_first_invalid       : std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
  signal lookup_new_tag_assoc_way   : std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
  signal lru_tag_assoc_way          : std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
  
  
  -- ----------------------------------------
  -- Stall Detection 
  
  signal update_write_miss_true_busy  : INT_PORT_TYPE;
  signal lu_check_wait_for_update_vec : INT_PORT_TYPE;
  signal lookup_data_hit_pre_stall    : std_logic;
  signal lookup_data_hit_stall        : std_logic;
  signal lookup_push_wm_stall         : std_logic;
  signal lookup_data_miss_stall       : std_logic;
  
  signal lookup_other_write_stall     : std_logic;
  
  
  -- ----------------------------------------
  -- TAG Conflict 
  
  signal lu_mem_tag_conflict        : std_logic;
  signal lu_check_tag_conflict      : std_logic;
  signal lookup_tag_conflict        : std_logic;
  
  
  -- ----------------------------------------
  -- Data Offset Counter
  
  signal lookup_use_bits            : ADDR_OFFSET_TYPE;
  signal lookup_stp_bits            : ADDR_OFFSET_TYPE;
  signal lookup_kind                : std_logic;
  signal lookup_step_last           : std_logic;
  signal lookup_base_offset         : ADDR_OFFSET_TYPE;
  signal lookup_word_offset         : ADDR_OFFSET_TYPE;
  signal lookup_offset_len          : INT_LEN_TYPE;
  signal lookup_offset_len_cmb      : INT_LEN_TYPE;
  signal lookup_offset_len_cnt      : INT_LEN_TYPE;
  signal lookup_last_beat           : std_logic;
  signal lookup_next_is_last_beat   : std_logic;
  signal lookup_offset_first        : std_logic;
  signal lookup_force_first         : std_logic;
  signal lookup_offset_all_first    : std_logic;
  signal lookup_offset_last         : std_logic;
  signal lookup_offset_cnt          : ADDR_OFFSET_TYPE;
  signal lookup_offset_cnt_cmb      : ADDR_OFFSET_TYPE;
  signal lookup_data_stall          : std_logic;
  
  signal access_data_valid            : INT_PORT_TYPE;
  signal access_data_last             : INT_PORT_TYPE;
  signal access_data_valid_stall      : INT_PORT_TYPE;
  signal lu_check_info_wr_vec         : INT_PORT_TYPE;
  signal access_data_conflict_stall   : INT_PORT_TYPE;
  signal read_locked_vector           : WAY_TYPE;
  signal lu_check_info_wr_pspvec      : WAY_TYPE;
  signal lu_io_selected_full          : std_logic;
  signal lu_io_valid_read             : std_logic;
  signal lu_io_full_block_read        : std_logic;
  signal lu_io_write_blocked          : std_logic;
  signal lu_io_lud_stall_pipe         : std_logic;
  
  signal lookup_io_stall_carry        : std_logic;
  signal lookup_io_stall_carry_no_wait: std_logic;
  signal lookup_io_and_conflict_stall : std_logic;
  signal lookup_io_stall_hit_carry    : std_logic;
  signal lu_ds_no_last                : std_logic;
  signal lookup_io_no_transaction     : std_logic;
  signal lookup_io_stall_hit_carry_no_last : std_logic;
  signal lookup_io_wr_done_drop       : std_logic;
  signal lookup_io_valid_and_no_drop  : std_logic;
  signal lookup_io_stall_pre_valid    : std_logic;
  signal lookup_io_stall_valid        : std_logic;
  signal lookup_io_data_stall         : std_logic;
  
  
  signal lu_ds_last_beat_multi_start  : std_logic;
  signal lu_ds_last_beat_sel_first    : std_logic;
  signal lu_ds_last_beat_next_last_n  : std_logic;
  signal lu_ds_last_beat              : std_logic;
  signal lu_ds_lb_transaction_done    : std_logic;
  signal lu_ds_last_beat_no_wait      : std_logic;
  signal lu_ds_last_beat_all_tag_hit  : std_logic;
  signal lookup_ds_lb_no_transaction  : std_logic;
  signal lu_ds_last_beat_hit          : std_logic;
  signal lu_ds_last_beat_valid_hit    : std_logic;
  signal lu_ds_last_beat_valid        : std_logic;
  signal lu_ds_last_beat_rd_locked    : WAY_TYPE;
--  signal lu_ds_lb_delayed_restart     : std_logic;
  signal lu_ds_lb_delayed_restart_normal    : std_logic;
  signal lud_step_allow_read_step_normal    : std_logic;
--  signal lud_step_allow_read_step_conf      : std_logic;
  signal lu_ds_rs_miss                : std_logic;
  signal lu_ds_rs_read_valid          : std_logic;
  signal lu_ds_rs_read_miss           : std_logic;
  signal lu_ds_rs_new_valid           : std_logic;
  signal lu_ds_rs_new_read_no_rs      : std_logic;
  signal lu_ds_rs_valid_restart       : std_logic;
  signal lu_ds_rs_valid_mem_restart   : std_logic;
  signal lu_ds_rs_del_restart_no_rs   : std_logic;
  signal lu_ds_lb_delayed_restart_conflict  : std_logic;
  signal lu_ds_last_beat_stall_pre    : std_logic;
  signal lu_ds_last_beat_stall        : std_logic;
  
  
  -- ----------------------------------------
  -- Control Lookup TAG
  
  signal lookup_tag_addr_i          : ADDR_FULL_LINE_TYPE;
  signal lookup_tag_en_i            : std_logic;
  
  
  -- ----------------------------------------
  -- Control Lookup DATA
  
  signal lookup_data_addr_i         : ADDR_DATA_TYPE;
  signal lookup_data_en_sel         : WAY_TYPE;
  signal lookup_data_en_i           : WAY_TYPE;
  signal lookup_write_hit_valid_vec : BE_TYPE;
  signal lu_check_allow_write_vec   : BE_TYPE;
  signal lu_check_wait_for_update_bevec : BE_TYPE;
  signal lookup_data_we_i           : BE_TYPE;
  
  
  -- ----------------------------------------
  -- Control Lookup DATA
  
  signal lookup_data_sel_check_addr : std_logic;
  signal lu_mem_info_wr_vec         : WAY_TYPE;
  signal lu_check_info_wr_wayvec    : WAY_TYPE;
  signal lud_mem_waiting_for_pipe_vec : WAY_TYPE;
  signal lookup_data_en_read        : WAY_TYPE;
  signal lookup_data_en_write       : WAY_TYPE;
  signal lookup_data_en_any_write   : std_logic;
  signal lu_check_wait_for_update_pspvec : WAY_TYPE;
  signal need_insert_read_trans_vec : WAY_TYPE;
  signal lu_chkins_insert_done_vec  : WAY_TYPE;
  
  
  -- ----------------------------------------
  -- Cache Hit & Miss Detect (Mem)
  
  signal lu_mem_valid_or_conflict   : std_logic;
  signal lu_mem_cur_write           : std_logic;
  signal lu_mem_cur_force_hit       : std_logic;
  signal lu_mem_cur_force_hit_vec   : WAY_TYPE;
  signal lu_mem_cur_wr_allocate     : std_logic;
  signal lu_mem_cur_addr            : ADDR_TAG_TYPE;
  signal lu_mem_cur_secure          : std_logic;
  signal lu_mem_valid_carry         : WAY_TYPE;
  signal lu_mem_pre_pure_valid_tag  : WAY_TYPE;
  signal lu_mem_pure_valid_tag      : WAY_TYPE;
  signal lu_mem_masked_valid_tag    : WAY_TYPE;
  signal lu_mem_valid_tag           : WAY_TYPE;
  signal lu_mem_tag_hit             : WAY_TYPE;
  signal lu_mem_tag_hit_copy_pc     : WAY_TYPE;
  signal lu_mem_tag_hit_copy_md     : WAY_TYPE;
  signal lu_mem_tag_hit_copy_wm     : WAY_TYPE;
  signal lu_mem_tag_hit_copy_ds     : WAY_TYPE;
  signal lu_mem_tag_hit_copy_lb     : WAY_TYPE;
  signal lu_mem_tag_hit_copy_rs     : WAY_TYPE;
  signal lu_mem_tag_miss            : WAY_TYPE;
  signal lu_mem_sel_locked          : WAY_TYPE;
  signal lu_mem_locked_hit          : WAY_TYPE;
  signal lu_mem_locked_hit_copy_lb  : WAY_TYPE;
  signal lu_mem_locked_write        : WAY_TYPE;
  signal lu_mem_valid_protect       : WAY_TYPE;
  signal lu_mem_other_protect       : WAY_TYPE;
  signal lu_mem_mst_protect         : WAY_TYPE;
  signal lu_mem_protected_pre1      : WAY_TYPE;
  signal lu_mem_protected_pre2      : WAY_TYPE;
  signal lu_mem_protected           : WAY_TYPE;
  signal lu_mem_valid_bits          : WAY_TYPE;
  signal lu_mem_reused_bits         : WAY_TYPE;
  signal lu_mem_dirty_bits          : WAY_TYPE;
  signal lu_mem_locked_bits         : WAY_TYPE;
  signal lu_mem_unique_bits         : WAY_TYPE;
  signal lu_mem_secure_bits         : WAY_TYPE;
  signal lu_mem_force_valid         : WAY_TYPE;
  
  signal lu_mem_update_line_match   : std_logic;
  signal lu_mem_update_data_match   : std_logic;
  signal lu_mem_releasing_lock      : WAY_TYPE;
  signal lu_mem_removing_way        : WAY_TYPE;
  signal lu_mem_making_unique       : WAY_TYPE;
  signal lu_mem_release_lock_hold   : WAY_TYPE;
  signal lu_mem_removed_way_hold    : WAY_TYPE;
  signal lu_mem_made_unique_hold    : WAY_TYPE;
  signal lu_mem_released_lock       : WAY_TYPE;
  signal lu_mem_removed_way         : WAY_TYPE;
  signal lu_mem_made_unique         : WAY_TYPE;
  
  signal lu_check_update_line_match : std_logic;
  signal lu_check_update_data_match : std_logic;
  signal lu_check_releasing_lock    : WAY_TYPE;
  signal lu_check_removing_way      : WAY_TYPE;
  signal lu_check_making_unique     : WAY_TYPE;
  signal lu_check_release_lock_hold : WAY_TYPE;
  signal lu_check_removed_way_hold  : WAY_TYPE;
  signal lu_check_made_unique_hold  : WAY_TYPE;
  signal lu_check_released_lock     : WAY_TYPE;
  signal lu_check_removed_way       : WAY_TYPE;
  signal lu_check_made_unique       : WAY_TYPE;
  
  
  -- ----------------------------------------
  -- Cache Hit & Miss Detect (Check)
  
  signal lu_check_valid_tag         : WAY_TYPE;
  signal lu_check_tag_hit           : WAY_TYPE;
  signal lu_check_tag_hit_copy_pc   : WAY_TYPE;
  signal lu_check_tag_hit_copy_md   : WAY_TYPE;
  signal lu_check_tag_hit_copy_wm   : WAY_TYPE;
  signal lu_check_tag_hit_copy_ds   : WAY_TYPE;
  signal lu_check_tag_hit_copy_lb   : WAY_TYPE;
  signal lu_check_tag_hit_copy_rs   : WAY_TYPE;
  signal lu_check_tag_miss          : WAY_TYPE;
  signal lu_check_locked_hit_copy_lb : WAY_TYPE;
  signal lu_check_locked_hit        : WAY_TYPE;
  signal lu_check_locked_write      : WAY_TYPE;
  signal lu_check_protected         : WAY_TYPE;
  signal lu_check_valid_bits        : WAY_TYPE;
  signal lu_check_reused_bits_cmb   : WAY_TYPE;
  signal lu_check_dirty_bits_cmb    : WAY_TYPE;
  signal lu_check_locked_bits_cmb   : WAY_TYPE;
  signal lu_check_unique_bits_cmb   : WAY_TYPE;
  signal lu_check_secure_bits_cmb   : WAY_TYPE;
  signal lu_check_reused_bits       : WAY_TYPE;
  signal lu_check_dirty_bits        : WAY_TYPE;
  signal lu_check_locked_bits       : WAY_TYPE;
  signal lu_check_unique_bits       : WAY_TYPE;
  signal lu_check_secure_bits       : WAY_TYPE;
  signal lu_check_tag_hit_all       : std_logic;
  signal lu_check_tag_hit_all_copy_ds  : std_logic;
  signal lu_check_tag_miss_all      : std_logic;
  signal lookup_raw_hit             : std_logic;
  signal lookup_hit                 : std_logic;
  signal lookup_raw_miss            : std_logic;
  signal lookup_miss                : std_logic;
  signal lookup_miss_dirty          : std_logic;
  signal lookup_evict_hit           : std_logic;
  signal lookup_read_hit            : std_logic;
  signal lookup_read_miss           : std_logic;
  signal lookup_read_miss_dirty     : std_logic;
  signal lookup_write_hit           : std_logic;
  signal lookup_locked_wr_hit_raw   : std_logic;
  signal lookup_locked_write_hit    : std_logic;
  signal lookup_locked_read_hit     : std_logic;
  signal lookup_true_locked_read    : std_logic;
  signal lookup_block_reuse         : std_logic;
  signal lookup_first_write_hit     : std_logic;
  signal lookup_write_miss          : std_logic;
  signal lookup_write_miss_dirty    : std_logic;
  signal lookup_tag_assoc_way       : std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
  

  -- ----------------------------------------
  -- Detect Write Hit
  
  signal lu_check_tag_hit_all_carry   : std_logic;
  signal lookup_raw_hit_carry2        : std_logic;
  signal write_hit_other_conflict     : std_logic;
  signal lookup_hit_carry             : std_logic;
  signal lookup_write_hit_carry       : std_logic;
  signal lookup_write_hit_no_busy     : std_logic;
  signal lookup_write_hit_no_conflict : std_logic;
  signal lookup_write_hit_valid       : std_logic;
  
  
  -- ----------------------------------------
  -- Read Data Forwarding
  
  signal lookup_read_data_valid_i   : PORT_TYPE;
  signal lookup_read_data_last_i    : std_logic;
  signal lookup_read_data_resp_i    : std_logic_vector(C_MAX_RRESP_WIDTH - 1 downto 0);
  signal lookup_read_data_word_i    : AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
  signal lookup_read_port           : C_PORT_POS;
  signal lookup_read_pipeline_port  : C_PORT_POS;
  signal lookup_read_stall_port     : C_PORT_POS;
  
  
  -- ----------------------------------------
  -- Data Pipeline Stage: Step (virtual stage)
  
  signal lud_step_use_check         : std_logic;
  signal lud_step_offset_is_read    : std_logic;
  signal lud_step_is_read           : std_logic;
  signal lud_step_write_port_num    : C_INT_PORT_POS;
  signal lud_step_allow_write_step  : std_logic;
  signal lud_step_allow_read_step   : std_logic;
  signal lud_step_offset            : std_logic;
  signal lud_step_stall             : std_logic;
  signal lud_step_pos_read_in_mem   : std_logic;
  signal lud_step_want_check_step   : std_logic;
  signal lud_step_want_mem_step     : std_logic;
  signal lud_step_want_restart      : std_logic;
  signal lud_step_delayed_restart   : std_logic;
  signal lud_step_unlock_rerun      : std_logic;
  signal lud_step_unlock_rerun_vec  : WAY_TYPE;
  signal lud_step_want_read_step    : std_logic;
  signal lud_step_want_write_step   : std_logic;
  signal lud_step_want_step_offset  : std_logic;
  signal lud_step_want_run          : std_logic;
  signal lud_step_want_stall        : std_logic;
  signal lookup_data_en_ii          : std_logic_vector(C_NUM_WAYS downto 0);
  
  
  -- ----------------------------------------
  -- Data Pipeline Stage: Address
  
  signal lud_addr_piperun_pre1      : std_logic;
  signal lud_addr_piperun_pre2      : std_logic;
  signal lud_addr_rerun_after_conf  : std_logic;
  signal lud_addr_piperun           : std_logic;
  signal lud_addr_stall             : std_logic;
  signal lud_addr_pipeline_full     : std_logic;
  
  signal lud_write_hit_done         : std_logic;
  
  
  -- ----------------------------------------
  -- Data Pipeline Stage: Memory
  
  signal lud_mem_piperun            : std_logic;
  signal lud_mem_speculative_valid  : std_logic;
  signal lud_mem_valid_pipe         : std_logic;
  signal lud_mem_valid              : std_logic;
  signal lud_mem_stall              : std_logic;
  signal lud_mem_rresp              : AXI_RRESP_TYPE;
  signal lud_mem_port_num           : C_PORT_POS;
  signal lud_mem_port_one_hot       : PORT_TYPE;
  signal lud_mem_completed          : std_logic;
  signal lud_mem_use_spec_cmb       : std_logic;
  signal lud_mem_use_speculative    : std_logic;
  signal lud_mem_last               : std_logic;
  signal lud_mem_delayed_read_data  : std_logic;
  signal lud_mem_way                : rinteger range 0 to C_NUM_WAYS - 1;
  signal lud_mem_way_d1             : natural range 0 to C_NUM_WAYS - 1;
  signal lud_mem_conflict           : std_logic;
  signal lud_mem_waiting_for_pipe   : std_logic;
  signal lud_mem_already_used       : std_logic;
  signal lud_mem_keep_single_during_stall : std_logic;
  
  
  -- ----------------------------------------
  -- Data Pipeline Stage: Pipeline
  
  signal lud_reg_piperun_pre1       : std_logic;
  signal lud_reg_piperun            : std_logic;
  signal lud_reg_valid              : std_logic;
  signal lud_mem_valid_vec          : PORT_TYPE;
  signal lud_reg_valid_one_hot      : PORT_TYPE;
  signal lud_reg_last               : std_logic;
  signal lud_reg_rresp              : AXI_RRESP_TYPE;
  signal lud_reg_port_num           : rinteger range 0 to C_NUM_PORTS - 1; -- Change type due to NCSim issues.
  
  
  -- ----------------------------------------
  -- Write Data Forwarding

  signal lookup_write_data_ready_vec : INT_PORT_TYPE;
  signal lookup_write_data_ready_i  : INT_PORT_TYPE;
  signal access_be_word_i           : BE_TYPE;
  signal lookup_data_new_word_i     : DATA_TYPE;
  signal lookup_write_port          : rinteger range 0 to C_NUM_INTERNAL_PORTS - 1; -- Change type due to NCSim issues.
  
  
  -- ----------------------------------------
  -- Master coherency
  
  signal lu_fetch_mst_fetch_stall   : std_logic;
  signal lu_fetch_mst_mem_stall     : std_logic;
  signal lu_fetch_mst_check_stall   : std_logic;
  
  signal lu_mem_snoop_tag_hit         : WAY_TYPE;
  signal lu_mem_snoop_tag_locked_hit  : WAY_TYPE;
  signal lu_mem_snoop_made_clean      : WAY_TYPE;
  signal lu_mem_snoop_made_shared     : WAY_TYPE;
  signal lu_mem_snoop_made_invalid    : WAY_TYPE;
  signal lu_mem_snoop_quick_halt      : std_logic;
  signal lu_mem_snoop_mst_fetch_stall : std_logic;
  signal lu_mem_snoop_mst_mem_stall   : std_logic;
  signal lu_mem_snoop_mst_check_stall : std_logic;
  signal lu_mem_snoop_mst_data_stall  : std_logic;
  signal lu_mem_snoop_line_match      : std_logic;
  signal lu_mem_snoop_active_cycle    : std_logic;
  
  signal lu_mem_writeunique_hazard_halt : std_logic;
  signal lu_mem_writeback_hazard_halt   : std_logic;
  
  signal lu_check_snoop_tag_hit         : WAY_TYPE;
  signal lu_check_snoop_tag_locked_hit  : WAY_TYPE;
  signal lu_check_snoop_made_clean      : WAY_TYPE;
  signal lu_check_snoop_made_shared     : WAY_TYPE;
  signal lu_check_snoop_made_invalid    : WAY_TYPE;
  signal lu_check_snoop_made_txn_clean  : std_logic;
  signal lu_check_snoop_made_txn_shared : std_logic;
  signal lu_check_snoop_made_txn_invalid: std_logic;
  signal mst_snoop_already_run          : std_logic;
  signal lu_check_snoop_quick_halt      : std_logic;
  signal lu_check_snoop_mst_fetch_stall : std_logic;
  signal lu_check_snoop_mst_mem_stall   : std_logic;
  signal lu_check_snoop_mst_check_stall : std_logic;
  signal lu_check_snoop_mst_data_stall  : std_logic;
  signal lu_check_snoop_line_match      : std_logic;
  signal lu_check_snoop_tag_match       : std_logic;
  signal lu_check_snoop_active_cycle    : std_logic;
  signal lu_check_write_no_permission   : std_logic;
  signal lu_check_write_permission      : std_logic;
  signal lu_check_snoop_reject_write    : std_logic;
  
  signal lu_check_writeback_hazard_halt : std_logic;
  signal lu_check_writeunique_hazard_halt : std_logic;
  
  signal lu_check_shared_force_miss : std_logic;
  signal lu_check_shared_force_drop : std_logic;
  signal lu_check_shared_force_kill : std_logic;
  
  signal lookup_unique_hit              : std_logic;
  
  
  -- ----------------------------------------
  -- Error handling
  
  signal lu_check_error_force_miss  : std_logic;
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
  -----------------------------------------------------------------------------
  -- Attributes
  -----------------------------------------------------------------------------
  
  
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- 
  -----------------------------------------------------------------------------
  
  Gen_Input_Rd_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    read_data_hit_full(I) <= read_data_status(I).Hit_Full;
    
  end generate Gen_Input_Rd_Array;
  Gen_Input_Wr_Array: for I in 0 to C_NUM_INTERNAL_PORTS - 1 generate
  begin
    access_data_valid(I)  <= access_data_info(I).Valid;
    access_data_last(I)   <= access_data_info(I).Last;
    
  end generate Gen_Input_Wr_Array;


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- New Access Handle 
  -----------------------------------------------------------------------------
  
  -- Select source of fetch.
  lu_fetch_info     <= access_info;
  
  
  -----------------------------------------------------------------------------
  -- Lookup Pipeline Stage: Access
  -- 
  -- Propagate Piperun signal when there
  -- are no tag address conflicts or other stalls prohibiting progress.
  -----------------------------------------------------------------------------
  
  
  -- Move this stage when there is no stall or there is a bubble to fill.
  lookup_piperun    <= lookup_piperun_i;
--  lookup_piperun_i  <= ( lu_fetch_piperun_i or not access_valid );
  LU_PR_Or_Inst1: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_fetch_piperun_i,
      A_N       => access_valid,
      Carry_OUT => lookup_piperun_i
    );
  
  
  -----------------------------------------------------------------------------
  -- Control Set Association
  -- 
  -- It possible to configure in one static modes:
  --  * Pure Parallel Association
  -- 
  -----------------------------------------------------------------------------
  
  
  -- Tag address part.
  lu_fetch_tag_addr     <= lu_fetch_info.Addr(C_ADDR_LINE_POS);
  
  -- Mark which way is selected by address for forcing.
  lu_fetch_force_way    <= to_integer(unsigned(lu_fetch_info.Addr(C_ADDR_TAG_LO + C_WAY_BITS - 1 downto 
                                                                  C_ADDR_TAG_LO)));
  
  -- Complete Set.
  lookup_tag_assoc_way  <= std_logic_vector(to_unsigned(lu_check_way, C_WAY_BITS));
  
  -- Always multiple parallel Ways.
  lu_check_lru_way      <= to_integer(unsigned(lru_check_next_way(C_WAY_BIT_POS)));
  
  -- Data address part.
  lu_mem_data_addr      <= lu_mem_tag_addr   & lookup_word_offset(C_ADDR_WORD_POS);
  lu_check_data_addr    <= lu_check_tag_addr & lookup_word_offset(C_ADDR_WORD_POS);
  
  
  -----------------------------------------------------------------------------
  -- Lookup Pipeline Stage: Fetch
  -- 
  -- Move transaction information to Memory stage when pipe is able to move.
  -- 
  -- Also maintain the Locked Write Hit bypass signals.
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall, there is a bubble to fill or previous next stage is flushed.
  -- Start with one padding to keep latch-as-logic in separate slices.
--  lu_fetch_piperun  <= ( lu_mem_piperun_i or not lu_mem_valid ) and not lu_fetch_stall;
  LU_Fetch_PR_And_Inst1: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_mem_piperun_i,
      A         => '1',
      Carry_OUT => lu_fetch_piperun_pre2
    );
  LU_Fetch_PR_Or_Inst2: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_fetch_piperun_pre2,
      A_N       => lu_mem_valid,
      Carry_OUT => lu_fetch_piperun_pre1
    );
  LU_Fetch_PR_And_Inst2: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_fetch_piperun_pre1,
      A_N       => lu_fetch_stall,
      Carry_OUT => lu_fetch_piperun
    );
  
  -- Stall Fetch stage if not ready.
  lu_fetch_stall    <= lookup_tag_conflict       or 
                       update_tag_conflict       or 
                       lu_fetch_protect_conflict or 
                       lookup_restart_mem        or
-- TODO: Separate carry input?
                       lu_fetch_mst_fetch_stall  or
                       lu_fetch_mst_mem_stall    or
                       lu_fetch_mst_check_stall;
  
  -- New access without conflicting stall.
  -- Locked Write enables Memory through other means.
  lu_fetch_valid    <= ( access_valid and not lu_fetch_stall );
  
  -- Propagate to next stage when possible.
  Pipeline_Stage_Mem_Valid : process (ACLK) is
  begin  -- process Pipeline_Stage_Mem_Valid
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_mem_valid    <= '0';
      else
        -- Forward Fetch to Memory if pipe can move, clear for move without new.
        if( lu_fetch_piperun = '1' ) then
          lu_mem_valid    <= lu_fetch_valid;
        elsif( lu_mem_piperun = '1' ) then
          lu_mem_valid    <= '0';
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Mem_Valid;
  
  Pipeline_Stage_Mem_First_Cycle : process (ACLK) is
  begin  -- process Pipeline_Stage_Mem_First_Cycle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_mem_first_cycle  <= '0';
        lu_mem_second_cycle <= '0';
      else
        if( lu_fetch_piperun = '1' ) then
          lu_mem_first_cycle  <= lu_fetch_valid;
        else
          lu_mem_first_cycle  <= '0';
        end if;
        
        if( lu_fetch_piperun = '1' ) then
          lu_mem_second_cycle <= '0';
        else
          lu_mem_second_cycle <= lu_mem_first_cycle;
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Mem_First_Cycle;
  
  Pipeline_Stage_Mem : process (ACLK) is
  begin  -- process Pipeline_Stage_Mem
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_mem_info           <= C_NULL_ACCESS;
        lu_mem_tag_addr       <= (others=>'0');
        lu_mem_single_beat    <= '0';
        lu_mem_force_way      <= 0;
        lu_mem_write_alloc    <= '0';
        
      else
        -- Forward Fetch to Memory if pipe can move, clear for move without new.
        if( lu_fetch_piperun = '1' ) then
          lu_mem_info           <= lu_fetch_info;
          lu_mem_tag_addr       <= lu_fetch_tag_addr;
          if( to_integer(unsigned(lu_fetch_info.Len(C_INT_LEN_POS))) = 0 ) then
            lu_mem_single_beat    <= '1';
          else
            lu_mem_single_beat    <= '0';
          end if;
          lu_mem_force_way      <= lu_fetch_force_way;
          lu_mem_write_alloc    <= lu_fetch_info.Wr and lu_fetch_info.Allocate;
          
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Mem;
  
  -- Assign Locked Write Hit signal for this stage.
  lu_fetch_protect_conflict <= lookup_protect_conflict;
  
  -- Propagate to next stage when possible.
  Pipeline_Stage_Mem_Tag : process (ACLK) is
  begin  -- process Pipeline_Stage_Mem_Tag
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_mem_protect_conflict     <= '0';
        lu_mem_protect_conflict_d1  <= '0';
        
      else
        lu_mem_protect_conflict     <= lu_fetch_protect_conflict;
        lu_mem_protect_conflict_d1  <= lu_mem_protect_conflict;
        
      end if;
    end if;
  end process Pipeline_Stage_Mem_Tag;
  
  
  -----------------------------------------------------------------------------
  -- Lookup Pipeline Stage: Memory
  -- 
  -- Move transaction information to Check when pipe is able to move, this
  -- includes the ordinary information and any pre-decoded Hit/Miss results.
  -- 
  -- Determine if the transaction in will be in Normal or Late state when it 
  -- reaches Check.
  -- 
  -- There is a bypass mode for the Hit/Miss pre-decoding to be able to detect
  -- when a Locked Write Hit has been resolved, i.e. when the Read Miss that
  -- caused the Lock has been stored in the Cache.
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  lu_mem_piperun  <= ( lu_check_piperun_i or lu_check_done or not lu_check_valid ) and 
--                     not lu_mem_stall;
  LU_Mem_PR_Or_Inst1: carry_or 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_check_piperun_i,
      A         => lu_check_done,
      Carry_OUT => lu_mem_piperun_pre2
    );
  LU_Mem_PR_Or_Inst2: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_mem_piperun_pre2,
      A_N       => lu_check_valid,
      Carry_OUT => lu_mem_piperun_pre1
    );
  LU_Mem_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_mem_piperun_pre1,
      A_N       => lu_mem_stall,
      Carry_OUT => lu_mem_piperun
    );
  
  -- Generate new control set for write conflict handling.
--  lu_mem_piperun_or_conflict <= lu_mem_piperun or lu_mem_protect_conflict;
  LU_Mem_PR_Latch_Inst1: carry_latch_or
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => lu_mem_piperun,
      A         => lu_mem_protect_conflict,
      O         => lu_mem_piperun_or_conflict,
      Carry_OUT => lu_mem_piperun_i
    );
  
  -- Stall Memory stage if not ready.
  lu_mem_stall    <= lookup_restart_mem             or 
-- TODO: Separate carry input?
                     lu_mem_snoop_quick_halt        or
                     lu_mem_snoop_mst_fetch_stall   or
                     lu_mem_snoop_mst_mem_stall     or
                     lu_mem_snoop_mst_check_stall   or
                     lu_mem_snoop_mst_data_stall    or
                     lu_mem_writeunique_hazard_halt or
                     lu_mem_writeback_hazard_halt   or
                     ( lu_mem_valid and not lu_mem_info.Wr and
                       ( read_info_status(lu_mem_read_port).Almost_Full or 
                         read_info_status(lu_mem_read_port).Full ) );
  
  -- Evaluate if next valid will be late or not.
  lookup_next_data_late <= lu_mem_valid and 
                           ( lu_mem_info.Wr or 
                             ( not lud_step_want_mem_step and not lud_mem_waiting_for_pipe ) or
                             (     lud_step_want_mem_step and not lud_addr_piperun         ) );
  
  -- Propagate status to next stage when possible.
  Pipeline_Stage_Check_Valid : process (lu_mem_piperun, lu_mem_valid,
                                        lu_check_piperun, lu_check_done, lu_check_valid) is
  begin  -- process Pipeline_Stage_Check_Valid
    -- Forward Mem to Check if pipe can move, clear for move without new.
    if( lu_mem_piperun = '1' ) then
      lu_check_valid_cmb  <= lu_mem_valid;
    elsif( lu_check_piperun = '1' or lu_check_done = '1' ) then
      lu_check_valid_cmb  <= '0';
    else
      lu_check_valid_cmb  <= lu_check_valid;
    end if;
  end process Pipeline_Stage_Check_Valid;
  
  Chk_Valid_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => lu_check_valid_cmb,
      Q         => lu_check_valid
    );
  
  Pipeline_Stage_Check_First_Cycle : process (ACLK) is
  begin  -- process Pipeline_Stage_Check_First_Cycle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_first_cycle  <= '0';
        lu_check_second_cycle <= '0';
      else
        if( lu_mem_piperun = '1' ) then
          lu_check_first_cycle  <= lu_mem_valid;
        else
          lu_check_first_cycle  <= '0';
        end if;
        
        if( lu_mem_piperun = '1' ) then
          lu_check_second_cycle <= '0';
        else
          lu_check_second_cycle <= lu_check_first_cycle;
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Check_First_Cycle;
  
  Pipeline_Stage_Check : process (ACLK) is
  begin  -- process Pipeline_Stage_Check
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_info           <= C_NULL_ACCESS;
        lu_check_tag_addr       <= (others=>'0');
        lu_check_single_beat    <= '0';
        lu_check_multi_beat     <= '1';
        lu_check_port_one_hot   <= (others=>'0');
        lu_check_allow_write    <= '0';
        lu_check_write_alloc    <= '0';
        lu_check_missed_by_snoop_raw  <= '0';
        lu_check_killed_by_snoop_raw  <= '0';
        
      elsif( lu_mem_piperun = '1' ) then
        lu_check_info           <= lu_mem_info;
        lu_check_tag_addr       <= lu_mem_tag_addr;
        lu_check_single_beat    <= lu_mem_single_beat;
        lu_check_multi_beat     <= not lu_mem_single_beat;
        lu_check_port_one_hot   <= std_logic_vector(to_unsigned(2 ** lu_mem_read_port, C_NUM_PORTS));
        lu_check_allow_write    <= ( not lu_mem_info.Exclusive ) or
                                   ( lu_mem_info.Exclusive and lu_mem_ex_mon_hit ) ;
        lu_check_write_alloc    <= lu_mem_write_alloc;
-- TODO: Need to assign or remove?
        lu_check_missed_by_snoop_raw  <= '0';
        lu_check_killed_by_snoop_raw  <= '0';
        
      else
        -- Turn off write if Exclusive fails to get permission when Master Coherency
        -- is enabled. The write will terminate as usual, but the data is ignored. 
        if( ( lu_chkins_insert_complete = '1' ) and
            ( lu_check_info.Exclusive   = '1' ) and 
            ( update_inserted_ex_ok     = '0' ) and 
            is_mst_coherent(C_ENABLE_COHERENCY) ) then
          lu_check_allow_write    <= '0';

        end if;
      end if;
    end if;
  end process Pipeline_Stage_Check;
  
  lu_mem_piperun_vec    <= (0 downto 0=>lu_mem_piperun);
  lu_mem_prot_conf_edge <= lu_mem_protect_conflict and not lu_mem_protect_conflict_d1;
  
  Late_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '1',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => lu_mem_prot_conf_edge,
      CE        => lu_mem_piperun_vec,
      D         => lookup_next_data_late,
      Q         => lookup_access_data_late
    );
  
  -- Read Hit done handling (information sent but pipe stage still active).
  Pipeline_Check_Done_Handle : process (ACLK) is
  begin  -- process Pipeline_Check_Done_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_read_info_done <= '0';
      else
        if( lu_mem_piperun = '1' ) then
          lu_check_read_info_done <= '0';
          
        elsif( lookup_read_data_new_i = '1' ) then
          lu_check_read_info_done <= '1';
          
        end if;
      end if;
    end if;
  end process Pipeline_Check_Done_Handle;
  
  -- Modify TAG inforamation if required.
  lu_mem_piperun_or_conf_vec  <= (0 downto 0=>lu_mem_piperun_or_conflict);
  lu_mem_cur_force_hit_vec    <= (others => lu_mem_cur_force_hit);
  lu_check_reused_bits_cmb    <= lu_mem_reused_bits and not lu_mem_cur_force_hit_vec;
  lu_check_dirty_bits_cmb     <= lu_mem_dirty_bits  and not lu_mem_cur_force_hit_vec;
  lu_check_locked_bits_cmb    <= lu_mem_locked_bits and not lu_mem_cur_force_hit_vec;
  lu_check_unique_bits_cmb    <= lu_mem_unique_bits and not lu_mem_cur_force_hit_vec;
  lu_check_secure_bits_cmb    <= lu_mem_secure_bits and not lu_mem_cur_force_hit_vec;
  
  Par_Reuse_Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_WAY_POS=>'0'),
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => lu_mem_piperun_or_conf_vec,
      D         => lu_check_reused_bits_cmb,
      Q         => lu_check_reused_bits
    );
  Par_Dirty_Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_WAY_POS=>'0'),
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => lu_mem_piperun_or_conf_vec,
      D         => lu_check_dirty_bits_cmb,
      Q         => lu_check_dirty_bits
    );
  Par_Locked_Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_WAY_POS=>'0'),
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => lu_mem_piperun_or_conf_vec,
      D         => lu_check_locked_bits_cmb,
      Q         => lu_check_locked_bits
    );
  Par_Unique_Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_WAY_POS=>'0'),
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => lu_mem_piperun_or_conf_vec,
      D         => lu_check_unique_bits_cmb,
      Q         => lu_check_unique_bits
    );
  Par_Secure_Inst: reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_WAY_POS=>'0'),
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => lu_mem_piperun_or_conf_vec,
      D         => lu_check_secure_bits_cmb,
      Q         => lu_check_secure_bits
    );
  
  
  -- Move Tag information to next stage.
  Pipeline_Stage_Check_Tag : process (ACLK) is
  begin  -- process Pipeline_Stage_Check_Tag
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_valid_tag            <= (others=>'0');
        lu_check_tag_hit              <= (others=>'0');
        lu_check_tag_hit_copy_pc      <= (others=>'0');
        lu_check_tag_hit_copy_md      <= (others=>'0');
        lu_check_tag_hit_copy_wm      <= (others=>'0');
        lu_check_tag_hit_copy_ds      <= (others=>'0');
        lu_check_tag_hit_copy_lb      <= (others=>'0');
        lu_check_tag_hit_copy_rs      <= (others=>'0');
        lu_check_tag_miss             <= (others=>'0');
        lu_check_locked_hit           <= (others=>'0');
        lu_check_locked_hit_copy_lb   <= (others=>'0');
        lu_check_locked_write         <= (others=>'0');
        lu_check_protected            <= (others=>'0');
        lu_check_valid_bits           <= (others=>'0');
        lu_check_tag                  <= (others=>C_NULL_WAY_LINE_TAG);
      elsif( lu_mem_piperun_or_conflict = '1' ) then
        lu_check_valid_tag            <= lu_mem_valid_tag;
        lu_check_tag_hit              <= lu_mem_tag_hit;
        lu_check_tag_hit_copy_pc      <= lu_mem_tag_hit_copy_pc;
        lu_check_tag_hit_copy_md      <= lu_mem_tag_hit_copy_md;
        lu_check_tag_hit_copy_wm      <= lu_mem_tag_hit_copy_wm;
        lu_check_tag_hit_copy_ds      <= lu_mem_tag_hit_copy_ds;
        lu_check_tag_hit_copy_lb      <= lu_mem_tag_hit_copy_lb;
        lu_check_tag_hit_copy_rs      <= lu_mem_tag_hit_copy_rs;
        lu_check_tag_miss             <= lu_mem_tag_miss;
        lu_check_locked_hit           <= lu_mem_locked_hit;
        lu_check_locked_hit_copy_lb   <= lu_mem_locked_hit_copy_lb;
        lu_check_locked_write         <= lu_mem_locked_write;
        lu_check_protected            <= lu_mem_protected;
        lu_check_valid_bits           <= lu_mem_valid_bits;
        lu_check_tag                  <= lookup_tag_current_word;
      end if;
    end if;
  end process Pipeline_Stage_Check_Tag;
  
  Pipeline_Stage_Check_Protected : process (ACLK) is
  begin  -- process Pipeline_Stage_Check_Protected
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_protected_way  <= 0;
      elsif( lookup_protect_conflict = '1' ) then
        if( lookup_raw_hit = '1' ) then
          lu_check_protected_way  <= lu_check_way;
        else
          lu_check_protected_way  <= to_int(lookup_new_tag_assoc_way);
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Check_Protected;
  
  -- Port for current transaction.
  lu_mem_read_port        <= get_port_num(lu_mem_info.Port_Num, C_NUM_PORTS);
  
  
  -----------------------------------------------------------------------------
  -- Lookup Pipeline Stage: Check
  -- 
  -- During this pipeline stage will Read Hit and Write Hit data use the 
  -- selected way.
  -- 
  -- When all reading and writing to the Data memory on the Lookup port has 
  -- been completed will the transaction be forwarded to Update for any 
  -- scheduled Tag manipulation.
  -- 
  -- Read and Write Misses are also forwarded to the data related part of 
  -- Update to get the missing data from external memory or update the external 
  -- memory with the new data.
  -- 
  -- This Pipeline stage can be in two states: Normal or Late (delayed).
  --  * Normal is when the pipe is able to perform speculative read, i.e. first
  --    address phase in Mem stage.
  --  * Late is when all the address phases of the Data transactions are in 
  --    the Check stage (default for Write and read following Write without 
  --    bubble).
  -- 
  -- Some data structures needs to be delayed in order to support the Late 
  -- phase for Read.
  -- 
  -- A Locked Write Hit will stall Pipe and restart the next scheduled
  -- transaction.
  -- 
  -- Write miss information must be updated directly from Check Pipeline Stage
  -- or a conflicting write from the same port can slip pass.
  -- A Read Miss Dirty is also written to the Write Miss Queue in order to 
  -- synchronize eviction in the Write queues.
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  lu_check_piperun          <= ( lu_chk_start_piperun or not lu_chkins_valid ) and 
--                               not lu_check_stall and not lu_check_insert_stall;
  LU_Check_PR_Or_Inst1: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_chk_start_piperun,
      A_N       => lu_chkins_valid,
      Carry_OUT => lu_check_piperun_pre1
    );
  LU_Check_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_check_piperun_pre1,
      A_N       => lu_check_stall,
      Carry_OUT => lu_check_piperun_pre2
    );
  LU_Check_PR_And_Inst2: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lu_check_piperun_pre2,
      A_N       => lu_check_insert_stall,
      Carry_OUT => lu_check_piperun
    );
  
  -- Stall Check when 
  -- For timing purposes has part of the hit stall moved to data stall => only conflict remains.
  -- (they are still together in the original stall signal)
  lu_check_stall            <= lookup_data_stall       or 
                               lookup_protect_conflict or 
                               lookup_data_miss_stall  or
                               lookup_other_write_stall;
  lu_check_insert_stall     <= need_insert_read_trans  or
                               need_insert_write_trans or
                               update_error_freeze;
  
  -- Detect if current write transaction is being killed by a snoop request.
  lu_check_missed_by_snoop  <= lu_check_missed_by_snoop_raw or 
                               lu_check_snoop_missing_hold  or 
                               lu_check_snoop_missing_raw;
  lu_check_dropped_by_snoop <= lu_check_snoop_dropping_hold or 
                               lu_check_snoop_dropping_raw;
  lu_check_killed_by_snoop  <= lu_check_killed_by_snoop_raw or 
                               lu_check_snoop_killing_hold  or 
                               lu_check_snoop_killing_raw;
  
  -- Remember killing until pipeline moves.
  Hold_Snoop_Killing : process (ACLK) is
  begin  -- process Hold_Snoop_Killing
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_snoop_missing_hold   <= '0';
        lu_check_snoop_dropping_hold  <= '0';
        lu_check_snoop_killing_hold   <= '0';
      else
        if( lu_check_piperun = '1' ) then
          lu_check_snoop_missing_hold   <= '0';
          lu_check_snoop_killing_hold   <= '0';
          
        elsif( lu_check_snoop_missing_raw = '1' ) then
          lu_check_snoop_missing_hold   <= '1';
          lu_check_snoop_killing_hold   <= lu_check_snoop_killing_raw;
          
        end if;
        
        if( lu_check_piperun = '1' ) then
          lu_check_snoop_dropping_hold  <= '0';
          
        elsif( lu_check_snoop_dropping_raw = '1' ) then
          lu_check_snoop_dropping_hold  <= '1';
          
        end if;
        
      end if;
    end if;
  end process Hold_Snoop_Killing;

  -- Determine if this iteration is complete in Check.
  lu_check_done             <= not lu_check_need_move2update and not lu_check_stall;
  
  -- Determine if transactions needs to be moved to update.
  lu_check_need_move2update <= ( ( lookup_write_hit                              ) or 
                                 ( lookup_write_hit and not lu_check_early_bresp ) or 
                                 ( lookup_write_miss                             ) or 
                                 ( lookup_true_locked_read                       ) or 
                                 ( lookup_read_miss                              ) or
                                 ( lookup_evict_hit                              ) ) and 
                               not (     lu_check_info.KillHit                     and 
                                         lu_check_info.SnoopResponse               and 
                                     not lu_check_info.Evict                       ) and
                               not ( lu_check_is_barrier                           );
  
  -- Determine if the Allocate flag shall be kept when moving to Update.
  lu_check_keep_allocate    <= lu_check_info.Allocate and 
                               ( not lookup_true_locked_read    ) and 
                               ( not lookup_block_reuse         ) and
                               ( not lu_check_error_force_miss  ) and
                               ( not lu_check_shared_force_miss ) and
                               ( not lu_check_shared_force_drop );
  
  -- Determine if data shall be evicted from line.
  lu_check_possible_evict   <= ( lu_check_info.Evict or lu_check_keep_allocate ) and 
                               ( not lu_check_info.Ignore_Data );
  
  -- Determine if there has been an early BRESP.
  lu_check_is_barrier       <= '1' when ( lu_check_info.Barrier = C_BAR_MEMORY_BARRIER  ) or
                                        ( lu_check_info.Barrier = C_BAR_SYNCHRONIZATION ) else
                               '0';

  -- Make sure Early BRESP is not possible for Exclusive transactions when Master Coherent.
  lu_check_create_bresp     <= lu_check_keep_allocate 
                                                        when ( (     is_mst_coherent(C_ENABLE_COHERENCY)       ) and
                                                               (     lu_check_info.Exclusive             = '1' ) ) else
                               lu_check_keep_allocate and not lu_check_early_bresp;
  lu_check_early_bresp      <= lu_check_info.Early;
  lu_check_keep_allocation  <= lu_check_info.Keep         and not lu_check_shared_force_drop;
  lu_check_drop_allocation  <= lu_check_shared_force_drop or  not lu_check_info.Keep;
  
  -- Propagate status to next stage when possible.
  Pipeline_Stage_Update_Valid : process (lu_check_piperun, lu_check_need_move2update, lu_check_info, 
                                         lu_check_possible_evict, lu_check_keep_allocate, lu_check_early_bresp, 
                                         lookup_read_miss, lookup_read_miss_dirty, 
                                         lookup_write_miss, lookup_write_miss_dirty, 
                                         lookup_write_hit, lookup_first_write_hit, 
                                         lookup_true_locked_read, lookup_miss, lu_check_shared_force_miss,
                                         update_valid_i, update_need_bs_i, update_need_ar_i, update_need_aw_i, 
                                         update_need_evict_i, update_need_tag_write_i, update_piperun, 
                                         lu_chkins_piperun, need_insert_write_trans, need_insert_read_trans,
                                         lu_chkins_prohibit_insert, lu_check_keep_allocation, lu_check_create_bresp,
                                         update_error_evict_insert, lu_check_drop_allocation) is
  begin  -- process Pipeline_Stage_Update_Valid
    -- Forward Check to Update if pipe can move, clear for move without new.
    if( lu_check_piperun = '1' ) then
      update_valid_cmb          <= lu_check_need_move2update;
      
      update_need_bs_cmb        <= lu_check_need_move2update and 
                               ( ( lookup_read_miss_dirty  and     lu_check_possible_evict    ) or 
                                 ( lookup_write_miss       and not lu_check_early_bresp       ) or
                                 ( lookup_write_miss_dirty and     lu_check_keep_allocate     ) or 
                                 ( lookup_write_miss       and     lu_check_early_bresp       and
                                                               not lu_check_keep_allocate     ) or
                                 ( lookup_write_hit        and not lu_check_early_bresp       ) or
                                 ( lookup_write_hit        and     lu_check_drop_allocation   ) );
      update_need_ar_cmb        <= lu_check_need_move2update and 
                               ( ( lookup_read_miss                                           ) or 
                                 ( lookup_true_locked_read                                    ) or
                                 ( lookup_write_miss       and     lu_check_keep_allocate     ) );
      update_need_aw_cmb        <= lu_check_need_move2update and 
                               ( ( lookup_read_miss_dirty  and     lu_check_possible_evict    ) or 
                                 ( lookup_write_miss       and not lu_check_keep_allocate     ) or
                                 ( lookup_write_miss_dirty and     lu_check_keep_allocate     ) or 
                                 ( lookup_write_miss       and     lu_check_shared_force_miss ) or
                                 ( lookup_write_hit        and not lu_check_keep_allocation   ) );
      update_need_evict_cmb     <= lu_check_need_move2update and 
                               ( ( lookup_read_miss_dirty  and     lu_check_possible_evict    ) or
                                 ( lookup_write_miss_dirty and     lu_check_keep_allocate     ) or 
                                 ( lookup_write_hit        and not lu_check_keep_allocation   ) );
      update_need_tag_write_cmb <= lu_check_need_move2update and 
                               ( ( lu_check_info.Evict                                        ) or 
                                 ( lookup_first_write_hit                                     ) or 
                                 ( lookup_write_hit        and not lu_check_keep_allocation   ) or
                                 ( lookup_miss             and     lu_check_keep_allocate     ) );
      
    elsif( lu_chkins_piperun = '1' ) then
      update_valid_cmb          <= ( ( need_insert_read_trans  or
                                       need_insert_write_trans ) and
                                     ( not lu_chkins_prohibit_insert ) ) or 
                                   update_error_evict_insert;
      update_need_bs_cmb        <= ( need_insert_write_trans and not lu_chkins_prohibit_insert ) or
                                   update_error_evict_insert;
      update_need_ar_cmb        <= need_insert_read_trans  and not lu_chkins_prohibit_insert;
      update_need_aw_cmb        <= ( need_insert_write_trans and not lu_chkins_prohibit_insert ) or
                                   update_error_evict_insert;
      update_need_evict_cmb     <= update_error_evict_insert;
      update_need_tag_write_cmb <= '0';
      
    elsif( update_piperun = '1' ) then
      update_valid_cmb          <= '0';
      update_need_bs_cmb        <= '0';
      update_need_ar_cmb        <= '0';
      update_need_aw_cmb        <= '0';
      update_need_evict_cmb     <= '0';
      update_need_tag_write_cmb <= '0';
      
    else
      update_valid_cmb          <= update_valid_i;
      update_need_bs_cmb        <= update_need_bs_i;
      update_need_ar_cmb        <= update_need_ar_i;
      update_need_aw_cmb        <= update_need_aw_i;
      update_need_evict_cmb     <= update_need_evict_i;
      update_need_tag_write_cmb <= update_need_tag_write_i;
      
    end if;
  end process Pipeline_Stage_Update_Valid;
  
  Ud_Valid_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_valid_cmb,
      Q         => update_valid_i
    );
    
  BS_Need_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_need_bs_cmb,
      Q         => update_need_bs_i
    );
    
  AR_Need_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_need_ar_cmb,
      Q         => update_need_ar_i
    );
    
  AW_Need_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_need_aw_cmb,
      Q         => update_need_aw_i
    );
    
  E_Need_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_need_evict_cmb,
      Q         => update_need_evict_i
    );
    
  TAG_Need_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => update_need_tag_write_cmb,
      Q         => update_need_tag_write_i
    );
  
  Pipeline_Stage_Update : process (ACLK) is
  begin  -- process Pipeline_Stage_Update
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        update_way                <= 0;
        update_info               <= C_NULL_ACCESS;
        update_hit                <= '0';
        update_miss               <= '0';
        update_read_hit           <= '0';
        update_read_miss          <= '0';
        update_read_miss_dirty    <= '0';
        update_write_hit          <= '0';
        update_write_miss         <= '0';
        update_write_miss_dirty   <= '0';
        update_locked_write_hit   <= '0';
        update_locked_read_hit    <= '0';
        update_first_write_hit    <= '0';
        update_evict_hit          <= '0';
        update_exclusive_hit      <= '0';
        update_create_bresp       <= '0';
        update_early_bresp        <= '0';
        update_failed_allocation  <= '0';
        update_whl_rejected       <= '0';
        update_snoop_made_clean   <= '0';
        update_snoop_made_shared  <= '0';
        update_snoop_made_invalid <= '0';
        update_reused_tag         <= '0';
        update_inserted_trans     <= '0';
        
      else
        -- Forward Check to Update if pipe can move, clear for move without new.
        if( lu_chkins_piperun = '1' ) then
          -- Default values.
          update_way                <= to_int(lru_tag_assoc_way);
          update_info               <= lu_check_info;
          update_info.Domain        <= C_DOMAIN_INNER_SHAREABLE;
          
          -- Patch transaction Information.
          if( need_insert_read_trans = '1'  ) then
            update_info.Wr            <= '0';
            update_info.Kind          <= C_KIND_INCR;
            update_info.Len           <= C_NATIVE_LEN;
            update_info.Size          <= C_NATIVE_SIZE;
            update_info.Snoop         <= fit_vec(lu_chkins_read_snoop,  AXI_SNOOP_TYPE'length);
            
          elsif( need_insert_write_trans = '1' ) then
            update_info.Wr            <= '1';
            update_info.Kind          <= C_KIND_INCR;
            update_info.Len           <= C_NATIVE_LEN;
            update_info.Size          <= C_NATIVE_SIZE;
            update_info.Snoop         <= fit_vec(lu_chkins_write_snoop, AXI_SNOOP_TYPE'length);
            
          elsif( lu_check_info.Wr = '1' ) then
            update_info.Snoop         <= fit_vec(lu_chkins_write_snoop, AXI_SNOOP_TYPE'length);
            
          else
            update_info.Snoop         <= fit_vec(lu_chkins_read_snoop,  AXI_SNOOP_TYPE'length);
            
          end if;
          
          if( ( lookup_true_locked_read = '1' ) or ( lookup_block_reuse = '1' ) ) then
            -- A Locked read hit is not allowed to update the cache because data is already on the way due to 
            -- earlier transactions.
            -- Or, cache line is being reused for another address, it is not allowed to allocate this line to other
            -- addresses until this has been solved (otherwise it might create a false temporary ownership
            -- if reused back to an earlier address, i.e. A-B-A miss scenario)
            update_info.Allocate      <= '0';
            
          end if;
          if( ( lookup_write_hit and not lu_check_keep_allocation ) = '1' ) then
            -- Set that this is a transaction that write back data (because it need external bresp). 
            -- If the allocate bit is asserted will the line be evicted instead. 
            update_info.Evict         <= '1';
            
          end if;
          if( s2b(lu_check_shared_force_miss) or 
              s2b(lu_check_shared_force_drop) or 
              s2b(lu_check_error_force_miss)  ) then
            -- A forced Miss cannot allocate.
            update_info.Allocate      <= '0';
          end if;
          if( s2b(lu_check_shared_force_drop) ) then
            update_info.Keep          <= '0';
          end if;
--          if( lu_check_killed_by_snoop = '1' ) then
--            -- Forcefully remove this line as it has been killed by a snoop.
--            update_info.Allocate      <= '0';
--            update_info.Evict         <= '1';
--          end if;
          if( ( lu_check_info.Wr        = '1' ) and 
              ( lu_check_info.Exclusive = '1' ) and 
              ( lu_check_allow_write    = '0' ) and 
              ( need_insert_read_trans  = '0' ) and 
              ( need_insert_write_trans = '0' ) ) then
            -- Failed Exclusive transaction will continue as a ordinary write with no valid data.
            update_info.Exclusive     <= '0';
          end if;
          update_hit                <= lookup_hit;
          update_miss               <= lookup_miss;
          update_read_hit           <= lookup_read_hit;
          update_read_miss          <= lookup_read_miss;
          update_read_miss_dirty    <= lookup_read_miss_dirty;
          update_write_hit          <= lookup_write_hit;
          update_write_miss         <= lookup_write_miss;
          update_write_miss_dirty   <= lookup_write_miss_dirty;
          update_locked_write_hit   <= lookup_locked_write_hit;
          update_locked_read_hit    <= lookup_true_locked_read;
          update_first_write_hit    <= lookup_first_write_hit;
          update_evict_hit          <= lookup_evict_hit;
          update_exclusive_hit      <= lu_check_info.Exclusive and lu_check_allow_write;
          update_create_bresp       <= lu_check_create_bresp;
          update_early_bresp        <= lu_check_early_bresp;
          update_failed_allocation  <= '0';
          update_whl_rejected       <= '0';
          if( ( ( lookup_read_miss = '1' ) or ( lookup_write_miss = '1' ) ) and 
              ( lu_check_valid_bits(lu_check_old_tag_idx)  = '1' ) and
              ( lu_check_locked_bits(lu_check_old_tag_idx) = '1' ) and
              ( lu_check_tag(lu_check_old_tag_idx).Addr(C_ADDR_TAG_POS) /= lu_check_info.Addr(C_ADDR_TAG_POS) ) ) then
            -- Reusing the cache line to another address will mark it as reused, this is to prevent fake ownership
            -- in the A-B-A reuse scenario.
            update_reused_tag         <= lu_check_info.Allocate;
          else
            update_reused_tag         <= '0';
          end if;
          update_inserted_trans     <= need_insert_read_trans    or
                                       need_insert_write_trans   or
                                       update_error_evict_insert;
          
          if( s2b(update_error_evict_insert) ) then
            -- Insert event to Evict data from broken WMA.
            update_way                <= update_error_evict_way;
            update_info               <= update_error_evict_info;
            update_failed_allocation  <= update_error_evict_insert;
            
          end if;
          if( s2b(lu_check_snoop_reject_write and not lu_check_shared_force_drop) ) then
            update_whl_rejected       <= '1';
          end if;
          
          update_snoop_made_clean   <= lu_check_snoop_made_clean(to_int(lru_tag_assoc_way));
          update_snoop_made_shared  <= lu_check_snoop_made_shared(to_int(lru_tag_assoc_way));
          update_snoop_made_invalid <= lu_check_snoop_made_invalid(to_int(lru_tag_assoc_way));
          
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Update;
  
  Pipeline_Stage_Mod_Update : process (ACLK) is
  begin  -- process Pipeline_Stage_Mod_Update
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        update_snoop_altered_delayed_txn  <= '0';
        update_snoop_made_txn_clean       <= '0';
        update_snoop_made_txn_shared      <= '0';
        update_snoop_made_txn_invalid     <= '0';
        mst_snoop_already_run             <= '0';
        
      else
        -- Tack Snoop pipeline movement, only need to modify the Update Tag info if
        -- Snoop moves at same time as Core Check or before.
        if( s2b(lu_chkins_piperun) ) then
          mst_snoop_already_run             <= '0';
        elsif( s2b(mst_snoop_fetch_piperun and lu_check_write_permission and lu_check_wait_for_update and lookup_write_hit) ) then
          mst_snoop_already_run             <= '1';
        end if;
      
        if( lu_chkins_piperun = '1' ) then
          -- If the current write has been snooped and the Tag update been delayed it is necessary to 
          -- modify the Tag according to the snoop effect. 
          -- Both Snoop response and the Tag is modified to accommodate for the time and order slip.
          update_snoop_altered_delayed_txn  <= lu_check_write_permission and
                                               lu_check_wait_for_update  and 
                                               lookup_write_hit          and
                                               ( mst_snoop_fetch_piperun or
                                                 mst_snoop_already_run   );
          
          -- A write has been completed, if this was the case when a snoop was delayed due to the write
          -- it might me necessary to alter the tag when it is able to proceed.
          update_snoop_made_txn_clean       <= lu_check_snoop_made_txn_clean;
          update_snoop_made_txn_shared      <= lu_check_snoop_made_txn_shared;
          update_snoop_made_txn_invalid     <= lu_check_snoop_made_txn_invalid;
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Mod_Update;
  
  -- Propagate that the LRU has been updated.
  Update_LRU_Refresh_Handle : process (ACLK) is
  begin  -- process Update_LRU_Refresh_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        update_refreshed_lru  <= '0';
        update_all_tags       <= (others=>C_NULL_WAY_LINE_TAG);
        
      else
        update_refreshed_lru  <= lru_check_use_lru_i;
        update_all_tags       <= lu_check_tag;
        
      end if;
    end if;
  end process Update_LRU_Refresh_Handle;
  
  -- Detect that Check completed but was unable to move because Update was stalling.
  Pipeline_Check_Complete_Handle : process (lu_check_piperun, lu_check_valid, lu_check_need_move2update, lu_check_stall, lu_check_wait_for_update) is
  begin  -- process Pipeline_Check_Complete_Handle
    if( lu_check_piperun = '1' ) then
      lu_check_wait_for_update_cmb  <= '0';
      
    elsif( ( lu_check_valid and lu_check_need_move2update and 
             not lu_check_stall ) = '1' ) then
      -- lu_check_stall prevents Update(/CheckInsert) piperun during inserting 
      -- transaction from being falsely detected.
      lu_check_wait_for_update_cmb  <= '1';
      
    else
      -- Keep old value.
      lu_check_wait_for_update_cmb  <= lu_check_wait_for_update;
      
    end if;
  end process Pipeline_Check_Complete_Handle;
  Pipeline_Check_Complete_DFF : process (ACLK) is
  begin  -- process Pipeline_Check_Complete_DFF
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_wait_for_update  <= '0';
        
      else
        lu_check_wait_for_update  <= lu_check_wait_for_update_cmb;
          
      end if;
    end if;
  end process Pipeline_Check_Complete_DFF;
  
  -- .
  Pipeline_Check_Push_Handle : process (ACLK) is
  begin  -- process Pipeline_Check_Push_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
          lu_check_wr_already_pushed  <= '0';
        
      else
        if( lu_check_piperun = '1' ) then
          lu_check_wr_already_pushed  <= '0';
          
        elsif( s2b(lookup_push_write_miss_i and not update_error_evict_insert) ) then
          lu_check_wr_already_pushed  <= '1';
          
        end if;
      end if;
    end if;
  end process Pipeline_Check_Push_Handle;
  
  -- Assign output.
  update_valid            <= update_valid_i;
  update_need_bs          <= update_need_bs_i;
  update_need_ar          <= update_need_ar_i;
  update_need_aw          <= update_need_aw_i;
  update_need_evict       <= update_need_evict_i;
  update_need_tag_write   <= update_need_tag_write_i;
  
  -- Get index for old Tag extraction.
  lu_check_old_tag_idx  <= to_integer(unsigned(lookup_tag_assoc_way)) when lookup_first_write_hit = '1' else 
                           to_integer(unsigned(lru_check_next_way));
  
  -- Get old Tag information.
  Pipeline_Stage_Old_Tag_Handle : process (ACLK) is
  begin  -- process Pipeline_Stage_Old_Tag_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        update_old_tag  <= C_NULL_WAY_LINE_TAG;
      else
        if( lu_chkins_piperun = '1' ) then
          update_old_tag  <= lu_check_tag(lu_check_old_tag_idx);
        end if;
      end if;
    end if;
  end process Pipeline_Stage_Old_Tag_Handle;
  
  -- Delay pipe status for late read handling.
  Pipeline_Stage_Check_Delayed : process (ACLK) is
  begin  -- process Pipeline_Stage_Check_Delayed
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lu_check_valid_delayed      <= '0';
        lu_check_info_delayed       <= C_NULL_ACCESS;
        lookup_read_hit_d1          <= '0';
        lookup_locked_read_hit_d1   <= '0';
        lookup_access_data_late_d1  <= '0';
      else
        lu_check_valid_delayed      <= lu_check_valid;
        lu_check_info_delayed       <= lu_check_info;
        lookup_read_hit_d1          <= lookup_read_hit;
        lookup_locked_read_hit_d1   <= lookup_locked_read_hit;
        lookup_access_data_late_d1  <= lookup_access_data_late;
      end if;
    end if;
  end process Pipeline_Stage_Check_Delayed;
  
  -- Make sure Mem is only refresed once.
  Handle_Mem_Restart : process (ACLK) is
  begin  -- process Handle_Mem_Restart
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lookup_restart_mem_done <= '0';
      else
        if( lu_mem_piperun = '1' ) then
          lookup_restart_mem_done <= '0';
        elsif( lookup_restart_mem = '1' ) then
          lookup_restart_mem_done <= '1';
        end if;
      end if;
    end if;
  end process Handle_Mem_Restart;
  
  -- Signal to restart Mem when Locked stall is solved, new tag is clean but earlier stage is still marked.
  lookup_restart_mem      <= lu_mem_protect_conflict and not lookup_protect_conflict and 
                             not lookup_restart_mem_done;
  
  -- Internal write signal to write miss queue.
--  lookup_push_write_miss_i  <= ( lookup_write_miss or ( lookup_miss_dirty not lu_check_info.Ignore_Data ) or 
--                                 lu_check_shared_force_miss or lu_check_error_force_miss or
--                                 ( lookup_write_hit and not lu_check_keep_allocation ) ) and
--                               not lookup_protect_conflict  and
--                               not lu_check_wait_for_update;
  LU_WM_And_Inst0: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_miss_dirty,
      A_N       => lu_check_info.Ignore_Data,
      Carry_OUT => lookup_miss_dirty_no_clean
    );
  
  wm_sel  <= lu_check_info.Wr and not reduce_or(lu_check_tag_hit_copy_wm);
  LU_WM_Or_Inst1: carry_or
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_miss_dirty_no_clean,
      A         => wm_sel,
      Carry_OUT => lookup_md_or_wm
    );
  
  whne_sel  <= lu_check_info.Wr and reduce_or(lu_check_tag_hit_copy_wm) and not lu_check_keep_allocation;
  LU_WM_Or_Inst2: carry_or
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_md_or_wm,
      A         => lu_check_shared_force_miss,
      Carry_OUT => lookup_md_or_wm_or_whne
    );
  
  LU_WM_Or_Inst3: carry_or
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_md_or_wm_or_whne,
      A         => lu_check_error_force_miss,
      Carry_OUT => lookup_md_or_wm_or_whne2
    );
  
  lu_wm_no_barrier <= lu_check_valid and not lu_check_is_barrier;
  LU_WM_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_md_or_wm_or_whne2,
      A         => lu_wm_no_barrier,
      Carry_OUT => lookup_md_wm_whne_valid
    );
  LU_WM_And_Inst2: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_md_wm_whne_valid,
      A_N       => lu_check_wait_for_update,
      Carry_OUT => lookup_push_write_miss_pre
    );
    
  lookup_push_wm_edrop_raw  <= lu_check_valid and whne_sel and not lu_check_wait_for_update;
  lookup_push_wm_early_drop <= lookup_push_wm_edrop_raw and not lookup_data_stall;
  
  lookup_push_write_miss_i  <= ( ( ( ( lookup_push_write_miss_pre       ) or 
                                     ( lookup_push_wm_early_drop        ) ) and
                                   ( not lookup_protect_conflict          ) ) or
                                 ( update_error_evict_insert                ) ) and
                               ( not update_write_miss_full                   ) and
                               ( not lu_check_wr_already_pushed               );
  
  -- Information to write miss queue.
  lookup_push_write_miss    <= lookup_push_write_miss_i;
  lookup_wm_allocate_i      <= lu_check_info.Wr and lu_check_info.Allocate and 
                               ( not lu_check_missed_by_snoop   ) and 
                               ( not lu_check_shared_force_drop ) and 
                               ( not lu_check_error_force_miss  ) and
                               ( not update_error_evict_insert  );
  lookup_wm_allocate        <= lookup_wm_allocate_i;
  lookup_wm_evict_i         <= lookup_miss_dirty or
                               ( update_error_evict_insert ) or 
                               ( lookup_write_hit and not lu_check_keep_allocation );
  lookup_wm_evict           <= lookup_wm_evict_i;
  lookup_wm_will_use        <= not ( lookup_write_hit and not lu_check_keep_allocation ) and
                               not ( lookup_evict_hit ) and
                               not ( update_error_evict_insert );
  lookup_wm_info            <= update_error_evict_info when s2b(update_error_evict_insert) else
                               lu_check_info;
  lookup_wm_use_bits        <= lu_check_info.Addr_Use(C_ADDR_OFFSET_POS);
  lookup_wm_stp_bits        <= lu_check_info.Addr_Stp(C_ADDR_OFFSET_POS);
  lookup_wm_allow_write     <= lu_check_allow_write and 
                               not lu_check_shared_force_kill;
  lookup_wm_create          <= lu_check_create_bresp;
  
  -- Port for current transaction.
  lu_check_read_port        <= get_port_num(lu_check_info.Port_Num, C_NUM_PORTS);
  
  
  -----------------------------------------------------------------------------
  -- Virtual Lookup Pipeline Stage: Check Insert
  -- 
  -- Handle insertion of transactions in order to handle Master ACE functions.
  -- The following cases need to be addressed for Write:
  --  * UniqueClean Write Hit,
  --  * UniqueDirty Write Hit       => No action, write immediately.
  --  
  --  * SharedClean Write Hit       => Discard cache Line and forward as WriteUnique
  --                                   If C_KEEP_SHARED_WRITE is asserted the behaviour is
  --                                   the same as SharedDirty Write Hit.
  --  
  --  * SharedDirty Write Hit       => Insert a CleanUnique and write data
  --  
  --  * Write Invalid Miss Allocate => Get Line with ReadUnique and merge in Update
  --                                   stage.
  -- 
  --  * Write Clean Miss Allocate   => If C_SUPPORT_SNOOP_FILTER is asserted a Evict transaction
  --                                   has to be used on AW for Line tracking.
  --                                   Get Line with ReadUnique and merge in Update
  --                                   stage.
  -- 
  --  * Write Dirty Miss Allocate   => Use WriteBack on AW to move Dirty data to main memory.
  --                                   Get Line with ReadUnique and merge in Update
  --                                   stage.
  --   
  --  * Write Invalid Miss,
  --  * Write Clean Miss,
  --  * Write Dirty Miss            => Forward as WriteUnique.
  -- 
  -- 
  -- The following cases need to be addressed for Read:
  --  * UniqueClean Read Hit,
  --  * UniqueDirty Read Hit,
  --  * SharedClean Read Hit,
  --  * SharedDirty Read Hit        => No action, read immediately.
  -- 
  --  * Read Invalid Miss Allocate  => Get Line with ReadShared to get data in any state.
  --                                   If C_READ_ONLY_UNIQUE is asserted a ReadUnique has to be 
  --                                   used in order to have the Line in proper state.
  -- 
  --  * Read Clean Miss Allocate    => If C_SUPPORT_SNOOP_FILTER is asserted a Evict transaction
  --                                   has to be used on AW for Line tracking.
  --                                   Get Line with ReadShared to get data in any state.
  --                                   If C_READ_ONLY_UNIQUE is asserted a ReadUnique has to be 
  --                                   used in order to have the Line in proper state.
  -- 
  --  * Read Dirty Miss Allocate    => Use WriteBack on AW to move Dirty data to main memory.
  --                                   Get Line with ReadShared to get data in any state.
  --                                   If C_READ_ONLY_UNIQUE is asserted a ReadUnique has to be 
  --                                   used in order to have the Line in proper state.
  -- 
  --  * Read Invalid Miss,
  --  * Read Clean Miss,
  --  * Read Dirty Miss             => Get data with a ReadOnce transaction
  -- 
  -----------------------------------------------------------------------------
  
  Use_Mst_Coherency_Pipeline: if (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
    
    signal lu_chkins_stall                  : std_logic;
  
    signal lookup_unique_clean_hit          : std_logic;
    signal lookup_unique_dirty_hit          : std_logic;
    signal lookup_shared_hit                : std_logic;
    signal lookup_shared_clean_hit          : std_logic;
    signal lookup_shared_dirty_hit          : std_logic;
    signal lookup_invalid_miss_allocate     : std_logic;
    signal lookup_clean_miss_allocate       : std_logic;
    signal lookup_dirty_miss_allocate       : std_logic;
    signal lookup_invalid_miss              : std_logic;
    signal lookup_clean_miss                : std_logic;
    signal lookup_dirty_miss                : std_logic;
    signal lookup_unique_write_hit          : std_logic;
    signal lookup_unique_clean_write_hit    : std_logic;
    signal lookup_unique_dirty_write_hit    : std_logic;
    signal lookup_shared_write_hit          : std_logic;
    signal lookup_shared_clean_write_hit    : std_logic;
    signal lookup_shared_dirty_write_hit    : std_logic;
    signal lookup_invalid_write_miss        : std_logic;
    signal lookup_clean_write_miss          : std_logic;
    signal lookup_dirty_write_miss          : std_logic;
    signal lookup_unique_read_hit           : std_logic;
    signal lookup_unique_clean_read_hit     : std_logic;
    signal lookup_unique_dirty_read_hit     : std_logic;
    signal lookup_shared_read_hit           : std_logic;
    signal lookup_shared_clean_read_hit     : std_logic;
    signal lookup_shared_dirty_read_hit     : std_logic;
    signal lookup_invalid_read_miss         : std_logic;
    signal lookup_clean_read_miss           : std_logic;
    signal lookup_dirty_read_miss           : std_logic;
    
    signal need_insert_read_trans_raw       : std_logic;
    signal need_insert_write_trans_raw      : std_logic;
    
    signal lu_check_shared_safe             : std_logic;
    
  begin
        
    lu_chk_start_piperun          <= ( update_piperun or not update_valid_i ) and not lu_chkins_stall;
    lu_chkins_piperun             <= lu_chk_start_piperun;
    
    -- Create new valid for virtual pipeline stage in order to avoid being overrun.
    -- (include the snoop hazard stall signal to prevent Check from overriding Chkinc stage)
    lu_chkins_valid               <= update_valid_i                   or
                                     update_error_freeze              or
                                     lu_chkins_insert_done            or
                                     lu_check_snoop_quick_halt        or
                                     lu_check_snoop_mst_fetch_stall   or
                                     lu_check_snoop_mst_mem_stall     or
                                     lu_check_snoop_mst_check_stall   or
                                     lu_check_snoop_mst_data_stall    or
                                     lu_check_writeback_hazard_halt   or
                                     lu_check_writeunique_hazard_halt;
    
    -- Stall Check Insert when:
    --  * Waiting for a response from inserted commands
    --  * Waiting for Error to be sorted out
    lu_chkins_stall               <= ( ( ( lu_chkins_insert_done            ) or 
                                         (     update_error_freeze          and 
                                           not need_insert_read_trans       and 
                                           not need_insert_write_trans      ) or
-- TODO: Separate carry input?
                                         ( lu_check_snoop_quick_halt        ) or
                                         ( lu_check_snoop_mst_fetch_stall   ) or
                                         ( lu_check_snoop_mst_mem_stall     ) or
                                         ( lu_check_snoop_mst_check_stall   ) or
                                         ( lu_check_snoop_mst_data_stall    ) or
                                         ( lu_check_writeback_hazard_halt   ) or
                                         ( lu_check_writeunique_hazard_halt ) ) and 
                                       ( not update_error_evict_insert ) );
    
    -- Classify transaction.
    lookup_unique_hit             <= lookup_hit                                                 and 
                                     (     lu_check_unique_bits(to_int(lookup_tag_assoc_way)) );
    lookup_unique_clean_hit       <= lookup_hit                                                 and 
                                     (     lu_check_unique_bits(to_int(lookup_tag_assoc_way)) ) and 
                                     ( not lu_check_dirty_bits(to_int(lookup_tag_assoc_way))  );
    lookup_unique_dirty_hit       <= lookup_hit                                                 and 
                                     (     lu_check_unique_bits(to_int(lookup_tag_assoc_way)) ) and 
                                     (     lu_check_dirty_bits(to_int(lookup_tag_assoc_way))  );
    lookup_shared_hit             <= lookup_hit                                                 and 
                                     ( not lu_check_unique_bits(to_int(lookup_tag_assoc_way)) );
    lookup_shared_clean_hit       <= lookup_hit                                                 and 
                                     ( not lu_check_unique_bits(to_int(lookup_tag_assoc_way)) ) and 
                                     ( not lu_check_dirty_bits(to_int(lookup_tag_assoc_way))  );
    lookup_shared_dirty_hit       <= lookup_hit                                                 and 
                                     ( not lu_check_unique_bits(to_int(lookup_tag_assoc_way)) ) and 
                                     (     lu_check_dirty_bits(to_int(lookup_tag_assoc_way))  );
    lookup_invalid_miss_allocate  <= lookup_miss                                                   and 
                                     (     lu_check_info.Allocate )                                and
                                     ( not lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) );
    lookup_clean_miss_allocate    <= lookup_miss                                                   and 
                                     (     lu_check_info.Allocate )                                and
                                     (     lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) ) and
                                     ( not lu_check_dirty_bits(to_int(lookup_new_tag_assoc_way)) );
    lookup_dirty_miss_allocate    <= lookup_miss                                                   and 
                                     (     lu_check_info.Allocate )                                and
                                     (     lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) ) and
                                     (     lu_check_dirty_bits(to_int(lookup_new_tag_assoc_way)) );
    lookup_invalid_miss           <= lookup_miss                                                   and 
                                     ( not lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) );
    lookup_clean_miss             <= lookup_miss                                                   and 
                                     (     lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) ) and
                                     ( not lu_check_dirty_bits(to_int(lookup_new_tag_assoc_way)) );
    lookup_dirty_miss             <= lookup_miss                                                   and 
                                     (     lu_check_valid_bits(to_int(lookup_new_tag_assoc_way)) ) and
                                     (     lu_check_dirty_bits(to_int(lookup_new_tag_assoc_way)) );
    
    lookup_unique_write_hit       <= lookup_unique_hit       and     lu_check_info.Wr;
    lookup_unique_clean_write_hit <= lookup_unique_clean_hit and     lu_check_info.Wr;
    lookup_unique_dirty_write_hit <= lookup_unique_dirty_hit and     lu_check_info.Wr;
    lookup_shared_write_hit       <= lookup_shared_hit       and     lu_check_info.Wr;
    lookup_shared_clean_write_hit <= lookup_shared_clean_hit and     lu_check_info.Wr;
    lookup_shared_dirty_write_hit <= lookup_shared_dirty_hit and     lu_check_info.Wr;
    lookup_invalid_write_miss     <= lookup_invalid_miss     and     lu_check_info.Wr;
    lookup_clean_write_miss       <= lookup_clean_miss       and     lu_check_info.Wr;
    lookup_dirty_write_miss       <= lookup_dirty_miss       and     lu_check_info.Wr;
    
    lookup_unique_read_hit        <= lookup_unique_hit       and not lu_check_info.Wr;
    lookup_unique_clean_read_hit  <= lookup_unique_clean_hit and not lu_check_info.Wr;
    lookup_unique_dirty_read_hit  <= lookup_unique_dirty_hit and not lu_check_info.Wr;
    lookup_shared_read_hit        <= lookup_shared_hit       and not lu_check_info.Wr;
    lookup_shared_clean_read_hit  <= lookup_shared_clean_hit and not lu_check_info.Wr;
    lookup_shared_dirty_read_hit  <= lookup_shared_dirty_hit and not lu_check_info.Wr;
    lookup_invalid_read_miss      <= lookup_invalid_miss     and not lu_check_info.Wr;
    lookup_clean_read_miss        <= lookup_clean_miss       and not lu_check_info.Wr;
    lookup_dirty_read_miss        <= lookup_dirty_miss       and not lu_check_info.Wr;
    
    
    -- Need to protect line from update until permission is granted.
    -- If a snoop removes this before permission is granted the write has to continue 
    -- as an asynchronous Write.
    protect_shared_write          <= (     lookup_shared_write_hit ) and 
                                     ( not lu_check_shared_safe    ) and
                                     ( not lu_check_info.Exclusive or
                                           lu_check_allow_write    );
    
    -- Determine when a command need to be inserted before a transaction can be completed.
    need_insert_read_trans_raw    <= ( lookup_shared_clean_write_hit or lookup_shared_dirty_write_hit )
                                          when ( C_KEEP_SHARED_WRITE > 0 ) else
                                     lookup_shared_dirty_write_hit;
    need_insert_read_trans        <= need_insert_read_trans_raw        and
                                     ( not lu_chkins_insert_done     ) and
                                     ( not lu_chkins_prohibit_insert );
    
    -- Determine the type of transactions.
    Read_Trans_Type_Handle : process (need_insert_read_trans_raw, lu_check_info,
                                      lookup_invalid_write_miss, lookup_clean_write_miss, lookup_dirty_write_miss) is
    begin  -- process Read_Trans_Type_Handle
      if( need_insert_read_trans_raw = '1' ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_CleanUnique;
        
      elsif( ( lookup_invalid_write_miss or lookup_clean_write_miss or lookup_dirty_write_miss ) = '1' ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadUnique;
        
      elsif( ( lu_check_info.Exclusive = '1' ) and ( C_READ_EXCLUSIVE_CLEAN > 0 ) ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadClean;
        
      elsif( ( lu_check_info.Exclusive = '1' ) and ( C_READ_EXCLUSIVE_CLEAN = 0 ) ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadShared;
        
      elsif( ( lu_check_info.Allocate  = '1' ) and ( C_READ_ONLY_UNIQUE > 0 ) ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadUnique;
        
      elsif( ( lu_check_info.Allocate  = '1' ) and ( C_READ_ONLY_UNIQUE = 0 ) ) then
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadShared;
        
      else
        lu_chkins_read_snoop  <= C_ARSNOOP_ReadOnce;
        
      end if;
    end process Read_Trans_Type_Handle;
    
    Write_Trans_Type_Handle : process (need_insert_write_trans_raw, lookup_wm_allocate_i, 
                                       lookup_invalid_write_miss, lookup_clean_write_miss, lookup_dirty_write_miss) is
    begin  -- process Write_Trans_Type_Handle
      if( need_insert_write_trans_raw = '1' ) then
        lu_chkins_write_snoop <= C_AWSNOOP_Evict;
        
      elsif( ( ( lookup_invalid_write_miss or lookup_clean_write_miss or lookup_dirty_write_miss ) = '1' ) and 
               ( lookup_wm_allocate_i = '0' ) ) then
        lu_chkins_write_snoop <= C_AWSNOOP_WriteUnique;
        
      else
        lu_chkins_write_snoop <= C_AWSNOOP_WriteBack;
        
      end if;
    end process Write_Trans_Type_Handle;
    
-- TODO: Snoop filter not supported...
    need_insert_write_trans_raw   <= '0' when C_SUPPORT_SNOOP_FILTER > 0 else '0';
    need_insert_write_trans       <= need_insert_write_trans_raw       and
                                     ( not lu_chkins_insert_done     ) and
                                     ( not lu_chkins_prohibit_insert );
    
    -- Determine when actions inserted transactions are done.
    lu_chkins_insert_complete     <= update_inserted_rd_done or update_inserted_wr_done;
    
    -- Handle the insertion of extra transaction in order to track allocations for snoop filters, or
    -- acquiring permission for actions in lookup.
    Insert_Handle: process (ACLK) is
    begin  -- process Insert_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_chkins_insert_done     <= '0';
          lu_chkins_prohibit_insert <= '0';
          
        else
          -- Prevent new transactions from being inserted until primary transaction is done.
          if( lu_check_piperun = '1' ) then
            lu_chkins_prohibit_insert <= '0';
            
          elsif( ( lu_chkins_insert_done     = '1' ) and
                 ( lu_chkins_insert_complete = '1' ) ) then
            lu_chkins_prohibit_insert <= '1';
            
          end if;
          
          -- Prevent new transaction form being inserted while wait for the response on
          -- the inserted transaction.
          if( lu_chkins_insert_complete = '1' ) then
            lu_chkins_insert_done <= '0';
            
          elsif( ( ( need_insert_read_trans_raw or need_insert_write_trans_raw ) = '1' ) and
                 ( lu_chkins_prohibit_insert = '0' ) and
                 ( lu_chkins_piperun = '1' ) ) then
            lu_chkins_insert_done <= '1';
            
          end if;
          
        end if;
      end if;
    end process Insert_Handle;
    
    Shared_Write_Handle: process (ACLK) is
    begin  -- process Shared_Write_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_shared_safe        <= '0';
          lu_check_shared_force_miss  <= '0';
          lu_check_shared_force_drop  <= '0';
          lu_check_shared_force_kill  <= '0';
          
        else
          if( lu_chkins_insert_complete = '1' ) then
            lu_check_shared_safe        <= '1';
            lu_check_shared_force_miss  <= lu_check_missed_by_snoop;
            lu_check_shared_force_drop  <= lu_check_dropped_by_snoop;
            lu_check_shared_force_kill  <= lu_check_killed_by_snoop;
            
          elsif( protect_shared_write = '1' ) then
            lu_check_shared_force_drop  <= lu_check_dropped_by_snoop;
            
          elsif( lu_check_piperun = '1' ) then
            lu_check_shared_safe        <= '0';
            lu_check_shared_force_miss  <= '0';
            lu_check_shared_force_drop  <= '0';
            lu_check_shared_force_kill  <= '0';
            
          end if;
          
        end if;
      end if;
    end process Shared_Write_Handle;
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      LOOKUP_DEBUG(307 downto 256)  <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            LOOKUP_DEBUG(307 downto 256)  <= (others=>'0');
          else
            -- Default assignment.
            LOOKUP_DEBUG(307 downto 256)  <= (others=>'0');
            
            LOOKUP_DEBUG(           256)  <= lu_chkins_stall;
            
            LOOKUP_DEBUG(           257)  <= lookup_unique_hit;
            LOOKUP_DEBUG(           258)  <= lookup_unique_clean_hit;
            LOOKUP_DEBUG(           259)  <= lookup_unique_dirty_hit;
            LOOKUP_DEBUG(           260)  <= lookup_shared_hit;
            LOOKUP_DEBUG(           261)  <= lookup_shared_clean_hit;
            LOOKUP_DEBUG(           262)  <= lookup_shared_dirty_hit;
            LOOKUP_DEBUG(           263)  <= lookup_invalid_miss_allocate;
            LOOKUP_DEBUG(           264)  <= lookup_clean_miss_allocate;
            LOOKUP_DEBUG(           265)  <= lookup_dirty_miss_allocate;
            LOOKUP_DEBUG(           266)  <= lookup_invalid_miss;
            LOOKUP_DEBUG(           267)  <= lookup_clean_miss;
            LOOKUP_DEBUG(           268)  <= lookup_dirty_miss;
            LOOKUP_DEBUG(           269)  <= lookup_unique_write_hit;
            LOOKUP_DEBUG(           270)  <= lookup_unique_clean_write_hit;
            LOOKUP_DEBUG(           271)  <= lookup_unique_dirty_write_hit;
            LOOKUP_DEBUG(           272)  <= lookup_shared_write_hit;
            LOOKUP_DEBUG(           273)  <= lookup_shared_clean_write_hit;
            LOOKUP_DEBUG(           274)  <= lookup_shared_dirty_write_hit;
            LOOKUP_DEBUG(           275)  <= lookup_invalid_write_miss;
            LOOKUP_DEBUG(           276)  <= lookup_clean_write_miss;
            LOOKUP_DEBUG(           277)  <= lookup_dirty_write_miss;
            LOOKUP_DEBUG(           278)  <= lookup_unique_read_hit;
            LOOKUP_DEBUG(           279)  <= lookup_unique_clean_read_hit;
            LOOKUP_DEBUG(           280)  <= lookup_unique_dirty_read_hit;
            LOOKUP_DEBUG(           281)  <= lookup_shared_read_hit;
            LOOKUP_DEBUG(           282)  <= lookup_shared_clean_read_hit;
            LOOKUP_DEBUG(           283)  <= lookup_shared_dirty_read_hit;
            LOOKUP_DEBUG(           284)  <= lookup_invalid_read_miss;
            LOOKUP_DEBUG(           285)  <= lookup_clean_read_miss;
            LOOKUP_DEBUG(           286)  <= lookup_dirty_read_miss;
            
            LOOKUP_DEBUG(           287)  <= need_insert_read_trans_raw;
            LOOKUP_DEBUG(           288)  <= need_insert_write_trans_raw;
            
            LOOKUP_DEBUG(           289)  <= lu_check_shared_safe;
            
            LOOKUP_DEBUG(           290)  <= lu_chk_start_piperun;
            LOOKUP_DEBUG(           291)  <= lu_chkins_piperun;
            LOOKUP_DEBUG(           292)  <= lu_chkins_valid;
            
            LOOKUP_DEBUG(           293)  <= need_insert_read_trans;
            LOOKUP_DEBUG(           294)  <= need_insert_write_trans;
            
            LOOKUP_DEBUG(           295)  <= lu_chkins_insert_complete;
            LOOKUP_DEBUG(           296)  <= lu_chkins_insert_done;
            LOOKUP_DEBUG(           297)  <= lu_chkins_prohibit_insert;
            
            LOOKUP_DEBUG(           298)  <= protect_shared_write;
            
            LOOKUP_DEBUG(           299)  <= lu_check_shared_force_miss;
            LOOKUP_DEBUG(           300)  <= lu_check_shared_force_kill;
            
            LOOKUP_DEBUG(303 downto 301)  <= lu_chkins_write_snoop;
            LOOKUP_DEBUG(307 downto 304)  <= lu_chkins_read_snoop;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
      
  end generate Use_Mst_Coherency_Pipeline;

  Use_Error_Pipeline: if ( not is_mst_coherent(C_ENABLE_COHERENCY) and ( C_ENABLE_ERROR_HANDLING > 0 ) ) generate
    
    signal lu_chkins_stall                  : std_logic;
  
  begin
        
    lu_chk_start_piperun          <= ( update_piperun or not update_valid_i ) and not lu_chkins_stall;
    lu_chkins_piperun             <= lu_chk_start_piperun;
    
    -- Create new valid for virtual pipeline stage in order to avoid being overrun.
    lu_chkins_valid               <= update_valid_i or update_error_freeze;
    
    -- Stall Check Insert when:
    --  * Waiting for Error to be sorted out
    lu_chkins_stall               <= update_error_freeze and not update_error_evict_insert;
    
    
  end generate Use_Error_Pipeline;

  No_Insert_Pipeline: if  ( not is_mst_coherent(C_ENABLE_COHERENCY) and ( C_ENABLE_ERROR_HANDLING = 0 ) ) generate
  begin
  
    lu_chk_start_piperun        <= update_piperun;
    lu_chkins_piperun           <= lu_check_piperun;
    lu_chkins_valid             <= update_valid_i;
    
  end generate No_Insert_Pipeline;
  
  No_Mst_Coherency_Info: if  ( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
  
    lu_chkins_read_snoop        <= C_ARSNOOP_ReadNoSnoop;
    lu_chkins_write_snoop       <= C_AWSNOOP_WriteNoSnoop;
    
    need_insert_read_trans      <= '0';
    need_insert_write_trans     <= '0';
    
    lu_chkins_insert_complete   <= '0';
    lu_chkins_insert_done       <= '0';
    lu_chkins_prohibit_insert   <= '0';
    
    protect_shared_write        <= '0';
    
    lu_check_shared_force_miss  <= '0';
    lu_check_shared_force_drop  <= '0';
    lu_check_shared_force_kill  <= '0';
    
    lookup_unique_hit           <= '1';
    
    LOOKUP_DEBUG(307 downto 256)  <= (others=>'0');
    
  end generate No_Mst_Coherency_Info;
  
  update_error_wait             <= need_insert_read_trans or 
                                   need_insert_write_trans;
  
  
  -----------------------------------------------------------------------------
  -- Exclusive Monitor
  -----------------------------------------------------------------------------
  
  Exclusive_Monitor : process (ACLK) is
  begin  -- process Exclusive_Monitor
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' or 
          ( ( C_ENABLE_EX_MON = 0 ) and
            ( not is_mst_coherent(C_ENABLE_COHERENCY) ) ) ) then      -- synchronous reset (active high)
        lookup_exclusive_monitor  <= (others=>C_NULL_EX_MON);
        
      else
        if( lu_mem_piperun = '1' ) then
          if( lu_mem_info.Exclusive = '1' ) then
            if( lu_mem_info.Wr = '0' ) then
              -- Activate monitor for this port.
              lookup_exclusive_monitor(lu_mem_read_port).Valid    <= '1';
              lookup_exclusive_monitor(lu_mem_read_port).ID       <= lu_mem_info.ID(C_ID_WIDTH - 1 downto 0);
              lookup_exclusive_monitor(lu_mem_read_port).Addr     <= lu_mem_info.Addr(C_ADDR_INTERNAL_POS);
              lookup_exclusive_monitor(lu_mem_read_port).Prot     <= lu_mem_info.Prot;
              
            elsif( lu_mem_ex_mon_hit = '1'  ) then
              -- Sequence completed => turn off monitor.
              lookup_exclusive_monitor(lu_mem_read_port).Valid    <= '0';
              
              for I in 0 to C_NUM_PORTS - 1 loop
                if( ( lu_mem_read_port       /=  I  ) and
                    ( lu_mem_ex_mon_match(I)  = '1' ) ) then
                  -- Turn off all monitors on other ports that match this address,
                  -- since this port was able to complete first.
                  lookup_exclusive_monitor(I).Valid    <= '0';
                end if;
              end loop;
              
            end if;
          end if;
        end if;
        
        -- Terminate any Exclusive Monitor that is touched by the Master Snoop event.
        -- No risk of colliding with Mem transaction since Hazards are stalled in Fetch when
        -- a Snoop has been committed to the pipeline (i.e. Mst_Mem and later).
        for I in 0 to C_NUM_PORTS - 1 loop
          if( ( ex_mon_lost_by_reuse(I)  = '1' ) or
              ( ex_mon_lost_by_evict(I)  = '1' ) or 
              ( ex_mon_mst_snoop_kill(I) = '1' ) ) then
            lookup_exclusive_monitor(I).Valid    <= '0';
          end if;
        end loop;
        
      end if;
    end if;
  end process Exclusive_Monitor;
  
  -- Detect match with any port.
  Gen_Port_Mon_Match: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    lu_mem_ex_mon_match(I)      <= lookup_exclusive_monitor(I).Valid when
                                      ( ( ( C_ENABLE_EX_MON                   = 1                                 ) or
                                          ( is_mst_coherent(C_ENABLE_COHERENCY)                                   ) ) and 
                                        ( lookup_exclusive_monitor(I).Addr  = lu_mem_info.Addr(C_ADDR_INTERNAL_POS) ) and
                                        ( ( C_ENABLE_NON_SECURE = 0 ) or
                                          ( lookup_exclusive_monitor(I).Prot(C_PROT_SECURE_POS) = 
                                                            lu_mem_info.Prot(C_PROT_SECURE_POS)                   ) ) ) else
                                   '0';
    
    -- For Master Coherent it must be tracked if the line that is associated with a monitor is dropped
    -- due to excessive reuse of Ways in the current Set. It is a requirement that an Exclusive address
    -- is constantly monitored, loosing it by oneself has the same affect as snooping.
    ex_mon_lost_by_reuse(I)     <= ( lookup_exclusive_monitor(I).Valid                           ) and
                                   ( lu_check_valid                                              ) and
                                   ( lu_check_tag(lu_check_old_tag_idx).Valid                    ) and
                                   ( ( lookup_write_hit and not lu_check_keep_allocation       ) or
                                     ( lookup_miss      and     lu_check_info.Allocate         ) ) when
                                   ( ( is_mst_coherent(C_ENABLE_COHERENCY)                       ) and
                                     ( lookup_exclusive_monitor(I).Addr(C_ADDR_TAG_POS) = 
                                       lu_check_tag(lu_check_old_tag_idx).Addr(C_ADDR_TAG_POS)   ) and
                                     ( ( C_ENABLE_NON_SECURE = 0 ) or
                                       ( lookup_exclusive_monitor(I).Prot(C_PROT_SECURE_POS) = 
                                         lu_check_tag(lu_check_old_tag_idx).Secure             ) ) ) else
                                   '0';
    
    ex_mon_lost_by_evict(I)     <= ( lookup_exclusive_monitor(I).Valid                      ) and
                                   ( lu_check_valid                                         ) and
                                   ( ( lookup_evict_hit                                   ) ) when
                                   ( ( is_mst_coherent(C_ENABLE_COHERENCY)                  ) and
                                     ( lookup_exclusive_monitor(I).Addr(C_ADDR_TAG_POS) =   
                                       lu_check_info.Addr(C_ADDR_TAG_POS)                   ) and
                                     ( ( C_ENABLE_NON_SECURE = 0 ) or
                                       ( lookup_exclusive_monitor(I).Prot(C_PROT_SECURE_POS) = 
                                                       lu_check_info.Prot(C_PROT_SECURE_POS) ) ) ) else
                                   '0';
    
    -- Let all actions that remove the line terminate the Exclusive Monitor.
    -- No need to enable with Mst Check Piperun, since there are no conflicts and the Monitor
    -- can only be disabled once anyway.
    ex_mon_mst_snoop_kill(I)    <= ( lookup_exclusive_monitor(I).Valid                                ) and
                                   ( mst_snoop_check_info.Valid                                       ) and
                                   ( ( mst_snoop_check_info.Clean and not mst_snoop_check_info.Keep ) or
                                     ( mst_snoop_check_info.Kill                                    ) or
                                     ( mst_snoop_check_info.Get   and not mst_snoop_check_info.Keep ) ) when
                                   ( ( ( is_mst_coherent(C_ENABLE_COHERENCY)                                                ) and
                                       ( lookup_exclusive_monitor(I).Addr  = mst_snoop_check_info.Addr(C_ADDR_INTERNAL_POS) ) ) and
                                     ( ( C_ENABLE_NON_SECURE = 0 ) or
                                       ( lookup_exclusive_monitor(I).Prot(C_PROT_SECURE_POS) = 
                                                mst_snoop_check_info.Prot(C_PROT_SECURE_POS) ) ) ) else
                                   '0';
    
  end generate Gen_Port_Mon_Match;
  
  -- Detect if this is a Hit for the current port.
  lu_mem_ex_mon_hit <= lu_mem_ex_mon_match(lu_mem_read_port) when
                          ( ( ( C_ENABLE_EX_MON                               = 1                                   ) or
                              ( is_mst_coherent(C_ENABLE_COHERENCY)                                                 ) ) and
                            ( lookup_exclusive_monitor(lu_mem_read_port).ID = lu_mem_info.ID(C_ID_WIDTH - 1 downto 0) ) ) else
                       '0';
  
  
  -----------------------------------------------------------------------------
  -- Error handling
  -----------------------------------------------------------------------------
  
  Use_Err_Handling: if  ( C_ENABLE_ERROR_HANDLING > 0 ) generate
  
    signal lu_check_error_conflict    : std_logic;
    
  begin
    -- Evaluate if this is a line that can be affected by bad return data.
    lu_check_error_conflict <= lu_check_info.Wr         and
                               lookup_protect_conflict  and
                               update_allocate_conflict and
                               update_allocate_error;
    
    Drop_Write_Handle: process (ACLK) is
    begin  -- process Drop_Write_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_error_force_miss <= '0';
          
        else
          if( s2b(lu_check_piperun) ) then
            lu_check_error_force_miss <= '0';
            
          elsif( s2b(lu_check_error_conflict) ) then
            lu_check_error_force_miss <= '1';
            
          end if;
          
        end if;
      end if;
    end process Drop_Write_Handle;
    
  end generate Use_Err_Handling;

  No_Err_Handling: if  ( C_ENABLE_ERROR_HANDLING = 0 ) generate
  begin
  
    lu_check_error_force_miss   <= '0';
    
  end generate No_Err_Handling;
  
  
  -----------------------------------------------------------------------------
  -- Read Transaction Properties
  -----------------------------------------------------------------------------
  
  -- Push hit/miss information to queue.
  lookup_read_data_new_i    <= ( ( lookup_read_miss ) or 
                                 ( lookup_read_hit and     lookup_true_locked_read and not lookup_protect_conflict ) or 
                                 ( lookup_read_hit and not lookup_locked_read_hit ) or 
                                 ( lookup_miss     and     lu_check_info.SnoopResponse ) ) and 
                               not lu_check_read_info_done and not lu_check_wait_for_update;
  
  lookup_read_data_hit_i    <= lookup_read_hit and not lookup_locked_read_hit;
  Gen_Port_Lookup_Type: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    lookup_read_data_new(I).Valid       <= lookup_read_data_new_i and lu_check_port_one_hot(I);
    lookup_read_data_new(I).Hit         <= lookup_read_data_hit_i;
      
    lookup_read_data_new(I).Snoop       <= lu_check_info.SnoopResponse  when is_slv_coherent(C_ENABLE_COHERENCY) else
                                           '0';
    lookup_read_data_new(I).Lx_Allocate <= lu_check_info.Lx_Allocate    when is_slv_coherent(C_ENABLE_COHERENCY) else
                                           '0';
  end generate Gen_Port_Lookup_Type;
  
  -- Determine when it is done.
  lookup_read_done_i        <= lookup_read_data_new_i;
  
  -- Assign external signals.
  lookup_read_done_vec      <= (others => lookup_read_done_i);
  lookup_read_done          <= lookup_read_done_vec and 
                               lu_check_port_one_hot;
  
  
  -----------------------------------------------------------------------------
  -- LRU Handling
  -- 
  -- The LRU is updated for almost all accesses, to make sure that it is as
  -- accurate as possible.
  -- The only exceptions are:
  --  Write Miss - Because this passes right through without touching affecting 
  --               the Tag.
  --  Evict      - Because it doesn't use or affect the Cache contents.
  -- 
  -- The LRU is only use for Read Miss with no invalid way.
  -----------------------------------------------------------------------------
  
  -- Pipe control signals.
  lookup_fetch_piperun    <= lu_fetch_piperun;
  lookup_mem_piperun      <= lu_mem_piperun;
    
  -- Peek on current LRU value and let it flow through the pipe.
  lru_fetch_line_addr     <= lu_fetch_tag_addr(C_ADDR_LINE_POS);
  
  -- Update LRU when relevant transaction is moved to update.
  lru_check_use_lru       <= lru_check_use_lru_i;
  
  lu_check_enable_wr_lru  <= ( lu_check_valid and not lu_check_info.KillHit and 
                               ( lookup_hit or ( lookup_read_miss and lu_check_info.Allocate ) ) );
  
  LU_LRU_Latch_Inst1: carry_latch_and
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => lu_check_piperun,
      A         => lu_check_enable_wr_lru,
      O         => lru_check_use_lru_i,
      Carry_OUT => lu_check_piperun_i
    );
  
  lru_check_line_addr   <= lu_check_tag_addr(C_ADDR_LINE_POS);
  
  -- Update with current way for Hit and LRU for Miss.
  lru_check_used_way    <= lru_tag_assoc_way;
  lru_tag_assoc_way     <= lookup_tag_assoc_way      when lookup_raw_hit = '1' else 
                           lookup_new_tag_assoc_way;
  
  -- Detect if there are any invalid lines available.
  lookup_invalid_exist  <= '0' when lu_check_valid_bits = way_pos_one_vec else '1';
  
  -- Finding the first invalid line.
  process(lu_check_valid_bits) is
    variable temp : natural range 0 to C_NUM_WAYS - 1;
  begin
    temp := 0;
    for K in 0 to C_NUM_WAYS - 1 loop
      if lu_check_valid_bits(K) = '0' then
        temp := K;
        exit;
      end if;
    end loop;
    lookup_first_invalid <= std_logic_vector(to_unsigned(temp, C_WAY_BITS));
  end process;
  
  -- Select an invalid if it exist or the one pointer out by the LRU in other cases.
  lookup_new_tag_assoc_way  <= lookup_first_invalid when ( lookup_invalid_exist ) = '1' else 
                               lru_check_next_way;
  
  
  -----------------------------------------------------------------------------
  -- Stall detection
  -- 
  -- Detect if a Write Hit has currently ongoing/queued Write Miss, in that 
  -- case must the write be stalled to prevent popping data prematurely. Or
  -- otherwise corrupting the write data stream.
  -- 
  -- Stall write miss until there is room in the Write Miss queue.
  -----------------------------------------------------------------------------
  
  -- Previous write miss for this port is still working or there is a locked hit situation.
  -- Also includes stalling for protected misses as well.
--  lookup_data_hit_stall   <= lookup_protect_conflict or
--                             lud_write_hit_done or
--                             ( lookup_write_hit and not lu_check_wait_for_update
--                               update_write_miss_busy(get_port_num(lu_check_info.Port_Num, C_NUM_INTERNAL_PORTS)) );

  lu_check_wait_for_update_vec  <= (others => lu_check_wait_for_update);
  update_write_miss_true_busy   <= update_write_miss_busy and not lu_check_wait_for_update_vec;
  
  LU_DHS_Or_Inst1: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_INTERNAL_PORTS
    )
    port map(
      Carry_In  => lookup_protect_conflict,
      No        => lookup_write_port,
      A_Vec     => update_write_miss_true_busy,
      Carry_Out => lookup_data_hit_pre_stall
    );
  LU_DHS_Or_Inst2: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_data_hit_pre_stall,
      A         => lud_write_hit_done,
      Carry_OUT => lookup_data_hit_stall
    );
  
  -- No room for new write miss.
--  lookup_data_miss_stall  <= lookup_push_write_miss_i and update_write_miss_full;
  LU_WMS_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_push_write_miss_pre,
      A         => update_write_miss_full,
      Carry_OUT => lookup_push_wm_stall
    );
  lookup_data_miss_stall    <= lookup_push_wm_stall and not lookup_protect_conflict;
  
  lookup_other_write_stall  <= (     lookup_push_wm_edrop_raw   or 
                                     update_error_evict_insert  ) and 
                               (     update_write_miss_full     or 
                                     update_error_evict_insert  ) and
                               ( not lu_check_wr_already_pushed );
  
  
  -----------------------------------------------------------------------------
  -- TAG Conflict 
  -- 
  -- Detect any address conflict in order to be able to stall Access, and
  -- preventing any BRAM conflicts that could arise.
  -----------------------------------------------------------------------------
  
  -- Detect any Lookup TAG address conflicts with Access.
  -- Unconditional stall because it is not known if they will update the TAG or not.
--  lu_mem_tag_conflict   <= access_valid and lu_mem_valid when 
--                              access_info.Addr(C_ADDR_LINE_POS) = lu_mem_info.Addr(C_ADDR_LINE_POS)   else 
--                           '0';
  LU_Mem_TagConf_Compare_Inst1: carry_compare
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_ADDR_LINE_BITS
    )
    port map(
      Carry_In  => '1',
      A_Vec     => access_info.Addr(C_ADDR_LINE_POS),
      B_Vec     => lu_mem_info.Addr(C_ADDR_LINE_POS),
      Carry_Out => lu_mem_match_addr
    );
  
  lu_mem_tag_check_valid  <= access_valid and lu_mem_valid;
  LU_Mem_TagConf_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_mem_match_addr,
      A         => lu_mem_tag_check_valid,
      Carry_OUT => lu_mem_tag_conflict
    );
    
--  lu_check_tag_conflict <= access_valid and lu_check_valid when 
--                              access_info.Addr(C_ADDR_LINE_POS) = lu_check_info.Addr(C_ADDR_LINE_POS) else 
--                           '0';
  LU_Check_TagConf_Compare_Inst1: carry_compare
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_ADDR_LINE_BITS
    )
    port map(
      Carry_In  => '1',
      A_Vec     => access_info.Addr(C_ADDR_LINE_POS),
      B_Vec     => lu_check_info.Addr(C_ADDR_LINE_POS),
      Carry_Out => lu_check_match_addr
    );
  
  lu_check_tag_check_valid  <= access_valid and lu_check_valid;
  LU_Check_TagConf_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_check_match_addr,
      A         => lu_check_tag_check_valid,
      Carry_OUT => lu_check_tag_conflict
    );
    
  lookup_tag_conflict   <= lu_mem_tag_conflict or lu_check_tag_conflict;
  
  -- Provide address to check if there are conflicts with Update
  lookup_new_addr       <= access_info.Addr;
  lookup_stall_addr     <= lu_check_info.Addr;
  
  
  -----------------------------------------------------------------------------
  -- Data Offset Counter
  -- 
  -- Access all words that are needed for Read or Write Hit.
  -- 
  -- Read are speculatively accessed during Memory stage if the Pipeline isn't
  -- in late mode (due to earlier Write without bubble cycles).
  -- Speculative read has to return to idle state if there is a Miss.
  -- 
  -- Write are accessed from Check stage because it must be known if it is a 
  -- hit or not.
  -----------------------------------------------------------------------------

  -- Use information from Check stage for: write and delayed read.
  -- Select Use and Step data.
  lookup_use_bits     <= lu_mem_info.Addr_Use(C_ADDR_OFFSET_POS)  when ( lud_step_use_check ) = '0' else 
                         lu_check_info.Addr_Use(C_ADDR_OFFSET_POS);
  lookup_stp_bits     <= lu_mem_info.Addr_Stp(C_ADDR_OFFSET_POS)  when ( lud_step_use_check ) = '0' else 
                         lu_check_info.Addr_Stp(C_ADDR_OFFSET_POS);
  lookup_kind         <= lu_mem_info.Kind when ( lud_step_use_check ) = '0' else 
                         lu_check_info.Kind;
  
  -- Select the current word that should be read from lookup port.
  Lookup_Offset_Gen: process (lookup_offset_all_first, lookup_offset_cnt, lud_step_use_check, 
                              lu_mem_info, lu_check_info, lookup_offset_len_cnt,
                              lookup_next_is_last_beat, lu_mem_single_beat, lu_check_single_beat) is
  begin  -- process Lookup_Offset_Gen
    -- Determine base address for this transaction.
    if ( ( lud_step_use_check ) = '0' ) then
      lookup_base_offset    <= lu_mem_info.Addr(C_ADDR_OFFSET_POS);
    else
      lookup_base_offset    <= lu_check_info.Addr(C_ADDR_OFFSET_POS);
    end if;
    
    -- Determine the adress thet is going used this cycle.
    if( lookup_offset_all_first = '0' ) then
      lookup_word_offset  <= lookup_offset_cnt;
      lookup_offset_len   <= lookup_offset_len_cnt;
      lookup_last_beat    <= lookup_next_is_last_beat;
    else
      if ( ( lud_step_use_check ) = '0' ) then
        lookup_word_offset  <= lu_mem_info.Addr(C_ADDR_OFFSET_POS);
        lookup_offset_len   <= lu_mem_info.Len(C_INT_LEN_POS);
        lookup_last_beat    <= lu_mem_single_beat;
      else
        lookup_word_offset  <= lu_check_info.Addr(C_ADDR_OFFSET_POS);
        lookup_offset_len   <= lu_check_info.Len(C_INT_LEN_POS);
        lookup_last_beat    <= lu_check_single_beat;
      end if;
    end if;
  end process Lookup_Offset_Gen;
  
  -- Detect failing speculative read and force first to restart.
  lookup_force_first      <= lu_check_valid and not lu_check_info.Wr and not lookup_read_hit and 
                             not lud_mem_waiting_for_pipe;
  lookup_offset_all_first <= lookup_offset_first or lookup_force_first or lud_step_unlock_rerun;
  
  -- Loop through all words in Slave line length.
  Lookup_Offset_First_Handle : process (ACLK) is
  begin  -- process Lookup_Offset_First_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        lookup_offset_first       <= '1';
        
      elsif( ( lud_step_offset = '1' ) and 
             ( ( lookup_locked_read_hit = '0' ) or ( lud_step_use_check = '0' ) ) ) then
        -- Handle first word status. Next is marked as first when last beat is used.
        if( lookup_step_last = '1' ) then
          lookup_offset_first       <= '1';
        else
          lookup_offset_first       <= '0';
        end if;
        
      elsif( ( lookup_locked_read_hit = '1' and lud_mem_waiting_for_pipe = '0' ) or 
             ( lookup_force_first = '1' ) or 
             ( lud_mem_conflict = '1' ) )then
        -- Need to restore speculative read (non late) that ended up being Locked Read Hit.
        lookup_offset_first   <= '1';
        
      end if;
    end if;
  end process Lookup_Offset_First_Handle;
  
  -- Loop through all words in Slave line length.
  Lookup_Offset_Handle : process (ACLK) is
  begin  -- process Lookup_Offset_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        lookup_offset_len_cnt       <= (others => '0');
        lookup_offset_cnt           <= (others => '0');
        lookup_next_is_last_beat    <= '0';
        lu_ds_last_beat_next_last_n <= '1';
        
      elsif( ( lud_step_offset = '1' ) and 
             ( ( lookup_locked_read_hit = '0' ) or ( lud_step_use_check = '0' ) ) ) then
        -- Update remaining length and counter.
        lookup_offset_len_cnt       <= lookup_offset_len_cmb;
        lookup_offset_cnt           <= lookup_offset_cnt_cmb;
        
        -- Update if next is expected to be last.
        if( to_integer(unsigned(lookup_offset_len)) = 1 ) then
          lookup_next_is_last_beat    <= '1';
          lu_ds_last_beat_next_last_n <= '0';
        else
          lookup_next_is_last_beat    <= '0';
          lu_ds_last_beat_next_last_n <= '1';
        end if;
        
      end if;
    end if;
  end process Lookup_Offset_Handle;
  
  -- Last step in burst.
  lookup_step_last      <= lookup_last_beat;
  
  -- Decrease when used.
  lookup_offset_len_cmb <= std_logic_vector(unsigned(lookup_offset_len) - 1);
  
  -- Generate next value.
  Lookup_Offset_Select: process (lookup_word_offset, lookup_use_bits, lookup_stp_bits, 
                                 lookup_base_offset, lookup_kind) is
    variable lookup_offset_cnt_next : ADDR_OFFSET_TYPE;
  begin  -- process Lookup_Offset_Select
    lookup_offset_cnt_next  := std_logic_vector(unsigned(lookup_word_offset) + unsigned(lookup_stp_bits));
    
    for N in lookup_base_offset'range loop
      if( lookup_use_bits(N) = '0' ) and ( lookup_kind = C_KIND_WRAP ) then
        lookup_offset_cnt_cmb(N) <= lookup_base_offset(N);
      else
        lookup_offset_cnt_cmb(N) <= lookup_offset_cnt_next(N);
      end if;
    end loop;
  end process Lookup_Offset_Select;
  
  -- Signal when data offset counter is busy.
--  lookup_data_stall <= ( lookup_hit and not lookup_locked_read_hit and not lu_check_wait_for_update and 
--                         not lookup_step_last ) or
--                       ( lookup_read_hit and not lookup_locked_read_hit and not lu_check_wait_for_update and 
--                         ( read_data_status(lu_check_read_port).Hit_Almost_Full or read_data_hit_full(lu_check_read_port) ) ) or 
--                       ( lookup_write_hit and not lu_check_wait_for_update and
--                         not access_data_valid(get_port_num(lu_check_info.Port_Num, C_NUM_INTERNAL_PORTS)) );
  lookup_data_stall <= ( lu_ds_last_beat_stall ) or
                       ( lookup_io_data_stall  );
  
  
  -----------------------------------------------------------------------------
  -- Optimized Data Stall:
  -- 
  -- IO Stall with Busy
  -----------------------------------------------------------------------------
  
  
  -- Prepare vectors.
  lu_check_info_wr_vec         <=     (others => lu_check_info.Wr);
  access_data_valid_stall      <=     lu_check_info_wr_vec      and not access_data_valid;
  access_data_conflict_stall   <=     lu_check_info_wr_vec      and     update_write_miss_busy and 
                                  not lu_check_wait_for_update_vec;
  lu_check_info_wr_pspvec      <=     (others => lu_check_info.Wr);
  read_locked_vector           <= not lu_check_info_wr_pspvec   and     lu_check_locked_hit;
  
  
--  lu_io_lud_stall_pipe  <= ( ( lud_addr_pipeline_full and read_data_hit_full(lud_reg_port_num) ) and 
--                             ( not lud_mem_completed or lud_mem_keep_single_during_stall ) and 
--                             not lu_check_info.Wr ) or
--                           ( lu_check_valid and lu_check_info.Wr and lud_addr_pipeline_full );
-- TODO: update equation
  
  LU_DS_IO_Or_Inst1: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_PORTS
    )
    port map(
      Carry_In  => '0',
      No        => lud_reg_port_num,
      A_Vec     => read_data_hit_full,
      Carry_Out => lu_io_selected_full
    );
  
  lu_io_valid_read  <= ( lud_addr_pipeline_full and 
                         ( not lud_mem_completed or lud_mem_keep_single_during_stall ) and 
                         not lu_check_info.Wr );
  LU_DS_IO_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_io_selected_full,
      A         => lu_io_valid_read,
      Carry_OUT => lu_io_full_block_read
    );
  
  lu_io_write_blocked <= ( lu_check_valid and lu_check_info.Wr and lud_addr_pipeline_full );
  LU_DS_IO_Or_Inst2: carry_or
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_io_full_block_read,
      A         => lu_io_write_blocked,
      Carry_OUT => lu_io_lud_stall_pipe
    );
  
  LU_DS_IO_Or_Inst3: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_INTERNAL_PORTS
    )
    port map(
      Carry_In  => lu_io_lud_stall_pipe,
      No        => lookup_write_port,
      A_Vec     => access_data_valid_stall,
      Carry_Out => lookup_io_stall_carry
    );
  
  LU_DS_IO_And_Inst2: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_io_stall_carry,
      A_N       => lu_check_wait_for_update,
      Carry_OUT => lookup_io_stall_carry_no_wait
    );
  
  LU_DS_IO_Or_Inst4: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_INTERNAL_PORTS
    )
    port map(
      Carry_In  => lookup_io_stall_carry_no_wait,
      No        => lookup_write_port,
      A_Vec     => access_data_conflict_stall,
      Carry_Out => lookup_io_and_conflict_stall
    );
  
  lu_check_tag_hit_all_copy_ds <= reduce_or(lu_check_tag_hit_copy_ds);
  LU_DS_IO_And_Inst3: carry_and
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_io_and_conflict_stall,
      A         => lu_check_tag_hit_all_copy_ds,
      Carry_OUT => lookup_io_stall_hit_carry
    );
  
  lu_ds_no_last <=  ( not lu_check_info.Wr and lud_mem_speculative_valid and lud_mem_last and 
                      not lookup_access_data_late ) or 
                    lud_mem_already_used; 
  LU_DS_IO_And_Inst4: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_io_stall_hit_carry,
      A_N       => lu_ds_no_last,
      Carry_OUT => lookup_io_stall_hit_carry_no_last
    );
  
  lookup_io_wr_done_drop      <= lud_write_hit_done and not lu_check_keep_allocation;
  lookup_io_valid_and_no_drop <= lu_check_valid     and not lookup_io_wr_done_drop;
  
  LU_DS_IO_And_Inst5: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_io_stall_hit_carry_no_last,
      A         => lookup_io_valid_and_no_drop,
      Carry_OUT => lookup_io_stall_pre_valid
    );
  
  lookup_io_no_transaction        <= '1' when ( lu_check_info.Barrier = C_BAR_MEMORY_BARRIER  ) or
                                              ( lu_check_info.Barrier = C_BAR_SYNCHRONIZATION ) or
                                              ( lu_check_info.KillHit = '1'                   ) else
                                     '0';
  LU_DS_IO_And_Inst6: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_io_stall_pre_valid,
      A_N       => lookup_io_no_transaction,
      Carry_OUT => lookup_io_stall_valid
    );
  
  LU_DS_IO_And_Inst7: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 2,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => lookup_io_stall_valid,     -- [in  std_logic]
      A_Vec     => read_locked_vector,        -- [in  std_logic_vector]
      Carry_Out => lookup_io_data_stall       -- [out std_logic]
    );
  
  -----------------------------------------------------------------------------
  -- Optimized Data Stall:
  -- 
  -- Last Beat
  -----------------------------------------------------------------------------
  
  lu_ds_last_beat_rd_locked   <= not lu_check_info_wr_pspvec and lu_check_locked_hit_copy_lb;
  
  lu_ds_last_beat_sel_first   <= lookup_offset_first or 
                                 ( lookup_access_data_late and lu_check_valid_delayed and 
                                   not lu_check_info_delayed.wr and not lookup_read_hit_d1 );
  
  LU_DS_LB_And_Inst0: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => '1',
      A         => lu_check_multi_beat,
      Carry_OUT => lu_ds_last_beat_multi_start
    );
  
  LU_DS_LB_And_Inst1: carry_and_di
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_last_beat_multi_start,
      A         => lu_ds_last_beat_sel_first,
      DI        => lu_ds_last_beat_next_last_n,
      Carry_OUT => lu_ds_last_beat
    );
  
  lu_ds_lb_transaction_done <= lu_check_wait_for_update or lud_write_hit_done;
  LU_DS_LB_And_Inst2: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_last_beat,
      A_N       => lu_ds_lb_transaction_done,
      Carry_OUT => lu_ds_last_beat_no_wait
    );
  
  lu_ds_last_beat_all_tag_hit <= reduce_or(lu_check_tag_hit_copy_lb);
  LU_DS_LB_And_Inst3: carry_and
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_last_beat_no_wait,
      A         => lu_ds_last_beat_all_tag_hit,
      Carry_OUT => lu_ds_last_beat_hit
    );
  
  LU_DS_LB_And_Inst4: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_last_beat_hit,
      A         => lu_check_valid,
      Carry_OUT => lu_ds_last_beat_valid_hit
    );
  
  lookup_ds_lb_no_transaction     <= '1' when ( lu_check_info.Barrier = C_BAR_MEMORY_BARRIER  ) or
                                              ( lu_check_info.Barrier = C_BAR_SYNCHRONIZATION ) or
                                              ( lu_check_info.KillHit = '1'                   ) else
                                     '0';
  LU_DS_LB_And_Inst5: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_last_beat_valid_hit,
      A_N       => lookup_ds_lb_no_transaction,
      Carry_OUT => lu_ds_last_beat_valid
    );
  
  LU_DS_LB_And_Inst6: carry_compare_const
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET,
      C_SIGNALS => 2,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => lu_ds_last_beat_valid,      -- [in  std_logic]
      A_Vec     => lu_ds_last_beat_rd_locked,  -- [in  std_logic_vector]
      Carry_Out => lu_ds_last_beat_stall_pre   -- [out std_logic]
    );
  
--  lu_ds_lb_delayed_restart <= ( ( lud_step_allow_read_step and lud_mem_conflict ) or 
--                                ( lud_step_delayed_restart                      ) ) and 
--                              lud_addr_pipeline_full;
--  LU_DS_LB_Or_Inst0: carry_or
--    generic map(
--      C_TARGET  => C_TARGET
--    )
--    port map(
--      Carry_IN  => lu_ds_last_beat_stall_pre,
--      A         => lu_ds_lb_delayed_restart,
--      Carry_OUT => lu_ds_last_beat_stall
--    );
  -- lud_step_allow_read_step contains conflict signal which prevents it from 
  -- being used as an input to the carry chain. Must be appended with regular
  -- or to avoid frequency regression.
  -- Create several local partial expressions in order to guide synthesis toward
  -- a better implementation.

  lu_ds_last_beat_stall <= ( (     lu_ds_last_beat_stall_pre  ) and 
                             ( not lu_check_shared_force_miss ) and 
                             ( not lu_check_error_force_miss  ) ) or 
                           ( lu_ds_lb_delayed_restart_normal                                      ) or 
                           ( lu_ds_lb_delayed_restart_conflict and not lookup_protect_conflict    ) ;

  lud_step_allow_read_step_normal <= ( lookup_read_hit and not lookup_true_locked_read and not lud_mem_already_used ) or 
                                     ( lud_step_want_mem_step );
                                     
  lu_ds_lb_delayed_restart_normal <= ( ( lud_step_allow_read_step_normal and lud_mem_conflict ) or 
                                       ( lud_step_delayed_restart                      ) ) and 
                                     lud_addr_pipeline_full;

--  lud_step_allow_read_step_conf   <= ( lookup_read_miss and lu_mem_valid and not lu_mem_info.Wr and lookup_restart_mem );
--  lu_ds_lb_delayed_restart_conflict <= lud_step_allow_read_step_conf and lud_mem_conflict and lud_addr_pipeline_full;

  -- Check for Miss.
  LU_DS_RS_And_Inst1: carry_compare_const
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => '1',                       -- [in  std_logic]
      A_Vec     => lu_check_tag_hit_copy_rs, -- [in  std_logic_vector]
      Carry_Out => lu_ds_rs_miss              -- [out std_logic]
    );
  
  -- Check for read miss.
  lu_ds_rs_read_valid <= lu_check_valid and not lu_check_info.Wr and not lu_check_info.KillHit;
  
  LU_DS_RS_And_Inst2: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_rs_miss,
      A         => lu_ds_rs_read_valid,
      Carry_OUT => lu_ds_rs_read_miss
    );
  
  -- Check for Allow Read Step (with no Mem restart).
  lu_ds_rs_new_valid  <= lu_mem_valid and not lu_mem_info.Wr;
  
  LU_DS_RS_And_Inst3: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_rs_read_miss,
      A         => lu_ds_rs_new_valid,
      Carry_OUT => lu_ds_rs_new_read_no_rs
    );

  -- Check for Delayed Restart (with no Mem restart).
  lu_ds_rs_valid_restart  <= lud_mem_conflict and lud_addr_pipeline_full;

  LU_DS_RS_And_Inst4: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_rs_new_read_no_rs,
      A         => lu_ds_rs_valid_restart,
      Carry_OUT => lu_ds_rs_del_restart_no_rs
    );

  -- Apply Mem restart qulifier.
  -- lookup_restart_mem      <= lu_mem_protect_conflict and not lookup_protect_conflict and 
  --                            not lookup_restart_mem_done;

  lu_ds_rs_valid_mem_restart  <= lu_mem_protect_conflict and not lookup_restart_mem_done;

  LU_DS_RS_And_Inst5: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_ds_rs_del_restart_no_rs,
      A         => lu_ds_rs_valid_mem_restart,
      Carry_OUT => lu_ds_lb_delayed_restart_conflict
    );

  
  -----------------------------------------------------------------------------
  -- Control Lookup TAG
  -- 
  -- Generate normal Fetch or Locked Write bypass Tag address that shall be
  -- looked up.
  -----------------------------------------------------------------------------
  
  lookup_tag_addr       <= lookup_tag_addr_i;
  lookup_tag_addr_i     <= lu_check_tag_addr when ( lu_fetch_protect_conflict = '1' ) else 
                           lu_mem_tag_addr   when ( lookup_restart_mem        = '1' ) else 
                           lu_fetch_tag_addr;
  lookup_tag_en         <= lookup_tag_en_i;
  
--  lookup_tag_en_i       <= lu_fetch_piperun or lu_fetch_protect_conflict or lookup_restart_mem;
  lu_fetch_restart_or_lck_wr_conf  <= lu_fetch_protect_conflict or lookup_restart_mem;
  LU_Tag_En_Latch_Inst1: carry_latch_or
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => lu_fetch_piperun,
      A         => lu_fetch_restart_or_lck_wr_conf,
      O         => lookup_tag_en_i,
      Carry_OUT => lu_fetch_piperun_i
    );
  
  lookup_tag_we         <= (others=>'0');
  lookup_tag_new_word   <= (others=>C_NULL_WAY_LINE_TAG);

  
  -----------------------------------------------------------------------------
  -- Control Lookup DATA
  -- 
  -- Control the Lookup ports of Data memory for all Ways, i.e. Read
  -- and Write to the Way that has the Hit/Miss.
  -- 
  -- The Data Line and Way addresses is not the same as the Tag Line and Way 
  -- addresses because the Data Memory is accessed in different pipe stages
  -- (Mem & Check) compared to the Tag Memory (Fetch).
  -- 
  -- Read Ways has to be activated early if the pipe is not in delayed read 
  -- mode. 
  -- 
  -- Write has to be delayed until any Lock has been resolved (to avoid
  -- corrupting the BRAM contents due to multiple write).
  -----------------------------------------------------------------------------
  
  lookup_data_sel_check_addr  <= ( lookup_access_data_late ) or 
                                 ( lookup_read_hit         );
  lookup_data_addr            <= lookup_data_addr_i;
  lookup_data_addr_i          <= lu_mem_data_addr when lud_step_use_check = '0' else 
                                 lu_check_data_addr;
  lu_mem_info_wr_vec          <= (others => lu_mem_info.Wr);
  lu_check_info_wr_wayvec     <= (others => lu_check_info.Wr);
  lud_mem_waiting_for_pipe_vec <= (others => lud_mem_waiting_for_pipe);
  lookup_data_en_read         <= (     lu_check_tag_hit        and 
                                   not lu_check_info_wr_wayvec )
                                    when ( lud_step_use_check = '1' ) else 
                                 ( not lu_mem_info_wr_vec           and
                                   not lud_mem_waiting_for_pipe_vec );
  lu_check_wait_for_update_pspvec <= (others => lu_check_wait_for_update);
  lud_step_unlock_rerun_vec   <= (others => lud_step_unlock_rerun);
  need_insert_read_trans_vec  <= (others => need_insert_read_trans);
  lu_chkins_insert_done_vec   <= (others => lu_chkins_insert_done);
  lookup_data_en_any_write    <= lu_check_tag_hit_all and 
                                 ( not lu_check_wait_for_update ) and 
                                 ( not need_insert_read_trans   ) and 
                                 ( not lu_chkins_insert_done    );
  lookup_data_en_write        <= lu_check_tag_hit and 
                                 ( not lu_check_wait_for_update_pspvec ) and 
                                 ( not need_insert_read_trans_vec      ) and 
                                 ( not lu_chkins_insert_done_vec       );
  lookup_data_en              <= lookup_data_en_i;
  lookup_data_en_sel          <= lookup_data_en_read or lookup_data_en_write or lud_step_unlock_rerun_vec;
  lookup_data_we              <= lookup_data_we_i;
  lookup_write_hit_valid_vec  <= (others => lookup_write_hit_valid);
  lu_check_allow_write_vec    <= (others => lu_check_allow_write);
  lu_check_wait_for_update_bevec <= (others => lu_check_wait_for_update);
  lookup_data_we_i            <= access_be_word_i and lookup_write_hit_valid_vec and 
                                 lu_check_allow_write_vec and 
                                 not lu_check_wait_for_update_bevec;
  lookup_data_new_word        <= lookup_data_new_word_i;
  
  LU_Data_WE_Or_Inst1: carry_vec_or
    generic map(
      C_TARGET  => C_TARGET,
      C_INPUTS  => 1,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_IN  => '0',
      A_Vec     => lu_check_tag_hit,
      Carry_OUT => lu_check_tag_hit_all_carry
    );
  
  LU_Data_WE_And_Inst1: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lu_check_tag_hit_all_carry,
      A         => lu_check_valid,
      Carry_OUT => lookup_raw_hit_carry2
    );
  
  write_hit_other_conflict  <= need_insert_read_trans     or 
                               lu_chkins_insert_done      or
                               lu_check_shared_force_miss or 
                               lu_check_error_force_miss;
  LU_Data_WE_And_Inst2: carry_and_n
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_raw_hit_carry2,
      A_N       => write_hit_other_conflict,
      Carry_OUT => lookup_hit_carry
    );
  
  LU_Data_WE_And_Inst3: carry_and
    generic map(
      C_TARGET  => C_TARGET
    )
    port map(
      Carry_IN  => lookup_hit_carry,
      A         => lu_check_info.Wr,
      Carry_OUT => lookup_write_hit_carry
    );
  
  LU_Data_WE_And_Inst4: carry_select_and_n
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_INTERNAL_PORTS
    )
    port map(
      Carry_In  => lookup_write_hit_carry,
      No        => lookup_write_port,
      A_Vec     => update_write_miss_busy,
      Carry_Out => lookup_write_hit_no_busy
    );
  
  LU_Data_WE_Const_Inst1: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => lookup_write_hit_no_busy,    -- [in  std_logic]
      A_Vec     => lu_check_locked_write,      -- [in  std_logic_vector]
      Carry_Out => lookup_write_hit_no_conflict -- [out std_logic]
    );
  
  LU_Data_WE_And_Inst5: carry_select_and
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_INTERNAL_PORTS
    )
    port map(
      Carry_In  => lookup_write_hit_no_conflict,
      No        => lookup_write_port,
      A_Vec     => access_data_valid,
      Carry_Out => lookup_write_hit_valid
    );
  
  
  -----------------------------------------------------------------------------
  -- Cache Hit & Miss Detect (Memory)
  -- 
  -- Pre-decode all Ways separately from storage before forwarding to 
  -- the next pipeline stage.
  -----------------------------------------------------------------------------
  
  -- Generate current address to check against because Mem can be poisoned by next transaction.
  lu_mem_cur_wr_allocate    <= lu_check_write_alloc                   when ( lu_mem_protect_conflict ) = '1' else 
                               lu_mem_write_alloc;
  lu_mem_cur_force_hit      <= lu_check_info.Force_Hit                when ( lu_mem_protect_conflict ) = '1' else 
                               lu_mem_info.Force_Hit;
  lu_mem_cur_write          <= lu_check_info.Wr                       when ( lu_mem_protect_conflict ) = '1' else 
                               lu_mem_info.Wr;
  lu_mem_cur_addr           <= lu_check_info.Addr(C_ADDR_TAG_POS)     when ( lu_mem_protect_conflict ) = '1' else 
                               lu_mem_info.Addr(C_ADDR_TAG_POS);
  lu_mem_cur_secure         <= lu_check_info.Prot(C_PROT_SECURE_POS)  when ( lu_mem_protect_conflict ) = '1' else 
                               lu_mem_info.Prot(C_PROT_SECURE_POS);
  lu_mem_valid_or_conflict  <= ( lu_mem_valid or lu_mem_protect_conflict );
  
  -- Instantiate TAG Checks for all Ways.
  Gen_Set_Cachehit_Mem: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    -- Extract Tag status bits.
    lu_mem_valid_bits(K)  <= lookup_tag_current_word(K).Valid  and not ( lu_mem_snoop_made_invalid(K) and 
                                                                         not lu_mem_protect_conflict )
                                                               and not ( lu_mem_removed_way(K)        and 
                                                                         not lu_mem_protect_conflict );
    lu_mem_secure_bits(K) <= lookup_tag_current_word(K).Secure;
    lu_mem_unique_bits(K) <=(lookup_tag_current_word(K).Unique and not ( lu_mem_snoop_made_shared(K)  and 
                                                                         not lu_mem_protect_conflict ) ) or
                            (                                          ( lu_mem_made_unique(K)        and      
                                                                         not lu_mem_protect_conflict ) );
    lu_mem_reused_bits(K) <= lookup_tag_current_word(K).Reused and not ( lu_mem_released_lock(K)      and 
                                                                         not lu_mem_protect_conflict );
    lu_mem_dirty_bits(K)  <= lookup_tag_current_word(K).Dirty  and not ( lu_mem_snoop_made_clean(K)   and 
                                                                         not lu_mem_protect_conflict );
    lu_mem_locked_bits(K) <= lookup_tag_current_word(K).Locked and not ( lu_mem_released_lock(K)      and 
                                                                         not lu_mem_protect_conflict );
    
    -- Check cacheline address and valid (force hit when requested).
--    lu_mem_valid_tag(K)    <= lu_mem_valid_bits(K) when 
--                                 lu_mem_cur_addr = lookup_tag_current_word(K).Addr(C_ADDR_TAG_POS) and
--                                 lu_mem_cur_force_hit = '0' else
--                               '1' when 
--                                 ( lu_mem_cur_force_hit and lu_mem_force_way = K )
--                               else '0';
    LU_Tag_And_Inst1: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => '1',
        A         => lu_mem_valid_bits(K),
        Carry_OUT => lu_mem_valid_carry(K)
      );
    
    LU_Tag_Compare_Inst1: carry_compare
      generic map(
        C_TARGET  => C_TARGET,
        C_SIZE    => C_NUM_ADDR_TAG_BITS
      )
      port map(
        A_Vec     => lu_mem_cur_addr,
        B_Vec     => lookup_tag_current_word(K).Addr(C_ADDR_TAG_POS),
        Carry_In  => lu_mem_valid_carry(K),
        Carry_Out => lu_mem_pre_pure_valid_tag(K)
      );
    
    Use_Mem_Secure: if ( C_ENABLE_NON_SECURE > 0 ) generate
      signal local_secure_check : std_logic;
    begin
      local_secure_check  <= not ( lookup_tag_current_word(K).Secure xor lu_mem_cur_secure );
      
      LU_Tag_Compare_Inst2: carry_and
        generic map(
          C_TARGET  => C_TARGET
        )
        port map(
          Carry_IN  => lu_mem_pre_pure_valid_tag(K),
          A         => local_secure_check,
          Carry_OUT => lu_mem_pure_valid_tag(K)
        );
        
    end generate Use_Mem_Secure;
    No_Mem_Secure: if ( C_ENABLE_NON_SECURE = 0 ) generate
    begin
      lu_mem_pure_valid_tag(K) <= lu_mem_pre_pure_valid_tag(K);
      
    end generate No_Mem_Secure;
    
    lu_mem_force_valid(K)  <= lu_mem_cur_force_hit when ( lu_mem_force_way = K ) else 
                               '0';
    LU_Tag_And_Inst2: carry_and_n
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_pure_valid_tag(K),
        A_N       => lu_mem_cur_force_hit,
        Carry_OUT => lu_mem_masked_valid_tag(K)
      );
    
    LU_Tag_Or_Inst1: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_masked_valid_tag(K),
        A         => lu_mem_force_valid(K),
        Carry_OUT => lu_mem_valid_tag(K)
      );
    
    -- Determine if hit.
--    lu_mem_tag_hit(K)      <= ( lu_mem_valid or lu_mem_protect_conflict ) and lu_mem_valid_tag(K);
    LU_Tag_And_Inst3: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_valid_tag(K),
        A         => lu_mem_valid_or_conflict,
        Carry_OUT => lu_mem_tag_hit(K)
      );
    LU_Tag_And_Inst3b: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_pc(K)
      );
    LU_Tag_And_Inst3c: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_pc(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_md(K)
      );
    LU_Tag_And_Inst3d: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_md(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_wm(K)
      );
    LU_Tag_And_Inst3e: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_wm(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_ds(K)
      );
    LU_Tag_And_Inst3f: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_ds(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_lb(K)
      );
    LU_Tag_And_Inst3g: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_lb(K),
        A         => '1',
        Carry_OUT => lu_mem_tag_hit_copy_rs(K)
      );
    
    -- Determine if miss.
    lu_mem_tag_miss(K)     <= ( lu_mem_valid or lu_mem_protect_conflict ) and not lu_mem_valid_tag(K) and 
                               not lu_mem_cur_force_hit;
    
    -- Determine if locked hit (but not for forced hit).
--    lu_mem_locked_hit(K)   <= lu_mem_locked_bits(K) and lu_mem_tag_hit(K) and not lu_mem_cur_force_hit;
    lu_mem_sel_locked(K) <= lu_mem_locked_bits(K) and not lu_mem_cur_force_hit;
    LU_Tag_And_Inst4: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_tag_hit_copy_rs(K),
        A         => lu_mem_sel_locked(K),
        Carry_OUT => lu_mem_locked_hit(K)
      );
    LU_Tag_And_Inst4b: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_locked_hit(K),
        A         => '1',
        Carry_OUT => lu_mem_locked_hit_copy_lb(K)
      );
    
    -- Determine Write Locked hit.
--    lu_mem_locked_write(K) <= lu_mem_cur_write and lu_mem_locked_hit(K);
    LU_Tag_And_Inst5: carry_and
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_locked_hit_copy_lb(K),
        A         => lu_mem_cur_write,
        Carry_OUT => lu_mem_locked_write(K)
      );
    
    -- Determine if Line is Protected.
--    lu_mem_protected(K)  <= lu_mem_locked_write(K) or 
--                            ( ( lu_mem_valid or lu_mem_protect_conflict ) and not lu_mem_cur_force_hit and 
--                              ( lu_mem_valid_bits(K) and lu_mem_locked_bits(K) and lu_mem_dirty_bits(K) ) );
    lu_mem_valid_protect(K) <= ( ( lu_mem_valid or lu_mem_protect_conflict ) and not lu_mem_cur_force_hit and 
                                 ( lu_mem_valid_bits(K) and lu_mem_locked_bits(K) and lu_mem_dirty_bits(K) ) );
    LU_Tag_Or_Inst2: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_locked_write(K),
        A         => lu_mem_valid_protect(K),
        Carry_OUT => lu_mem_protected_pre1(K)
      );
    
    lu_mem_other_protect(K)   <= ( ( lu_mem_valid or lu_mem_protect_conflict ) and 
                                   ( lu_mem_cur_wr_allocate and lu_mem_valid_bits(K) and lu_mem_reused_bits(K)) );
    LU_Tag_Or_Inst3: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_protected_pre1(K),
        A         => lu_mem_other_protect(K),
        Carry_OUT => lu_mem_protected_pre2(K)
      );
    
    lu_mem_mst_protect(K)     <= ( ( lu_mem_valid or lu_mem_protect_conflict ) and not lu_mem_cur_force_hit and  
                                   ( lu_mem_valid_bits(K) and lu_mem_locked_bits(K) and not lu_mem_cur_write ) )
                                      when ( is_mst_coherent(C_ENABLE_COHERENCY) ) else
                                 '0';
    LU_Tag_Or_Inst4: carry_or
      generic map(
        C_TARGET  => C_TARGET
      )
      port map(
        Carry_IN  => lu_mem_protected_pre2(K),
        A         => lu_mem_mst_protect(K),
        Carry_OUT => lu_mem_protected(K)
      );
    
  end generate Gen_Set_Cachehit_Mem;
  
  -- Check if the release if for current Set.
  lu_mem_update_line_match  <= lu_mem_valid and update_lock_release and
                               b2s(lu_mem_info.Addr(C_ADDR_LINE_POS) = update_release_tag.Addr(C_ADDR_LINE_POS) );
  lu_mem_update_data_match  <= lu_mem_update_line_match and
                               b2s(lu_mem_info.Addr(C_ADDR_WORD_POS) = update_release_tag.Addr(C_ADDR_WORD_POS) );
  
  -- When the allocation is completed the lock will seize to make transaction 
  -- invisible and the snoop will have it's full effect.
  Gen_Mem_Lock_Release : process (update_lock_release, update_lock_way, lu_mem_update_line_match,
                                  update_release_tag) is
  begin  -- process Gen_Mem_Lock_Release
    lu_mem_removing_way     <= (others=>'0');
    lu_mem_making_unique    <= (others=>'0');
    lu_mem_releasing_lock   <= (others=>'0');
    
    if( s2b(lu_mem_update_line_match) ) then
      lu_mem_removing_way(update_lock_way)    <= not update_release_tag.Valid;
      lu_mem_making_unique(update_lock_way)   <=     update_release_tag.Unique;
      lu_mem_releasing_lock(update_lock_way)  <=     update_lock_release;
    end if;
  end process Gen_Mem_Lock_Release;
  
  Gen_Mem_Keep_Locked_Release : process (ACLK) is
  begin  -- process Gen_Mem_Keep_Locked_Release
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        lu_mem_removed_way_hold   <= (others=>'0');
        lu_mem_made_unique_hold   <= (others=>'0');
        lu_mem_release_lock_hold  <= (others=>'0');
        
      elsif( lu_fetch_piperun = '1' ) then
        lu_mem_removed_way_hold   <= (others=>'0');
        lu_mem_made_unique_hold   <= (others=>'0');
        lu_mem_release_lock_hold  <= (others=>'0');
          
      else
        for K in 0 to C_NUM_WAYS - 1 loop
          if( s2b(lu_mem_removing_way(K)) ) then
            lu_mem_removed_way_hold(K)  <= '1';
          end if;
          if( s2b(lu_mem_making_unique(K)) ) then
            lu_mem_made_unique_hold(K)  <= '1';
          end if;
          if( s2b(lu_mem_releasing_lock(K)) ) then
            lu_mem_release_lock_hold(K) <= '1';
          end if;
        end loop;
      end if;
    end if;
  end process Gen_Mem_Keep_Locked_Release;
  
  -- Combine action this cycle with what has happened during rest of this pipestage.
  lu_mem_removed_way    <= lu_mem_removing_way   or lu_mem_removed_way_hold;
  lu_mem_made_unique    <= lu_mem_making_unique  or lu_mem_made_unique_hold;
  lu_mem_released_lock  <= lu_mem_releasing_lock or lu_mem_release_lock_hold;
  
  
  -- Check if the release if for current Set.
  lu_check_update_line_match  <= lu_check_valid and update_lock_release and
                                 b2s(lu_check_info.Addr(C_ADDR_LINE_POS) = update_release_tag.Addr(C_ADDR_LINE_POS) );
  lu_check_update_data_match  <= lu_check_update_line_match and
                                 b2s(lu_check_info.Addr(C_ADDR_WORD_POS) = update_release_tag.Addr(C_ADDR_WORD_POS) );
  
  -- When the allocation is completed the lock will seize to make transaction 
  -- invisible and the snoop will have it's full effect.
  Gen_Check_Lock_Release : process (update_lock_release, update_lock_way, lu_check_update_line_match,
                                  update_release_tag) is
  begin  -- process Gen_Check_Lock_Release
    lu_check_removing_way     <= (others=>'0');
    lu_check_making_unique    <= (others=>'0');
    lu_check_releasing_lock   <= (others=>'0');
    
    if( s2b(lu_check_update_line_match) ) then
      lu_check_removing_way(update_lock_way)    <= not update_release_tag.Valid;
      lu_check_making_unique(update_lock_way)   <=     update_release_tag.Unique;
      lu_check_releasing_lock(update_lock_way)  <=     update_lock_release;
    end if;
  end process Gen_Check_Lock_Release;
  
  Gen_Check_Keep_Locked_Release : process (ACLK) is
  begin  -- process Gen_Check_Keep_Locked_Release
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then           -- synchronous reset (active high)
        lu_check_removed_way_hold   <= (others=>'0');
        lu_check_made_unique_hold   <= (others=>'0');
        lu_check_release_lock_hold  <= (others=>'0');
        
      elsif( lu_mem_piperun = '1' ) then
        lu_check_removed_way_hold   <= (others=>'0');
        lu_check_made_unique_hold   <= (others=>'0');
        lu_check_release_lock_hold  <= (others=>'0');
          
      else
        for K in 0 to C_NUM_WAYS - 1 loop
          if( s2b(lu_check_removing_way(K)) ) then
            lu_check_removed_way_hold(K)  <= '1';
          end if;
          if( s2b(lu_check_making_unique(K)) ) then
            lu_check_made_unique_hold(K)  <= '1';
          end if;
          if( s2b(lu_check_releasing_lock(K)) ) then
            lu_check_release_lock_hold(K) <= '1';
          end if;
        end loop;
      end if;
    end if;
  end process Gen_Check_Keep_Locked_Release;
  
  -- Combine action this cycle with what has happened during rest of this pipestage.
  lu_check_removed_way    <= lu_check_removing_way   or lu_check_removed_way_hold;
  lu_check_made_unique    <= lu_check_making_unique  or lu_check_made_unique_hold;
  lu_check_released_lock  <= lu_check_releasing_lock or lu_check_release_lock_hold;
  
  
  -----------------------------------------------------------------------------
  -- Cache Hit & Miss Detect (Check)
  -- 
  -- Generate hit and miss information for all associative ways in the
  -- Check pipe stage, such as:
  --  * Hit or Miss
  --  * Hit Way number
  --  * Type of Hit or Miss: read, write, locked, dirty
  -- 
  -- Event              Action
  --  Write Miss        N/A
  --  Write Hit (first) Update Tag:
  --                      Read to get information (Addr)
  --                      Write to make it dirty (keeping the Addr)
  --  Write Hit         N/A
  --  Read Hit          N/A
  --  Read Miss         Write new contents (Locked)
  --  Read Miss Dirty   Swap Tag:
  --                      Read to get address for the Evicted data
  --                      Write new Address etc. (Locked)
  --  
  -----------------------------------------------------------------------------
  
  -- Add remaining hit signals
  lu_check_tag_hit_all    <= reduce_or(lu_check_tag_hit);
  lu_check_tag_miss_all   <= not lu_check_tag_hit_all;
  
  -- Detect cacheline status.
  lookup_raw_hit          <= lu_check_valid and lu_check_tag_hit_all;
  lookup_hit              <= lookup_raw_hit and 
                             ( not lu_check_info.KillHit      ) and 
                             ( not lu_check_shared_force_miss ) and
                             ( not lu_check_error_force_miss  );
  lookup_raw_miss         <= ( lu_check_valid and lu_check_tag_miss_all );
-- TODO: possible to remove lookup_raw_hit from equation?
  lookup_miss             <= lookup_raw_miss or 
                             ( lookup_raw_hit and lu_check_info.KillHit      ) or 
                             ( lookup_raw_hit and lu_check_shared_force_miss ) or 
                             ( lookup_raw_hit and lu_check_error_force_miss  );
  
  lookup_evict_hit        <= lookup_raw_hit and lu_check_info.Evict;
  
  lookup_read_hit         <= lookup_hit  and not lu_check_info.Wr and not lu_check_info.KillHit;
  lookup_read_miss        <= lookup_miss and not lu_check_info.Wr and not lu_check_info.KillHit;
  lookup_read_miss_dirty  <= lookup_miss_dirty and not lu_check_info.Wr;
  
  lookup_write_hit        <= lookup_hit  and     lu_check_info.Wr;
  lookup_write_miss       <= lookup_miss and     lu_check_info.Wr;
  lookup_write_miss_dirty <= lookup_miss_dirty and     lu_check_info.Wr;
  
  lookup_locked_wr_hit_raw<= lookup_raw_hit   and lu_check_info.Wr and reduce_or(lu_check_locked_write);
  lookup_locked_write_hit <= lookup_hit       and lu_check_info.Wr and reduce_or(lu_check_locked_write);
  lookup_locked_read_hit  <= lookup_read_hit  and ( lookup_protect_conflict or reduce_or(lu_check_locked_hit) );
  lookup_first_write_hit  <= lookup_write_hit and not lu_check_dirty_bits(lu_check_way);
  
  lookup_true_locked_read <= ( lookup_read_hit and reduce_or(lu_check_locked_hit) );
  
  lookup_block_reuse      <= lookup_read_miss and lu_check_reused_bits(lu_check_old_tag_idx);
    
  
  -----------------------------------------------------------------------------
  -- Detect Miss Dirty
  -----------------------------------------------------------------------------
  
--  lookup_miss_dirty       <= lookup_miss and 
--                             ( ( lu_check_info.Allocate and not lookup_raw_hit and 
--                                 lu_check_dirty_bits(to_integer(unsigned(lookup_new_tag_assoc_way))) ) or
--                               ( lookup_raw_hit and  lu_check_dirty_bits(lu_check_way) ) );
  
  -- Generate Dirty for fully utilized ways.
  lru_md_way <= to_integer(unsigned(lru_check_next_way));
  LU_MD_Or_Inst1: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_In  => '0',
      No        => lru_md_way,
      A_Vec     => lu_check_dirty_bits,
      Carry_Out => lru_dirty_bit
    );
  
  -- Turn off Full LRU if there is (at least) one free Way.
  lu_check_valid_vec  <= (others => lu_check_valid);
  md_valid_qualified  <= lu_check_valid_vec and lu_check_valid_bits;
  LU_MD_And_Inst1: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'1')
    )
    port map(
      Carry_In  => lru_dirty_bit,             -- [in  std_logic]
      A_Vec     => md_valid_qualified,     -- [in  std_logic_vector]
      Carry_Out => dirty_bit_miss             -- [out std_logic]
    );
  
  -- Turn off Miss related dirty bit if this is a hit.
  LU_MD_And_Inst2: carry_compare_const
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => dirty_bit_miss,            -- [in  std_logic]
      A_Vec     => lu_check_tag_hit_copy_md,  -- [in  std_logic_vector]
      Carry_Out => dirty_bit_miss_valid       -- [out std_logic]
    );
  
  -- Help signal for Valid pipestage with allocating transaction (miss).
  md_valid_alloc_miss <= lu_check_valid and lu_check_info.Allocate;
  
  -- Valid dirty bit for a miss.
  LU_MD_And_Inst3: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => dirty_bit_miss_valid,      -- [in  std_logic]
      A         => md_valid_alloc_miss,       -- [in  std_logic]
      Carry_OUT => dirty_miss_valid           -- [out std_logic]
    );
  
  -- Generate help signal for dirty hit.
  md_hit_dirty  <= lu_check_tag_hit_copy_md and lu_check_dirty_bits;
  
  -- Valid dirty bit for hit or miss.
  LU_MD_Or_Inst3: carry_vec_or
    generic map(
      C_TARGET  => C_TARGET,
      C_INPUTS  => 2,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_IN  => dirty_miss_valid,
      A_Vec     => md_hit_dirty,
      Carry_OUT => dirty_bit
    );
  
  -- Help signal for detecting if this is a valid hit ot miss.
  lu_check_info_evict_vec <= (others => lu_check_info.Evict);
  md_valid_hit_miss       <= lu_check_tag_hit and not lu_check_info_evict_vec;
  
  -- Generate valid dirty bit.
  LU_MD_And_Inst4: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 2,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => dirty_bit,                 -- [in  std_logic]
      A_Vec     => md_valid_hit_miss,         -- [in  std_logic_vector]
      Carry_Out => dirty_bit_valid            -- [out std_logic]
    );
  
  -- Validate (step 1/2)
  md_check_valid <= not ( lu_check_info.KillHit and lu_check_info.SnoopResponse );
  LU_MD_And_Inst5: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => dirty_bit_valid,           -- [in  std_logic]
      A         => md_check_valid,            -- [in  std_logic]
      Carry_OUT => lookup_miss_dirty_pre      -- [out std_logic]
    );
  
  -- Validate (step 2/2)
  LU_MD_And_Inst6: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lookup_miss_dirty_pre,     -- [in  std_logic]
      A         => lu_check_valid,            -- [in  std_logic]
      Carry_OUT => lookup_miss_dirty          -- [out std_logic]
    );
  
  
  -----------------------------------------------------------------------------
  -- Detect Protected Conflict
  -----------------------------------------------------------------------------
  
--  lookup_protect_conflict <= lu_check_valid and 
--                             ( ( ( ( lu_check_info.Allocate and lookup_raw_miss and 
--                                     lu_check_protected(to_integer(unsigned(lookup_new_tag_assoc_way))) ) or
--                                   ( lookup_raw_hit and lu_check_protected(lu_check_way) ) ) and
--                                 ( not ( lu_mem_protect_conflict_d1 and not lu_check_protected(lu_check_protected_way) ) ) ) or
--                               ( protect_shared_write ) );
  
  lru_pc_way <= to_integer(unsigned(lru_check_next_way));
  LU_PC_Or_Inst1: carry_select_or
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_In  => '0',
      No        => lru_pc_way,
      A_Vec     => lu_check_protected,
      Carry_Out => lru_protected_bit
    );
  
  LU_PC_And_Inst1: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'1')
    )
    port map(
      Carry_In  => lru_protected_bit,         -- [in  std_logic]
      A_Vec     => lu_check_valid_bits,      -- [in  std_logic_vector]
      Carry_Out => protected_bit_miss         -- [out std_logic]
    );
  
  LU_PC_And_Inst2: carry_compare_const
    generic map(
      C_KEEP    => true,
      C_TARGET  => C_TARGET,
      C_SIGNALS => 1,
      C_SIZE    => C_NUM_WAYS,
      B_Vec     => (C_WAY_POS=>'0')
    )
    port map(
      Carry_In  => protected_bit_miss,        -- [in  std_logic]
      A_Vec     => lu_check_tag_hit_copy_pc, -- [in  std_logic_vector]
      Carry_Out => protected_bit_miss_valid   -- [out std_logic]
    );
  
  pc_valid_alloc_miss <= lu_check_valid and lu_check_info.Allocate;
  LU_PC_And_Inst3: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => protected_bit_miss_valid,  -- [in  std_logic]
      A         => pc_valid_alloc_miss,       -- [in  std_logic]
      Carry_OUT => protected_miss_valid       -- [out std_logic]
    );
  
  pc_hit_protected  <= lu_check_tag_hit and lu_check_protected;
  LU_PC_Or_Inst3: carry_vec_or
    generic map(
      C_TARGET  => C_TARGET,
      C_INPUTS  => 2,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_IN  => protected_miss_valid,
      A_Vec     => pc_hit_protected,
      Carry_OUT => protected_bit
    );

  lu_mem_protect_conflict_d1_vec  <= (others => lu_mem_protect_conflict_d1);
  pc_filter                       <= ( lu_mem_protect_conflict_d1_vec and not lu_check_protected );
  LU_PC_And_Inst4: carry_select_and_n
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_WAYS
    )
    port map(
      Carry_In  => protected_bit,
      No        => lu_check_protected_way,
      A_Vec     => pc_filter,
      Carry_Out => filtered_protection_bit
    );
  
  LU_PC_Or_Inst4: carry_or
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => filtered_protection_bit,   -- [in  std_logic]
      A         => protect_shared_write,      -- [in  std_logic]
      Carry_OUT => protection_with_coherency  -- [out std_logic]
    );
  
  
  LU_PC_And_Inst5: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => protection_with_coherency, -- [in  std_logic]
      A         => lu_check_valid,            -- [in  std_logic]
      Carry_OUT => lookup_protect_conflict    -- [out std_logic]
    );
  
  
  -----------------------------------------------------------------------------
  -- Read Data Forwarding
  -- 
  -- Select data from current hit and forward it to the current port.
  -----------------------------------------------------------------------------
  
  -- Generate mux structures for read data.
  Use_Par_RdData: if( C_NUM_WAYS > 1 ) generate
  begin
    Use_RTL: if( C_TARGET = RTL ) generate
    begin
      -- Calculate the association address.
      Cachehit_Assoc_Set_Gen: process (lu_check_tag_hit) is
      begin  -- process Cachehit_Assoc_Set_Gen
        lu_check_way  <= 0;
        for K in 1 to C_NUM_WAYS - 1 loop
          if( lu_check_tag_hit(K) = '1' ) then
            lu_check_way  <= K;
          end if;
        end loop; 
      end process Cachehit_Assoc_Set_Gen;
      
      -- Get current Way for hit data.
      lud_mem_way           <= lud_mem_way_d1     when ( lud_mem_keep_single_during_stall = '1' ) or
                                                       ( lud_mem_delayed_read_data        = '1' ) else 
                               lu_check_way;
      
    end generate Use_RTL;
    
    Use_FPGA: if( C_TARGET /= RTL ) generate
    begin
      Use_2: if( C_NUM_WAYS = 2 ) generate
      begin
        -- Calculate the association address.
        lu_check_way         <= 1 when lu_check_tag_hit(1) = '1' else 0;
        
        -- Get current Way for hit data.
        lud_mem_way           <= lud_mem_way_d1     when ( lud_mem_keep_single_during_stall = '1' ) or
                                                         ( lud_mem_delayed_read_data        = '1' ) else 
                                 lu_check_way;
        
      end generate Use_2;
      
      Use_4_8: if( C_NUM_WAYS = 4 or C_NUM_WAYS = 8 ) generate
      
        subtype C_HIT_DETECT_POS            is natural range 3 downto 0;
        subtype HIT_DETECT_TYPE             is std_logic_vector(C_HIT_DETECT_POS);
        type SET_HIT_DETECT_TYPE            is array(C_WAY_BIT_POS) of HIT_DETECT_TYPE;
        
        signal hit_array    : SET_HIT_DETECT_TYPE;
        
        signal way_delayed  : WAY_BIT_TYPE;
        signal read_idx_i0  : WAY_BIT_TYPE;
        signal hit_way_i    : WAY_BIT_TYPE;
        signal read_idx_i   : WAY_BIT_TYPE;
        
      begin
        -- Type conversion.
        way_delayed       <= std_logic_vector(to_unsigned(lud_mem_way_d1, C_WAY_BITS));
        
        -- Generate input to optimized detection.
        Use_4: if( C_NUM_WAYS = 4 ) generate
        begin
          hit_array(1)  <= '0' & '0' & lu_check_tag_hit(3) & lu_check_tag_hit(2);
          hit_array(0)  <= '0' & '0' & lu_check_tag_hit(3) & lu_check_tag_hit(1);
        end generate Use_4;
        Use_8: if( C_NUM_WAYS = 8 ) generate
        begin
          hit_array(2)  <= lu_check_tag_hit(7) & lu_check_tag_hit(6) & lu_check_tag_hit(5) & lu_check_tag_hit(4);
          hit_array(1)  <= lu_check_tag_hit(7) & lu_check_tag_hit(6) & lu_check_tag_hit(3) & lu_check_tag_hit(2);
          hit_array(0)  <= lu_check_tag_hit(7) & lu_check_tag_hit(5) & lu_check_tag_hit(3) & lu_check_tag_hit(1);
        end generate Use_8;
        
        -- Instantiate detection logic.
        Gen_Detect: for K in C_WAY_BIT_POS generate
        begin
          LUT_Inst: LUT6_2
            generic map(
              INIT => X"FFFF0000FFFEFFFE"
            )
            port map(
              O5 => hit_way_i(K),                     -- [out]
              O6 => read_idx_i0(K),                   -- [out]
              I0 => hit_array(K)(0),                  -- [in]
              I1 => hit_array(K)(1),                  -- [in]
              I2 => hit_array(K)(2),                  -- [in]
              I3 => hit_array(K)(3),                  -- [in]
              I4 => way_delayed(K),                   -- [in]
              I5 => lud_mem_keep_single_during_stall  -- [in]
            );
            
          MUXF7_Inst: MUXF7
            port map (
              O  => read_idx_i(K),                -- [out std_logic]
              I0 => read_idx_i0(K),               -- [in  std_logic]
              I1 => way_delayed(K),               -- [in  std_logic]
              S  => lud_mem_delayed_read_data);   -- [in  std_logic]
          
        end generate Gen_Detect;
        
        -- Type conversion.
        lu_check_way  <= to_integer(unsigned(hit_way_i));
        lud_mem_way   <= to_integer(unsigned(read_idx_i));
        
      end generate Use_4_8;
      
    end generate Use_FPGA;
    
  end generate Use_Par_RdData;
  
  -- Only one possible source for data.
  No_Par_RdData: if( C_NUM_WAYS = 1 ) generate
  begin
    lu_check_way  <= 0;
    lud_mem_way   <= 0;
    
  end generate No_Par_RdData;
  
  
  
  -----------------------------------------------------------------------------
  -- Data Pipeline Stage: Step (virtual stage)
  -- 
  -- 
  -----------------------------------------------------------------------------
  
  -- Determine if current beat is read.
--  lud_step_offset_is_read   <= ( lud_step_offset and lud_step_is_read );
  lud_step_is_read          <= ( not lu_check_info.Wr ) when ( lud_step_use_check = '1' ) else
                               ( not lu_mem_info.Wr );
  LUD_Read_PR_And_Inst1: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_step_offset,
      A         => lud_step_is_read,
      Carry_OUT => lud_step_offset_is_read
    );
  
  -- Detect when information from Check stage is used.
  lud_step_use_check        <= lookup_hit and not lu_check_wait_for_update and not lud_mem_already_used and 
                               ( not lud_mem_use_speculative or lu_check_info.Wr );
  
  -- Get current write port number.
  lud_step_write_port_num   <= get_port_num(lu_check_info.Port_Num, C_NUM_INTERNAL_PORTS);
  
  -- Detect when it is allowed to step.
  lud_step_allow_write_step <= ( lookup_write_hit and not lookup_data_hit_stall and not lu_check_wait_for_update and  
                                 access_data_valid(lud_step_write_port_num) );
  lud_step_allow_read_step  <= ( lookup_read_hit and not lookup_true_locked_read and not lud_mem_already_used ) or 
                               ( lookup_read_miss and lu_mem_valid and not lu_mem_info.Wr and lookup_restart_mem ) or
                               ( lud_step_want_mem_step );
  
  -- Generate step for data handling.
--  lud_step_offset           <= ( lud_step_want_step_offset ) and 
--                               not lud_step_stall;
  LUD_Step_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lookup_data_en_ii(C_NUM_WAYS),
      A_N       => lud_step_stall,
      Carry_OUT => lud_step_offset
    );
  
  -- Stall Data Step stage if not ready.
  -- A refresh of the BRAM output should not propagate further.
  lud_step_stall            <= lud_step_unlock_rerun or not ( lud_step_allow_write_step or lud_step_allow_read_step );
  
  
  -- Want read step when (read data is filtered via valid bit instead):
  --  * Read in Check with data remaining 
  --     - Not waiting for Update
  --  * Read in Mem with nothing or done in Check
  -- 
  -- Want write step when:
  --  * Write in Check with data remaining
  --     - Not waiting for Update
  
  lud_step_pos_read_in_mem  <= lu_mem_valid and not lu_mem_info.Wr and not lud_mem_conflict and 
                               not lud_mem_waiting_for_pipe and
                               ( not lookup_write_hit or lu_check_wait_for_update or lud_mem_already_used );
  lud_step_want_check_step  <= ( lu_check_valid and not lu_check_info.Wr and not lud_mem_use_speculative and 
                                 not lu_check_wait_for_update and not lud_mem_already_used and 
                                 not lud_mem_waiting_for_pipe and not lud_mem_conflict );
  lud_step_want_mem_step    <= ( lud_step_pos_read_in_mem and     lu_check_wait_for_update ) or 
                               ( lud_step_pos_read_in_mem and not lookup_hit               ) or 
                               ( lud_step_pos_read_in_mem and     lud_mem_already_used     ) or 
                               ( lud_step_pos_read_in_mem and     lud_mem_use_speculative  ) or 
                               ( lud_step_pos_read_in_mem and not lu_check_valid           );
  lud_step_want_restart     <= ( ( lud_step_allow_read_step and lud_mem_conflict ) or lud_step_delayed_restart ) and 
                               not lud_addr_pipeline_full;
  lud_step_want_read_step   <= lud_step_want_check_step or
                               lud_step_want_mem_step;
  
  lud_step_want_write_step  <= ( lu_check_valid and lu_check_info.Wr and not lu_check_wait_for_update and 
                                 not lud_addr_pipeline_full and not lud_write_hit_done );
  
  -- If the Tag is unlocked and a speculative read has already been started, it need
  -- to refresh the output of the BRAMs to get the new contents.
  lud_step_unlock_rerun     <= lu_mem_update_line_match and lud_mem_waiting_for_pipe;
  
--  lud_step_want_step_offset <= ( lud_addr_piperun or lud_step_want_write_step or lud_step_unlock_rerun ) and 
--                               not lud_step_want_stall;
  lud_step_want_run <= lud_step_unlock_rerun or lud_step_want_write_step;
  LUD_WStep_PR_Or_Inst1: carry_or 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_addr_piperun,
      A         => lud_step_want_run,
      Carry_OUT => lud_step_want_step_offset
    );
-- Disable since no event need to stall
--  LUD_WStep_PR_And_Inst1: carry_and_n 
--    generic map(
--      C_TARGET => C_TARGET
--    )
--    port map(
--      Carry_IN  => lud_step_want_step_pre1,
--      A_N       => lud_step_want_stall,
--      Carry_OUT => lud_step_want_step_offset
--    );
  
  -- Stall Data Step stage if not ready.
  lud_step_want_stall       <= '0';
  
  lookup_data_en_ii(0)      <= lud_step_want_step_offset;
  Gen_Set_Data_En: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    LUD_WStep_PR_And_Inst1: carry_latch_and
      generic map(
        C_TARGET  => C_TARGET,
        C_NUM_PAD => min_of(4, K * 4),
        C_INV_C   => false
      )
      port map(
        Carry_IN  => lookup_data_en_ii(K),
        A         => lookup_data_en_sel(K),
        O         => lookup_data_en_i(K),
        Carry_OUT => lookup_data_en_ii(K+1)
      );
  end generate Gen_Set_Data_En;
  
  -- .
  Data_Pipeline_Stage_Step_Restart : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Step_Restart
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_step_delayed_restart  <= '0';
        
      elsif( lud_step_offset = '1' ) then
        lud_step_delayed_restart  <= '0';
        
      elsif( ( lud_step_allow_read_step and lud_mem_conflict and lud_addr_pipeline_full ) = '1' ) then
        lud_step_delayed_restart  <= '1';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Step_Restart;
  
  
  -----------------------------------------------------------------------------
  -- Data Pipeline Stage: Address
  -- 
  -- 
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  lud_addr_piperun  <= ( lud_mem_piperun or not lud_mem_valid or
--                          lud_addr_rerun_after_conf) and 
--                       not lud_addr_stall;
-- Instead of including 'lud_addr_rerun_after_conf' (i.e. 'lud_step_want_restart') in 
-- the 'lud_step_want_read_step' (i.e. 'lud_addr_stall') is it move after the and_n gate, 
-- to have simpler logic for the and_n and or gates.
  LUD_Addr_PR_Or_Inst1: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_mem_piperun,
      A_N       => lud_mem_valid_pipe,
      Carry_OUT => lud_addr_piperun_pre1
    );
  lud_addr_rerun_after_conf <= lud_step_want_restart;
  LUD_Addr_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_addr_piperun_pre1,
      A_N       => lud_addr_stall,
      Carry_OUT => lud_addr_piperun_pre2
    );
  LUD_Addr_PR_Or_Inst2: carry_or 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_addr_piperun_pre2,
      A         => lud_addr_rerun_after_conf,
      Carry_OUT => lud_addr_piperun
    );
  
  -- Stall Data Address stage if not ready.
  lud_addr_stall    <= not lud_step_want_read_step;
  
  -- Track Write requests.
  Data_Write_Complete_Tracking : process (ACLK) is
  begin  -- process Data_Write_Complete_Tracking
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_write_hit_done  <= '0';
        
      elsif( lu_mem_piperun = '1' ) then
        lud_write_hit_done  <= '0';
        
      elsif( s2b(lu_check_valid)                             and 
             s2b(access_data_valid(lud_step_write_port_num)) and
             s2b(access_data_last(lud_step_write_port_num))  and
             s2b(lookup_write_data_ready_i(lud_step_write_port_num)) ) then
        lud_write_hit_done  <= '1';
        
      end if;
    end if;
  end process Data_Write_Complete_Tracking;
  
  -- Propagate status to next stage when possible.
  Data_Pipeline_Stage_Mem_Valid : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Valid
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_speculative_valid <= '0';
        
      elsif( lud_addr_piperun = '1' ) then
        lud_mem_speculative_valid <= '1';
        
      elsif( lud_mem_piperun = '1' ) then
        lud_mem_speculative_valid <= '0';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Valid;
  
  -- Move information to next stage when possible.
  Data_Pipeline_Stage_Mem : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_rresp             <= C_RRESP_OKAY;
        lud_mem_port_num          <= 0;
        lud_mem_port_one_hot      <= (others=>'0');
        lud_mem_last              <= '0';
        lud_mem_delayed_read_data <= '0';
        
      elsif( lud_addr_piperun = '1' ) then
        lud_mem_rresp             <= C_RRESP_OKAY;
        if( lud_step_use_check = '0' ) then
          if( is_mst_coherent(C_ENABLE_COHERENCY) or 
              is_slv_coherent(C_ENABLE_COHERENCY) or 
              has_ex_mon(C_ENABLE_EX_MON) ) then
            if( lu_mem_info.Exclusive = '1' ) then
              lud_mem_rresp             <= C_RRESP_EXOKAY;
            end if;
          end if;
          if( is_slv_coherent(C_ENABLE_COHERENCY) ) then
            lud_mem_rresp(C_RRESP_ISSHARED_POS)   <= lu_mem_info.IsShared;
            lud_mem_rresp(C_RRESP_PASSDIRTY_POS)  <= lu_mem_info.PassDirty;
          end if;
          lud_mem_port_num          <= get_port_num(lu_mem_info.Port_Num, C_NUM_PORTS);
          lud_mem_port_one_hot      <= std_logic_vector(to_unsigned(2 ** get_port_num(lu_mem_info.Port_Num, C_NUM_PORTS), 
                                                                    C_NUM_PORTS));
        else
          if( is_mst_coherent(C_ENABLE_COHERENCY) or
              is_slv_coherent(C_ENABLE_COHERENCY) or 
              has_ex_mon(C_ENABLE_EX_MON) ) then
            if( lu_check_info.Exclusive = '1' ) then
              lud_mem_rresp             <= C_RRESP_EXOKAY;
            end if;
          end if;
          if( is_slv_coherent(C_ENABLE_COHERENCY) ) then
            lud_mem_rresp(C_RRESP_ISSHARED_POS)   <= lu_check_info.IsShared;
            lud_mem_rresp(C_RRESP_PASSDIRTY_POS)  <= lu_check_info.PassDirty;
          end if;
          lud_mem_port_num          <= get_port_num(lu_check_info.Port_Num, C_NUM_PORTS);
          lud_mem_port_one_hot      <= std_logic_vector(to_unsigned(2 ** get_port_num(lu_check_info.Port_Num, C_NUM_PORTS), 
                                                                    C_NUM_PORTS));
        end if;
        lud_mem_last              <= lookup_step_last;
        lud_mem_delayed_read_data <= ( ( lud_step_use_check and lookup_step_last ) or 
                                       (  lookup_access_data_late ) ) and 
                                     ( lookup_read_hit and not lookup_locked_read_hit and not lud_mem_already_used );
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem;
  
  -- .
  Data_Pipeline_Stage_Set : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Set
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_way_d1            <= 0;
        
      elsif( ( lud_addr_piperun = '1' ) or
             ( lud_mem_completed and not lud_mem_piperun and not lud_mem_keep_single_during_stall and
               lookup_read_hit and not lookup_locked_read_hit ) = '1' ) then
        lud_mem_way_d1            <= lu_check_way;
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Set;
  
  --
  Data_Pipeline_Stage_Mem_Single_Beat : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Single_Beat
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_completed         <= '0';
        
      elsif( lud_addr_piperun = '1' ) then
        lud_mem_completed         <= lu_mem_valid and not lu_mem_info.Wr and lookup_step_last and 
                                     not lud_step_use_check and not lookup_protect_conflict;
        
      elsif( ( lookup_protect_conflict = '1' ) or ( lud_mem_piperun = '1' ) )then
        lud_mem_completed         <= '0';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Single_Beat;
  
  -- Need to control if speculative read in Mem is allowed:
  --  * Speculative read of last (and only beat) directly
  --  * Sliding speculative read of last (and only beat)
  Data_Pipeline_Stage_Mem_Stop_Spec : process (lud_addr_piperun, lu_mem_piperun_i, lookup_protect_conflict, 
                                               lu_mem_valid, lu_mem_info, lookup_step_last, lud_step_use_check, 
                                               lud_mem_waiting_for_pipe, lud_mem_completed, 
                                               lud_mem_use_speculative) is
  begin  -- process Data_Pipeline_Stage_Mem_Stop_Spec
    if( lud_addr_piperun = '1' ) then
      lud_mem_use_spec_cmb  <= lu_mem_valid and not lu_mem_info.Wr and lookup_step_last and 
                               not lud_step_use_check and not lookup_protect_conflict;
      
    elsif( lu_mem_piperun_i = '1' )then
      lud_mem_use_spec_cmb  <= lud_mem_waiting_for_pipe and lud_mem_completed;
      
    elsif( lookup_protect_conflict = '1' )then
      lud_mem_use_spec_cmb  <= '0';
      
    else
      lud_mem_use_spec_cmb  <= lud_mem_use_speculative;
    end if;
  end process Data_Pipeline_Stage_Mem_Stop_Spec;
  
  USpec_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET_I,
      CE        => "1",
      D         => lud_mem_use_spec_cmb,
      Q         => lud_mem_use_speculative
    );
  
  -- 
  Data_Pipeline_Stage_Mem_Prefetch : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Prefetch
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_waiting_for_pipe  <= '0';
        
      elsif( ( lud_addr_piperun and not lud_mem_waiting_for_pipe ) = '1' ) then
        lud_mem_waiting_for_pipe  <= lu_mem_valid and not lu_mem_info.Wr and lookup_offset_all_first and 
                                     not lookup_protect_conflict and not lud_step_use_check and not lu_mem_piperun_i;
        
      elsif( lu_mem_piperun_i = '1' ) then
        lud_mem_waiting_for_pipe  <= '0';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Prefetch;
  
  -- Propagate status to next stage when possible.
  Data_Pipeline_Stage_Mem_Done : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Done
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_already_used  <= '0';
        
      elsif( lu_mem_piperun_i = '1' ) then
        lud_mem_already_used  <= '0';
        
      elsif( ( lud_step_offset and not lookup_locked_read_hit and lud_step_use_check and lookup_step_last and
               lu_check_valid and not lu_check_info.Wr ) = '1' ) then
        lud_mem_already_used  <= '1';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Done;
  
  -- 
  Data_Pipeline_Stage_Mem_Keep : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Keep
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_keep_single_during_stall  <= '0';
        
      elsif( ( lud_mem_completed and not lud_mem_piperun and
               lookup_read_hit and not lookup_locked_read_hit ) = '1' ) then
        lud_mem_keep_single_during_stall  <= '1';
        
      elsif( lud_mem_piperun = '1' ) then
        lud_mem_keep_single_during_stall  <= '0';
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Keep;
  
  --
  Data_Pipeline_Stall : process (ACLK) is
  begin  -- process Data_Pipeline_Stall
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_addr_pipeline_full  <= '0';
        
      else
        lud_addr_pipeline_full  <= -- Data doesn't move and fifo is almost full 
                                   -- => Pipe will be full next cycle.
                                   ( lud_mem_valid and lud_reg_valid and 
                                     read_data_status(lud_reg_port_num).Hit_Almost_Full and 
                                     not read_data_status(lud_reg_port_num).Hit_Pop ) or
                                   -- Data doesn't move and last empty stage will get new data 
                                   -- => Pipe will be full next cycle.
                                   ( lud_step_offset_is_read and not lookup_locked_read_hit and 
                                     not lud_mem_valid and lud_reg_valid and 
                                     read_data_hit_full(lud_reg_port_num) and 
                                     not read_data_status(lud_reg_port_num).Hit_Pop ) or
                                   -- Data doesn't move and last empty stage will speculatively get new data 
                                   -- => Pipe will be full next cycle.
                                   ( lud_step_offset_is_read and lud_step_want_mem_step and not lud_step_use_check and 
                                     not lud_mem_valid and lud_reg_valid and 
                                     read_data_hit_full(lud_reg_port_num) and 
                                     not read_data_status(lud_reg_port_num).Hit_Pop ) or
                                   -- Data (Reg) can move but fifo for Mem is full and doesn't move
                                   -- => Pipe will be full next cycle. 
                                   ( lud_mem_valid and lud_reg_valid and 
                                     read_data_hit_full(lud_mem_port_num) and 
                                     not read_data_status(lud_mem_port_num).Hit_Pop ) or
                                   -- Hole in data pipe is filled and data doesn't move 
                                   -- => Pipe will be full next cycle. 
                                   ( lud_step_offset_is_read and not lookup_locked_read_hit and 
                                     lud_mem_valid and not lud_reg_valid and 
                                     read_data_hit_full(lud_mem_port_num) and 
                                     not read_data_status(lud_mem_port_num).Hit_Pop ) or
                                   -- Hole in data pipe is speculatively filled and data doesn't move 
                                   -- => Pipe will be full next cycle. 
                                   ( lud_step_offset_is_read and lud_step_want_mem_step and not lud_step_use_check and 
                                     lud_mem_valid and not lud_reg_valid and 
                                     read_data_hit_full(lud_mem_port_num) and 
                                     not read_data_status(lud_mem_port_num).Hit_Pop ) or
                                   -- Keep until data can move.
                                   ( lud_addr_pipeline_full and 
                                     read_data_hit_full(lud_reg_port_num) );
        
      end if;
    end if;
  end process Data_Pipeline_Stall;
  
  
  -----------------------------------------------------------------------------
  -- Data Pipeline Stage: Memory
  -- 
  -- 
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  lud_mem_piperun <= ( lud_reg_piperun or not lud_reg_valid ) and 
--                     not lud_mem_stall;
  LUD_Mem_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_reg_piperun,
      A_N       => lud_mem_stall,
      Carry_OUT => lud_mem_piperun
    );
  
  -- Stall Data Memory stage if not ready.
  lud_mem_stall       <= lud_mem_waiting_for_pipe;
  
  -- Determine if stage is truly valid (from a pipeline utilization point-of-view).
  lud_mem_valid_pipe  <= lud_mem_speculative_valid and
                         ( ( lookup_read_hit and not lookup_true_locked_read and not lud_mem_conflict and 
                             not lookup_access_data_late ) or
                           ( lud_mem_delayed_read_data ) or
                           ( lud_mem_keep_single_during_stall ) );
  
  -- Determine if stage is truly valid.
  lud_mem_valid       <= lud_mem_speculative_valid and
                         ( ( lookup_read_hit and not lookup_locked_read_hit and not lud_mem_conflict and 
                             not lookup_access_data_late ) or
                           ( lud_mem_delayed_read_data ) or
                           ( lud_mem_keep_single_during_stall ) );
  
  -- Detect if this was a speculative read with a conflict (potentially old data read).
  Data_Pipeline_Stage_Mem_Conflict : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Mem_Conflict
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_mem_conflict  <= '0';
        
      else
        lud_mem_conflict  <= lookup_protect_conflict;
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Mem_Conflict;

  lud_mem_valid_vec <= (others => lud_mem_valid);

  -- Propagate status to next stage when possible.
  Data_Pipeline_Stage_Reg_Valid : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Reg_Valid
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_reg_valid         <= '0';
        lud_reg_valid_one_hot <= (others=>'0');
        
      elsif( lud_mem_piperun = '1' ) then
        lud_reg_valid         <= lud_mem_valid;
        lud_reg_valid_one_hot <= lud_mem_valid_vec and 
                                 lud_mem_port_one_hot;
        
      elsif( lud_reg_piperun = '1' ) then
        lud_reg_valid         <= '0';
        lud_reg_valid_one_hot <= (others=>'0');
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Reg_Valid;
  
  -- Move information to next stage when possible.
  Data_Pipeline_Stage_Reg : process (ACLK) is
  begin  -- process Data_Pipeline_Stage_Reg
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        lud_reg_rresp         <= C_RRESP_OKAY;
        lud_reg_port_num      <= 0;
        lud_reg_last          <= '0';
        
      elsif( lud_mem_piperun = '1' ) then
        lud_reg_rresp         <= lud_mem_rresp;
        lud_reg_port_num      <= lud_mem_port_num;
        lud_reg_last          <= lud_mem_last;
        
      end if;
    end if;
  end process Data_Pipeline_Stage_Reg;
  
  -- Select data from this pipe stage.
  No_Rd_Pipeline: if( not C_PIPELINE_LU_READ_DATA ) generate
  begin
    lookup_read_data_valid_i  <= lud_mem_valid_vec and 
                                 lud_mem_port_one_hot;
    
    lookup_read_data_last_i   <= lud_mem_last;
    lookup_read_data_word_i   <= lookup_data_current_word;
    lookup_read_data_resp_i   <= lud_mem_rresp;
  end generate No_Rd_Pipeline;
  
  Use_Rd_Pipeline: if( C_PIPELINE_LU_READ_DATA ) generate
  begin
    lookup_read_data_valid_i  <= lud_reg_valid_one_hot;
    lookup_read_data_last_i   <= lud_reg_last;
    lookup_read_data_resp_i   <= lud_reg_rresp;
    
    -- Split to local array.
    Gen_Set_Data_Array: for K in 0 to C_NUM_WAYS - 1 generate
    begin
      Rd_Pipeline : process (ACLK) is
      begin  -- process Rd_Pipeline
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if( lud_mem_piperun = '1' and lud_mem_way /= K  and C_NUM_WAYS > 1 ) then  -- synchronous reset (active high)
            lookup_read_data_word_i(K) <= (C_MAX_DATA_WIDTH - 1 downto 0=>'0');
          elsif( lud_mem_piperun = '1' ) then
            lookup_read_data_word_i(K) <= lookup_data_current_word(K);
          end if;
        end if;
      end process Rd_Pipeline;
      
    end generate Gen_Set_Data_Array;
    
  end generate Use_Rd_Pipeline;
  
  -- Generate RRESP queues per port.
  Gen_Port_RRESP_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    lookup_read_data_info(I).Valid    <= lookup_read_data_valid_i(I);
    lookup_read_data_info(I).Way      <= std_logic_vector(to_unsigned(lud_mem_way, C_MAX_WAYS_BITS));
    lookup_read_data_info(I).Last     <= lookup_read_data_last_i;
    lookup_read_data_info(I).RRESP    <= fit_vec(lookup_read_data_resp_i, C_MAX_RRESP_WIDTH);
    
    Gen_Set_Data_Array: for K in 0 to C_NUM_WAYS - 1 generate
    begin
      lookup_read_data_info(I).Data(K)  <= lookup_read_data_word_i(K);
    end generate Gen_Set_Data_Array;
    Gen_Set_Dummy_Fill: for K in C_NUM_WAYS to C_MAX_WAYS - 1 generate
    begin
      lookup_read_data_info(I).Data(K)  <= (C_MAX_DATA_WIDTH - 1 downto 0=>'1');
    end generate Gen_Set_Dummy_Fill;
    
  end generate Gen_Port_RRESP_Array;
  
  
  
  -----------------------------------------------------------------------------
  -- Data Pipeline Stage: Pipeline
  -- 
  -- Optional pipeline stage that keeps data in one register per Set.
  -- Only one register at the time is allowed to contain data, enabling the 
  -- possibility to use or instead of muxing data.
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  lud_reg_piperun <= not lud_reg_stall;
  
  -- Stall Data Register stage if not ready.
--  lud_reg_stall   <= lud_reg_valid and read_data_hit_full(lud_reg_port_num);
  
  LUD_Reg_PR_Or_Inst1: carry_select_or_n
    generic map(
      C_TARGET  => C_TARGET,
      C_SIZE    => C_NUM_PORTS
    )
    port map(
      Carry_In  => '0',
      No        => lud_reg_port_num,
      A_Vec     => read_data_hit_full,
      Carry_Out => lud_reg_piperun_pre1
    );
  LUD_Reg_PR_Or_Inst2: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lud_reg_piperun_pre1,
      A_N       => lud_reg_valid,
      Carry_OUT => lud_reg_piperun
    );
  
  
  -----------------------------------------------------------------------------
  -- Write Data Forwarding
  -- 
  -- Select data that shall be forwarded to the memory to be written. Takes 
  -- data form the currently active port and writes it to the Way
  -- for the hit. 
  -----------------------------------------------------------------------------
  
  -- Generate mux structures for write data.
  Use_Multi_WrData: if( C_NUM_INTERNAL_PORTS > 1 ) generate
    signal access_be_word_ii          : INT_PORT_BE_TYPE;
    signal access_data_word_i         : INT_PORT_DATA_TYPE;
  begin
    -- Split to local array.
    Gen_Port_Data_Array: for I in 0 to C_NUM_INTERNAL_PORTS - 1 generate
    begin
      access_be_word_ii(I)    <= access_data_info(I).BE(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
      access_data_word_i(I)   <= access_data_info(I).Data(C_CACHE_DATA_WIDTH - 1 downto 0);
      
    end generate Gen_Port_Data_Array;
    
    -- Source port for write data
    lookup_write_port       <= get_port_num(lu_check_info.Port_Num, C_NUM_INTERNAL_PORTS);
    
    -- Select hit data.
    access_be_word_i        <= access_be_word_ii(lookup_write_port);
    lookup_data_new_word_i  <= access_data_word_i(lookup_write_port);
    
  end generate Use_Multi_WrData;
  
  -- Only one possible source for data.
  No_Multi_WrData: if( C_NUM_INTERNAL_PORTS = 1 ) generate
  begin
    lookup_write_port       <= 0;
    access_be_word_i        <= access_data_info(0).BE(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
    lookup_data_new_word_i  <= access_data_info(0).Data(C_CACHE_DATA_WIDTH - 1 downto 0);
    
  end generate No_Multi_WrData;
  
  -- Acknowledge port.
  lookup_write_data_ready   <= lookup_write_data_ready_i;
  lookup_write_data_ready_vec <= (others => (     lookup_write_hit         and
                                              not lookup_data_hit_stall    and 
                                              not lu_check_wait_for_update and 
                                              not lud_addr_pipeline_full));
  lookup_write_data_ready_i <= lookup_write_data_ready_vec and 
                               std_logic_vector(to_unsigned(2 ** lookup_write_port, C_NUM_INTERNAL_PORTS));
  
  
  -----------------------------------------------------------------------------
  -- Master coherency
  -----------------------------------------------------------------------------
  
  Use_Mst_Coherency: if (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  
    signal lookup_tag_word_d1                 : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal lu_mem_snoop_mst_fetch_stall_cmb   : std_logic;
    signal lu_check_snoop_mst_fetch_stall_cmb : std_logic;
    signal lu_check_snoop_reject_write_cmb    : std_logic;
    
    -- ----------------------------------------
    -- Write Hit Last
    
    signal whl_push                     : std_logic;
    signal whl_pop                      : std_logic;
    signal whl_fifo_full                : std_logic;
    signal whl_fifo_empty               : std_logic;
    signal whl_read_fifo_addr           : QUEUE_ADDR_TYPE:= (others=>'1');
    signal whl_fifo_mem                 : WHL_FIFO_MEM_TYPE; -- := (others=>C_NULL_WHL);
    signal whl_strb                     : CACHE_LINE_BE_TYPE;
    
    signal whl_assert                   : std_logic;
    signal stat_ud_whl                  : STAT_FIFO_TYPE;
    
    signal lu_check_pushing_writeunique : std_logic;
    signal lu_check_pushing_writeback   : std_logic;
    
    signal lu_check_whl_strb            : CACHE_LINE_BE_TYPE;
    signal lu_check_whl_strb_hold       : CACHE_LINE_BE_TYPE;
    
    signal lu_check_piperun_d1          : std_logic;
    signal lu_check_snoop_reject_write_d1 : std_logic;
    signal lu_check_shared_force_drop_d1  : std_logic;
    signal lud_step_want_step_offset_d1 : std_logic;
    signal lookup_data_en_any_write_d1  : std_logic;
    signal access_data_last_d1          : std_logic;
    signal lookup_word_idx              : rinteger range 0 to 2 ** (C_ADDR_WORD_HI - C_ADDR_WORD_LO + 1) - 1;
    signal lookup_word_idx_d1           : rinteger range 0 to 2 ** (C_ADDR_WORD_HI - C_ADDR_WORD_LO + 1) - 1;
    signal lookup_data_we_d1            : BE_TYPE;
    
  begin
    -- Delay Tag to be able to use fine grain conflict detection, with 
    -- proper timing if Mem is stalling.
-- QoR: Carry chain before FF.
    Delayed_Mem_Tag : process (ACLK) is
    begin  -- process Delayed_Mem_Tag
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lookup_tag_word_d1  <= (others=>C_NULL_WAY_LINE_TAG);
        elsif( s2b(lu_mem_first_cycle) ) then
          lookup_tag_word_d1  <= lookup_tag_current_word;
          
        end if;
      end if;
    end process Delayed_Mem_Tag;
    
    -- Detect if a Way has a Tag Hit.
    Gen_Set_Snoop_Cachehit: for K in 0 to C_NUM_WAYS - 1 generate
    begin
      lu_mem_snoop_tag_hit(K)         <= b2s(lookup_tag_word_d1(K).Addr(C_ADDR_TAG_POS) = mst_snoop_fetch_info.Addr(C_ADDR_TAG_POS)        ) and
                                         ( b2s(lookup_tag_word_d1(K).Secure               = mst_snoop_fetch_info.Prot(C_PROT_SECURE_POS) ) or
                                           b2s(C_ENABLE_NON_SECURE = 0                                                                   ) ) and
                                         (     lookup_tag_word_d1(K).Valid and not lu_mem_snoop_made_invalid(K)                            ) and
                                         ( mst_snoop_fetch_info.Valid and not lu_mem_first_cycle );
      lu_mem_snoop_tag_locked_hit(K)  <= lu_mem_snoop_tag_hit(K) and 
                                         (     lookup_tag_word_d1(K).Locked and 
                                           not lu_mem_released_lock(K)    );
      
      lu_check_snoop_tag_hit(K)       <= b2s(lu_check_tag(K).Addr(C_ADDR_TAG_POS) = mst_snoop_fetch_info.Addr(C_ADDR_TAG_POS)        ) and
                                         ( b2s(lu_check_tag(K).Secure               = mst_snoop_fetch_info.Prot(C_PROT_SECURE_POS) ) or
                                           b2s(C_ENABLE_NON_SECURE = 0                                                             ) ) and
                                         ( lu_check_tag(K).Valid and not lu_check_snoop_made_invalid(K)                              ) and
                                         ( mst_snoop_fetch_info.Valid );
      lu_check_snoop_tag_locked_hit(K)<= lu_check_snoop_tag_hit(K) and 
                                         (     lu_check_tag(K).Locked and 
                                           not lu_check_released_lock(K)  );
      
    end generate Gen_Set_Snoop_Cachehit;
    
    -- Detect when Fetch need to stall, i.e. when there are Line conflicts.
    -- It has to be Lines since it is not possible to make a full address
    -- check since current contents is unknown in this state.
    Gen_Fetch_Stall : process (access_valid, lu_fetch_info, 
                               mst_snoop_fetch_info, mst_snoop_mem_info, mst_snoop_check_info) is
    begin  -- process Gen_Fetch_Stall
      -- Default assignments.
      lu_fetch_mst_fetch_stall  <= '0';
      lu_fetch_mst_mem_stall    <= '0';
      lu_fetch_mst_check_stall  <= '0';
      
      if( ( access_valid                        = '1'                                        ) and
          ( mst_snoop_fetch_info.Valid          = '1'                                        ) and
          ( mst_snoop_fetch_info.Lookup         = '1'                                        ) and
          ( lu_fetch_info.Addr(C_ADDR_LINE_POS) = mst_snoop_fetch_info.Addr(C_ADDR_LINE_POS) ) ) then
        lu_fetch_mst_fetch_stall  <= '1';
      end if;
      
      if( ( access_valid                        = '1'                                        ) and
          ( mst_snoop_mem_info.Valid            = '1'                                        ) and
          ( mst_snoop_mem_info.Lookup           = '1'                                        ) and
          ( lu_fetch_info.Addr(C_ADDR_LINE_POS) = mst_snoop_mem_info.Addr(C_ADDR_LINE_POS)   ) ) then
        lu_fetch_mst_mem_stall    <= '1';
      end if;
      
      if( ( access_valid                        = '1'                                        ) and
          ( mst_snoop_check_info.Valid          = '1'                                        ) and
          ( mst_snoop_check_info.Lookup         = '1'                                        ) and
          ( lu_fetch_info.Addr(C_ADDR_LINE_POS) = mst_snoop_check_info.Addr(C_ADDR_LINE_POS) ) ) then
        lu_fetch_mst_check_stall  <= '1';
      end if;
      
    end process Gen_Fetch_Stall;
    
    Gen_Mem_Snoop_Effect : process (ACLK) is
    begin  -- process Gen_Mem_Snoop_Effect
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_mem_snoop_made_clean       <= (others=>'0');
          lu_mem_snoop_made_shared      <= (others=>'0');
          lu_mem_snoop_made_invalid     <= (others=>'0');
            
        elsif( lu_fetch_piperun = '1' ) then
          lu_mem_snoop_made_clean       <= (others=>'0');
          lu_mem_snoop_made_shared      <= (others=>'0');
          lu_mem_snoop_made_invalid     <= (others=>'0');
            
        elsif( s2b(lu_mem_snoop_quick_halt and not lu_mem_first_cycle) ) then
          for K in 0 to C_NUM_WAYS - 1 loop
            if( s2b(lu_mem_snoop_tag_hit(K)) and not s2b(lu_mem_snoop_tag_locked_hit(K)) ) then
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Get) ) then
                lu_mem_snoop_made_shared(K)   <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean) ) then
                lu_mem_snoop_made_clean(K)    <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean and not mst_snoop_fetch_info.Keep) ) then
                lu_mem_snoop_made_invalid(K)  <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Kill) ) then
                lu_mem_snoop_made_invalid(K)  <= '1';
              end if;
              
            end if;
          end loop;
        end if;
      end if;
    end process Gen_Mem_Snoop_Effect;
    
    Gen_Check_Snoop_Effect : process (ACLK) is
    begin  -- process Gen_Check_Snoop_Effect
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_made_clean       <= (others=>'0');
          lu_check_snoop_made_shared      <= (others=>'0');
          lu_check_snoop_made_invalid     <= (others=>'0');
            
        elsif( lu_mem_piperun = '1' ) then
          lu_check_snoop_made_clean       <= (others=>'0');
          lu_check_snoop_made_shared      <= (others=>'0');
          lu_check_snoop_made_invalid     <= (others=>'0');
            
        elsif( not s2b(lu_check_write_permission) ) then
          for K in 0 to C_NUM_WAYS - 1 loop
            if( s2b(lu_check_snoop_line_match and lu_check_snoop_tag_hit(K) and not lookup_protect_conflict) ) then
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Get) ) then
                lu_check_snoop_made_shared(K)   <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean) ) then
                lu_check_snoop_made_clean(K)    <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean and not mst_snoop_fetch_info.Keep) ) then
                lu_check_snoop_made_invalid(K)  <= '1';
              end if;
              
              if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Kill) ) then
                lu_check_snoop_made_invalid(K)  <= '1';
              end if;
              
            end if;
          end loop;
        end if;
      end if;
    end process Gen_Check_Snoop_Effect;
    
    Gen_Check_Snoop_Delayed_Effect : process (ACLK) is
    begin  -- process Gen_Check_Snoop_Delayed_Effect
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_made_txn_clean   <= '0';
          lu_check_snoop_made_txn_shared  <= '0';
          lu_check_snoop_made_txn_invalid <= '0';
            
        elsif( lu_mem_piperun = '1' ) then
          lu_check_snoop_made_txn_clean   <= '0';
          lu_check_snoop_made_txn_shared  <= '0';
          lu_check_snoop_made_txn_invalid <= '0';
            
        elsif( s2b(lu_check_write_permission) ) then
          if( s2b(lu_check_snoop_line_match and lu_check_snoop_tag_match and lookup_write_hit) ) then
            if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Get) ) then
              lu_check_snoop_made_txn_shared  <= '1';
            end if;
            
            if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean) ) then
              lu_check_snoop_made_txn_clean   <= '1';
            end if;
            
            if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Clean and not mst_snoop_fetch_info.Keep) ) then
              lu_check_snoop_made_txn_invalid <= '1';
            end if;
            
            if( s2b(mst_snoop_fetch_info.Lookup and mst_snoop_fetch_info.Update and mst_snoop_fetch_info.Kill) ) then
              lu_check_snoop_made_txn_invalid <= '1';
            end if;
            
          end if;
        end if;
      end if;
    end process Gen_Check_Snoop_Delayed_Effect;
    
    -- Let affecting snoop propagate through the pipeline before releasing core.
    lu_mem_snoop_mst_fetch_stall_cmb  <= lu_mem_snoop_line_match and reduce_or(lu_mem_snoop_tag_hit and not lu_mem_snoop_tag_locked_hit);
    Gen_MstFetch_Snoop_CoreMem_Stall : process (ACLK) is
    begin  -- process Gen_MstFetch_Snoop_CoreMem_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_mem_snoop_mst_fetch_stall  <= '0';
          
        elsif( s2b(mst_snoop_fetch_piperun) ) then
          lu_mem_snoop_mst_fetch_stall  <= '0';
            
        elsif( s2b(lu_mem_snoop_mst_fetch_stall_cmb) ) then
          lu_mem_snoop_mst_fetch_stall  <= '1';
            
        end if;
      end if;
    end process Gen_MstFetch_Snoop_CoreMem_Stall;
    Gen_MstMem_Snoop_CoreMem_Stall : process (ACLK) is
    begin  -- process Gen_MstMem_Snoop_CoreMem_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_mem_snoop_mst_mem_stall    <= '0';
          
        elsif( s2b(mst_snoop_fetch_piperun) ) then
          lu_mem_snoop_mst_mem_stall    <= lu_mem_snoop_mst_fetch_stall or lu_mem_snoop_mst_fetch_stall_cmb;
            
        end if;
      end if;
    end process Gen_MstMem_Snoop_CoreMem_Stall;
    Gen_MstCheck_Snoop_CoreMem_Stall : process (ACLK) is
    begin  -- process Gen_MstCheck_Snoop_CoreMem_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_mem_snoop_mst_check_stall  <= '0';
          
        elsif( s2b(mst_snoop_mem_piperun) ) then
          lu_mem_snoop_mst_check_stall  <= lu_mem_snoop_mst_mem_stall;
            
        elsif( s2b(mst_snoop_check_piperun) ) then
          lu_mem_snoop_mst_check_stall  <= '0';
            
        end if;
      end if;
    end process Gen_MstCheck_Snoop_CoreMem_Stall;
    Gen_MstData_Snoop_CoreMem_Stall : process (ACLK) is
    begin  -- process Gen_MstData_Snoop_CoreMem_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_mem_snoop_mst_data_stall   <= '0';
          
        elsif( s2b(mst_snoop_check_piperun) ) then
          lu_mem_snoop_mst_data_stall   <= lu_check_snoop_mst_check_stall and
                                           mst_snoop_check_info.Lookup    and 
                                           mst_snoop_check_info.Get;
            
        elsif( s2b(mst_snoop_sdr_empty) ) then
          lu_mem_snoop_mst_data_stall   <= '0';
            
        end if;
      end if;
    end process Gen_MstData_Snoop_CoreMem_Stall;
    
    -- Let affecting snoop propagate through the pipeline before releasing core.
    lu_check_snoop_mst_fetch_stall_cmb  <=     lu_check_snoop_line_match         and 
                                               reduce_or(lu_check_snoop_tag_hit) and
                                           not lookup_read_hit;
    lu_check_snoop_reject_write_cmb     <=     lu_check_snoop_line_match         and 
                                               lu_check_snoop_tag_match          and
                                               reduce_or(lu_check_snoop_tag_hit) and 
                                               lu_check_write_no_permission      and 
                                               mst_snoop_fetch_info.Lookup       and 
                                               mst_snoop_fetch_info.Update       and
                                               mst_snoop_fetch_info.Clean        and 
                                           not mst_snoop_fetch_info.Keep         and 
                                           not lookup_locked_write_hit;
    Gen_MstFetch_Snoop_CoreCheck_Stall : process (ACLK) is
    begin  -- process Gen_MstFetch_Snoop_CoreCheck_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_mst_fetch_stall  <= '0';
          
        elsif( s2b(mst_snoop_fetch_piperun) ) then
          lu_check_snoop_mst_fetch_stall  <= '0';
            
        elsif( s2b(lu_check_snoop_mst_fetch_stall_cmb) ) then
          lu_check_snoop_mst_fetch_stall  <= '1';
            
        end if;
      end if;
    end process Gen_MstFetch_Snoop_CoreCheck_Stall;
    Gen_MstMem_Snoop_CoreCheck_Stall : process (ACLK) is
    begin  -- process Gen_MstMem_Snoop_CoreCheck_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_mst_mem_stall    <= '0';
          
        elsif( s2b(mst_snoop_fetch_piperun) ) then
          lu_check_snoop_mst_mem_stall    <= lu_check_snoop_mst_fetch_stall or lu_check_snoop_mst_fetch_stall_cmb;
            
        end if;
      end if;
    end process Gen_MstMem_Snoop_CoreCheck_Stall;
    Gen_MstCheck_Snoop_CoreCheck_Stall : process (ACLK) is
    begin  -- process Gen_MstCheck_Snoop_CoreCheck_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_mst_check_stall  <= '0';
          
        elsif( s2b(mst_snoop_mem_piperun) ) then
          lu_check_snoop_mst_check_stall  <= lu_check_snoop_mst_mem_stall;
            
        elsif( s2b(mst_snoop_check_piperun) ) then
          lu_check_snoop_mst_check_stall  <= '0';
            
        end if;
      end if;
    end process Gen_MstCheck_Snoop_CoreCheck_Stall;
    Gen_MstData_Snoop_CoreCheck_Stall : process (ACLK) is
    begin  -- process Gen_MstData_Snoop_CoreCheck_Stall
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then           -- synchronous reset (active high)
          lu_check_snoop_mst_data_stall   <= '0';
          
        elsif( s2b(mst_snoop_check_piperun) ) then
          lu_check_snoop_mst_data_stall   <= lu_check_snoop_mst_check_stall and
                                             mst_snoop_check_info.Lookup    and 
                                             mst_snoop_check_info.Get;
            
        elsif( s2b(mst_snoop_sdr_empty) ) then
          lu_check_snoop_mst_data_stall   <= '0';
            
        end if;
      end if;
    end process Gen_MstData_Snoop_CoreCheck_Stall;
    
    lu_mem_snoop_line_match       <= lu_mem_valid and mst_snoop_fetch_info.Valid and
                                     b2s(          lu_mem_info.Addr(C_ADDR_LINE_POS) = 
                                          mst_snoop_fetch_info.Addr(C_ADDR_LINE_POS) );
    
    lu_mem_snoop_active_cycle     <= ( mst_snoop_fetch_info.First and not lu_mem_first_cycle   ) or
                                     ( mst_snoop_fetch_info.Valid and     lu_mem_second_cycle  );
                                     
    lu_check_snoop_line_match     <= lu_check_valid and mst_snoop_fetch_info.Valid and
                                     b2s(        lu_check_info.Addr(C_ADDR_LINE_POS) = 
                                          mst_snoop_fetch_info.Addr(C_ADDR_LINE_POS) );
    
    lu_check_snoop_tag_match      <= ( b2s(       lu_check_info.Addr(C_ADDR_TAG_POS)    = 
                                           mst_snoop_fetch_info.Addr(C_ADDR_TAG_POS)    ) ) and
                                     ( b2s(       lu_check_info.Prot(C_PROT_SECURE_POS) = 
                                           mst_snoop_fetch_info.Prot(C_PROT_SECURE_POS) ) or
                                       b2s(C_ENABLE_NON_SECURE = 0                      ) ) and
                                     ( lu_check_valid and mst_snoop_fetch_info.Valid      );
                                          
    lu_check_snoop_active_cycle   <= ( mst_snoop_fetch_info.First                              );
    
    lu_check_write_no_permission  <= ( need_insert_read_trans or lu_chkins_insert_done ) and
                                     ( lu_check_valid and lu_check_info.Wr and not lu_chkins_insert_complete );
  
    lu_check_write_permission     <= ( lu_check_valid and lu_check_info.Wr ) and 
                                     ( lu_chkins_insert_complete or 
                                       lu_chkins_prohibit_insert or 
                                       lookup_unique_hit );
  
    
    Gen_Hazard_Detect : process (lu_mem_valid, lu_mem_first_cycle, 
                                 lu_check_valid, lu_check_info, 
                                 mst_snoop_fetch_info, mst_snoop_check_info, lookup_locked_write_hit, lookup_read_hit,
                                 lookup_hit, lu_chkins_insert_done, lu_check_wait_for_update, protect_shared_write,
                                 lu_check_dirty_bits, lookup_new_tag_assoc_way, 
                                 lu_mem_snoop_active_cycle, lu_mem_snoop_tag_hit, lu_mem_snoop_tag_locked_hit,
                                 lu_mem_snoop_line_match,
                                 lu_check_snoop_line_match, lu_check_snoop_tag_match, lu_check_write_permission, 
                                 lu_check_snoop_mst_fetch_stall_cmb) is
    begin  -- process Gen_Hazard_Detect
      -- Default assignments.
      mst_core_fetch_hazard           <= C_NULL_MST_SNOOP_HAZ;
      mst_core_mem_hazard             <= C_NULL_MST_SNOOP_HAZ;
      mst_core_check_hazard           <= C_NULL_MST_SNOOP_HAZ;
      lu_mem_snoop_quick_halt         <= '0';
      lu_check_snoop_quick_halt       <= '0';
      
      lu_check_snoop_missing_raw      <= '0';
      lu_check_snoop_killing_raw      <= '0';
      lu_check_snoop_dropping_raw     <= '0';
      
      -- Simple decoding if information is valid.
      mst_core_mem_hazard.Valid     <= lu_mem_valid   and mst_snoop_fetch_info.Valid;
      mst_core_check_hazard.Valid   <= lu_check_valid and mst_snoop_fetch_info.Valid;
      
      if( s2b(lu_mem_snoop_line_match) ) then
        -- Tag filter is not allowed for first cycle, because it is not available with proper timing.
        -- Tag filtering is not allowed when there is a conflict since Tag Line and Mem Line 
        -- doesn't necessarily match.
        -- Otherwise it is OK to check Tag to reduce conflicts.
        if( lu_mem_first_cycle                  = '1'                                        ) then
          -- First cycle both need to halt in order to make sure all data is a available.
          lu_mem_snoop_quick_halt       <= '1';
          mst_core_mem_hazard.Hazard    <= '1';
          
        elsif( s2b(lu_mem_snoop_active_cycle and reduce_or(lu_mem_snoop_tag_hit and not lu_mem_snoop_tag_locked_hit)) ) then
          -- Second cycle only the Cache Core need to stall in order to calculate how the 
          -- manipulation will affect the cache line
          lu_mem_snoop_quick_halt       <= '1';
          
        end if;
      end if;
      
      if( s2b(lu_check_snoop_line_match) ) then
        -- This is a potential conflict for the currently accessed Line.
        
        if( s2b(mst_snoop_fetch_info.First) ) then
          -- First Snoop cycle both pipelines need to stall in order to evaluate what the event needs to be.
          lu_check_snoop_quick_halt       <= not lookup_read_hit;
          mst_core_check_hazard.Hazard    <= not lookup_read_hit;
          
        elsif( s2b(lu_check_write_permission) ) then
          -- Write permission has been received, continue temporary stall snoop since there
          -- are no outstanding events that are related to ACE interface.
          mst_core_check_hazard.Hazard    <= not lu_check_wait_for_update;
          mst_core_check_hazard.MadeDirty <=     lu_check_wait_for_update;
          mst_core_check_hazard.MadeUnique<=     lu_check_wait_for_update;
          
        end if;
        if( s2b(lu_check_snoop_mst_fetch_stall_cmb) ) then
          -- A collision hazard with current transaction is detected, let the snoop complete 
          -- it's cycle by stalling Core pipeline.
          lu_check_snoop_quick_halt       <= '1';
          
        end if;
      end if;
      
      -- Determine if this line is being killed by a snoop (MakeInavalid etc.).
      if( s2b(lu_check_snoop_line_match) and
          ( ( lu_check_info.Evict                 = '1'      ) or
            ( ( lu_check_info.Wr                    = '1'  ) and
              ( lookup_locked_write_hit             = '0'  ) and
              ( lu_check_snoop_tag_match            = '1'  ) ) ) ) then
        
        lu_check_snoop_missing_raw        <= lookup_hit                  and 
                                             mst_snoop_fetch_info.Valid  and 
                                             mst_snoop_fetch_info.Clean;
        lu_check_snoop_killing_raw        <= lookup_hit                  and 
                                             mst_snoop_fetch_info.Valid  and 
                                             mst_snoop_fetch_info.Clean  and 
                                             mst_snoop_fetch_info.Kill;
        
      end if;
      
      -- Determine if this line is being killed by a snoop (MakeInavalid etc.).
      if( s2b(lu_check_snoop_line_match and lu_check_snoop_tag_match and lu_check_info.Wr and 
              ( lookup_locked_write_hit or protect_shared_write ) ) ) then
        lu_check_snoop_dropping_raw       <= lookup_hit                  and 
                                             mst_snoop_fetch_info.Valid  and 
                                             mst_snoop_fetch_info.Clean;
      end if;
      
    end process Gen_Hazard_Detect;
    
    -- Type of Write being generated.
    lu_check_pushing_writeunique      <= ( lu_check_valid and lu_check_info.Wr and
                                               ( b2s( lu_chkins_write_snoop = C_AWSNOOP_WriteUnique     ) or 
                                                 b2s( lu_chkins_write_snoop = C_AWSNOOP_WriteLineUnique ) ) );
    lu_check_pushing_writeback        <= ( lu_check_valid and lu_check_info.Wr and
                                           not ( b2s( lu_chkins_write_snoop = C_AWSNOOP_WriteUnique     ) or 
                                                 b2s( lu_chkins_write_snoop = C_AWSNOOP_WriteLineUnique ) ) ) or
                                         lookup_read_miss_dirty;
    
    -- Need to stall in Mem if this is Write that is supposed to be allocated and there are
    -- any WriteUnique in progress or supposed to be created.
    lu_mem_writeunique_hazard_halt    <= lu_mem_valid and lu_mem_info.Wr and     lu_mem_info.Allocate and
                                         ( lu_check_pushing_writeunique          or
                                           reduce_or(update_pushing_writeunique) or
                                           be_writeunique_inflight               );
    
    -- Need to stall in Mem if this is Write is guaranteed to be a WriteUnique (not allocating)
    -- and there are non "WriteUnique" type in progress or supposed to be created.
    lu_mem_writeback_hazard_halt      <= lu_mem_valid and lu_mem_info.Wr and not lu_mem_info.Allocate and
                                         ( lu_check_pushing_writeback          or
                                           reduce_or(update_pushing_writeback) or
                                           be_writeback_inflight               );
    
    -- If Check is about to become a WriteUnique class it is has to be stalled until any earlier
    -- WriteBack has been completed.
    -- A downgrade can happen for a number of reasons for a transaction that is originally 
    -- meant to allocate, in the normal case it would be stopped in Mem but all information 
    -- is not available then.
    lu_check_writeback_hazard_halt    <= lu_check_valid and lu_check_info.Wr and 
                                         ( lu_check_pushing_writeunique        ) and
                                         ( reduce_or(update_pushing_writeback) or
                                           be_writeback_inflight               );
    
    -- If a Write that is not supposed to be allocated still Hit, it needs to be pushed out.
    -- Such a transaction need to be transformed into a WriteBack due to the current contents.
    -- Also need to take into account that Read Miss Dirty will issue a WriteBack for old line.
    lu_check_writeunique_hazard_halt  <= ( ( lu_check_valid and lu_check_info.Wr ) or
                                           ( lookup_read_miss_dirty              ) ) and 
                                         ( ( lu_check_valid and whne_sel         ) or
                                           ( lookup_read_miss_dirty              ) ) and
                                         ( reduce_or(update_pushing_writeunique) or
                                           be_writeunique_inflight               );
    
    Access_Collision_Handler : process (ACLK) is
    begin  -- process Access_Collision_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          lu_check_snoop_reject_write <= '0';
        else
          
          if( s2b(lu_check_piperun) ) then
            lu_check_snoop_reject_write <= '0';
            
          elsif( s2b(lu_check_snoop_reject_write_cmb) ) then
            -- 
            lu_check_snoop_reject_write <= '1';
            
          end if;
        end if;
      end if;
    end process Access_Collision_Handler;
    
    LastWrite_OneBeat: if( C_CACHE_LINE_WORDS = 1 ) generate
    begin
      lookup_word_idx <= 0;
      update_whl_strb <= whl_strb(0);
      
    end generate LastWrite_OneBeat;
    
    LastWrite_MultiBeat: if( C_CACHE_LINE_WORDS > 1 ) generate
    begin
      lookup_word_idx <= to_integer(unsigned(lookup_word_offset(C_ADDR_WORD_HI downto C_ADDR_WORD_LO)));
      
      WriteHit_DeWordify: for N in C_CACHE_WORD_POS generate
      begin
        update_whl_strb(C_CACHE_DATA_WIDTH/8 * (N+1) - 1 downto C_CACHE_DATA_WIDTH/8 * N) <= whl_strb(N);
      end generate WriteHit_DeWordify;
      
    end generate LastWrite_MultiBeat;
  
    -- Merge STRBs to rest of line.
    -- Depending on Use/Stp same word can be touched multiple times.
    LW_Cmb_Handler : process (lookup_word_idx_d1, lookup_data_we_d1, lu_check_whl_strb_hold, 
                              lud_step_want_step_offset_d1, lookup_data_en_any_write_d1) is
    begin  -- process LW_Cmb_Handler
      lu_check_whl_strb                     <= lu_check_whl_strb_hold;
      
      -- Apply new strb information.
      if( s2b(lud_step_want_step_offset_d1 and lookup_data_en_any_write_d1) ) then
        lu_check_whl_strb(lookup_word_idx_d1) <= lu_check_whl_strb_hold(lookup_word_idx_d1) or lookup_data_we_d1;
      end if;
      
    end process LW_Cmb_Handler;
    
    LW_Assembly_Handler : process (ACLK) is
    begin  -- process LW_Assembly_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          lu_check_whl_strb_hold          <= C_NULL_WHL;
          lu_check_piperun_d1             <= '0';
          lu_check_snoop_reject_write_d1  <= '0';
          lu_check_shared_force_drop_d1   <= '0';
          lud_step_want_step_offset_d1    <= '0';
          lookup_data_en_any_write_d1     <= '0';
          lookup_word_idx_d1              <= 0;
          lookup_data_we_d1               <= (others=>'0');
          access_data_last_d1             <= '0';
          
        else
          -- Delay for time to evaluate (also aligns it with Update).
          lu_check_piperun_d1             <= lu_check_piperun;
          lu_check_snoop_reject_write_d1  <= lu_check_snoop_reject_write;
          lu_check_shared_force_drop_d1   <= lu_check_shared_force_drop;
          lud_step_want_step_offset_d1    <= lud_step_want_step_offset;
          lookup_data_en_any_write_d1     <= lookup_data_en_any_write;
          lookup_word_idx_d1              <= lookup_word_idx;
          lookup_data_we_d1               <= lookup_data_we_i;
          access_data_last_d1             <= access_data_last(lud_step_write_port_num);
          
          if( s2b(lu_check_piperun_d1) ) then
            lu_check_whl_strb_hold          <= C_NULL_WHL;
            
          elsif( s2b(lud_step_want_step_offset_d1 and lookup_data_en_any_write_d1) ) then
            lu_check_whl_strb_hold          <= lu_check_whl_strb;
            
          end if;
        end if;
      end if;
    end process LW_Assembly_Handler;
    
    whl_push  <=     lud_step_want_step_offset_d1   and 
                     lookup_data_en_any_write_d1    and
                     access_data_last_d1            and
                     lu_check_snoop_reject_write_d1 and 
                 not lu_check_shared_force_drop_d1;
    whl_pop   <= update_whl_pop and not whl_fifo_empty;
    
    FIFO_WHL_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => whl_push,
        queue_pop                 => whl_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => open,
        queue_almost_empty        => open,
        queue_empty               => whl_fifo_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => whl_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_ud_whl,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => whl_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for Write Hit Last FIFO.
    FIFO_WHL_Memory : process (ACLK) is
    begin  -- process FIFO_WHL_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( whl_push = '1' ) then
          -- Insert new item.
          whl_fifo_mem(0)                           <= lu_check_whl_strb;
          
          -- Shift FIFO contents.
          whl_fifo_mem(whl_fifo_mem'left downto 1)  <= whl_fifo_mem(whl_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_WHL_Memory;
    
    -- Extract current Write Hit Last information.
    whl_strb          <= whl_fifo_mem(to_integer(unsigned(whl_read_fifo_addr)));
    update_whl_exist  <= not whl_fifo_empty;
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      LOOKUP_DEBUG(C_MAX_DEBUG_WIDTH - 1 downto 308)  <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            LOOKUP_DEBUG(C_MAX_DEBUG_WIDTH - 1 downto 308)  <= (others=>'0');
          else
            -- Default assignment.
            LOOKUP_DEBUG(C_MAX_DEBUG_WIDTH - 1 downto 308)  <= (others=>'0');
            
            LOOKUP_DEBUG(311 downto 308)  <= fit_vec(lu_mem_snoop_tag_hit, 4);
            LOOKUP_DEBUG(315 downto 312)  <= fit_vec(lu_mem_snoop_made_clean, 4);
            LOOKUP_DEBUG(319 downto 316)  <= fit_vec(lu_mem_snoop_made_shared, 4);
            LOOKUP_DEBUG(323 downto 320)  <= fit_vec(lu_mem_snoop_made_invalid, 4);
            LOOKUP_DEBUG(327 downto 324)  <= fit_vec(lu_check_snoop_tag_hit, 4);
            LOOKUP_DEBUG(331 downto 328)  <= fit_vec(lu_check_snoop_made_clean, 4);
            LOOKUP_DEBUG(335 downto 332)  <= fit_vec(lu_check_snoop_made_shared, 4);
            LOOKUP_DEBUG(339 downto 336)  <= fit_vec(lu_check_snoop_made_invalid, 4);
            LOOKUP_DEBUG(           340)  <= lu_mem_snoop_quick_halt;
            LOOKUP_DEBUG(           341)  <= lu_mem_snoop_mst_fetch_stall;
            LOOKUP_DEBUG(           342)  <= lu_mem_snoop_mst_mem_stall;
            LOOKUP_DEBUG(           343)  <= lu_mem_snoop_mst_check_stall;
            LOOKUP_DEBUG(           344)  <= lu_mem_snoop_line_match;
            LOOKUP_DEBUG(           345)  <= lu_mem_snoop_active_cycle;
            LOOKUP_DEBUG(           346)  <= lu_check_snoop_quick_halt;
            LOOKUP_DEBUG(           347)  <= lu_check_snoop_mst_fetch_stall;
            LOOKUP_DEBUG(           348)  <= lu_check_snoop_mst_mem_stall;
            LOOKUP_DEBUG(           349)  <= lu_check_snoop_mst_check_stall;
            LOOKUP_DEBUG(           350)  <= lu_check_snoop_line_match;
            LOOKUP_DEBUG(           351)  <= lu_check_snoop_active_cycle;
            LOOKUP_DEBUG(           352)  <= lu_check_write_no_permission;
            LOOKUP_DEBUG(           353)  <= lu_check_write_permission;
            LOOKUP_DEBUG(           354)  <= lu_check_snoop_reject_write;
            LOOKUP_DEBUG(           355)  <= lu_mem_snoop_mst_fetch_stall_cmb;
            LOOKUP_DEBUG(           356)  <= lu_check_snoop_mst_fetch_stall_cmb;
            LOOKUP_DEBUG(           357)  <= lu_check_snoop_reject_write_cmb;
            LOOKUP_DEBUG(           358)  <= whl_push;
            LOOKUP_DEBUG(           359)  <= whl_pop;
            LOOKUP_DEBUG(           360)  <= whl_fifo_empty;
            LOOKUP_DEBUG(           361)  <= whl_fifo_full;
            LOOKUP_DEBUG(           363)  <= lu_check_piperun_d1;
            LOOKUP_DEBUG(           364)  <= lu_check_snoop_reject_write_d1;
            LOOKUP_DEBUG(           365)  <= lu_check_shared_force_drop_d1;
            LOOKUP_DEBUG(           366)  <= lud_step_want_step_offset_d1;
            LOOKUP_DEBUG(           367)  <= lookup_data_en_any_write_d1;
            LOOKUP_DEBUG(           368)  <= access_data_last_d1;
            
            LOOKUP_DEBUG(           369)  <= lu_check_snoop_tag_match;
            LOOKUP_DEBUG(           370)  <= lu_mem_snoop_mst_data_stall;
            LOOKUP_DEBUG(           371)  <= lu_mem_writeunique_hazard_halt;
            LOOKUP_DEBUG(           372)  <= lu_mem_writeback_hazard_halt;
            LOOKUP_DEBUG(           373)  <= lu_check_snoop_mst_data_stall;
            LOOKUP_DEBUG(           374)  <= lu_check_writeback_hazard_halt;
            LOOKUP_DEBUG(           375)  <= lu_check_writeunique_hazard_halt;
            LOOKUP_DEBUG(           376)  <= lu_check_pushing_writeunique;
            LOOKUP_DEBUG(           377)  <= lu_check_pushing_writeback;
            LOOKUP_DEBUG(           378)  <= reduce_or(update_pushing_writeunique);
            LOOKUP_DEBUG(           379)  <= reduce_or(update_pushing_writeback);
            LOOKUP_DEBUG(           380)  <= be_writeunique_inflight;
            LOOKUP_DEBUG(           381)  <= be_writeback_inflight;
            
            LOOKUP_DEBUG(385 downto 382)  <= fit_vec(lu_mem_snoop_tag_locked_hit, 4);
            LOOKUP_DEBUG(389 downto 386)  <= fit_vec(lu_mem_releasing_lock, 4);
            LOOKUP_DEBUG(393 downto 390)  <= fit_vec(lu_mem_released_lock, 4);
            LOOKUP_DEBUG(           394)  <= lu_mem_update_line_match;
            LOOKUP_DEBUG(           395)  <= lu_mem_update_data_match;
            LOOKUP_DEBUG(399 downto 396)  <= fit_vec(lu_mem_removed_way, 4);
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Use_Mst_Coherency;

  No_Mst_Coherency: if  ( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    lu_fetch_mst_fetch_stall        <= '0';
    lu_fetch_mst_mem_stall          <= '0';
    lu_fetch_mst_check_stall        <= '0';
    
    lu_mem_snoop_tag_hit            <= (others=>'0');
    lu_mem_snoop_tag_locked_hit     <= (others=>'0');
    lu_mem_snoop_made_clean         <= (others=>'0');
    lu_mem_snoop_made_shared        <= (others=>'0');
    lu_mem_snoop_made_invalid       <= (others=>'0');
    lu_mem_snoop_quick_halt         <= '0';
    lu_mem_snoop_mst_fetch_stall    <= '0';
    lu_mem_snoop_mst_mem_stall      <= '0';
    lu_mem_snoop_mst_check_stall    <= '0';
    lu_mem_snoop_mst_data_stall     <= '0';
    lu_mem_snoop_line_match         <= '0';
    lu_mem_snoop_active_cycle       <= '0';
    
    lu_mem_writeunique_hazard_halt  <= '0';
    lu_mem_writeback_hazard_halt    <= '0';

    lu_check_snoop_tag_hit          <= (others=>'0');
    lu_check_snoop_tag_locked_hit   <= (others=>'0');
    lu_check_snoop_made_clean       <= (others=>'0');
    lu_check_snoop_made_shared      <= (others=>'0');
    lu_check_snoop_made_invalid     <= (others=>'0');
    lu_check_snoop_made_txn_clean   <= '0';
    lu_check_snoop_made_txn_shared  <= '0';
    lu_check_snoop_made_txn_invalid <= '0';
    lu_check_snoop_quick_halt       <= '0';
    lu_check_snoop_mst_fetch_stall  <= '0';
    lu_check_snoop_mst_mem_stall    <= '0';
    lu_check_snoop_mst_check_stall  <= '0';
    lu_check_snoop_mst_data_stall   <= '0';
    lu_check_snoop_line_match       <= '0';
    lu_check_snoop_tag_match        <= '0';
    lu_check_snoop_active_cycle     <= '0';
    lu_check_write_no_permission    <= '0';
    lu_check_write_permission       <= '0';
    lu_check_snoop_reject_write     <= '0';
    
    lu_check_writeback_hazard_halt  <= '0';
    lu_check_writeunique_hazard_halt<= '0';
   
    mst_core_fetch_hazard           <= C_NULL_MST_SNOOP_HAZ;
    mst_core_mem_hazard             <= C_NULL_MST_SNOOP_HAZ;
    mst_core_check_hazard           <= C_NULL_MST_SNOOP_HAZ;
    
    lu_check_snoop_missing_raw      <= '0';
    lu_check_snoop_killing_raw      <= '0';
    lu_check_snoop_dropping_raw     <= '0';
    
    update_whl_exist                <= '0';
    update_whl_strb                 <= (others=>'0');
    
    LOOKUP_DEBUG(C_MAX_DEBUG_WIDTH - 1 downto 308)  <= (others=>'0');
  end generate No_Mst_Coherency;
  
  
  -- ---------------------------------------------------
  -- ACE Downstream Barrier Request.
  
  ctrl_lookup_done          <= ( not access_valid   ) and -- ( = lu_fetch_valid )
                               ( not lu_mem_valid   ) and
                               ( not lu_check_valid );
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_lu_opt_write_hit         <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_write_miss        <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_write_miss_dirty  <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_read_hit          <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_read_miss         <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_read_miss_dirty   <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_locked_write_hit  <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_locked_read_hit   <= (others=>C_NULL_STAT_POINT);
    stat_lu_opt_first_write_hit   <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_write_hit         <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_write_miss        <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_write_miss_dirty  <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_read_hit          <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_read_miss         <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_read_miss_dirty   <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_locked_write_hit  <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_locked_read_hit   <= (others=>C_NULL_STAT_POINT);
    stat_lu_gen_first_write_hit   <= (others=>C_NULL_STAT_POINT);
    stat_lu_stall                 <= C_NULL_STAT_POINT;
    stat_lu_fetch_stall           <= C_NULL_STAT_POINT;
    stat_lu_mem_stall             <= C_NULL_STAT_POINT;
    stat_lu_data_stall            <= C_NULL_STAT_POINT;
    stat_lu_data_hit_stall        <= C_NULL_STAT_POINT;
    stat_lu_data_miss_stall       <= C_NULL_STAT_POINT;
    
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    
    signal valid_new_stat         : std_logic;
    signal lu_check_stat_done     : std_logic;
    
    signal det_lu_stall           : std_logic;
    signal det_lu_fetch_stall     : std_logic;
    signal det_lu_mem_stall       : std_logic;
    signal det_lu_data_stall      : std_logic;
    signal det_lu_data_hit_stall  : std_logic;
    signal det_lu_data_miss_stall : std_logic;
    
  begin
    valid_new_stat  <= lu_check_valid and not lu_check_stat_done;
    
    Stat_Control : process (ACLK) is
    begin  -- process Stat_Control
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          lu_check_stat_done  <= '1';
        else
          lu_check_stat_done  <= '1';
          
          if( lu_mem_piperun = '1' ) then
            lu_check_stat_done  <= not lu_mem_valid;
          end if;
        end if;
      end if;
    end process Stat_Control;
    
    Stat_Handle : process (ACLK) is
    begin  -- process Stat_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          -- Stall information.
          det_lu_stall            <= '0';
          det_lu_fetch_stall      <= '0';
          det_lu_mem_stall        <= '0';
          det_lu_data_stall       <= '0';
          det_lu_data_hit_stall   <= '0';
          det_lu_data_miss_stall  <= '0';
        else
          -- Stall information.
          det_lu_stall            <= '0';
          det_lu_fetch_stall      <= lu_fetch_valid and lu_fetch_stall;
          det_lu_mem_stall        <= lu_mem_valid   and lu_mem_stall;
          det_lu_data_stall       <= lu_check_valid and lookup_data_stall and not lookup_data_hit_stall;
          det_lu_data_hit_stall   <= lu_check_valid and lookup_data_hit_stall;
          det_lu_data_miss_stall  <= lu_check_valid and lookup_data_miss_stall;
        end if;
      end if;
    end process Stat_Handle;
    
    Gen_Per_Port: for I in 0 to C_NUM_PORTS - 1 generate
      signal new_read_hit               : std_logic;
      signal new_read_miss              : std_logic;
      signal new_read_miss_dirty        : std_logic;
      signal new_write_hit              : std_logic;
      signal new_write_miss             : std_logic;
      signal new_write_miss_dirty       : std_logic;
      signal new_locked_write_hit       : std_logic;
      signal new_locked_read_hit        : std_logic;
      signal new_first_write_hit        : std_logic;
      
      signal stat_lu_write_hit          : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_write_miss         : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_write_miss_dirty   : STAT_POINT_TYPE;    -- Number of transactions (future use)
      signal stat_lu_read_hit           : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_read_miss          : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_read_miss_dirty    : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_locked_write_hit   : STAT_POINT_TYPE;    -- Number of transactions 
      signal stat_lu_locked_read_hit    : STAT_POINT_TYPE;    -- Number of Transactions
      signal stat_lu_first_write_hit    : STAT_POINT_TYPE;    -- Number of Transactions
    begin
    
      Stat_Port_Handle : process (ACLK) is
      begin  -- process Stat_Port_Handle
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if( stat_reset = '1' ) then         -- synchronous reset (active high)
            -- Hit/Miss information.
            new_read_hit            <= '0';
            new_read_miss           <= '0';
            new_read_miss_dirty     <= '0';
            new_write_hit           <= '0';
            new_write_miss          <= '0';
            new_write_miss_dirty    <= '0';
            new_locked_write_hit    <= '0';
            new_locked_read_hit     <= '0';
            new_first_write_hit     <= '0';
            
          else
            -- Hit/Miss information.
            if( get_port_num(lu_check_info.Port_Num, C_NUM_PORTS) = I ) then
              new_read_hit            <= valid_new_stat and lookup_read_hit;
              new_read_miss           <= valid_new_stat and lookup_read_miss;
              new_read_miss_dirty     <= valid_new_stat and lookup_read_miss_dirty and not lu_check_info.Evict;
              new_write_hit           <= valid_new_stat and lookup_write_hit;
              new_write_miss          <= valid_new_stat and lookup_write_miss;
              new_write_miss_dirty    <= valid_new_stat and lookup_write_miss_dirty;
              new_locked_write_hit    <= valid_new_stat and lookup_locked_write_hit;
              new_locked_read_hit     <= valid_new_stat and lookup_locked_read_hit;
              new_first_write_hit     <= valid_new_stat and lookup_first_write_hit;
            else
              new_read_hit            <= '0';
              new_read_miss           <= '0';
              new_read_miss_dirty     <= '0';
              new_write_hit           <= '0';
              new_write_miss          <= '0';
              new_write_miss_dirty    <= '0';
              new_locked_write_hit    <= '0';
              new_locked_read_hit     <= '0';
              new_first_write_hit     <= '0';
            end if;
              
          end if;
        end if;
      end process Stat_Port_Handle;
      
      Write_Hit_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_write_hit,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_write_hit
        );
        
      Write_Miss_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_write_miss,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_write_miss
        );
        
      Write_Miss_Dirty_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_write_miss_dirty,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_write_miss_dirty
        );
        
      Read_Hit_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_read_hit,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_read_hit
        );
        
      Read_Miss_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_read_miss,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_read_miss
        );
        
      Read_Miss_Dirty_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_read_miss_dirty,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_read_miss_dirty
        );
        
      Locked_Write_Hit_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_locked_write_hit,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_locked_write_hit
        );
        
      Locked_Read_Hit_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_locked_read_hit,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_locked_read_hit
        );
        
      First_Write_Hit_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 1,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => new_first_write_hit,
          counter                   => (C_STAT_COUNTER_BITS-1 downto 0=>'0'),
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_lu_first_write_hit
        );
      -- Assign depending on category.
      Use_Opt: if( I < C_NUM_OPTIMIZED_PORTS ) generate
      begin
        stat_lu_opt_write_hit(I)                                <= stat_lu_write_hit;
        stat_lu_opt_write_miss(I)                               <= stat_lu_write_miss;
        stat_lu_opt_write_miss_dirty(I)                         <= stat_lu_write_miss_dirty;
        stat_lu_opt_read_hit(I)                                 <= stat_lu_read_hit;
        stat_lu_opt_read_miss(I)                                <= stat_lu_read_miss;
        stat_lu_opt_read_miss_dirty(I)                          <= stat_lu_read_miss_dirty;
        stat_lu_opt_locked_write_hit(I)                         <= stat_lu_locked_write_hit;
        stat_lu_opt_locked_read_hit(I)                          <= stat_lu_locked_read_hit;
        stat_lu_opt_first_write_hit(I)                          <= stat_lu_first_write_hit;
        
      end generate Use_Opt;
      Use_Gen: if( I >= C_NUM_OPTIMIZED_PORTS ) generate
      begin
        stat_lu_gen_write_hit(I - C_NUM_OPTIMIZED_PORTS)        <= stat_lu_write_hit;
        stat_lu_gen_write_miss(I - C_NUM_OPTIMIZED_PORTS)       <= stat_lu_write_miss;
        stat_lu_gen_write_miss_dirty(I - C_NUM_OPTIMIZED_PORTS) <= stat_lu_write_miss_dirty;
        stat_lu_gen_read_hit(I - C_NUM_OPTIMIZED_PORTS)         <= stat_lu_read_hit;
        stat_lu_gen_read_miss(I - C_NUM_OPTIMIZED_PORTS)        <= stat_lu_read_miss;
        stat_lu_gen_read_miss_dirty(I - C_NUM_OPTIMIZED_PORTS)  <= stat_lu_read_miss_dirty;
        stat_lu_gen_locked_write_hit(I - C_NUM_OPTIMIZED_PORTS) <= stat_lu_locked_write_hit;
        stat_lu_gen_locked_read_hit(I - C_NUM_OPTIMIZED_PORTS)  <= stat_lu_locked_read_hit;
        stat_lu_gen_first_write_hit(I - C_NUM_OPTIMIZED_PORTS)  <= stat_lu_first_write_hit;
      end generate Use_Gen;
    end generate Gen_Per_Port;
    
    LS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_stall
      );
      
    FS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_fetch_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_fetch_stall
      );
      
    MS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_mem_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_mem_stall
      );
      
    DS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_data_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_data_stall
      );
      
    DHS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_data_hit_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_data_hit_stall
      );
      
    DMS_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_lu_data_miss_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_lu_data_miss_stall
      );
      
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    LOOKUP_DEBUG(255 downto 0)  <= (others=>'0');
  end generate No_Debug;
  
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_PORTS   : natural := min_of( 4, C_NUM_INTERNAL_PORTS);
    constant C_MY_WORD    : natural := min_of( 6, C_ADDR_WORD_HI - C_ADDR_BYTE_LO + 1);
    constant C_MY_TLINE   : natural := min_of(10, C_ADDR_FULL_LINE_HI - C_ADDR_FULL_LINE_LO + 1);
    constant C_MY_DLINE   : natural := min_of(14, C_ADDR_DATA_HI - C_ADDR_DATA_LO + 1);
    constant C_MY_PWAY    : natural := min_of( 4, C_NUM_WAYS);
    constant C_MY_WAY     : natural := min_of( 2, C_WAY_BIT_HI - C_WAY_BIT_LO + 1);
    constant C_MY_TAG     : natural := min_of(16, C_TAG_SIZE);
    constant C_MY_WE      : natural := min_of( 4, C_CACHE_DATA_WIDTH/8);
    constant C_MY_2ND_WAY : natural := min_of( 1, C_NUM_WAYS - 1);
    constant C_MY_OFF     : natural := min_of( 6, C_ADDR_WORD_HI - C_ADDR_BYTE_LO + 1);
    constant C_MY_LEN     : natural := min_of( 6, C_INT_LEN);
    constant C_MY_DATA    : natural := min_of(32, C_CACHE_DATA_WIDTH);
    
    signal ack_write                : std_logic;
    
  begin
    -- Properties.
    ack_write               <= access_data_valid(lud_step_write_port_num) and lookup_write_data_ready_i(lud_step_write_port_num);
    
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          LOOKUP_DEBUG(255 downto 0)  <= (others=>'0');
        else
          -- Default assignment.
          LOOKUP_DEBUG(255 downto 0)  <= (others=>'0');
          
          -- Access signals: 1+6+6 + 4+4 = 13 + 8 (limited scope 9->6, 9->4)
--          LOOKUP_DEBUG(                              0)  <= access_valid;
--          LOOKUP_DEBUG(  1 + C_MY_WORD  - 1 downto   1)  <= access_info.Addr_Use(C_ADDR_OFFSET_POS)(C_MY_WORD - 1 downto 0);
--          LOOKUP_DEBUG(  7 + C_MY_WORD  - 1 downto   7)  <= access_info.Addr_Stp(C_ADDR_OFFSET_POS)(C_MY_WORD - 1 downto 0);
--          LOOKUP_DEBUG( 13 + C_MY_PORTS - 1 downto  13)  <= access_data_valid(C_MY_PORTS - 1 downto 0);

--          LOOKUP_DEBUG(                              0)  <= lud_step_use_check         : std_logic;
          LOOKUP_DEBUG(                              0)  <= lud_step_allow_write_step;
          LOOKUP_DEBUG(                              1)  <= lud_step_allow_read_step;
--          LOOKUP_DEBUG(                              0)  <= lud_step_offset            : std_logic;
--          LOOKUP_DEBUG(                              2)  <= lud_step_stall             : std_logic;
          LOOKUP_DEBUG(                              2)  <= lud_step_pos_read_in_mem;
          LOOKUP_DEBUG(                              3)  <= lud_step_want_check_step;
          LOOKUP_DEBUG(                              4)  <= lud_step_want_mem_step;
          LOOKUP_DEBUG(                              5)  <= lud_step_want_read_step;
          LOOKUP_DEBUG(                              6)  <= lud_step_want_write_step;
          LOOKUP_DEBUG(                              7)  <= lud_step_want_step_offset;
          LOOKUP_DEBUG(                              8)  <= lud_step_want_stall;
          LOOKUP_DEBUG(                              9)  <= lud_addr_piperun;
          LOOKUP_DEBUG(                             10)  <= lud_addr_stall;
          LOOKUP_DEBUG(                             11)  <= lud_mem_piperun;
--          LOOKUP_DEBUG(                              0)  <= lud_mem_speculative_valid  : std_logic;
--          LOOKUP_DEBUG(                              0)  <= lud_mem_valid              : std_logic;
          LOOKUP_DEBUG(                             12)  <= lud_mem_stall;
          LOOKUP_DEBUG(                             13)  <= lud_mem_completed;
          LOOKUP_DEBUG(                             14)  <= lud_mem_delayed_read_data;
          LOOKUP_DEBUG(                             15)  <= lud_mem_conflict;
          LOOKUP_DEBUG(                             16)  <= lud_mem_waiting_for_pipe;
          LOOKUP_DEBUG(                             17)  <= lud_reg_piperun;
          LOOKUP_DEBUG(                             18)  <= lud_reg_valid;
          LOOKUP_DEBUG(                             19)  <= ack_write;
          LOOKUP_DEBUG(                             20)  <= lud_reg_last;
          
          -- Internal Interface Signals (Read Data): 4+4 = 8 (limited scope 9->4)
--          LOOKUP_DEBUG( 21 + C_MY_PORTS - 1 downto  21)  <= read_data_status(C_MY_PORTS - 1 downto 0).Hit_Almost_Full;
          LOOKUP_DEBUG( 25 + C_MY_PORTS - 1 downto  25)  <= fit_vec(read_data_hit_full, C_MY_PORTS);
          
          -- Update signals: 1+1+1+1+1 = 5 (limited scope 9->1, current selected)
          LOOKUP_DEBUG(                             29)  <= update_tag_conflict;
          LOOKUP_DEBUG(                             30)  <= update_piperun;
          LOOKUP_DEBUG(                             31)  <= '0';
          LOOKUP_DEBUG(                             32)  <= update_write_miss_full;
          LOOKUP_DEBUG(                             33)  <= update_write_miss_busy(get_port_num(lu_check_info.Port_Num, C_NUM_INTERNAL_PORTS));
          
          -- Lookup signals (to Access): 1
          LOOKUP_DEBUG(                             34)  <= lookup_piperun_i;
          
          -- Lookup signals (to Frontend): 4+1+4 = 9 (limited scope 9->4)
          LOOKUP_DEBUG( 35 + C_MY_PORTS - 1 downto  35)  <= fit_vec(lookup_read_data_valid_i, C_MY_PORTS);
          LOOKUP_DEBUG(                             39)  <= lud_mem_use_speculative;
          LOOKUP_DEBUG( 40 + C_MY_PORTS - 1 downto  40)  <= fit_vec(lookup_write_data_ready_i, C_MY_PORTS);
          
          
          -- Lookup signals (to Tag & Data): 10+1+16*2 + 14+4+4 = 43 + 22 (limited scope 8->4)
          LOOKUP_DEBUG( 44 + C_MY_TLINE - 1 downto  44)  <= lookup_tag_addr_i(C_ADDR_FULL_LINE_LO + C_MY_TLINE - 1 downto 
                                                                              C_ADDR_FULL_LINE_LO);
          LOOKUP_DEBUG(                             54)  <= lookup_tag_en_i;
--          LOOKUP_DEBUG( 55 + C_MY_TAG   - 1 downto  55)  <= lookup_tag_current_word(0)(C_TAG_SIZE - 1 downto C_TAG_SIZE - C_MY_TAG);
--          LOOKUP_DEBUG( 71 + C_MY_TAG   - 1 downto  71)  <= lookup_tag_current_word(C_MY_2ND_WAY)(C_TAG_SIZE - 1 downto C_TAG_SIZE - C_MY_TAG);
          LOOKUP_DEBUG( 87 + C_MY_DLINE - 1 downto  87)  <= lookup_data_addr_i(C_ADDR_DATA_LO + C_MY_DLINE - 1 downto 
                                                                               C_ADDR_DATA_LO);
          LOOKUP_DEBUG(101 + C_MY_PWAY  - 1 downto 101)  <= fit_vec(lookup_data_en_i, C_MY_PWAY );
          LOOKUP_DEBUG(105 + C_MY_WE    - 1 downto 105)  <= fit_vec(lookup_data_we_i, C_MY_WE);
          
          -- Lookup signals (to Arbiter): 2+1+1 = 4 (limited scope 4->2)
          LOOKUP_DEBUG(                            109)  <= lookup_io_data_stall;
          LOOKUP_DEBUG(                            110)  <= lu_ds_last_beat_stall;
          LOOKUP_DEBUG(                            111)  <= lookup_read_done_i;
          LOOKUP_DEBUG(                            112)  <= lookup_read_data_new_i;
          
          -- Lookup signals (to LRU): 1+2+2 = 5 (limited scope 3->2)
          LOOKUP_DEBUG(                            113)  <= lru_check_use_lru_i;

          LOOKUP_DEBUG(114 + C_MY_WAY   - 1 downto 114)  <= lru_tag_assoc_way(C_WAY_BIT_LO + C_MY_WAY - 1 downto 
                                                                              C_WAY_BIT_LO); 
                                                            -- lru_check_used_way, update_way
          LOOKUP_DEBUG(116 + C_MY_WAY   - 1 downto 116)  <= lru_check_next_way(C_WAY_BIT_LO + C_MY_WAY - 1 downto 
                                                                               C_WAY_BIT_LO);
            
          -- Lookup signals (to Update): 1+1+1 = 3
          LOOKUP_DEBUG(                            118)  <= lookup_push_write_miss_i;
          LOOKUP_DEBUG(                            119)  <= lookup_wm_evict_i;
          LOOKUP_DEBUG(                            120)  <= update_valid_i;
          
          -- Lookup Pipeline Stage: Access : 1
          LOOKUP_DEBUG(                            121)  <= lu_check_wr_already_pushed;
          
          -- Lookup pipe stage: Fetch : 7
          LOOKUP_DEBUG(                            122)  <= lu_fetch_piperun;
          LOOKUP_DEBUG(                            123)  <= lu_fetch_valid;
          LOOKUP_DEBUG(                            124)  <= lu_fetch_stall;
          LOOKUP_DEBUG(                            125)  <= lud_write_hit_done;
          LOOKUP_DEBUG(                            126)  <= lookup_io_wr_done_drop;
          LOOKUP_DEBUG(                            127)  <= lu_fetch_protect_conflict;
          LOOKUP_DEBUG(                            128)  <= lu_check_shared_force_drop;
          
          -- Lookup pipe stage: Memory : 7
          LOOKUP_DEBUG(                            129)  <= lu_mem_piperun;
          LOOKUP_DEBUG(                            130)  <= lu_mem_valid;
          LOOKUP_DEBUG(                            131)  <= lu_mem_stall;
          LOOKUP_DEBUG(                            132)  <= reduce_or(lu_mem_snoop_tag_hit);
          LOOKUP_DEBUG(                            133)  <= lud_step_unlock_rerun;
          LOOKUP_DEBUG(                            134)  <= lu_mem_protect_conflict;
          LOOKUP_DEBUG(                            135)  <= '0';
          
          -- Lookup pipe stage: Check : 15
          LOOKUP_DEBUG(                            136)  <= lu_check_piperun;
          LOOKUP_DEBUG(                            137)  <= lu_check_valid;
          LOOKUP_DEBUG(                            138)  <= lu_check_stall;
          LOOKUP_DEBUG(                            139)  <= lu_check_wait_for_update;
          LOOKUP_DEBUG(                            140)  <= lu_check_need_move2update;
          LOOKUP_DEBUG(                            141)  <= lookup_push_wm_edrop_raw;
          LOOKUP_DEBUG(                            142)  <= lookup_other_write_stall;
          LOOKUP_DEBUG(                            143)  <= lookup_access_data_late;
          LOOKUP_DEBUG(                            144)  <= lookup_protect_conflict;
          LOOKUP_DEBUG(                            145)  <= lookup_restart_mem;
          LOOKUP_DEBUG(                            146)  <= update_error_freeze;
          LOOKUP_DEBUG(                            147)  <= update_error_evict_insert;
          LOOKUP_DEBUG(                            148)  <= lookup_evict_hit;
          LOOKUP_DEBUG(                            149)  <= lookup_true_locked_read;
          LOOKUP_DEBUG(                            150)  <= lu_check_read_info_done;
          
          
          -- LRU Handling: 1
          LOOKUP_DEBUG(                            151)  <= lookup_invalid_exist;
          
          -- TAG Conflict: 1+1+1 = 3
          LOOKUP_DEBUG(                            152)  <= lu_mem_tag_conflict;
          LOOKUP_DEBUG(                            153)  <= lu_check_tag_conflict;
          LOOKUP_DEBUG(                            154)  <= lookup_tag_conflict;
          
          -- Data Offset Counter: 16 + 6*4 = 40 (limited scope max 6bit)
          LOOKUP_DEBUG(                            155)  <= lud_step_use_check;
          LOOKUP_DEBUG(                            156)  <= lookup_kind;
          LOOKUP_DEBUG(                            157)  <= lud_mem_already_used;
          LOOKUP_DEBUG(                            158)  <= lud_step_stall;
          LOOKUP_DEBUG(                            159)  <= lud_step_offset;
          LOOKUP_DEBUG(                            160)  <= lookup_step_last;
          LOOKUP_DEBUG(                            161)  <= lud_mem_keep_single_during_stall;
          LOOKUP_DEBUG(162 + C_MY_OFF   - 1 downto 162)  <= lookup_base_offset(C_ADDR_BYTE_LO + C_MY_OFF - 1 downto 
                                                                               C_ADDR_BYTE_LO);
          LOOKUP_DEBUG(168 + C_MY_OFF   - 1 downto 168)  <= lookup_word_offset(C_ADDR_BYTE_LO + C_MY_OFF - 1 downto 
                                                                               C_ADDR_BYTE_LO);
          LOOKUP_DEBUG(174 + C_MY_LEN   - 1 downto 174)  <= fit_vec(lookup_offset_len, C_MY_LEN);
          LOOKUP_DEBUG(                            180)  <= lookup_offset_first;
          LOOKUP_DEBUG(                            181)  <= lookup_force_first;
          LOOKUP_DEBUG(                            182)  <= lookup_offset_all_first;
          LOOKUP_DEBUG(                            183)  <= lu_check_early_bresp;
          LOOKUP_DEBUG(184 + C_MY_OFF   - 1 downto 184)  <= lookup_offset_cnt(C_ADDR_BYTE_LO + C_MY_OFF - 1 downto 
                                                                              C_ADDR_BYTE_LO);
          LOOKUP_DEBUG(                            190)  <= lookup_data_stall;
          LOOKUP_DEBUG(                            191)  <= lud_mem_speculative_valid;
          LOOKUP_DEBUG(                            192)  <= lud_mem_valid;
          LOOKUP_DEBUG(                            193)  <= lud_addr_pipeline_full;
          LOOKUP_DEBUG(                            194)  <= lud_mem_last;
          
          -- Cache Hit & Miss Detect (Check): 13
          LOOKUP_DEBUG(                            195)  <= lu_check_tag_hit_all;
          LOOKUP_DEBUG(                            196)  <= lu_check_tag_miss_all;
          LOOKUP_DEBUG(                            197)  <= lookup_raw_hit;
          LOOKUP_DEBUG(                            198)  <= lookup_hit;
          LOOKUP_DEBUG(                            199)  <= lookup_miss;
          LOOKUP_DEBUG(                            200)  <= lookup_read_hit;
          LOOKUP_DEBUG(                            201)  <= lookup_read_miss;
          LOOKUP_DEBUG(                            202)  <= lookup_read_miss_dirty;
          LOOKUP_DEBUG(                            203)  <= lookup_write_hit;
          LOOKUP_DEBUG(                            204)  <= lookup_locked_write_hit;
          LOOKUP_DEBUG(                            205)  <= lookup_locked_read_hit;
          LOOKUP_DEBUG(                            206)  <= lookup_first_write_hit;
          LOOKUP_DEBUG(                            207)  <= lookup_write_miss;
          LOOKUP_DEBUG(                            208)  <= lookup_data_hit_stall;
          LOOKUP_DEBUG(                            209)  <= lookup_data_miss_stall;
          LOOKUP_DEBUG(                            210)  <= lu_fetch_info.Wr;
          LOOKUP_DEBUG(                            211)  <= lu_mem_info.Wr;
          LOOKUP_DEBUG(                            212)  <= lu_check_info.Wr;
          LOOKUP_DEBUG(                            213)  <= lu_check_keep_allocation;
          LOOKUP_DEBUG(                            214)  <= lookup_read_data_hit_i;
          LOOKUP_DEBUG(215 + C_MY_PWAY  - 1 downto 215)  <= lu_check_valid_bits(C_MY_PWAY  - 1 downto 0);
          LOOKUP_DEBUG(219 + C_MY_PWAY  - 1 downto 219)  <= lu_check_dirty_bits(C_MY_PWAY  - 1 downto 0);
          LOOKUP_DEBUG(223 + C_MY_PWAY  - 1 downto 223)  <= lu_check_locked_bits(C_MY_PWAY  - 1 downto 0);
          LOOKUP_DEBUG(227 + C_MY_WAY   - 1 downto 227)  <= lookup_new_tag_assoc_way(C_WAY_BIT_LO + C_MY_WAY - 1 downto 
                                                                                     C_WAY_BIT_LO);
          LOOKUP_DEBUG(229 + C_MY_WAY   - 1 downto 229)  <= lookup_tag_assoc_way(C_WAY_BIT_LO + C_MY_WAY - 1 downto 
                                                                                 C_WAY_BIT_LO);
          LOOKUP_DEBUG(                            231)  <= lu_check_info.Evict;
          LOOKUP_DEBUG(                            232)  <= lu_check_info.KillHit;
          LOOKUP_DEBUG(                            233)  <= lu_check_info.SnoopResponse;
          LOOKUP_DEBUG(                            234)  <= lu_check_done;
          LOOKUP_DEBUG(                            235)  <= reduce_or(assert_err);
          LOOKUP_DEBUG(                            236)  <= lookup_write_miss_dirty;
          LOOKUP_DEBUG(237 + C_MY_PWAY  - 1 downto 237)  <= lu_check_protected(C_MY_PWAY  - 1 downto 0);
          LOOKUP_DEBUG(                            241)  <= lookup_wm_allocate_i;
          LOOKUP_DEBUG(                            242)  <= lookup_block_reuse;
          LOOKUP_DEBUG(                            243)  <= lookup_miss_dirty;
          LOOKUP_DEBUG(244 + C_MY_WAY   - 1 downto 244)  <= std_logic_vector(to_unsigned(lu_check_protected_way,
                                                                                         C_MY_WAY));
          
          LOOKUP_DEBUG(                            246)  <= lru_dirty_bit;
          LOOKUP_DEBUG(                            247)  <= dirty_bit_miss;
          LOOKUP_DEBUG(                            248)  <= dirty_miss_valid;
          LOOKUP_DEBUG(                            249)  <= dirty_bit;
          LOOKUP_DEBUG(                            250)  <= dirty_bit_valid;
          LOOKUP_DEBUG(                            251)  <= lookup_miss_dirty_pre;
          LOOKUP_DEBUG(                            252)  <= lu_check_error_force_miss;
          LOOKUP_DEBUG(                            253)  <= update_allocate_conflict;
          LOOKUP_DEBUG(                            254)  <= update_allocate_error;
          LOOKUP_DEBUG(                            255)  <= lu_check_drop_allocation;   -- Was: lu_check_early_with_drop;
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  Assertions: block
  begin
    -- ----------------------------------------
    -- Never detect multiple hits for the same address.
    
    Assert_Cachehit: process (lu_check_tag_hit) is
      variable detect_hit : std_logic;
    begin  -- process Assert_Cachehit
      detect_hit                        := '0';
      assert_err(C_ASSERT_MULTIPLE_HIT) <= '0';
      
      for K in lu_check_tag_hit'range loop
        if( lu_check_tag_hit(K) = '1' ) then
          if( detect_hit = '1' and C_USE_ASSERTIONS ) then
            assert_err(C_ASSERT_MULTIPLE_HIT) <= '1';
          end if;
          detect_hit  := '1';
        end if;
      end loop; 
    end process Assert_Cachehit;
    
    -- ----------------------------------------
    -- Never push Read Data to full FIFO.
    
    Assert_Full_FIFO: process (read_data_hit_full, lookup_read_data_valid_i) is
    begin  -- process Assert_Full_FIFO
      assert_err(C_ASSERT_FIFO_FULL_VIOLATION)  <= '0';
      
      for K in lookup_read_data_valid_i'range loop
        if( ( lookup_read_data_valid_i(K) and read_data_hit_full(K) ) = '1' and C_USE_ASSERTIONS ) then
          assert_err(C_ASSERT_FIFO_FULL_VIOLATION)  <= '1';
        end if;
      end loop; 
    end process Assert_Full_FIFO;
    
    
    -- ----------------------------------------
    -- Messages.
    
    -- pragma translate_off
      
    assert assert_err_1(C_ASSERT_FIFO_FULL_VIOLATION) = '0' 
      report "Lookup: Write to Full FIFO Detected."
        severity error;
    
    assert assert_err_1(C_ASSERT_MULTIPLE_HIT) = '0' 
      report "Lookup: Illegal Multiple Hit Detected."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_cache_core.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_cache_core.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_cache_core.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


entity sc_cache_core is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean:= false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
    C_NUM_WAYS                : natural range  1 to    8      :=  2;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_SUPPORT_SNOOP_FILTER    : natural range  0 to    1      :=  0;
    C_KEEP_SHARED_WRITE       : natural range  0 to    1      :=  1;
    C_READ_ONLY_UNIQUE        : natural range  0 to    1      :=  0;
    C_READ_EXCLUSIVE_CLEAN    : natural range  0 to    1      :=  1;
    C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
    
    -- Data type and settings specific.
    C_LRU_ADDR_BITS           : natural range  4 to   63      := 13;
    C_TAG_SIZE                : natural range  3 to   63      := 15;
    C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
    C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
    C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
    C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_EXT_DATA_HI        : natural range  2 to   63      := 14;
    C_ADDR_EXT_DATA_LO        : natural range  2 to   63      :=  2;
    C_ADDR_DATA_HI            : natural range  2 to   63      := 14;
    C_ADDR_DATA_LO            : natural range  2 to   63      :=  2;
    C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
    C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
    C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
    C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
    C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
    C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
    C_ADDR_EXT_BYTE_HI        : natural range  0 to   63      :=  1;
    C_ADDR_EXT_BYTE_LO        : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
    C_WAY_BIT_LO              : natural range  0 to    0      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Access signals.
    
    access_valid              : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    access_info               : in  ACCESS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    access_data_info          : in  DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : out READ_SOURCE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : in  STAT_RI_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    read_data_status          : in  STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Access).
    
    lookup_piperun            : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Frontend).
    
    lookup_read_data_info     : out READ_HIT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
    lookup_write_data_ready   : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Arbiter).
    
    lookup_read_done          : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (to Frontend).
    
    -- Read miss
    update_read_data_info     : out READ_MISS_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    update_read_data_ready    : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    -- Write Miss
    update_write_data_ready   : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    -- Write miss response
    update_ext_bresp_info     : out WRITE_RESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    update_ext_bresp_ready    : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Automatic Clean Information.
    
    update_auto_clean_push    : out std_logic;
    update_auto_clean_addr    : out AXI_ADDR_TYPE;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_lookup_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    ctrl_update_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (to Backend).
    
    read_req_info             : out READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_req_ready            : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_req_info            : out WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_req_ready           : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    write_data_info           : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    write_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_almost_full    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    write_data_full           : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Status signals (to Lookup).
    
    be_writeunique_inflight   : in  std_logic;
    be_writeback_inflight     : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Backend signals.
    
    backend_wr_resp_info      : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_wr_resp_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    backend_wr_resp_conf      : out WRITE_CONF_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    backend_rd_data_info      : in  READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    backend_rd_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Master Snoop Interface Signals.
    
    mst_snoop_fetch_piperun   : in  std_logic;
    mst_snoop_fetch_info      : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_piperun     : in  std_logic;
    mst_snoop_mem_info        : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_piperun   : in  std_logic;
    mst_snoop_check_info      : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_fetch_ack_info  : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_mem_ack_info    : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_ack_info  : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_update_ack_info : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_fetch_hazard     : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_mem_hazard       : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_check_hazard     : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_hazard    : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_mem_rm_alloc    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_check_rm_alloc  : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_tag_valid       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_way         : in  natural range C_NUM_WAYS - 1 downto 0;
    mst_snoop_tag_info        : in  WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_tag_stall       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_snoop_sdr_push        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_info        : in  MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_empty       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    mst_snoop_sdr_full        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    mst_core_update_data_info : out MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    mst_core_update_data_ready: in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                      : in  std_logic;
    stat_enable                     : in  std_logic;
    
    -- Lookup
    stat_lu_opt_write_hit           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss          : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss_dirty    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_hit            : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss_dirty     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_write_hit    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_read_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_first_write_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    
    stat_lu_gen_write_hit           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss          : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss_dirty    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_hit            : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss_dirty     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_write_hit    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_read_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_first_write_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    
    stat_lu_stall                   : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_fetch_stall             : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_mem_stall               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_stall              : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_hit_stall          : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_miss_stall         : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    
    -- Update
    stat_ud_stall                   : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time transactions are stalled
    stat_ud_tag_free                : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles tag is free
    stat_ud_data_free               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles data is free
    stat_ud_ri                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read Information
    stat_ud_r                       : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read data (optional)
    stat_ud_e                       : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Evict
    stat_ud_bs                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- BRESP Source
    stat_ud_wm                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss
    stat_ud_wma                     : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss Allocate (reserved)
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error                    : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    MEMORY_DEBUG1                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    MEMORY_DEBUG2                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    LOOKUP_DEBUG                    : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    UPDATE_DEBUG1                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    UPDATE_DEBUG2                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0)
  );
end entity sc_cache_core;

library IEEE;
use IEEE.numeric_std.all;

architecture IMP of sc_cache_core is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- The core of the System Cache functionality is implemented in the 
  -- sub-modules here.
  -- 
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_LOOKUP_ERROR              : natural :=  0;
  constant C_ASSERT_UPDATE_ERROR              : natural :=  1;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  2;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_WAY_BITS                 : natural := Log2(C_NUM_WAYS);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Data related.
  subtype C_TAG_POS                   is natural range C_TAG_SIZE - 1                 downto 0;
  subtype C_BE_POS                    is natural range C_CACHE_DATA_WIDTH/8 - 1       downto 0;
  subtype C_DATA_POS                  is natural range C_CACHE_DATA_WIDTH - 1         downto 0;
  subtype C_CACHE_DATA_ADDR_POS       is natural range C_CACHE_DATA_ADDR_WIDTH - 1    downto 0;
  subtype C_EXT_BE_POS                is natural range C_EXTERNAL_DATA_WIDTH/8 - 1    downto 0;
  subtype C_EXT_DATA_POS              is natural range C_EXTERNAL_DATA_WIDTH - 1      downto 0;
  subtype C_EXT_DATA_ADDR_POS         is natural range C_EXTERNAL_DATA_ADDR_WIDTH - 1 downto 0;
  subtype TAG_TYPE                    is std_logic_vector(C_TAG_POS);
  subtype BE_TYPE                     is std_logic_vector(C_BE_POS);
  subtype DATA_TYPE                   is std_logic_vector(C_DATA_POS);
  subtype EXT_BE_TYPE                 is std_logic_vector(C_EXT_BE_POS);
  subtype EXT_DATA_TYPE               is std_logic_vector(C_EXT_DATA_POS);
  
  -- Port related.
  subtype C_PORT_POS                  is natural range C_NUM_PORTS - 1 downto 0;
  subtype PORT_TYPE                   is std_logic_vector(C_PORT_POS);
  type PORT_BE_TYPE                   is array(C_PORT_POS) of BE_TYPE;
  type PORT_DATA_TYPE                 is array(C_PORT_POS) of DATA_TYPE;
  
  -- Set related.
  subtype C_WAY_POS                   is natural  range C_NUM_WAYS - 1          downto 0;
  subtype C_WAY_BIT_POS               is natural  range C_WAY_BIT_HI            downto C_WAY_BIT_LO;
  
  subtype WAY_TYPE                    is std_logic_vector(C_WAY_POS);
  subtype WAY_BIT_TYPE                is std_logic_vector(C_WAY_BIT_POS);
  
  -- Address related.
  subtype C_ADDR_VALID_POS            is natural range C_ADDR_VALID_HI downto C_ADDR_VALID_LO;
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI   downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  subtype C_ADDR_EXT_DATA_POS         is natural range C_ADDR_EXT_DATA_HI   downto C_ADDR_EXT_DATA_LO;
  subtype C_ADDR_DATA_POS             is natural range C_ADDR_DATA_HI       downto C_ADDR_DATA_LO;
  subtype C_ADDR_TAG_POS              is natural range C_ADDR_TAG_HI        downto C_ADDR_TAG_LO;
  subtype C_ADDR_FULL_LINE_POS        is natural range C_ADDR_FULL_LINE_HI  downto C_ADDR_FULL_LINE_LO;
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI     downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_EXT_WORD_POS         is natural range C_ADDR_EXT_WORD_HI   downto C_ADDR_EXT_WORD_LO;
  subtype C_ADDR_WORD_POS             is natural range C_ADDR_WORD_HI       downto C_ADDR_WORD_LO;
  subtype C_ADDR_EXT_BYTE_POS         is natural range C_ADDR_EXT_BYTE_HI   downto C_ADDR_EXT_BYTE_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  subtype ADDR_VALID_TYPE             is std_logic_vector(C_ADDR_VALID_POS);
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_DIRECT_TYPE            is std_logic_vector(C_ADDR_DIRECT_POS);
  subtype ADDR_EXT_DATA_TYPE          is std_logic_vector(C_ADDR_EXT_DATA_POS);
  subtype ADDR_DATA_TYPE              is std_logic_vector(C_ADDR_DATA_POS);
  subtype ADDR_TAG_TYPE               is std_logic_vector(C_ADDR_TAG_POS);
  subtype ADDR_FULL_LINE_TYPE         is std_logic_vector(C_ADDR_FULL_LINE_POS);
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_EXT_WORD_TYPE          is std_logic_vector(C_ADDR_EXT_WORD_POS);
  subtype ADDR_WORD_TYPE              is std_logic_vector(C_ADDR_WORD_POS);
  subtype ADDR_EXT_BYTE_TYPE          is std_logic_vector(C_ADDR_EXT_BYTE_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  -- Ranges for TAG information parts.
  constant C_NUM_ADDR_TAG_BITS        : natural := C_TAG_SIZE - C_NUM_STATUS_BITS;
  constant C_TAG_LOCKED_POS           : natural := C_NUM_ADDR_TAG_BITS;
  constant C_TAG_DIRTY_POS            : natural := C_TAG_LOCKED_POS    + 1;
  constant C_TAG_REUSED_POS           : natural := C_TAG_DIRTY_POS     + 1;
  constant C_TAG_SECURE_POS           : natural := C_TAG_REUSED_POS    + 1;
  constant C_TAG_UNIQUE_POS           : natural := C_TAG_SECURE_POS    + C_ENABLE_NON_SECURE;
  constant C_TAG_VALID_POS            : natural := C_TAG_UNIQUE_POS    + is_mst_coherent(C_ENABLE_COHERENCY);
  subtype C_TAG_ADDR_POS              is natural range C_NUM_ADDR_TAG_BITS - 1 downto 0;
  subtype TAG_ADDR_TYPE               is std_logic_vector(C_TAG_ADDR_POS);
  
  constant C_TAG_FORCE_BRAM           : boolean := (C_ADDR_FULL_LINE_HI - C_ADDR_FULL_LINE_LO + 1) >= 8;

  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_lookup is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean:= false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_NUM_WAYS                : natural range  2 to    8      :=  2;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_SUPPORT_SNOOP_FILTER    : natural range  0 to    1      :=  0;
      C_KEEP_SHARED_WRITE       : natural range  0 to    1      :=  1;
      C_READ_ONLY_UNIQUE        : natural range  0 to    1      :=  0;
      C_READ_EXCLUSIVE_CLEAN    : natural range  0 to    1      :=  1;
      C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_TAG_SIZE                : natural range  3 to   63      := 15;
      C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_DATA_HI            : natural range  2 to   63      := 14;
      C_ADDR_DATA_LO            : natural range  2 to   63      :=  2;
      C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
      C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
      C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
      C_WAY_BIT_LO              : natural range  0 to    0      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Access signals.
      
      access_valid              : in  std_logic;
      access_info               : in  ACCESS_TYPE;
      
      access_data_info          : in  DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : out READ_SOURCE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : in  STAT_RI_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      read_data_status          : in  STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      update_tag_conflict       : in  std_logic;
      update_piperun            : in  std_logic;
      
      update_write_miss_full    : in  std_logic;
      update_write_miss_busy    : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      update_allocate_conflict  : in  std_logic;
      update_allocate_error     : in  std_logic;
      
      update_error_freeze       : in  std_logic;
      update_error_evict_insert : in  std_logic;
      update_error_evict_way    : in  natural range C_NUM_WAYS - 1 downto 0;
      update_error_evict_info   : in  ACCESS_TYPE;
      update_error_wait         : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Access).
      
      lookup_piperun            : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Frontend).
      
      lookup_read_data_info     : out READ_HIT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      lookup_write_data_ready   : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Tag & Data).
      
      lookup_tag_addr           : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
      lookup_tag_en             : out std_logic;
      lookup_tag_we             : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
      lookup_tag_new_word       : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      lookup_tag_current_word   : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      
      lookup_data_addr          : out std_logic_vector(C_ADDR_DATA_HI downto C_ADDR_DATA_LO);
      lookup_data_en            : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
      lookup_data_we            : out std_logic_vector(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
      lookup_data_new_word      : out std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
      lookup_data_current_word  : in  AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Arbiter).
      
      lookup_read_done          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to LRU).
      
      -- Pipe control.
      lookup_fetch_piperun      : out std_logic;
      lookup_mem_piperun        : out std_logic;
      
      -- Peek LRU.
      lru_fetch_line_addr       : out std_logic_vector(C_ADDR_LINE_HI downto C_ADDR_LINE_LO);
      lru_check_next_way        : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
      lru_check_next_hot_way    : in  std_logic_vector(C_NUM_WAYS - 1 downto 0);
      
      -- Control LRU.
      lru_check_use_lru         : out std_logic;
      lru_check_line_addr       : out std_logic_vector(C_ADDR_LINE_HI downto C_ADDR_LINE_LO);
      lru_check_used_way        : out std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Update).
      
      lookup_new_addr           : out AXI_ADDR_TYPE;
      lookup_stall_addr         : out AXI_ADDR_TYPE;
      
      lookup_push_write_miss    : out std_logic;
      lookup_wm_allocate        : out std_logic;
      lookup_wm_evict           : out std_logic;
      lookup_wm_will_use        : out std_logic;
      lookup_wm_info            : out ACCESS_TYPE;
      lookup_wm_use_bits        : out std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
      lookup_wm_stp_bits        : out std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
      lookup_wm_allow_write     : out std_logic;
      lookup_wm_create          : out std_logic;
      
      update_valid              : out std_logic;
      update_way                : out natural range C_NUM_WAYS - 1 downto 0;
      update_info               : out ACCESS_TYPE;
      update_hit                : out std_logic;
      update_miss               : out std_logic;
      update_read_hit           : out std_logic;
      update_read_miss          : out std_logic;
      update_read_miss_dirty    : out std_logic;
      update_write_hit          : out std_logic;
      update_write_miss         : out std_logic;
      update_write_miss_dirty   : out std_logic;
      update_locked_write_hit   : out std_logic;
      update_locked_read_hit    : out std_logic;
      update_first_write_hit    : out std_logic;
      update_evict_hit          : out std_logic;
      update_exclusive_hit      : out std_logic;
      update_create_bresp       : out std_logic;
      update_early_bresp        : out std_logic;
      update_failed_allocation  : out std_logic;
      update_whl_rejected       : out std_logic;
      update_snoop_made_clean   : out std_logic;
      update_snoop_made_shared  : out std_logic;
      update_snoop_made_invalid : out std_logic;
      update_snoop_altered_delayed_txn : out std_logic;
      update_snoop_made_txn_clean      : out std_logic;
      update_snoop_made_txn_shared     : out std_logic;
      update_snoop_made_txn_invalid    : out std_logic;
      update_need_bs            : out std_logic;
      update_need_ar            : out std_logic;
      update_need_aw            : out std_logic;
      update_need_evict         : out std_logic;
      update_need_tag_write     : out std_logic;
      update_inserted_trans     : out std_logic;
      update_reused_tag         : out std_logic;
      update_old_tag            : out WAY_LINE_TAG_TYPE;
      update_refreshed_lru      : out std_logic;
      update_all_tags           : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      update_inserted_rd_done   : in  std_logic;
      update_inserted_ex_ok     : in  std_logic;
      update_inserted_wr_done   : in  std_logic;
      update_pushing_writeunique: in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      update_pushing_writeback  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      update_lock_release       : in  std_logic;
      update_lock_way           : in  natural range C_NUM_WAYS - 1 downto 0;
      update_release_tag        : in  WAY_LINE_TAG_TYPE;
      
      update_whl_pop            : in  std_logic;
      update_whl_exist          : out std_logic;
      update_whl_strb           : out std_logic_vector(C_CACHE_LINE_LENGTH * 32/8 - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   : in  std_logic;
      be_writeback_inflight     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   : in  std_logic;
      mst_snoop_fetch_info      : in  MST_SNOOP_REQ_TYPE;
      mst_snoop_mem_piperun     : in  std_logic;
      mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
      mst_snoop_check_piperun   : in  std_logic;
      mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
      
      mst_core_fetch_hazard     : out RMST_SNOOP_HAZ_TYPE;
      mst_core_mem_hazard       : out RMST_SNOOP_HAZ_TYPE;
      mst_core_check_hazard     : out RMST_SNOOP_HAZ_TYPE;
      
      mst_snoop_sdr_empty       : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_lookup_done          : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      stat_lu_opt_write_hit           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss_dirty    : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_hit            : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss_dirty     : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_write_hit    : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_read_hit     : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_first_write_hit     : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      
      stat_lu_gen_write_hit           : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss          : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss_dirty    : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_hit            : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss           : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss_dirty     : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_write_hit    : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_read_hit     : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_first_write_hit     : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      
      stat_lu_stall                   : out STAT_POINT_TYPE;    -- Time per occurrence
      stat_lu_fetch_stall             : out STAT_POINT_TYPE;    -- Time per occurrence
      stat_lu_mem_stall               : out STAT_POINT_TYPE;    -- Time per occurrence
      stat_lu_data_stall              : out STAT_POINT_TYPE;    -- Time per occurrence
      stat_lu_data_hit_stall          : out STAT_POINT_TYPE;    -- Time per occurrence
      stat_lu_data_miss_stall         : out STAT_POINT_TYPE;    -- Time per occurrence
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error                    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      LOOKUP_DEBUG                    : out MAX_DEBUG_TYPE
    );
  end component sc_lookup;
  
  component sc_lru_module is
    generic (
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_ADDR_SIZE_LOG2          : natural := 5;
      C_LINE_SIZE_LOG2          : natural := 2
    );
    port (
      -- Global signals.
      Clk                       : in  std_logic;
      Reset                     : in  std_logic;
      
      -- Pipe control.
      lookup_fetch_piperun      : in  std_logic;
      lookup_mem_piperun        : in  std_logic;
      
      -- Peek LRU.
      lru_fetch_line_addr       : in  std_logic_vector(C_ADDR_SIZE_LOG2 - 1 downto 0);
      lru_check_next_way        : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
      lru_check_next_hot_way    : out std_logic_vector(2**C_LINE_SIZE_LOG2 - 1 downto 0);
      
      -- Control LRU.
      lru_check_use_lru         : in  std_logic;
      lru_check_line_addr       : in  std_logic_vector(C_ADDR_SIZE_LOG2 - 1 downto 0);
      lru_check_used_way        : in  std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
      
      -- After refresh.
      lru_update_prev_lru_way   : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0);
      lru_update_new_lru_way    : out std_logic_vector(C_LINE_SIZE_LOG2 - 1 downto 0)
    );
  end component sc_lru_module;
  
  component sc_update is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean:= false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
      C_NUM_WAYS                : natural range  1 to    8      :=  2;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      
      -- Data type and settings specific.
      C_TAG_SIZE                : natural range  3 to   63      := 15;
      C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_EXT_DATA_HI        : natural range  2 to   63      := 14;
      C_ADDR_EXT_DATA_LO        : natural range  2 to   63      :=  2;
      C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
      C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
      C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
      C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
      C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
      C_ADDR_EXT_BYTE_HI        : natural range  0 to   63      :=  1;
      C_ADDR_EXT_BYTE_LO        : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
      C_WAY_BIT_LO              : natural range  0 to    0      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Access signals.
      
      access_valid              : in  std_logic;
      
      access_data_info          : in  DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
      
      -- ---------------------------------------------------
      -- Lookup signals.
      
      -- Tag Addr Check.
      lookup_new_addr           : in  AXI_ADDR_TYPE;
      lookup_stall_addr         : in  AXI_ADDR_TYPE;
      
      -- Write Miss
      lookup_push_write_miss    : in  std_logic;
      lookup_wm_allocate        : in  std_logic;
      lookup_wm_evict           : in  std_logic;
      lookup_wm_will_use        : in  std_logic;
      lookup_wm_info            : in  ACCESS_TYPE;
      lookup_wm_use_bits        : in  std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
      lookup_wm_stp_bits        : in  std_logic_vector(C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO);
      lookup_wm_allow_write     : in  std_logic;
      lookup_wm_create          : in  std_logic;
      
      -- Update transaction.
      update_valid              : in  std_logic;
      update_way                : in  natural range C_NUM_WAYS - 1 downto 0;
      update_info               : in  ACCESS_TYPE;
      update_hit                : in  std_logic;
      update_miss               : in  std_logic;
      update_read_hit           : in  std_logic;
      update_read_miss          : in  std_logic;
      update_read_miss_dirty    : in  std_logic;
      update_write_hit          : in  std_logic;
      update_write_miss         : in  std_logic;
      update_write_miss_dirty   : in  std_logic;
      update_locked_write_hit   : in  std_logic;
      update_locked_read_hit    : in  std_logic;
      update_first_write_hit    : in  std_logic;
      update_evict_hit          : in  std_logic;
      update_exclusive_hit      : in  std_logic;
      update_create_bresp       : in  std_logic;
      update_early_bresp        : in  std_logic;
      update_failed_allocation  : in  std_logic;
      update_whl_rejected       : in  std_logic;
      update_snoop_made_clean   : in std_logic;
      update_snoop_made_shared  : in std_logic;
      update_snoop_made_invalid : in std_logic;
      update_snoop_altered_delayed_txn : in  std_logic;
      update_snoop_made_txn_clean      : in  std_logic;
      update_snoop_made_txn_shared     : in  std_logic;
      update_snoop_made_txn_invalid    : in  std_logic;
      update_need_bs            : in  std_logic;
      update_need_ar            : in  std_logic;
      update_need_aw            : in  std_logic;
      update_need_evict         : in  std_logic;
      update_need_tag_write     : in  std_logic;
      update_inserted_trans     : in  std_logic;
      update_reused_tag         : in  std_logic;
      update_old_tag            : in  WAY_LINE_TAG_TYPE;
      update_refreshed_lru      : in  std_logic;
      update_all_tags           : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      update_inserted_rd_done   : out std_logic;
      update_inserted_ex_ok     : out std_logic;
      update_inserted_wr_done   : out std_logic;
      update_pushing_writeunique: out std_logic;
      update_pushing_writeback  : out std_logic;
      update_lock_release       : out std_logic;
      update_lock_way           : out natural range C_NUM_WAYS - 1 downto 0;
      update_release_tag        : out WAY_LINE_TAG_TYPE;
      
      update_whl_pop            : out std_logic;
      update_whl_exist          : in  std_logic;
      update_whl_strb           : in  std_logic_vector(C_CACHE_LINE_LENGTH * 32/8 - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- LRU signals.
      
      lru_update_prev_lru_way   : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
      lru_update_new_lru_way    : in  std_logic_vector(C_WAY_BIT_HI downto C_WAY_BIT_LO);
      
      
      -- ---------------------------------------------------
      -- Automatic Clean Information.
      
      update_auto_clean_push    : out std_logic;
      update_auto_clean_addr    : out AXI_ADDR_TYPE;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_update_done          : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      backend_wr_resp_info      : in  WRITE_RESP_TYPE;
      backend_wr_resp_ready     : out std_logic;
      backend_wr_resp_conf      : out WRITE_CONF_TYPE;
      
      backend_rd_data_info      : in  READ_RESP_TYPE;
      backend_rd_data_ready     : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Update signals (to Frontend).
      
      -- Read miss
      update_read_data_info     : out READ_MISS_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      update_read_data_ready    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      -- Write Miss
      update_write_data_ready   : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      -- Write miss response
      update_ext_bresp_info     : out WRITE_RESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      update_ext_bresp_ready    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (to Lookup).
      
      update_tag_conflict       : out std_logic;
      update_piperun            : out std_logic;
      
      update_write_miss_full    : out std_logic;
      update_write_miss_busy    : out std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      update_allocate_conflict  : out std_logic;
      update_allocate_error     : out std_logic;
      
      update_error_freeze       : out std_logic;
      update_error_evict_insert : out std_logic;
      update_error_evict_way    : out natural range C_NUM_WAYS - 1 downto 0;
      update_error_evict_info   : out ACCESS_TYPE;
      update_error_wait         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Update signals (to Tag & Data).
      
      update_tag_addr           : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
      update_tag_en             : out std_logic;
      update_tag_we             : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
      update_tag_new_word       : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      update_tag_current_word   : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      
      update_data_addr          : out std_logic_vector(C_ADDR_EXT_DATA_HI downto C_ADDR_EXT_DATA_LO);
      update_data_en            : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
      update_data_we            : out std_logic_vector(0 downto 0);
      update_data_new_word      : out std_logic_vector(C_EXTERNAL_DATA_WIDTH - 1 downto 0);
      update_data_current_word  : in  AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
      
      ud_snoop_tag_addr         : out std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
      ud_snoop_tag_en           : out std_logic;
      ud_snoop_tag_we           : out std_logic_vector(C_NUM_WAYS - 1 downto 0);
      ud_snoop_tag_new_word     : out SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      ud_snoop_tag_current_word : in  SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (to Backend).
      
      read_req_info             : out READ_REQ_TYPE;
      read_req_ready            : in  std_logic;
      
      write_req_info            : out WRITE_REQ_TYPE;
      write_req_ready           : in  std_logic;
      
      write_data_info           : out DATA_PORT_TYPE;
      write_data_ready          : in  std_logic;
      write_data_almost_full    : in  std_logic;
      write_data_full           : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   : in  std_logic;
      mst_snoop_fetch_info      : in  MST_SNOOP_REQ_TYPE;
      mst_snoop_mem_piperun     : in  std_logic;
      mst_snoop_mem_info        : in  MST_SNOOP_REQ_TYPE;
      mst_snoop_check_piperun   : in  std_logic;
      mst_snoop_check_info      : in  MST_SNOOP_REQ_TYPE;
      
      mst_snoop_fetch_ack_info  : out RMST_SNOOP_ACK_TYPE;
      mst_snoop_mem_ack_info    : out RMST_SNOOP_ACK_TYPE;
      mst_snoop_check_ack_info  : out RMST_SNOOP_ACK_TYPE;
      mst_snoop_update_ack_info : out RMST_SNOOP_ACK_TYPE;
      
      mst_core_update_hazard    : out RMST_SNOOP_HAZ_TYPE;
      
      mst_snoop_mem_rm_alloc    : out std_logic;
      mst_snoop_check_rm_alloc  : out std_logic;
      
      mst_snoop_tag_valid       : in  std_logic;
      mst_snoop_tag_way         : in  natural range C_NUM_WAYS - 1 downto 0;
      mst_snoop_tag_info        : in  WAY_LINE_TAG_TYPE;
      mst_snoop_tag_stall       : out std_logic;
      
      mst_snoop_sdr_push        : in  std_logic;
      mst_snoop_sdr_info        : in  MST_SNOOP_ADDR_TYPE;
      mst_snoop_sdr_empty       : out std_logic;
      mst_snoop_sdr_full        : out std_logic;
      
      mst_core_update_data_info : out MST_SNOOP_DATA_TYPE;
      mst_core_update_data_ready: in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_ud_stall             : out STAT_POINT_TYPE;    -- Time transactions are stalled
      stat_ud_tag_free          : out STAT_POINT_TYPE;    -- Cycles tag is free
      stat_ud_data_free         : out STAT_POINT_TYPE;    -- Cycles data is free
      stat_ud_ri                : out STAT_FIFO_TYPE;     -- Read Information
      stat_ud_r                 : out STAT_FIFO_TYPE;     -- Read data (optional)
      stat_ud_e                 : out STAT_FIFO_TYPE;     -- Evict
      stat_ud_bs                : out STAT_FIFO_TYPE;     -- BRESP Source
      stat_ud_wm                : out STAT_FIFO_TYPE;     -- Write Miss
      stat_ud_wma               : out STAT_FIFO_TYPE;     -- Write Miss Allocate (reserved)
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      UPDATE_DEBUG1             : out MAX_DEBUG_TYPE;
      UPDATE_DEBUG2             : out MAX_DEBUG_TYPE
    );
  end component sc_update;
  
  component sc_ram_module is
    generic (
      C_TARGET        : TARGET_FAMILY_TYPE;
      C_WE_A_WIDTH    : positive              := 1;
      C_DATA_A_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_A_WIDTH  : natural range 1 to 18 := 11;
      C_WE_B_WIDTH    : positive              := 1;
      C_DATA_B_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_B_WIDTH  : natural range 1 to 18 := 11;
      C_FORCE_BRAM    : boolean               := true;
      C_FORCE_LUTRAM  : boolean               := false
    );
    port (
      -- PORT A
      CLKA            : in  std_logic;
      ENA             : in  std_logic;
      WEA             : in  std_logic_vector(C_WE_A_WIDTH-1 downto 0);
      ADDRA           : in  std_logic_vector(C_ADDR_A_WIDTH-1 downto 0);
      DATA_INA        : in  std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      DATA_OUTA       : out std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      -- PORT B
      CLKB            : in  std_logic;
      ENB             : in  std_logic;
      WEB             : in  std_logic_vector(C_WE_B_WIDTH-1 downto 0);
      ADDRB           : in  std_logic_vector(C_ADDR_B_WIDTH-1 downto 0);
      DATA_INB        : in  std_logic_vector(C_DATA_B_WIDTH-1 downto 0);
      DATA_OUTB       : out std_logic_vector(C_DATA_B_WIDTH-1 downto 0)
    );
  end component sc_ram_module;
  
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  signal update_pushing_writeunique: std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal update_pushing_writeback  : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal lookup_assert              : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal update_assert              : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
begin  -- architecture IMP

  Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
  
    -- ----------------------------------------
    -- 
    
    -- Access signals.
    signal access_data_info_prt      : DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
    signal lookup_read_data_info_prt : READ_HIT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal update_read_data_info_prt : READ_MISS_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal update_ext_bresp_info_prt : WRITE_RESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal lookup_read_data_new_prt  : READ_SOURCE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal read_info_status_prt      : STAT_RI_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal read_data_status_prt      : STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Update signals.
    signal update_tag_conflict       : std_logic;
    signal update_piperun            : std_logic;
    
    signal update_write_miss_full    : std_logic;
    signal update_write_miss_busy    : std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    signal update_allocate_conflict  : std_logic;
    signal update_allocate_error     : std_logic;
      
    signal update_error_freeze       : std_logic;
    signal update_error_evict_insert : std_logic;
    signal update_error_evict_way    : natural range C_NUM_WAYS - 1 downto 0;
    signal update_error_evict_info   : ACCESS_TYPE;
    signal update_error_wait         : std_logic;
    
    
    -- Lookup signals (to Tag & Data).
    signal lookup_tag_addr           : ADDR_FULL_LINE_TYPE;
    signal lookup_tag_addr_d1        : ADDR_FULL_LINE_TYPE;
    signal lookup_tag_en             : std_logic;
    signal lookup_tag_we             : std_logic_vector(C_NUM_WAYS - 1 downto 0);
    signal lookup_tag_new_word       : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal lookup_tag_current_word   : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal lookup_tag_new_word_i     : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
    signal lookup_tag_current_word_i : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
    
    signal lookup_data_addr          : ADDR_DATA_TYPE;
    signal lookup_data_en            : std_logic_vector(C_NUM_WAYS - 1 downto 0);
    signal lookup_data_we            : BE_TYPE;
    signal lookup_data_new_word      : DATA_TYPE;
    signal lookup_data_current_word  : AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
    
    
    -- Lookup signals (to LRU).
    signal lookup_fetch_piperun      : std_logic;
    signal lookup_mem_piperun        : std_logic;
    signal lru_fetch_line_addr       : ADDR_LINE_TYPE;
    signal lru_check_next_way        : WAY_BIT_TYPE;
    signal lru_check_next_hot_way    : WAY_TYPE;
    signal lru_check_use_lru         : std_logic;
    signal lru_check_line_addr       : ADDR_LINE_TYPE;
    signal lru_check_used_way        : WAY_BIT_TYPE;
    
    -- LRU signals to update.
    signal lru_update_prev_lru_way   : WAY_BIT_TYPE;
    signal lru_update_new_lru_way    : WAY_BIT_TYPE;
    
    
    -- Lookup signals (to Update).
    signal lookup_new_addr           : AXI_ADDR_TYPE;
    signal lookup_stall_addr         : AXI_ADDR_TYPE;
    
    signal lookup_push_write_miss    : std_logic;
    signal lookup_wm_allocate        : std_logic;
    signal lookup_wm_evict           : std_logic;
    signal lookup_wm_will_use        : std_logic;
    signal lookup_wm_info            : ACCESS_TYPE;
    signal lookup_wm_use_bits        : ADDR_OFFSET_TYPE;
    signal lookup_wm_stp_bits        : ADDR_OFFSET_TYPE;
    signal lookup_wm_allow_write     : std_logic;
    signal lookup_wm_create          : std_logic;
    
    signal update_valid              : std_logic;
    signal update_way                : natural range C_NUM_WAYS - 1 downto 0;
    signal update_info               : ACCESS_TYPE;
    signal update_hit                : std_logic;
    signal update_miss               : std_logic;
    signal update_read_hit           : std_logic;
    signal update_read_miss          : std_logic;
    signal update_read_miss_dirty    : std_logic;
    signal update_write_hit          : std_logic;
    signal update_write_miss         : std_logic;
    signal update_write_miss_dirty   : std_logic;
    signal update_locked_write_hit   : std_logic;
    signal update_locked_read_hit    : std_logic;
    signal update_first_write_hit    : std_logic;
    signal update_evict_hit          : std_logic;
    signal update_exclusive_hit      : std_logic;
    signal update_create_bresp       : std_logic;
    signal update_early_bresp        : std_logic;
    signal update_failed_allocation  : std_logic;
    signal update_whl_rejected       : std_logic;
    signal update_snoop_made_clean   : std_logic;
    signal update_snoop_made_shared  : std_logic;
    signal update_snoop_made_invalid : std_logic;
    signal update_snoop_altered_delayed_txn : std_logic;
    signal update_snoop_made_txn_clean      : std_logic;
    signal update_snoop_made_txn_shared     : std_logic;
    signal update_snoop_made_txn_invalid    : std_logic;
    signal update_need_bs            : std_logic;
    signal update_need_ar            : std_logic;
    signal update_need_aw            : std_logic;
    signal update_need_evict         : std_logic;
    signal update_need_tag_write     : std_logic;
    signal update_inserted_trans     : std_logic;
    signal update_reused_tag         : std_logic;
    signal update_old_tag            : WAY_LINE_TAG_TYPE;
    signal update_refreshed_lru      : std_logic;
    signal update_all_tags           : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal update_inserted_rd_done   : std_logic;
    signal update_inserted_ex_ok     : std_logic;
    signal update_inserted_wr_done   : std_logic;

    signal update_lock_release       : std_logic;
    signal update_lock_way           : natural range C_NUM_WAYS - 1 downto 0;
    signal update_release_tag        : WAY_LINE_TAG_TYPE;
    
    signal update_whl_pop            : std_logic;
    signal update_whl_exist          : std_logic;
    signal update_whl_strb           : std_logic_vector(C_CACHE_LINE_LENGTH * 32/8 - 1 downto 0);
    
    signal mst_snoop_sdr_empty_i     : std_logic;
    
    
    -- ---------------------------------------------------
    -- 
    
    signal update_tag_addr           : ADDR_FULL_LINE_TYPE;
    signal update_tag_addr_d1        : ADDR_FULL_LINE_TYPE;
    signal update_tag_en             : std_logic;
    signal update_tag_we             : std_logic_vector(C_NUM_WAYS - 1 downto 0);
    signal update_tag_new_word       : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal update_tag_current_word   : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal update_tag_new_word_i     : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
    signal update_tag_current_word_i : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
    
    signal update_data_addr          : ADDR_EXT_DATA_TYPE;
    signal update_data_en            : std_logic_vector(C_NUM_WAYS - 1 downto 0);
    signal update_data_we            : std_logic_vector(0 downto 0);
    signal update_data_new_word      : EXT_DATA_TYPE;
    signal update_data_current_word  : AXI_DATA_VECTOR_TYPE(C_NUM_WAYS - 1 downto 0);
    
    signal ud_snoop_tag_addr         : std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
    signal snoop_tag_addr_d1         : std_logic_vector(C_ADDR_FULL_LINE_HI downto C_ADDR_FULL_LINE_LO);
    signal ud_snoop_tag_en           : std_logic;
    signal ud_snoop_tag_we           : std_logic_vector(C_NUM_WAYS - 1 downto 0);
    signal ud_snoop_tag_new_word     : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal ud_snoop_tag_current_word : SET_LINE_TAG_TYPE(C_NUM_WAYS - 1 downto 0);
    signal ud_snoop_tag_new_word_i     : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
    signal ud_snoop_tag_current_word_i : std_logic_vector(C_NUM_WAYS * C_TAG_SIZE - 1 downto 0);
      
    signal stat_prt_lu_opt_write_hit           : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_write_miss          : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_write_miss_dirty    : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_read_hit            : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_read_miss           : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_read_miss_dirty     : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_locked_write_hit    : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_locked_read_hit     : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_opt_first_write_hit     : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_write_hit           : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_write_miss          : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_write_miss_dirty    : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_read_hit            : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_read_miss           : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_read_miss_dirty     : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_locked_write_hit    : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_locked_read_hit     : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    signal stat_prt_lu_gen_first_write_hit     : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    
  begin
    -----------------------------------------------------------------------------
    -- Extract data
    -----------------------------------------------------------------------------
    
    Gen_Port: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      -- Extract Info from matrix to Port vector.
      access_data_info_prt(I)             <= access_data_info(J, I);
      read_info_status_prt(I)             <= read_info_status(J, I);
      read_data_status_prt(I)             <= read_data_status(J, I);
      
      lookup_read_data_new(J, I)          <= lookup_read_data_new_prt(I);
      lookup_read_data_info(J, I)         <= lookup_read_data_info_prt(I);
      update_read_data_info(J, I)         <= update_read_data_info_prt(I);
      update_ext_bresp_info(J, I)         <= update_ext_bresp_info_prt(I);
      
    end generate Gen_Port;
    Extra_Port: if ( C_NUM_INTERNAL_PORTS > C_NUM_PORTS ) generate
    begin
      access_data_info_prt(C_NUM_PORTS)   <= access_data_info(J, C_NUM_PORTS);
      
    end generate Extra_Port;
    
    Gen_Opt_Port: for I in 0 to C_NUM_OPTIMIZED_PORTS - 1 generate
    begin
      stat_lu_opt_write_hit(J, I)         <= stat_prt_lu_opt_write_hit(I);
      stat_lu_opt_write_miss(J, I)        <= stat_prt_lu_opt_write_miss(I);
      stat_lu_opt_write_miss_dirty(J, I)  <= stat_prt_lu_opt_write_miss_dirty(I);
      stat_lu_opt_read_hit(J, I)          <= stat_prt_lu_opt_read_hit(I);
      stat_lu_opt_read_miss(J, I)         <= stat_prt_lu_opt_read_miss(I);
      stat_lu_opt_read_miss_dirty(J, I)   <= stat_prt_lu_opt_read_miss_dirty(I);
      stat_lu_opt_locked_write_hit(J, I)  <= stat_prt_lu_opt_locked_write_hit(I);
      stat_lu_opt_locked_read_hit(J, I)   <= stat_prt_lu_opt_locked_read_hit(I);
      stat_lu_opt_first_write_hit(J, I)   <= stat_prt_lu_opt_first_write_hit(I);
      
    end generate Gen_Opt_Port;
      
    Gen_Gen_Port: for I in 0 to C_NUM_GENERIC_PORTS - 1 generate
    begin
      stat_lu_gen_write_hit(J, I)         <= stat_prt_lu_gen_write_hit(I);
      stat_lu_gen_write_miss(J, I)        <= stat_prt_lu_gen_write_miss(I);
      stat_lu_gen_write_miss_dirty(J, I)  <= stat_prt_lu_gen_write_miss_dirty(I);
      stat_lu_gen_read_hit(J, I)          <= stat_prt_lu_gen_read_hit(I);
      stat_lu_gen_read_miss(J, I)         <= stat_prt_lu_gen_read_miss(I);
      stat_lu_gen_read_miss_dirty(J, I)   <= stat_prt_lu_gen_read_miss_dirty(I);
      stat_lu_gen_locked_write_hit(J, I)  <= stat_prt_lu_gen_locked_write_hit(I);
      stat_lu_gen_locked_read_hit(J, I)   <= stat_prt_lu_gen_locked_read_hit(I);
      stat_lu_gen_first_write_hit(J, I)   <= stat_prt_lu_gen_first_write_hit(I);
      
    end generate Gen_Gen_Port;
      
      
    -----------------------------------------------------------------------------
    -- Lookup Instance
    -----------------------------------------------------------------------------
    
    LU: sc_lookup
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_GENERIC_PORTS       => C_NUM_GENERIC_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_NUM_INTERNAL_PORTS      => C_NUM_INTERNAL_PORTS,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_SUPPORT_SNOOP_FILTER    => C_SUPPORT_SNOOP_FILTER,
        C_KEEP_SHARED_WRITE       => C_KEEP_SHARED_WRITE,
        C_READ_ONLY_UNIQUE        => C_READ_ONLY_UNIQUE,
        C_READ_EXCLUSIVE_CLEAN    => C_READ_EXCLUSIVE_CLEAN,
        C_KEEP_BUFFERABLE         => C_KEEP_BUFFERABLE,
        
        -- Data type and settings specific.
        C_TAG_SIZE                => C_TAG_SIZE,
        C_NUM_STATUS_BITS         => C_NUM_STATUS_BITS,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_CACHE_DATA_ADDR_WIDTH   => C_CACHE_DATA_ADDR_WIDTH,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_POS'high,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_POS'low,
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_DATA_HI            => C_ADDR_DATA_POS'high,
        C_ADDR_DATA_LO            => C_ADDR_DATA_POS'low,
        C_ADDR_TAG_HI             => C_ADDR_TAG_POS'high,
        C_ADDR_TAG_LO             => C_ADDR_TAG_POS'low,
        C_ADDR_FULL_LINE_HI       => C_ADDR_FULL_LINE_POS'high,
        C_ADDR_FULL_LINE_LO       => C_ADDR_FULL_LINE_POS'low,
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_WORD_HI            => C_ADDR_WORD_POS'high,
        C_ADDR_WORD_LO            => C_ADDR_WORD_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_WAY_BIT_HI              => C_WAY_BIT_POS'high,
        C_WAY_BIT_LO              => C_WAY_BIT_POS'low
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- Access signals.
        
        access_valid              => access_valid(J),
        access_info               => access_info(J),
        
        access_data_info          => access_data_info_prt,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_prt,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_prt,
        read_data_status          => read_data_status_prt,
        
        
        -- ---------------------------------------------------
        -- Update signals.
        
        update_tag_conflict       => update_tag_conflict,
        update_piperun            => update_piperun,
        
        update_write_miss_full    => update_write_miss_full,
        update_write_miss_busy    => update_write_miss_busy,
        
        update_allocate_conflict  => update_allocate_conflict,
        update_allocate_error     => update_allocate_error,
        
        update_error_freeze       => update_error_freeze,
        update_error_evict_insert => update_error_evict_insert,
        update_error_evict_way    => update_error_evict_way,
        update_error_evict_info   => update_error_evict_info,
        update_error_wait         => update_error_wait,
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to Access).
        
        lookup_piperun            => lookup_piperun(J),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to Frontend).
        
        lookup_read_data_info     => lookup_read_data_info_prt,
        
        lookup_write_data_ready   => lookup_write_data_ready((J + 1) * C_NUM_INTERNAL_PORTS - 1 downto J * C_NUM_INTERNAL_PORTS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to Tag & Data).
        
        lookup_tag_addr           => lookup_tag_addr,
        lookup_tag_en             => lookup_tag_en,
        lookup_tag_we             => lookup_tag_we,
        lookup_tag_new_word       => lookup_tag_new_word,
        lookup_tag_current_word   => lookup_tag_current_word,
        
        lookup_data_addr          => lookup_data_addr,
        lookup_data_en            => lookup_data_en,
        lookup_data_we            => lookup_data_we,
        lookup_data_new_word      => lookup_data_new_word,
        lookup_data_current_word  => lookup_data_current_word,
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to Arbiter).
        
        lookup_read_done          => lookup_read_done((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to LRU).
        
        -- Pipe control.
        lookup_fetch_piperun      => lookup_fetch_piperun,
        lookup_mem_piperun        => lookup_mem_piperun,
        
        -- Peek LRU.
        lru_fetch_line_addr       => lru_fetch_line_addr,
        lru_check_next_way        => lru_check_next_way,
        lru_check_next_hot_way    => lru_check_next_hot_way,
        
        -- Control LRU.
        lru_check_use_lru         => lru_check_use_lru,
        lru_check_line_addr       => lru_check_line_addr,
        lru_check_used_way        => lru_check_used_way,
          
          
        -- ---------------------------------------------------
        -- Lookup signals (to Update).
        
        lookup_new_addr           => lookup_new_addr,
        lookup_stall_addr         => lookup_stall_addr,
        
        lookup_push_write_miss    => lookup_push_write_miss,
        lookup_wm_allocate        => lookup_wm_allocate,
        lookup_wm_evict           => lookup_wm_evict,
        lookup_wm_will_use        => lookup_wm_will_use,
        lookup_wm_info            => lookup_wm_info,
        lookup_wm_use_bits        => lookup_wm_use_bits,
        lookup_wm_stp_bits        => lookup_wm_stp_bits,
        lookup_wm_allow_write     => lookup_wm_allow_write,
        lookup_wm_create          => lookup_wm_create,
        
        update_valid              => update_valid,
        update_way                => update_way,
        update_info               => update_info,
        update_hit                => update_hit,
        update_miss               => update_miss,
        update_read_hit           => update_read_hit,
        update_read_miss          => update_read_miss,
        update_read_miss_dirty    => update_read_miss_dirty,
        update_write_hit          => update_write_hit,
        update_write_miss         => update_write_miss,
        update_write_miss_dirty   => update_write_miss_dirty,
        update_locked_write_hit   => update_locked_write_hit,
        update_locked_read_hit    => update_locked_read_hit,
        update_first_write_hit    => update_first_write_hit,
        update_evict_hit          => update_evict_hit,
        update_exclusive_hit      => update_exclusive_hit,
        update_create_bresp       => update_create_bresp,
        update_early_bresp        => update_early_bresp,
        update_failed_allocation  => update_failed_allocation,
        update_whl_rejected       => update_whl_rejected,
        update_snoop_made_clean   => update_snoop_made_clean,
        update_snoop_made_shared  => update_snoop_made_shared,
        update_snoop_made_invalid => update_snoop_made_invalid,
        update_snoop_altered_delayed_txn => update_snoop_altered_delayed_txn,
        update_snoop_made_txn_clean      => update_snoop_made_txn_clean,
        update_snoop_made_txn_shared     => update_snoop_made_txn_shared,
        update_snoop_made_txn_invalid    => update_snoop_made_txn_invalid,
        update_need_bs            => update_need_bs,
        update_need_ar            => update_need_ar,
        update_need_aw            => update_need_aw,
        update_need_evict         => update_need_evict,
        update_need_tag_write     => update_need_tag_write,
        update_inserted_trans     => update_inserted_trans,
        update_reused_tag         => update_reused_tag,
        update_old_tag            => update_old_tag,
        update_refreshed_lru      => update_refreshed_lru,
        update_all_tags           => update_all_tags,
        update_inserted_rd_done   => update_inserted_rd_done,
        update_inserted_ex_ok     => update_inserted_ex_ok,
        update_inserted_wr_done   => update_inserted_wr_done,
        update_pushing_writeunique=> update_pushing_writeunique,
        update_pushing_writeback  => update_pushing_writeback,
        update_lock_release       => update_lock_release,
        update_lock_way           => update_lock_way,
        update_release_tag        => update_release_tag,
        
        update_whl_pop            => update_whl_pop,
        update_whl_exist          => update_whl_exist,
        update_whl_strb           => update_whl_strb,
        
        
        -- ---------------------------------------------------
        -- Status signals (to Lookup).
        
        be_writeunique_inflight   => be_writeunique_inflight,
        be_writeback_inflight     => be_writeback_inflight,
        
        
        -- ---------------------------------------------------
        -- Master Snoop Interface Signals.
        
        mst_snoop_fetch_piperun   => mst_snoop_fetch_piperun,
        mst_snoop_fetch_info      => mst_snoop_fetch_info(J),
        mst_snoop_mem_piperun     => mst_snoop_mem_piperun,
        mst_snoop_mem_info        => mst_snoop_mem_info(J),
        mst_snoop_check_piperun   => mst_snoop_check_piperun,
        mst_snoop_check_info      => mst_snoop_check_info(J),
        
        mst_core_fetch_hazard     => mst_core_fetch_hazard(J),
        mst_core_mem_hazard       => mst_core_mem_hazard(J),
        mst_core_check_hazard     => mst_core_check_hazard(J),
        
        mst_snoop_sdr_empty       => mst_snoop_sdr_empty_i,
        
        
        -- ---------------------------------------------------
        -- ACE Downstream Barrier Request.
        
        ctrl_lookup_done          => ctrl_lookup_done(J),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_lu_opt_write_hit           => stat_prt_lu_opt_write_hit,
        stat_lu_opt_write_miss          => stat_prt_lu_opt_write_miss,
        stat_lu_opt_write_miss_dirty    => stat_prt_lu_opt_write_miss_dirty,
        stat_lu_opt_read_hit            => stat_prt_lu_opt_read_hit,
        stat_lu_opt_read_miss           => stat_prt_lu_opt_read_miss,
        stat_lu_opt_read_miss_dirty     => stat_prt_lu_opt_read_miss_dirty,
        stat_lu_opt_locked_write_hit    => stat_prt_lu_opt_locked_write_hit,
        stat_lu_opt_locked_read_hit     => stat_prt_lu_opt_locked_read_hit,
        stat_lu_opt_first_write_hit     => stat_prt_lu_opt_first_write_hit,
        
        stat_lu_gen_write_hit           => stat_prt_lu_gen_write_hit,
        stat_lu_gen_write_miss          => stat_prt_lu_gen_write_miss,
        stat_lu_gen_write_miss_dirty    => stat_prt_lu_gen_write_miss_dirty,
        stat_lu_gen_read_hit            => stat_prt_lu_gen_read_hit,
        stat_lu_gen_read_miss           => stat_prt_lu_gen_read_miss,
        stat_lu_gen_read_miss_dirty     => stat_prt_lu_gen_read_miss_dirty,
        stat_lu_gen_locked_write_hit    => stat_prt_lu_gen_locked_write_hit,
        stat_lu_gen_locked_read_hit     => stat_prt_lu_gen_locked_read_hit,
        stat_lu_gen_first_write_hit     => stat_prt_lu_gen_first_write_hit,
        
        stat_lu_stall                   => stat_lu_stall(J),
        stat_lu_fetch_stall             => stat_lu_fetch_stall(J),
        stat_lu_mem_stall               => stat_lu_mem_stall(J),
        stat_lu_data_stall              => stat_lu_data_stall(J),
        stat_lu_data_hit_stall          => stat_lu_data_hit_stall(J),
        stat_lu_data_miss_stall         => stat_lu_data_miss_stall(J),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => lookup_assert(J),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        LOOKUP_DEBUG              => LOOKUP_DEBUG(J)
      );
    
    
    -----------------------------------------------------------------------------
    -- Update Instance
    -----------------------------------------------------------------------------
    
    UD: sc_update
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_BASEADDR                => C_BASEADDR,
        C_HIGHADDR                => C_HIGHADDR,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_NUM_INTERNAL_PORTS      => C_NUM_INTERNAL_PORTS,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_ENABLE_EARLY_BRESP      => C_ENABLE_EARLY_BRESP,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        
        -- Data type and settings specific.
        C_TAG_SIZE                => C_TAG_SIZE,
        C_NUM_STATUS_BITS         => C_NUM_STATUS_BITS,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_CACHE_DATA_ADDR_WIDTH   => C_CACHE_DATA_ADDR_WIDTH,
        C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
        C_EXTERNAL_DATA_ADDR_WIDTH=> C_EXTERNAL_DATA_ADDR_WIDTH,
        C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_POS'high,
        C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_POS'low,
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_EXT_DATA_HI        => C_ADDR_EXT_DATA_POS'high,
        C_ADDR_EXT_DATA_LO        => C_ADDR_EXT_DATA_POS'low,
        C_ADDR_TAG_HI             => C_ADDR_TAG_POS'high,
        C_ADDR_TAG_LO             => C_ADDR_TAG_POS'low,
        C_ADDR_FULL_LINE_HI       => C_ADDR_FULL_LINE_POS'high,
        C_ADDR_FULL_LINE_LO       => C_ADDR_FULL_LINE_POS'low,
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_EXT_WORD_HI        => C_ADDR_EXT_WORD_POS'high,
        C_ADDR_EXT_WORD_LO        => C_ADDR_EXT_WORD_POS'low,
        C_ADDR_WORD_HI            => C_ADDR_WORD_POS'high,
        C_ADDR_WORD_LO            => C_ADDR_WORD_POS'low,
        C_ADDR_EXT_BYTE_HI        => C_ADDR_EXT_BYTE_POS'high,
        C_ADDR_EXT_BYTE_LO        => C_ADDR_EXT_BYTE_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_WAY_BIT_HI              => C_WAY_BIT_POS'high,
        C_WAY_BIT_LO              => C_WAY_BIT_POS'low
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
    
        -- ---------------------------------------------------
        -- Access signals.
        
        access_valid              => access_valid(J),
        
        access_data_info          => access_data_info_prt,
        
        
        -- ---------------------------------------------------
        -- Lookup signals.
        
        -- Tag Addr Check.
        lookup_new_addr           => lookup_new_addr,
        lookup_stall_addr         => lookup_stall_addr,
        
        -- Write Miss
        lookup_push_write_miss    => lookup_push_write_miss,
        lookup_wm_allocate        => lookup_wm_allocate,
        lookup_wm_evict           => lookup_wm_evict,
        lookup_wm_will_use        => lookup_wm_will_use,
        lookup_wm_info            => lookup_wm_info,
        lookup_wm_use_bits        => lookup_wm_use_bits,
        lookup_wm_stp_bits        => lookup_wm_stp_bits,
        lookup_wm_allow_write     => lookup_wm_allow_write,
        lookup_wm_create          => lookup_wm_create,
        
        -- Update transaction.
        update_valid              => update_valid,
        update_way                => update_way,
        update_info               => update_info,
        update_hit                => update_hit,
        update_miss               => update_miss,
        update_read_hit           => update_read_hit,
        update_read_miss          => update_read_miss,
        update_read_miss_dirty    => update_read_miss_dirty,
        update_write_hit          => update_write_hit,
        update_write_miss         => update_write_miss,
        update_write_miss_dirty   => update_write_miss_dirty,
        update_locked_write_hit   => update_locked_write_hit,
        update_locked_read_hit    => update_locked_read_hit,
        update_first_write_hit    => update_first_write_hit,
        update_evict_hit          => update_evict_hit,
        update_exclusive_hit      => update_exclusive_hit,
        update_create_bresp       => update_create_bresp,
        update_early_bresp        => update_early_bresp,
        update_failed_allocation  => update_failed_allocation,
        update_whl_rejected       => update_whl_rejected,
        update_snoop_made_clean   => update_snoop_made_clean,
        update_snoop_made_shared  => update_snoop_made_shared,
        update_snoop_made_invalid => update_snoop_made_invalid,
        update_snoop_altered_delayed_txn => update_snoop_altered_delayed_txn,
        update_snoop_made_txn_clean      => update_snoop_made_txn_clean,
        update_snoop_made_txn_shared     => update_snoop_made_txn_shared,
        update_snoop_made_txn_invalid    => update_snoop_made_txn_invalid,
        update_need_bs            => update_need_bs,
        update_need_ar            => update_need_ar,
        update_need_aw            => update_need_aw,
        update_need_evict         => update_need_evict,
        update_need_tag_write     => update_need_tag_write,
        update_inserted_trans     => update_inserted_trans,
        update_reused_tag         => update_reused_tag,
        update_old_tag            => update_old_tag,
        update_refreshed_lru      => update_refreshed_lru,
        update_all_tags           => update_all_tags,
        update_inserted_rd_done   => update_inserted_rd_done,
        update_inserted_ex_ok     => update_inserted_ex_ok,
        update_inserted_wr_done   => update_inserted_wr_done,
        update_pushing_writeunique=> update_pushing_writeunique(J),
        update_pushing_writeback  => update_pushing_writeback(J),
        update_lock_release       => update_lock_release,
        update_lock_way           => update_lock_way,
        update_release_tag        => update_release_tag,
        
        update_whl_pop            => update_whl_pop,
        update_whl_exist          => update_whl_exist,
        update_whl_strb           => update_whl_strb,
        
        
        -- ---------------------------------------------------
        -- LRU signals.
        
        lru_update_prev_lru_way   => lru_update_prev_lru_way,
        lru_update_new_lru_way    => lru_update_new_lru_way,
        
        
        -- ---------------------------------------------------
        -- Automatic Clean Information.
        
        update_auto_clean_push    => update_auto_clean_push,
        update_auto_clean_addr    => update_auto_clean_addr,
        
        
        -- ---------------------------------------------------
        -- ACE Downstream Barrier Request.
        
        ctrl_update_done          => ctrl_update_done(J),
        
        
        -- ---------------------------------------------------
        -- Backend signals.
        
        backend_wr_resp_info      => backend_wr_resp_info(J),
        backend_wr_resp_ready     => backend_wr_resp_ready(J),
        backend_wr_resp_conf      => backend_wr_resp_conf(J),
        
        backend_rd_data_info      => backend_rd_data_info(J),
        backend_rd_data_ready     => backend_rd_data_ready(J),
        
        
        -- ---------------------------------------------------
        -- Update signals (to Frontend).
        
        -- Read miss
        update_read_data_info     => update_read_data_info_prt,
        update_read_data_ready    => update_read_data_ready((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        -- Write Miss
        update_write_data_ready   => update_write_data_ready((J + 1) * C_NUM_INTERNAL_PORTS - 1 downto J * C_NUM_INTERNAL_PORTS),
        
        -- Write miss response
        update_ext_bresp_info     => update_ext_bresp_info_prt,
        update_ext_bresp_ready    => update_ext_bresp_ready((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        
        -- ---------------------------------------------------
        -- Update signals (to Lookup).
        
        update_tag_conflict       => update_tag_conflict,
        update_piperun            => update_piperun,
        
        update_write_miss_full    => update_write_miss_full,
        update_write_miss_busy    => update_write_miss_busy,
        
        update_allocate_conflict  => update_allocate_conflict,
        update_allocate_error     => update_allocate_error,
        
        update_error_freeze       => update_error_freeze,
        update_error_evict_insert => update_error_evict_insert,
        update_error_evict_way    => update_error_evict_way,
        update_error_evict_info   => update_error_evict_info,
        update_error_wait         => update_error_wait,
        
        
        -- ---------------------------------------------------
        -- Update signals (to Tag & Data).
        
        update_tag_addr           => update_tag_addr,
        update_tag_en             => update_tag_en,
        update_tag_we             => update_tag_we,
        update_tag_new_word       => update_tag_new_word,
        update_tag_current_word   => update_tag_current_word,
        
        update_data_addr          => update_data_addr,
        update_data_en            => update_data_en,
        update_data_we            => update_data_we,
        update_data_new_word      => update_data_new_word,
        update_data_current_word  => update_data_current_word,
        
        ud_snoop_tag_addr         => ud_snoop_tag_addr,
        ud_snoop_tag_en           => ud_snoop_tag_en,
        ud_snoop_tag_we           => ud_snoop_tag_we,
        ud_snoop_tag_new_word     => ud_snoop_tag_new_word,
        ud_snoop_tag_current_word => ud_snoop_tag_current_word,
        
        
        -- ---------------------------------------------------
        -- Update signals (to Backend).
        
        read_req_info             => read_req_info(J),
        read_req_ready            => read_req_ready(J),
        
        write_req_info            => write_req_info(J),
        write_req_ready           => write_req_ready(J),
        
        write_data_info           => write_data_info(J),
        write_data_ready          => write_data_ready(J),
        write_data_almost_full    => write_data_almost_full(J),
        write_data_full           => write_data_full(J),
        
        
        -- ---------------------------------------------------
        -- Master Snoop Interface Signals.
        
        mst_snoop_fetch_piperun   => mst_snoop_fetch_piperun,
        mst_snoop_fetch_info      => mst_snoop_fetch_info(J),
        mst_snoop_mem_piperun     => mst_snoop_mem_piperun,
        mst_snoop_mem_info        => mst_snoop_mem_info(J),
        mst_snoop_check_piperun   => mst_snoop_check_piperun,
        mst_snoop_check_info      => mst_snoop_check_info(J),
        
        mst_snoop_fetch_ack_info  => mst_snoop_fetch_ack_info(J),
        mst_snoop_mem_ack_info    => mst_snoop_mem_ack_info(J),
        mst_snoop_check_ack_info  => mst_snoop_check_ack_info(J),
        mst_snoop_update_ack_info => mst_snoop_update_ack_info(J),
        
        mst_core_update_hazard    => mst_core_update_hazard(J),
        
        mst_snoop_mem_rm_alloc    => mst_snoop_mem_rm_alloc(J),
        mst_snoop_check_rm_alloc  => mst_snoop_check_rm_alloc(J),
        
        mst_snoop_tag_valid       => mst_snoop_tag_valid(J),
        mst_snoop_tag_way         => mst_snoop_tag_way,
        mst_snoop_tag_info        => mst_snoop_tag_info(J),
        mst_snoop_tag_stall       => mst_snoop_tag_stall(J),
        
        mst_snoop_sdr_push        => mst_snoop_sdr_push(J),
        mst_snoop_sdr_info        => mst_snoop_sdr_info(J),
        mst_snoop_sdr_empty       => mst_snoop_sdr_empty_i,
        mst_snoop_sdr_full        => mst_snoop_sdr_full(J),
        
        mst_core_update_data_info => mst_core_update_data_info(J),
        mst_core_update_data_ready=> mst_core_update_data_ready(J),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_ud_stall             => stat_ud_stall(J),
        stat_ud_tag_free          => stat_ud_tag_free(J),
        stat_ud_data_free         => stat_ud_data_free(J),
        stat_ud_ri                => stat_ud_ri(J),
        stat_ud_r                 => stat_ud_r(J),
        stat_ud_e                 => stat_ud_e(J),
        stat_ud_bs                => stat_ud_bs(J),
        stat_ud_wm                => stat_ud_wm(J),
        stat_ud_wma               => stat_ud_wma(J),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => update_assert(J),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        UPDATE_DEBUG1             => UPDATE_DEBUG1(J),
        UPDATE_DEBUG2             => UPDATE_DEBUG2(J)
      );
    
    mst_snoop_sdr_empty(J)  <= mst_snoop_sdr_empty_i;
    
    
    -----------------------------------------------------------------------------
    -- LRU Instance
    -----------------------------------------------------------------------------
    
    LRU: sc_lru_module
      generic map(
        C_TARGET                  => C_TARGET,
        C_ADDR_SIZE_LOG2          => C_LRU_ADDR_BITS,
        C_LINE_SIZE_LOG2          => C_WAY_BITS
      )
      port map(
        -- Global signals.
        Clk                       => ACLK,
        Reset                     => ARESET,
        
        -- Pipe control.
        lookup_fetch_piperun      => lookup_fetch_piperun,
        lookup_mem_piperun        => lookup_mem_piperun,
        
        -- Peek LRU.
        lru_fetch_line_addr       => lru_fetch_line_addr,
        lru_check_next_way        => lru_check_next_way,
        lru_check_next_hot_way    => lru_check_next_hot_way,
        
        -- Control LRU.
        lru_check_use_lru         => lru_check_use_lru,
        lru_check_line_addr       => lru_check_line_addr,
        lru_check_used_way        => lru_check_used_way,
        
        -- After refresh.
        lru_update_prev_lru_way   => lru_update_prev_lru_way,
        lru_update_new_lru_way    => lru_update_new_lru_way
      );
    
    
    -----------------------------------------------------------------------------
    -- TAG Instance
    -----------------------------------------------------------------------------
    
    TAG: sc_ram_module 
      generic map(
        C_TARGET                  => C_TARGET,
        C_WE_A_WIDTH              => C_NUM_WAYS,
        C_DATA_A_WIDTH            => C_NUM_WAYS * C_TAG_SIZE,
        C_ADDR_A_WIDTH            => ADDR_FULL_LINE_TYPE'length,
        C_WE_B_WIDTH              => C_NUM_WAYS,
        C_DATA_B_WIDTH            => C_NUM_WAYS * C_TAG_SIZE,
        C_ADDR_B_WIDTH            => ADDR_FULL_LINE_TYPE'length,
        C_FORCE_BRAM              => C_TAG_FORCE_BRAM,
        C_FORCE_LUTRAM            => false
      )
      port map(
        -- PORT A
        CLKA                      => ACLK,
        ENA                       => lookup_tag_en,
        WEA                       => lookup_tag_we,
        ADDRA                     => lookup_tag_addr,
        DATA_INA                  => lookup_tag_new_word_i,
        DATA_OUTA                 => lookup_tag_current_word_i,
        -- PORT B
        CLKB                      => ACLK,
        ENB                       => update_tag_en,
        WEB                       => update_tag_we,
        ADDRB                     => update_tag_addr,
        DATA_INB                  => update_tag_new_word_i,
        DATA_OUTB                 => update_tag_current_word_i
      );
    
    Use_Mst_Coherency: if (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
    begin
      TAG_Snoop_Copy: sc_ram_module 
        generic map(
          C_TARGET                  => C_TARGET,
          C_WE_A_WIDTH              => C_NUM_WAYS,
          C_DATA_A_WIDTH            => C_NUM_WAYS * C_TAG_SIZE,
          C_ADDR_A_WIDTH            => ADDR_FULL_LINE_TYPE'length,
          C_WE_B_WIDTH              => C_NUM_WAYS,
          C_DATA_B_WIDTH            => C_NUM_WAYS * C_TAG_SIZE,
          C_ADDR_B_WIDTH            => ADDR_FULL_LINE_TYPE'length,
          C_FORCE_BRAM              => C_TAG_FORCE_BRAM,
          C_FORCE_LUTRAM            => false
        )
        port map(
          -- PORT A
          CLKA                      => ACLK,
          ENA                       => ud_snoop_tag_en,
          WEA                       => ud_snoop_tag_we,
          ADDRA                     => ud_snoop_tag_addr,
          DATA_INA                  => ud_snoop_tag_new_word_i,
          DATA_OUTA                 => ud_snoop_tag_current_word_i,
          -- PORT B
          CLKB                      => ACLK,
          ENB                       => update_tag_en,
          WEB                       => update_tag_we,
          ADDRB                     => update_tag_addr,
          DATA_INB                  => update_tag_new_word_i,
          DATA_OUTB                 => open
        );
      
    end generate Use_Mst_Coherency;
  
    No_Mst_Coherency: if  ( not is_mst_coherent(C_ENABLE_COHERENCY) ) generate
    begin
      ud_snoop_tag_current_word_i <= (others=>'0');
      
    end generate No_Mst_Coherency;
  
    Gen_Set_Tag: for K in 0 to C_NUM_WAYS - 1 generate
    
      signal lookup_new_tag_way_word  : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      signal update_new_tag_way_word  : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      signal snoop_new_tag_way_word   : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      
      signal lookup_cur_tag_way_word  : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      signal update_cur_tag_way_word  : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      signal snoop_cur_tag_way_word   : std_logic_vector(C_TAG_SIZE - 1 downto 0);
      
    begin
      -- -----------------------------------------------------------------------
      --Process  Lookup Tag into local Std Logic Vector from Record interface.
      lookup_new_tag_way_word(C_TAG_VALID_POS)  <= lookup_tag_new_word(K).Valid;
      Lookup_Mst_Coherency: if  (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
      begin
        lookup_new_tag_way_word(C_TAG_UNIQUE_POS) <= lookup_tag_new_word(K).Unique;
      end generate Lookup_Mst_Coherency;
      Lookup_Secure: if  ( C_ENABLE_NON_SECURE > 0 ) generate
      begin
        lookup_new_tag_way_word(C_TAG_SECURE_POS) <= lookup_tag_new_word(K).Secure;
      end generate Lookup_Secure;
      lookup_new_tag_way_word(C_TAG_REUSED_POS) <= lookup_tag_new_word(K).Reused;
      lookup_new_tag_way_word(C_TAG_DIRTY_POS)  <= lookup_tag_new_word(K).Dirty;
      lookup_new_tag_way_word(C_TAG_LOCKED_POS) <= lookup_tag_new_word(K).Locked;
      lookup_new_tag_way_word(C_TAG_ADDR_POS)   <= lookup_tag_new_word(K).Addr(C_ADDR_TAG_POS);
      
      -- -----------------------------------------------------------------------
      -- Process Update Tag into local Std Logic Vector from Record interface.
      update_new_tag_way_word(C_TAG_VALID_POS)  <= update_tag_new_word(K).Valid;
      Update_Mst_Coherency: if  (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
      begin
        update_new_tag_way_word(C_TAG_UNIQUE_POS) <= update_tag_new_word(K).Unique;
      end generate Update_Mst_Coherency;
      Update_Secure: if  ( C_ENABLE_NON_SECURE > 0 ) generate
      begin
        update_new_tag_way_word(C_TAG_SECURE_POS) <= update_tag_new_word(K).Secure;
      end generate Update_Secure;
      update_new_tag_way_word(C_TAG_REUSED_POS) <= update_tag_new_word(K).Reused;
      update_new_tag_way_word(C_TAG_DIRTY_POS)  <= update_tag_new_word(K).Dirty;
      update_new_tag_way_word(C_TAG_LOCKED_POS) <= update_tag_new_word(K).Locked;
      update_new_tag_way_word(C_TAG_ADDR_POS)   <= update_tag_new_word(K).Addr(C_ADDR_TAG_POS);
      
      
      -- -----------------------------------------------------------------------
      -- Process Snoop Tag into local Std Logic Vector from Record interface.
      snoop_new_tag_way_word(C_TAG_VALID_POS)   <= ud_snoop_tag_new_word(K).Valid;
      Snoop_Mst_Coherency: if  (     is_mst_coherent(C_ENABLE_COHERENCY) ) generate
      begin
        snoop_new_tag_way_word(C_TAG_UNIQUE_POS)  <= ud_snoop_tag_new_word(K).Unique;
      end generate Snoop_Mst_Coherency;
      Snoop_Secure: if  ( C_ENABLE_NON_SECURE > 0 ) generate
      begin
        snoop_new_tag_way_word(C_TAG_SECURE_POS)  <= ud_snoop_tag_new_word(K).Secure;
      end generate Snoop_Secure;
      snoop_new_tag_way_word(C_TAG_REUSED_POS)  <= ud_snoop_tag_new_word(K).Reused;
      snoop_new_tag_way_word(C_TAG_DIRTY_POS)   <= ud_snoop_tag_new_word(K).Dirty;
      snoop_new_tag_way_word(C_TAG_LOCKED_POS)  <= ud_snoop_tag_new_word(K).Locked;
      snoop_new_tag_way_word(C_TAG_ADDR_POS)    <= ud_snoop_tag_new_word(K).Addr(C_ADDR_TAG_POS);
      
      
      -- -----------------------------------------------------------------------
      -- Append this Way Tag to the Set.
      lookup_tag_new_word_i(  C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K)  <= lookup_new_tag_way_word;
      update_tag_new_word_i(  C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K)  <= update_new_tag_way_word;
      ud_snoop_tag_new_word_i(C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K)  <= snoop_new_tag_way_word;
      
      
      -- -----------------------------------------------------------------------
      -- Extract Tag for each Way in the Set.
      lookup_cur_tag_way_word   <= lookup_tag_current_word_i(  C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K);
      update_cur_tag_way_word   <= update_tag_current_word_i(  C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K);
      snoop_cur_tag_way_word    <= ud_snoop_tag_current_word_i(C_TAG_SIZE * (K+1) -1 downto C_TAG_SIZE * K);
      
      
      -- -----------------------------------------------------------------------
      -- Generate Tag Records for each Way in the Set.
      Current_Tag_Extract: process (lookup_cur_tag_way_word, lookup_tag_addr_d1, 
                                    update_cur_tag_way_word, update_tag_addr_d1, 
                                    snoop_cur_tag_way_word, snoop_tag_addr_d1) is 
      begin
        -- Lookup.
        lookup_tag_current_word(K).Valid                        <= lookup_cur_tag_way_word(C_TAG_VALID_POS);
        lookup_tag_current_word(K).Unique                       <= lookup_cur_tag_way_word(C_TAG_UNIQUE_POS);
        lookup_tag_current_word(K).Secure                       <= lookup_cur_tag_way_word(C_TAG_SECURE_POS);
        lookup_tag_current_word(K).Reused                       <= lookup_cur_tag_way_word(C_TAG_REUSED_POS);
        lookup_tag_current_word(K).Dirty                        <= lookup_cur_tag_way_word(C_TAG_DIRTY_POS);
        lookup_tag_current_word(K).Locked                       <= lookup_cur_tag_way_word(C_TAG_LOCKED_POS);
        lookup_tag_current_word(K).Addr                         <= (others=>'0');
        lookup_tag_current_word(K).Addr(C_ADDR_VALID_POS)       <= C_BASEADDR(C_ADDR_VALID_POS);
        lookup_tag_current_word(K).Addr(C_ADDR_TAG_POS)         <= lookup_cur_tag_way_word(C_TAG_ADDR_POS);
        lookup_tag_current_word(K).Addr(C_ADDR_FULL_LINE_POS)   <= lookup_tag_addr_d1;
        
        -- Update.
        update_tag_current_word(K).Valid                        <= update_cur_tag_way_word(C_TAG_VALID_POS);
        update_tag_current_word(K).Unique                       <= update_cur_tag_way_word(C_TAG_UNIQUE_POS);
        update_tag_current_word(K).Secure                       <= update_cur_tag_way_word(C_TAG_SECURE_POS);
        update_tag_current_word(K).Reused                       <= update_cur_tag_way_word(C_TAG_REUSED_POS);
        update_tag_current_word(K).Dirty                        <= update_cur_tag_way_word(C_TAG_DIRTY_POS);
        update_tag_current_word(K).Locked                       <= update_cur_tag_way_word(C_TAG_LOCKED_POS);
        update_tag_current_word(K).Addr                         <= (others=>'0');
        update_tag_current_word(K).Addr(C_ADDR_VALID_POS)       <= C_BASEADDR(C_ADDR_VALID_POS);
        update_tag_current_word(K).Addr(C_ADDR_TAG_POS)         <= update_cur_tag_way_word(C_TAG_ADDR_POS);
        update_tag_current_word(K).Addr(C_ADDR_FULL_LINE_POS)   <= update_tag_addr_d1;
        
        -- Snoop.
        ud_snoop_tag_current_word(K).Valid                      <= snoop_cur_tag_way_word(C_TAG_VALID_POS);
        ud_snoop_tag_current_word(K).Unique                     <= snoop_cur_tag_way_word(C_TAG_UNIQUE_POS);
        ud_snoop_tag_current_word(K).Secure                     <= snoop_cur_tag_way_word(C_TAG_SECURE_POS);
        ud_snoop_tag_current_word(K).Reused                     <= snoop_cur_tag_way_word(C_TAG_REUSED_POS);
        ud_snoop_tag_current_word(K).Dirty                      <= snoop_cur_tag_way_word(C_TAG_DIRTY_POS);
        ud_snoop_tag_current_word(K).Locked                     <= snoop_cur_tag_way_word(C_TAG_LOCKED_POS);
        ud_snoop_tag_current_word(K).Addr                       <= (others=>'0');
        ud_snoop_tag_current_word(K).Addr(C_ADDR_VALID_POS)     <= C_BASEADDR(C_ADDR_VALID_POS);
        ud_snoop_tag_current_word(K).Addr(C_ADDR_TAG_POS)       <= snoop_cur_tag_way_word(C_TAG_ADDR_POS);
        ud_snoop_tag_current_word(K).Addr(C_ADDR_FULL_LINE_POS) <= snoop_tag_addr_d1;
        
      end process Current_Tag_Extract;
      
    end generate Gen_Set_Tag;
      
    -----------------------------------------------------------------------------
    -- Data Instance(s)
    -----------------------------------------------------------------------------
    
    Gen_Set_Data: for K in 0 to C_NUM_WAYS - 1 generate
    
      signal lookup_data_current_word_i  : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
      signal update_data_current_word_i  : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
      
    begin
      DATA: sc_ram_module 
        generic map(
          C_TARGET                  => C_TARGET,
          C_WE_A_WIDTH              => C_CACHE_DATA_WIDTH / 8,
          C_DATA_A_WIDTH            => C_CACHE_DATA_WIDTH,
          C_ADDR_A_WIDTH            => ADDR_DATA_TYPE'length,
          C_WE_B_WIDTH              => 1,
          C_DATA_B_WIDTH            => C_EXTERNAL_DATA_WIDTH,
          C_ADDR_B_WIDTH            => ADDR_EXT_DATA_TYPE'length,
          C_FORCE_BRAM              => true,
          C_FORCE_LUTRAM            => false
        )
        port map(
          -- PORT A
          CLKA                      => ACLK,
          ENA                       => lookup_data_en(K),
          WEA                       => lookup_data_we,
          ADDRA                     => lookup_data_addr,
          DATA_INA                  => lookup_data_new_word,
          DATA_OUTA                 => lookup_data_current_word_i,
          -- PORT B
          CLKB                      => ACLK,
          ENB                       => update_data_en(K),
          WEB                       => update_data_we,
          ADDRB                     => update_data_addr,
          DATA_INB                  => update_data_new_word,
          DATA_OUTB                 => update_data_current_word_i
        );
    
        lookup_data_current_word(K) <= fit_vec(lookup_data_current_word_i, C_MAX_DATA_WIDTH);
        update_data_current_word(K) <= fit_vec(update_data_current_word_i, C_MAX_DATA_WIDTH);
        
    end generate Gen_Set_Data;
    
    
    -----------------------------------------------------------------------------
    -- Debug
    -----------------------------------------------------------------------------
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      MEMORY_DEBUG1(J)    <= (others=>'0');
      MEMORY_DEBUG2(J)    <= (others=>'0');
      
      lookup_tag_addr_d1  <= (others=>'0');
      update_tag_addr_d1  <= (others=>'0');
      snoop_tag_addr_d1   <= (others=>'0');
    end generate No_Debug;
    
    
    Use_Debug: if( C_USE_DEBUG ) generate
    
      constant C_MY_1ST_WAY : natural := min_of( 1, C_NUM_WAYS) - 1;
      constant C_MY_2ND_WAY : natural := min_of( 2, C_NUM_WAYS) - 1;
      constant C_MY_3RD_WAY : natural := min_of( 3, C_NUM_WAYS) - 1;
      constant C_MY_4TH_WAY : natural := min_of( 4, C_NUM_WAYS) - 1;
      
      constant C_MY_TLINE   : natural := min_of(10, C_ADDR_FULL_LINE_HI - C_ADDR_FULL_LINE_LO + 1);
      constant C_MY_DLINE   : natural := min_of(14, C_ADDR_DATA_HI - C_ADDR_DATA_LO + 1);
      constant C_MY_DELINE  : natural := min_of(14, C_ADDR_EXT_DATA_HI - C_ADDR_EXT_DATA_LO + 1);
      constant C_MY_TAG     : natural := min_of(16, C_TAG_SIZE);
      constant C_MY_TAGIN   : natural := min_of(32, C_TAG_SIZE);
      constant C_MY_DATA    : natural := min_of(32, C_CACHE_DATA_WIDTH);
      constant C_MY_WE      : natural := min_of( 4, C_CACHE_DATA_WIDTH/8);
      constant C_MY_PWAY    : natural := min_of( 4, C_NUM_WAYS);
        
      subtype C_WAY_POS                   is natural range C_NUM_WAYS - 1 downto 0;
      
    begin
    
      Address_Fix : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET = '1') then              -- synchronous reset (active true)
            lookup_tag_addr_d1  <= (others=>'0');
            update_tag_addr_d1  <= (others=>'0');
            snoop_tag_addr_d1   <= (others=>'0');
          else
            lookup_tag_addr_d1  <= lookup_tag_addr;
            update_tag_addr_d1  <= update_tag_addr;
            snoop_tag_addr_d1   <= ud_snoop_tag_addr;
            
          end if;
        end if;
      end process Address_Fix;
      
      Debug_Handle : process (ACLK) is 
        variable lu_wr    : boolean;
        variable ud_wr    : boolean;
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET = '1') then              -- synchronous reset (active true)
            MEMORY_DEBUG1(J)      <= (others=>'0');
            MEMORY_DEBUG2(J)      <= (others=>'0');
          else
            -- Default assignment.
            MEMORY_DEBUG1(J)      <= (others=>'0');
            MEMORY_DEBUG2(J)      <= (others=>'0');
            
            lu_wr                 := ( lookup_data_en /= (lookup_data_en'range=>'0') ) and
                                     ( lookup_data_we /= (lookup_data_we'range=>'0') );
            ud_wr                 := ( update_data_en /= (update_data_en'range=>'0') ) and
                                     ( update_data_we /= (update_data_we'range=>'0') );
            
            -- Data selection.
            if( C_CACHE_DATA_WIDTH <= 64 ) then
              MEMORY_DEBUG1(J)( 63 downto   0) <= fit_vec(lookup_data_current_word(C_MY_1ST_WAY), 64);
              MEMORY_DEBUG1(J)(127 downto  64) <= fit_vec(lookup_data_current_word(C_MY_2ND_WAY), 64);
              MEMORY_DEBUG1(J)(191 downto 128) <= fit_vec(lookup_data_current_word(C_MY_3RD_WAY), 64);
              MEMORY_DEBUG1(J)(255 downto 192) <= fit_vec(lookup_data_current_word(C_MY_4TH_WAY), 64);
              MEMORY_DEBUG1(J)(319 downto 256) <= fit_vec(update_data_current_word(C_MY_1ST_WAY), 64);
              MEMORY_DEBUG1(J)(383 downto 320) <= fit_vec(update_data_current_word(C_MY_2ND_WAY), 64);
              MEMORY_DEBUG1(J)(447 downto 384) <= fit_vec(update_data_current_word(C_MY_3RD_WAY), 64);
              MEMORY_DEBUG1(J)(511 downto 448) <= fit_vec(update_data_current_word(C_MY_4TH_WAY), 64);
              MEMORY_DEBUG1(J)(575 downto 512) <= fit_vec(lookup_data_new_word, 64);
              MEMORY_DEBUG1(J)(639 downto 576) <= fit_vec(update_data_new_word, 64);
              
            elsif( C_NUM_WAYS = 2 ) then
              MEMORY_DEBUG1(J)(127 downto   0) <= fit_vec(lookup_data_current_word(C_MY_1ST_WAY), 128);
              MEMORY_DEBUG1(J)(255 downto 128) <= fit_vec(lookup_data_current_word(C_MY_2ND_WAY), 128);
              MEMORY_DEBUG1(J)(383 downto 256) <= fit_vec(update_data_current_word(C_MY_1ST_WAY), 128);
              MEMORY_DEBUG1(J)(511 downto 384) <= fit_vec(update_data_current_word(C_MY_2ND_WAY), 128);
              if   (     lu_wr and not ud_wr ) then
                MEMORY_DEBUG1(J)(575 downto 512) <= fit_vec(lookup_data_new_word,                64);
                MEMORY_DEBUG1(J)(639 downto 576) <= fit_vec(lookup_data_new_word(127 downto 64), 64);
                
              elsif( not lu_wr and     ud_wr ) then
                MEMORY_DEBUG1(J)(575 downto 512) <= fit_vec(update_data_new_word(127 downto 64), 64);
                MEMORY_DEBUG1(J)(639 downto 576) <= fit_vec(update_data_new_word,                64);
                
              else
                MEMORY_DEBUG1(J)(575 downto 512) <= fit_vec(lookup_data_new_word, 64);
                MEMORY_DEBUG1(J)(639 downto 576) <= fit_vec(update_data_new_word, 64);
                
              end if;
              
            else
              MEMORY_DEBUG1(J)( 63 downto   0) <= fit_vec(lookup_data_current_word(C_MY_1ST_WAY), 64);
              MEMORY_DEBUG1(J)(127 downto  64) <= fit_vec(lookup_data_current_word(C_MY_2ND_WAY), 64);
              MEMORY_DEBUG1(J)(191 downto 128) <= fit_vec(lookup_data_current_word(C_MY_3RD_WAY), 64);
              MEMORY_DEBUG1(J)(255 downto 192) <= fit_vec(lookup_data_current_word(C_MY_4TH_WAY), 64);
              MEMORY_DEBUG1(J)(319 downto 256) <= fit_vec(update_data_current_word(C_MY_1ST_WAY), 64);
              MEMORY_DEBUG1(J)(385 downto 320) <= fit_vec(update_data_current_word(C_MY_2ND_WAY), 64);
              MEMORY_DEBUG1(J)(447 downto 384) <= fit_vec(update_data_current_word(C_MY_3RD_WAY), 64);
              MEMORY_DEBUG1(J)(511 downto 448) <= fit_vec(update_data_current_word(C_MY_4TH_WAY), 64);
              MEMORY_DEBUG1(J)(575 downto 512) <= fit_vec(lookup_data_new_word, 64);
              MEMORY_DEBUG1(J)(639 downto 576) <= fit_vec(update_data_new_word, 64);
              
            end if;
            
            -- Address.
            MEMORY_DEBUG1(J)(687 downto 640) <= fit_vec(C_BASEADDR(63 downto C_ADDR_DATA_HI     + 1) & lookup_data_addr & (C_ADDR_DATA_LO     - 1 downto 0=>'0'), 48);
            MEMORY_DEBUG1(J)(735 downto 688) <= fit_vec(C_BASEADDR(63 downto C_ADDR_EXT_DATA_HI + 1) & update_data_addr & (C_ADDR_EXT_DATA_LO - 1 downto 0=>'0'), 48);
                             
            -- Ctrl.         
            MEMORY_DEBUG1(J)(743 downto 736) <= fit_vec(lookup_data_en, 8);
            MEMORY_DEBUG1(J)(751 downto 744) <= fit_vec(update_data_en, 8);
            MEMORY_DEBUG1(J)(759 downto 752) <= fit_vec(lookup_data_we, 8);
            MEMORY_DEBUG1(J)(767 downto 760) <= fit_vec(update_data_we, 8);
            
            
            -- Tag.
            MEMORY_DEBUG2(J)( 47 downto   0) <= fit_vec(lookup_tag_current_word(C_MY_1ST_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(            58) <=         lookup_tag_current_word(C_MY_1ST_WAY).Unique;
            MEMORY_DEBUG2(J)(            59) <=         lookup_tag_current_word(C_MY_1ST_WAY).Secure;
            MEMORY_DEBUG2(J)(            60) <=         lookup_tag_current_word(C_MY_1ST_WAY).Reused;
            MEMORY_DEBUG2(J)(            61) <=         lookup_tag_current_word(C_MY_1ST_WAY).Dirty;
            MEMORY_DEBUG2(J)(            62) <=         lookup_tag_current_word(C_MY_1ST_WAY).Locked;
            MEMORY_DEBUG2(J)(            63) <=         lookup_tag_current_word(C_MY_1ST_WAY).Valid;
            
            MEMORY_DEBUG2(J)(111 downto  64) <= fit_vec(lookup_tag_current_word(C_MY_2ND_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           122) <=         lookup_tag_current_word(C_MY_2ND_WAY).Unique;
            MEMORY_DEBUG2(J)(           123) <=         lookup_tag_current_word(C_MY_2ND_WAY).Secure;
            MEMORY_DEBUG2(J)(           124) <=         lookup_tag_current_word(C_MY_2ND_WAY).Reused;
            MEMORY_DEBUG2(J)(           125) <=         lookup_tag_current_word(C_MY_2ND_WAY).Dirty;
            MEMORY_DEBUG2(J)(           126) <=         lookup_tag_current_word(C_MY_2ND_WAY).Locked;
            MEMORY_DEBUG2(J)(           127) <=         lookup_tag_current_word(C_MY_2ND_WAY).Valid;
            
            MEMORY_DEBUG2(J)(175 downto 128) <= fit_vec(lookup_tag_current_word(C_MY_3RD_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           186) <=         lookup_tag_current_word(C_MY_3RD_WAY).Unique;
            MEMORY_DEBUG2(J)(           187) <=         lookup_tag_current_word(C_MY_3RD_WAY).Secure;
            MEMORY_DEBUG2(J)(           188) <=         lookup_tag_current_word(C_MY_3RD_WAY).Reused;
            MEMORY_DEBUG2(J)(           189) <=         lookup_tag_current_word(C_MY_3RD_WAY).Dirty;
            MEMORY_DEBUG2(J)(           190) <=         lookup_tag_current_word(C_MY_3RD_WAY).Locked;
            MEMORY_DEBUG2(J)(           191) <=         lookup_tag_current_word(C_MY_3RD_WAY).Valid;
            
            MEMORY_DEBUG2(J)(239 downto 192) <= fit_vec(lookup_tag_current_word(C_MY_4TH_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           250) <=         lookup_tag_current_word(C_MY_4TH_WAY).Unique;
            MEMORY_DEBUG2(J)(           251) <=         lookup_tag_current_word(C_MY_4TH_WAY).Secure;
            MEMORY_DEBUG2(J)(           252) <=         lookup_tag_current_word(C_MY_4TH_WAY).Reused;
            MEMORY_DEBUG2(J)(           253) <=         lookup_tag_current_word(C_MY_4TH_WAY).Dirty;
            MEMORY_DEBUG2(J)(           254) <=         lookup_tag_current_word(C_MY_4TH_WAY).Locked;
            MEMORY_DEBUG2(J)(           255) <=         lookup_tag_current_word(C_MY_4TH_WAY).Valid;
            
            MEMORY_DEBUG2(J)(303 downto 256) <= fit_vec(update_tag_current_word(C_MY_1ST_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           314) <=         update_tag_current_word(C_MY_1ST_WAY).Unique;
            MEMORY_DEBUG2(J)(           315) <=         update_tag_current_word(C_MY_1ST_WAY).Secure;
            MEMORY_DEBUG2(J)(           316) <=         update_tag_current_word(C_MY_1ST_WAY).Reused;
            MEMORY_DEBUG2(J)(           317) <=         update_tag_current_word(C_MY_1ST_WAY).Dirty;
            MEMORY_DEBUG2(J)(           318) <=         update_tag_current_word(C_MY_1ST_WAY).Locked;
            MEMORY_DEBUG2(J)(           319) <=         update_tag_current_word(C_MY_1ST_WAY).Valid;
            
            MEMORY_DEBUG2(J)(367 downto 320) <= fit_vec(update_tag_current_word(C_MY_2ND_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           378) <=         update_tag_current_word(C_MY_2ND_WAY).Unique;
            MEMORY_DEBUG2(J)(           379) <=         update_tag_current_word(C_MY_2ND_WAY).Secure;
            MEMORY_DEBUG2(J)(           380) <=         update_tag_current_word(C_MY_2ND_WAY).Reused;
            MEMORY_DEBUG2(J)(           381) <=         update_tag_current_word(C_MY_2ND_WAY).Dirty;
            MEMORY_DEBUG2(J)(           382) <=         update_tag_current_word(C_MY_2ND_WAY).Locked;
            MEMORY_DEBUG2(J)(           383) <=         update_tag_current_word(C_MY_2ND_WAY).Valid;
            
            MEMORY_DEBUG2(J)(431 downto 384) <= fit_vec(update_tag_current_word(C_MY_3RD_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           442) <=         update_tag_current_word(C_MY_3RD_WAY).Unique;
            MEMORY_DEBUG2(J)(           443) <=         update_tag_current_word(C_MY_3RD_WAY).Secure;
            MEMORY_DEBUG2(J)(           444) <=         update_tag_current_word(C_MY_3RD_WAY).Reused;
            MEMORY_DEBUG2(J)(           445) <=         update_tag_current_word(C_MY_3RD_WAY).Dirty;
            MEMORY_DEBUG2(J)(           446) <=         update_tag_current_word(C_MY_3RD_WAY).Locked;
            MEMORY_DEBUG2(J)(           447) <=         update_tag_current_word(C_MY_3RD_WAY).Valid;
            
            MEMORY_DEBUG2(J)(495 downto 448) <= fit_vec(update_tag_current_word(C_MY_4TH_WAY).Addr, 48);
            MEMORY_DEBUG2(J)(           506) <=         update_tag_current_word(C_MY_4TH_WAY).Unique;
            MEMORY_DEBUG2(J)(           507) <=         update_tag_current_word(C_MY_4TH_WAY).Secure;
            MEMORY_DEBUG2(J)(           508) <=         update_tag_current_word(C_MY_4TH_WAY).Reused;
            MEMORY_DEBUG2(J)(           509) <=         update_tag_current_word(C_MY_4TH_WAY).Dirty;
            MEMORY_DEBUG2(J)(           510) <=         update_tag_current_word(C_MY_4TH_WAY).Locked;
            MEMORY_DEBUG2(J)(           511) <=         update_tag_current_word(C_MY_4TH_WAY).Valid;
            
            MEMORY_DEBUG2(J)(559 downto 512) <= fit_vec(lookup_tag_new_word(0).Addr, 48);
            MEMORY_DEBUG2(J)(           570) <=         lookup_tag_new_word(0).Unique;
            MEMORY_DEBUG2(J)(           571) <=         lookup_tag_new_word(0).Secure;
            MEMORY_DEBUG2(J)(           572) <=         lookup_tag_new_word(0).Reused;
            MEMORY_DEBUG2(J)(           573) <=         lookup_tag_new_word(0).Dirty;
            MEMORY_DEBUG2(J)(           574) <=         lookup_tag_new_word(0).Locked;
            MEMORY_DEBUG2(J)(           575) <=         lookup_tag_new_word(0).Valid;
            
            MEMORY_DEBUG2(J)(623 downto 576) <= fit_vec(update_tag_new_word(0).Addr, 48);
            MEMORY_DEBUG2(J)(           634) <=         update_tag_new_word(0).Unique;
            MEMORY_DEBUG2(J)(           635) <=         update_tag_new_word(0).Secure;
            MEMORY_DEBUG2(J)(           636) <=         update_tag_new_word(0).Reused;
            MEMORY_DEBUG2(J)(           637) <=         update_tag_new_word(0).Dirty;
            MEMORY_DEBUG2(J)(           638) <=         update_tag_new_word(0).Locked;
            MEMORY_DEBUG2(J)(           639) <=         update_tag_new_word(0).Valid;
            
            -- Address.
            MEMORY_DEBUG2(J)(687 downto 640) <= fit_vec(C_BASEADDR(63 downto C_ADDR_FULL_LINE_HI + 1) & lookup_tag_addr & (C_ADDR_FULL_LINE_LO - 1 downto 0=>'0'), 48);
            MEMORY_DEBUG2(J)(735 downto 688) <= fit_vec(C_BASEADDR(63 downto C_ADDR_FULL_LINE_HI + 1) & update_tag_addr & (C_ADDR_FULL_LINE_LO - 1 downto 0=>'0'), 48);
            
            -- Ctrl.
            MEMORY_DEBUG2(J)(743 downto 736) <= fit_vec("0" & lookup_tag_en, 8);
            MEMORY_DEBUG2(J)(751 downto 744) <= fit_vec("0" & update_tag_en, 8);
            MEMORY_DEBUG2(J)(759 downto 752) <= fit_vec(lookup_tag_we, 8);
            MEMORY_DEBUG2(J)(767 downto 760) <= fit_vec(update_tag_we, 8);
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Gen_Block;
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_LOOKUP_ERROR)     <= '1' when lookup_assert /= (C_CACHE_BLOCKS - 1 downto 0=>'0') and C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_UPDATE_ERROR)     <= '1' when update_assert /= (C_CACHE_BLOCKS - 1 downto 0=>'0') and C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_LOOKUP_ERROR) /= '1' 
      report "Cache Core: Lookup module error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_UPDATE_ERROR) /= '1' 
      report "Cache Core: Update module error."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_s_axi_length_generation.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_length_generation.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_length_generation.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-07-27    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_s_axi_length_generation is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    
    -- AXI4 Interface Specific.
    C_S_AXI_ADDR_WIDTH        : natural                       := 32;
    
    -- System Cache Specific.
    C_CACHE_LINE_LENGTH       : natural range  4 to  128      := 16;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    
    -- Data type and settings specific.
    C_ADDR_LENGTH_HI          : natural range  0 to   63      := 10;
    C_ADDR_LENGTH_LO          : natural range  0 to   63      :=  0;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Input Signals.
    
    arbiter_piperun           : in  std_logic;
    new_transaction           : in  std_logic;
    first_part                : in  std_logic;
    access_is_incr            : in  std_logic;
    access_is_wrap            : in  std_logic;
    access_byte_len           : in  AXI_ADDR_TYPE;
    aligned_addr              : in  AXI_ADDR_TYPE;
    allowed_max_wrap_len      : in  std_logic_vector(C_ADDR_LENGTH_HI downto C_ADDR_LENGTH_LO);
    full_line_beats           : in  std_logic_vector(C_ADDR_LENGTH_HI downto C_ADDR_LENGTH_LO);
    wrap_end_beats            : in  AXI_LENGTH_TYPE;
    adjusted_addr             : in  AXI_LENGTH_TYPE;
    wrap_split_mask           : in  AXI_LENGTH_TYPE;
    provided_port_len         : in  AXI_LENGTH_TYPE;
    S_AXI_ALEN_q              : in  AXI_LENGTH_TYPE;
    S_AXI_AADDR_q             : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Output Signals.
    
    fit_lx_line               : out std_logic;
    wrap_is_aligned           : out std_logic;
    access_must_split         : out std_logic;
    transaction_start_beats   : out AXI_LENGTH_TYPE;
    remaining_length          : out AXI_LENGTH_TYPE;
    wrap_fit_lx_line          : out std_logic;
    access_cross_line         : out std_logic;
    wrap_must_split           : out std_logic;
    access_fit_sys_line       : out std_logic;
    req_last                  : out std_logic;
    transaction_done          : out std_logic;
    port_access_len           : out AXI_LENGTH_TYPE;
    incr_need_extra           : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_length_generation;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_length_generation is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ADDR_OFFSET_BITS         : natural := C_ADDR_OFFSET_HI - C_ADDR_OFFSET_LO + 1;
  constant C_ADDR_BYTE_BITS           : natural := C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1;
  constant C_ADDR_PAGE_BITS           : natural := 12;
  constant C_ADDR_PAGE_HI             : natural := C_ADDR_PAGE_BITS - 1;
  constant C_ADDR_PAGE_LO             : natural := 0;
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  
  -- Address related.
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI     downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  subtype C_ADDR_LENGTH_POS           is natural range C_ADDR_LENGTH_HI     downto C_ADDR_LENGTH_LO;
  
  subtype C_ADDR_PAGE_NUM_POS         is natural range C_S_AXI_ADDR_WIDTH - 1 downto C_ADDR_PAGE_BITS;
  subtype C_ADDR_PAGE_POS             is natural range C_ADDR_PAGE_HI         downto C_ADDR_PAGE_LO;
  
  
  -- Subtypes for address parts.
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  subtype ADDR_LENGTH_TYPE            is std_logic_vector(C_ADDR_LENGTH_POS);
  
  subtype ADDR_PAGE_NUM_TYPE          is std_logic_vector(C_ADDR_PAGE_NUM_POS);
  subtype ADDR_PAGE_TYPE              is std_logic_vector(C_ADDR_PAGE_POS);
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ADDR_LENGTH              : natural := C_ADDR_LENGTH_HI - C_ADDR_LENGTH_LO + 1;
  constant C_FULL_LINE_BYTE_LENGTH    : ADDR_LENGTH_TYPE := std_logic_vector(to_unsigned(C_CACHE_LINE_LENGTH * 4 - 1, 
                                                                                         C_ADDR_LENGTH));
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_latch_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and;
  
  component carry_compare_mask_const is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIZE   : natural;
      B_Vec    : std_logic_vector
    );
    port (
      A_Vec      : in  std_logic_vector(C_SIZE-1 downto 0);
      Mask       : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In   : in  std_logic;
      Carry_Out  : out std_logic
    );
  end component carry_compare_mask_const;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Decode Transaction Information
  
  signal fit_lx_line_i            : std_logic;
  signal wrap_is_aligned_i        : std_logic;
  signal access_fit_sys_line_i    : std_logic;
  signal wrap_fit_lx_line_i       : std_logic;
  signal incr_end_address         : AXI_ADDR_TYPE;
  signal wrap_must_split_i        : std_logic;
  signal access_must_split_i      : std_logic;
  signal access_cross_line_i      : std_logic;
  signal transaction_start_beats_i: AXI_LENGTH_TYPE;
  signal wrap_tot_beats           : AXI_LENGTH_TYPE;
  
  
  -- ----------------------------------------
  -- Handle Internal Transactions
  
  signal port_access_len_i        : AXI_LENGTH_TYPE;
  signal remaining_length_i       : AXI_LENGTH_TYPE;
  signal req_last_i               : std_logic;
  signal first_word_in_line       : std_logic;
  
  
begin  -- architecture IMP

  -----------------------------------------------------------------------------
  -- Shared Code
  -----------------------------------------------------------------------------
  
  -- Calculate Incr end address.
  incr_end_address    <= std_logic_vector(unsigned(aligned_addr) + unsigned(access_byte_len));
  
  -- Detect when the transaction has to split.
  wrap_must_split_i   <= access_is_wrap and not wrap_fit_lx_line_i and not wrap_is_aligned_i;
  access_must_split_i <= wrap_must_split_i or access_cross_line_i;
  
  -- Number of Wrap beats.
  wrap_tot_beats      <= S_AXI_ALEN_q(7 downto 0);
  
  -- Detect that an incr need an extra beat due to scaling.
  incr_need_extra     <= b2s( incr_end_address(C_ADDR_BYTE_POS) < S_AXI_AADDR_q(C_ADDR_BYTE_POS) ) and 
                         req_last_i and not access_is_wrap and first_part;
  
  -- .
  Length_Handler : process (ACLK) is
  begin  -- process Length_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        first_word_in_line  <= '1';
      elsif( ( arbiter_piperun = '1' ) and ( new_transaction = '1' ) ) then
        if( ( C_CACHE_DATA_WIDTH /= ( C_CACHE_LINE_LENGTH * 32 ) ) and ( C_CACHE_DATA_WIDTH > 32 ) ) then
          if( incr_end_address(C_ADDR_OFFSET_HI downto C_ADDR_BYTE_HI + 1) = (C_ADDR_OFFSET_HI downto C_ADDR_BYTE_HI + 1=>'0') ) then
            first_word_in_line  <= '1';
          else
            first_word_in_line  <= '0';
          end if;
        end if;
      end if;
    end if;
  end process Length_Handler;
  
  
  -----------------------------------------------------------------------------
  -- RTL Code
  -----------------------------------------------------------------------------
  
  Use_RTL: if( C_TARGET = RTL ) generate
    signal port_access_len_ii       : AXI_LENGTH_TYPE;
    signal wrap_split_beats         : AXI_LENGTH_TYPE;
    signal remaining_length_new     : AXI_LENGTH_TYPE;
  begin
    -- Determine if transaction can fit in Lx Line Length.
    fit_lx_line_i             <= '1' when to_integer(unsigned(access_byte_len(C_ADDR_LENGTH_POS))) <= 
                                          to_integer(unsigned(allowed_max_wrap_len)) else 
                                 '0';
    
    -- Determine if a wrap can fit in Lx Line Length.
    wrap_fit_lx_line_i        <= access_is_wrap and fit_lx_line_i;
    
    -- Calculate if transaction is longer than internal cache line.
    access_fit_sys_line_i     <= '1' when to_integer(unsigned(access_byte_len(C_ADDR_LENGTH_POS))) <= 
                                          (C_CACHE_LINE_LENGTH * 4 - 1) else 
                                 '0';
    
    -- Test if Incr transaction crosses Cache Line boundaries.
    -- (Page High can only be smaller than Line Low for unsupported interface size)
    access_cross_line_i       <= access_is_incr or not access_fit_sys_line_i
                                   when    S_AXI_AADDR_q(C_ADDR_PAGE_HI downto C_ADDR_LINE_LO) /= 
                                        incr_end_address(C_ADDR_PAGE_HI downto C_ADDR_LINE_LO) else 
                               not access_fit_sys_line_i;
    
    -- Detect if wrap is aligned to wrap start address.
    wrap_is_aligned_i         <= '1' when ( S_AXI_AADDR_q(C_ADDR_OFFSET_POS) and access_byte_len(C_ADDR_OFFSET_POS) ) = 
                                            (C_ADDR_OFFSET_POS=>'0') else 
                                 '0';
    
    -- Point of split for wrapping burst.
    wrap_split_beats          <= adjusted_addr and wrap_split_mask;
    
    -- Number of beats in the first cache line.
    transaction_start_beats_i <= std_logic_vector(unsigned(full_line_beats(C_AXI_LENGTH_POS)) - unsigned(wrap_end_beats)) 
                                       when access_cross_line_i = '1' else
                                 std_logic_vector(unsigned(wrap_tot_beats) - unsigned(wrap_split_beats)) 
                                       when wrap_must_split_i = '1' else
                                 S_AXI_ALEN_q;
    
    -- Select transaction length.
    Gen_Len: process (first_part, transaction_start_beats_i, req_last_i, remaining_length_i, full_line_beats) is
    begin  -- process Gen_Len
      if( first_part = '1' ) then
        port_access_len_ii  <= transaction_start_beats_i;
      elsif( req_last_i = '1' ) then
        port_access_len_ii  <= remaining_length_i;
      else
        port_access_len_ii  <= full_line_beats(C_AXI_LENGTH_POS);
      end if;
    end process Gen_Len;
    
    -- Select transaction length.
    Gen_Rem_Len: process (first_part, S_AXI_ALEN_q, port_access_len_ii, remaining_length_i) is
    begin  -- process Gen_Rem_Len
      if( first_part = '1' ) then
        remaining_length_new  <= std_logic_vector(unsigned(S_AXI_ALEN_q) - unsigned(port_access_len_ii) - 1);
      else
        remaining_length_new  <= std_logic_vector(unsigned(remaining_length_i) - unsigned(port_access_len_ii) - 1);
      end if;
    end process Gen_Rem_Len;
    
    -- Keep track of remaining length.
    Length_Handler : process (ACLK) is
    begin  -- process Length_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
          port_access_len_i   <= (others=>'0');
          remaining_length_i  <= (others=>'0');
        elsif( ( arbiter_piperun = '1' ) and ( new_transaction = '1' ) ) then
          port_access_len_i   <= port_access_len_ii;
          remaining_length_i  <= remaining_length_new;
        end if;
      end if;
    end process Length_Handler;
    
    -- Determine if this is the last piece.
    req_last_i        <= '1' when ( ( first_part and not access_must_split_i ) = '1' ) or 
                                  ( first_part = '0' and
                                    ( to_integer(unsigned(remaining_length_i)) <= 
                                      to_integer(unsigned(full_line_beats(C_AXI_LENGTH_POS)))) ) else 
                         '0';
    
    -- Last part has been forwarded.
    transaction_done  <= new_transaction and req_last_i;
    
  end generate Use_RTL;
  
  
  -----------------------------------------------------------------------------
  -- FPGA Optimized Code
  -----------------------------------------------------------------------------
  
  Use_FPGA: if( C_TARGET /= RTL ) generate
  
    signal start_carry_sel          : std_logic;
    signal remaining_carry          : AXI_LENGTH_CARRY_TYPE;
    signal remaining_di             : AXI_LENGTH_TYPE;
    signal remaining_s              : AXI_LENGTH_TYPE;
    signal pre_length_i             : AXI_LENGTH_TYPE;
    signal pre_length               : AXI_LENGTH_TYPE;
    
    signal first_part_n             : std_logic;
    signal more_beats_carry         : AXI_LENGTH_CARRY_TYPE;
    signal more_beats_di            : AXI_LENGTH_TYPE;
    signal more_beats_s             : AXI_LENGTH_TYPE;
    signal use_full_length          : std_logic;
    
    signal fit_sys_carry            : std_logic_vector(C_ADDR_LENGTH_HI + 1 downto C_ADDR_LENGTH_LO);
    signal fit_sys_di               : ADDR_LENGTH_TYPE;
    signal fit_sys_s                : ADDR_LENGTH_TYPE;
    signal cross_carry              : std_logic_vector(C_ADDR_PAGE_HI + 1 downto C_ADDR_LINE_LO);
    signal cross_s                  : std_logic_vector(C_ADDR_PAGE_HI     downto C_ADDR_LINE_LO);
    
    signal fit_lx_carry             : std_logic_vector(C_ADDR_LENGTH_HI + 1 downto C_ADDR_LENGTH_LO);
    signal fit_lx_di                : ADDR_LENGTH_TYPE;
    signal fit_lx_s                 : ADDR_LENGTH_TYPE;
    signal fit_lx_line_n            : std_logic;
    signal fit_lx_line_n_i          : std_logic;
    signal wrap_fit_lx_line_n       : std_logic;
    
    signal long_split_len           : AXI_LENGTH_TYPE;
    signal short_split_carry        : AXI_LENGTH_CARRY_TYPE;
    signal short_split_di           : AXI_LENGTH_TYPE;
    signal short_split_s            : AXI_LENGTH_TYPE;
    signal short_split_len          : AXI_LENGTH_TYPE;
    
    signal feedback_or_full_len     : AXI_LENGTH_TYPE;
    signal feedback_or_other_len    : AXI_LENGTH_TYPE;
    signal port_access_len_cmb      : AXI_LENGTH_TYPE;
    
    signal first_done               : std_logic;
    
  begin
    -- ----------------------------------------
    -- Generate length before previous segment.
    
    pre_length_i  <= remaining_length_i when new_transaction = '1' else pre_length;
    
    remaining_carry(0) <= '0';
    
    Remaining_Bit_Gen: for I in 0 to C_AXI_LENGTH_WIDTH - 1 generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"F099CCCC00550000"
        )
        port map(
          O5 => remaining_di(I),              -- [out std_logic]
          O6 => remaining_s(I),               -- [out std_logic]
          I0 => port_access_len_i(I),         -- [in  std_logic]
          I1 => pre_length(I),                -- [in  std_logic]
          I2 => S_AXI_ALEN_q(I),              -- [in  std_logic]
          I3 => first_part,                   -- [in  std_logic]
          I4 => '1',                          -- [in  std_logic]
          I5 => '1'                           -- [in  std_logic]
        );
      MUXCY_Inst : MUXCY_L
        port map (
          DI => remaining_di(I),              -- [in  std_logic]
          CI => remaining_carry(I),           -- [in  std_logic]
          S  => remaining_s(I),               -- [in  std_logic]
          LO => remaining_carry(I+1)          -- [out std_logic]
        );

      -- Merge addsub result with carry in to get final result
      XOR_Inst : XORCY
        port map (
          LI => remaining_s(I),               -- [in  std_logic]
          CI => remaining_carry(I),           -- [in  std_logic]
          O  => remaining_length_i(I)         -- [out std_logic]
        );
          
      FDS_Inst : FDSE
        port map (
          Q  => pre_length(I),                -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          CE => arbiter_piperun,              -- [in  std_logic]
          D  => pre_length_i(I),              -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
      
    end generate Remaining_Bit_Gen;
    
    
    -- ----------------------------------------
    -- Detect middle segments.
    
    first_part_n                              <= not first_part;
    more_beats_carry(more_beats_carry'right)  <= '0';
    
    More_Beat_Det: for I in 0 to C_AXI_LENGTH_WIDTH - 1 generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"F099CCCC00550000"
        )
        port map(
          O5 => more_beats_di(I),             -- [out std_logic]
          O6 => more_beats_s(I),              -- [out std_logic]
          I0 => full_line_beats(I),           -- [in  std_logic]
          I1 => remaining_length_i(I),        -- [in  std_logic]
          I2 => '0',                          -- [in  std_logic]
          I3 => '0',                          -- [in  std_logic]
          I4 => '1',                          -- [in  std_logic]
          I5 => '1'                           -- [in  std_logic]
        );
        
      MUXCY_Inst : MUXCY_L
        port map (
          DI => more_beats_di(I),
          CI => more_beats_carry(I),
          S  => more_beats_s(I),
          LO => more_beats_carry(I+1)
        );

    end generate More_Beat_Det;
    
    Use_Full_Inst : MUXCY_L
      port map (
        DI => '0',
        CI => more_beats_carry(more_beats_carry'left),
        S  => first_part_n,
        LO => use_full_length
      );
    
    
    -- ----------------------------------------
    -- Detect crossing line
    
    fit_sys_carry(fit_sys_carry'right) <= '0';
    
    Fit_Sys_Det: for I in C_ADDR_LENGTH_LO to C_ADDR_LENGTH_HI generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"F099CCCC00550000"
        )
        port map(
          O5 => fit_sys_di(I),                -- [out std_logic]
          O6 => fit_sys_s(I),                 -- [out std_logic]
          I0 => C_FULL_LINE_BYTE_LENGTH(I),   -- [in  std_logic]
          I1 => access_byte_len(I),           -- [in  std_logic]
          I2 => '0',                          -- [in  std_logic]
          I3 => '0',                          -- [in  std_logic]
          I4 => '1',                          -- [in  std_logic]
          I5 => '1'                           -- [in  std_logic]
        );
        
      MUXCY_Inst : MUXCY_L
        port map (
          DI => fit_sys_di(I),
          CI => fit_sys_carry(I),
          S  => fit_sys_s(I),
          LO => fit_sys_carry(I+1)
        );
      
    end generate Fit_Sys_Det;
    
    access_fit_sys_line_i           <= not fit_sys_carry(fit_sys_carry'left);
    cross_carry(cross_carry'right)  <= fit_sys_carry(fit_sys_carry'left);
    
    Cross_Det: for I in C_ADDR_LINE_LO to C_ADDR_PAGE_HI generate
    begin
--      cross_s(I) <= not access_is_incr when S_AXI_AADDR_q(I) /= incr_end_address(I) else '0';
      
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"9009FFFF00000000"
        )
        port map(
          O5 => open,                         -- [out std_logic]
          O6 => cross_s(I),                   -- [out std_logic]
          I0 => S_AXI_AADDR_q(I),             -- [in  std_logic]
          I1 => incr_end_address(I),          -- [in  std_logic]
          I2 => S_AXI_AADDR_q(I+1),           -- [in  std_logic]
          I3 => incr_end_address(I+1),        -- [in  std_logic]
          I4 => access_is_incr,               -- [in  std_logic]
          I5 => '1'                           -- [in  std_logic]
        );
        
      MUXCY_Inst : MUXCY_L
        port map (
          DI => '1',
          CI => cross_carry(I),
          S  => cross_s(I),
          LO => cross_carry(I+1)
        );
      
    end generate Cross_Det;
    
    access_cross_line_i <= cross_carry(cross_carry'left);

    
    -- ----------------------------------------
    -- Detect wrap split
    
    fit_lx_carry(fit_lx_carry'right)  <= '0';
    
    Fit_Lx_Det: for I in C_ADDR_LENGTH_LO to C_ADDR_LENGTH_HI generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"F099CCCC00550000"
        )
        port map(
          O5 => fit_lx_di(I),                 -- [out std_logic]
          O6 => fit_lx_s(I),                  -- [out std_logic]
          I0 => allowed_max_wrap_len(I),      -- [in  std_logic]
          I1 => access_byte_len(I),           -- [in  std_logic]
          I2 => '0',                          -- [in  std_logic]
          I3 => '0',                          -- [in  std_logic]
          I4 => '1',                          -- [in  std_logic]
          I5 => '1'                           -- [in  std_logic]
        );
        
      MUXCY_Inst : MUXCY_L
        port map (
          DI => fit_lx_di(I),                 -- [in  std_logic]
          CI => fit_lx_carry(I),              -- [in  std_logic]
          S  => fit_lx_s(I),                  -- [in  std_logic]
          LO => fit_lx_carry(I+1));           -- [out std_logic]
      
    end generate Fit_Lx_Det;
    
    fit_lx_line_n             <= fit_lx_carry(fit_lx_carry'left);
    fit_lx_line_i             <= not fit_lx_line_n;
    
    Fit_Lx_Latch_And_Inst1: carry_latch_and
      generic map(
        C_TARGET  => C_TARGET,
        C_INV_C   => true
      )
      port map(
        Carry_IN  => fit_lx_line_n,
        A         => access_is_wrap,
        O         => wrap_fit_lx_line_i,
        Carry_OUT => fit_lx_line_n_i
      );
      
    Fit_Lx_MUXCY_Inst2: MUXCY_L
      port map (
        DI => '0',                          -- [in  std_logic]
        CI => fit_lx_line_n_i,              -- [in  std_logic]
        S  => access_is_wrap,               -- [in  std_logic]
        LO => wrap_fit_lx_line_n            -- [out std_logic]
      );
      
    
    -- ----------------------------------------
    -- Detect wrap alignment
    
    Aligned_Inst: carry_compare_mask_const
      generic map(
        C_TARGET    => C_TARGET,
        C_SIZE      => C_ADDR_OFFSET_BITS,
        B_Vec       => (C_ADDR_OFFSET_POS=>'0')
      )
      port map(
        A_Vec       => S_AXI_AADDR_q(C_ADDR_OFFSET_POS),
        Mask        => access_byte_len(C_ADDR_OFFSET_POS),
        Carry_In    => '1',
        Carry_Out   => wrap_is_aligned_i
      );
    
    
    -- ----------------------------------------
    -- Generate sub lengths
    
    long_split_len  <= std_logic_vector(unsigned(full_line_beats(C_AXI_LENGTH_POS)) - unsigned(wrap_end_beats));
    
    short_split_carry(short_split_carry'right)  <= '1';
    
    Short_Split_Bit_Gen: for I in 0 to C_AXI_LENGTH_WIDTH - 1 generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"8787878777777777"
        )
        port map(
          O5 => short_split_di(I),              -- [out std_logic]
          O6 => short_split_s(I),               -- [out std_logic]
          I0 => adjusted_addr(I),               -- [in  std_logic]
          I1 => wrap_split_mask(I),             -- [in  std_logic]
          I2 => wrap_tot_beats(I),              -- [in  std_logic]
          I3 => '0',                            -- [in  std_logic]
          I4 => '0',                            -- [in  std_logic]
          I5 => '1'                             -- [in  std_logic]
        );
        
      MUXCY_Inst : MUXCY_L
        port map (
          DI => short_split_di(I),              -- [in  std_logic]
          CI => short_split_carry(I),           -- [in  std_logic]
          S  => short_split_s(I),               -- [in  std_logic]
          LO => short_split_carry(I+1)          -- [out std_logic]
        );

      -- Merge addsub result with carry in to get final result
      XOR_Inst : XORCY
        port map (
          LI => short_split_s(I),               -- [in  std_logic]
          CI => short_split_carry(I),           -- [in  std_logic]
          O  => short_split_len(I)              -- [out std_logic]
        );
          
    end generate Short_Split_Bit_Gen;
    
    
    -- ----------------------------------------
    -- Generate first length
    
    Start_Len_Bit_Gen: for I in 0 to C_AXI_LENGTH_WIDTH - 1 generate
    begin
      LUT_Inst: LUT6_2
        generic map(
          INIT => X"F0F0F0F0AACCAAAA"
        )
        port map(
          O5 => open,                         -- [out std_logic]
          O6 => transaction_start_beats_i(I), -- [out std_logic]
          I0 => S_AXI_ALEN_q(I),              -- [in  std_logic]
          I1 => short_split_len(I),           -- [in  std_logic]
          I2 => long_split_len(I),            -- [in  std_logic]
          I3 => wrap_is_aligned_i,            -- [in  std_logic]
          I4 => wrap_fit_lx_line_n,           -- [in  std_logic]
          I5 => access_cross_line_i           -- [in  std_logic]
        );
      
    end generate Start_Len_Bit_Gen;
    
    
    -- ----------------------------------------
    -- Generate length
    
    feedback_or_full_len  <= full_line_beats(C_AXI_LENGTH_POS) when new_transaction = '1' else
                             port_access_len_i;
    
    Port_Len_Bit_Gen: for I in 0 to C_AXI_LENGTH_WIDTH - 1 generate
    begin
      LUT_Inst1: LUT6_2
        generic map(
          INIT => X"F0CCF0CCAAAAAAAA"
        )
        port map(
          O5 => open,                         -- [out std_logic]
          O6 => feedback_or_other_len(I),     -- [out std_logic]
          I0 => port_access_len_i(I),         -- [in  std_logic]
          I1 => remaining_length_i(I),        -- [in  std_logic]
          I2 => transaction_start_beats_i(I), -- [in  std_logic]
          I3 => first_part,                   -- [in  std_logic]
          I4 => '0',                          -- [in  std_logic]
          I5 => new_transaction               -- [in  std_logic]
        );
        
      MUXF7_I1 : MUXF7
        port map (
          O  => port_access_len_cmb(I),       -- [out std_logic]
          I0 => feedback_or_other_len(I),     -- [in  std_logic]
          I1 => feedback_or_full_len(I),      -- [in  std_logic]
          S  => use_full_length               -- [in  std_logic]
        );
        
      FDS_Inst : FDSE
        port map (
          Q  => port_access_len_i(I),         -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          CE => arbiter_piperun,              -- [in  std_logic]
          D  => port_access_len_cmb(I),       -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
      
    end generate Port_Len_Bit_Gen;
    
    
    -- ----------------------------------------
    -- Determine if this is the last piece.
    
    first_done  <= first_part and not access_must_split_i;
    
    req_last_i  <= first_done or ( not use_full_length and not first_part );
    
    
    -- ----------------------------------------
    -- Last part has been forwarded.
    
    transaction_done  <= new_transaction and req_last_i;
    
    
  end generate Use_FPGA;
  
  
  -----------------------------------------------------------------------------
  -- Assign Output
  -----------------------------------------------------------------------------
  
  fit_lx_line             <= fit_lx_line_i;
  wrap_is_aligned         <= wrap_is_aligned_i;
  access_must_split       <= access_must_split_i;
  transaction_start_beats <= transaction_start_beats_i;
  remaining_length        <= remaining_length_i;
  access_fit_sys_line     <= access_fit_sys_line_i;
  wrap_fit_lx_line        <= wrap_fit_lx_line_i;
  access_cross_line       <= access_cross_line_i;
  wrap_must_split         <= wrap_must_split_i;
  req_last                <= req_last_i;
  port_access_len         <= port_access_len_i;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          IF_DEBUG  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG      <= (others=>'0');
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- None.
  
  
end architecture IMP;
  
  


-------------------------------------------------------------------------------
-- sc_s_axi_a_channel.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_a_channel.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_a_channel.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-07-27    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_s_axi_a_channel is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- AXI4 Interface Specific.
    C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_S_AXI_ADDR_WIDTH        : natural                       := 32;
    C_S_AXI_ID_WIDTH          : natural                       :=  1;
    C_S_AXI_FORCE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_ALLOCATE : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_OTHER_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_OTHER_ALLOCATE : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_BUFFER      : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_BUFFER   : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_EXCLUSIVE: natural range  0 to    1      :=  1;
    
    -- Configuration.
    C_IS_READ                 : natural range  0 to    1      :=  0;
    C_LEN_WIDTH               : natural range  0 to    8      :=  2;
    C_REST_WIDTH              : natural range  0 to    7      :=  2;
    
    -- Data type and settings specific.
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    
    -- Lx Cache Specific.
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
    
    -- IP Specific.
    C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
    C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0;
    C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
    
    -- System Cache Specific.
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  4 to  128      := 16;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- AXI4/ACE Slave Interface Signals.
    
    -- AW-Channel
    S_AXI_AID                 : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_AADDR               : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    S_AXI_ALEN                : in  std_logic_vector(7 downto 0);
    S_AXI_ASIZE               : in  std_logic_vector(2 downto 0);
    S_AXI_ABURST              : in  std_logic_vector(1 downto 0);
    S_AXI_ALOCK               : in  std_logic;
    S_AXI_ACACHE              : in  std_logic_vector(3 downto 0);
    S_AXI_APROT               : in  std_logic_vector(2 downto 0);
    S_AXI_AQOS                : in  std_logic_vector(3 downto 0);
    S_AXI_AVALID              : in  std_logic;
    S_AXI_AREADY              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write data).
    
    wr_valid                  : out std_logic;
    wr_last                   : out std_logic;
    wr_failed                 : out std_logic;
    wr_offset                 : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_stp                    : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_use                    : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_len                    : out AXI_LENGTH_TYPE;
    wr_ready                  : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Write Response Information Interface Signals.
    
    write_req_valid           : out std_logic;
    write_req_ID              : out std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
    write_req_last            : out std_logic;
    write_req_failed          : out std_logic;
    write_req_ready           : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Read Information Interface Signals.
    
    read_req_valid            : out std_logic;
    read_req_ID               : out std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
    read_req_last             : out std_logic;
    read_req_failed           : out std_logic;
    read_req_single           : out std_logic;
    read_req_rest             : out std_logic_vector(C_REST_WIDTH - 1 downto 0);
    read_req_offset           : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_stp              : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_use              : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_len              : out std_logic_vector(C_LEN_WIDTH - 1  downto 0);
    read_req_ready            : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (All request).
    
    arbiter_piperun           : in  std_logic;
    arbiter_allowed           : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write request).
    
    wr_port_access            : out WRITE_PORT_TYPE;
    wr_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    rd_port_access            : out READ_PORT_TYPE;
    rd_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_s_axi_gen_segments   : out STAT_POINT_TYPE; -- Per transaction
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_a_channel;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_a_channel is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Address channel decoding for both read and write.
  -- Any transaction that doesn't fit the capabilities of the cache core is
  -- split in to pieces. Reasons for this could be that the transaction span
  -- multiple cache lines or are o wrapping in certain ways.
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ADDR_OFFSET_BITS         : natural := C_ADDR_OFFSET_HI - C_ADDR_OFFSET_LO + 1;
  constant C_ADDR_BYTE_BITS           : natural := C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1;
  constant C_ADDR_PAGE_BITS           : natural := 12;
  constant C_ADDR_PAGE_HI             : natural := C_ADDR_PAGE_BITS - 1;
  constant C_ADDR_PAGE_LO             : natural := 0;
  
  -- Select if Lx or Internal cache configuration should be targeted.
  constant C_TARGET_Lx                : boolean := is_slv_coherent(C_ENABLE_COHERENCY) and 
                                                   ( C_GEN_MATCH_Lx_CACHE > 0 )        and
                                                   ( ( C_ANY_SUPPORT_DIRTY > 0 ) or ( C_ENABLE_PEER_PORT_DATA > 0 ) );
  
  constant C_CURRENT_LINE_LENGTH      : natural := sel(C_TARGET_Lx, C_Lx_CACHE_LINE_LENGTH, C_CACHE_LINE_LENGTH);
  constant C_CURRENT_DATA_WIDTH       : natural := sel(C_TARGET_Lx, C_Lx_CACHE_DATA_WIDTH,  C_CACHE_DATA_WIDTH);
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  
  -- Address related.
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI     downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  constant C_BYTE_LENGTH              : natural := 8 + Log2(C_S_AXI_DATA_WIDTH/8);
  constant C_ADDR_LENGTH_HI           : natural := C_BYTE_LENGTH - 1;
  constant C_ADDR_LENGTH_LO           : natural := C_ADDR_OFFSET_LO;
  
  subtype C_ADDR_LENGTH_POS           is natural range C_ADDR_LENGTH_HI     downto C_ADDR_LENGTH_LO;
  
  subtype C_ADDR_PAGE_NUM_POS         is natural range C_MAX_ADDR_WIDTH - 1 downto C_ADDR_PAGE_BITS;
  subtype C_ADDR_PAGE_POS             is natural range C_ADDR_PAGE_HI       downto C_ADDR_PAGE_LO;
  
  
  -- Subtypes for address parts.
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  subtype ADDR_LENGTH_TYPE            is std_logic_vector(C_ADDR_LENGTH_POS);
  
  subtype ADDR_PAGE_NUM_TYPE          is std_logic_vector(C_ADDR_PAGE_NUM_POS);
  subtype ADDR_PAGE_TYPE              is std_logic_vector(C_ADDR_PAGE_POS);
  
  constant C_SIZE_MUX_BITS            : natural := Log2(Log2(C_CURRENT_DATA_WIDTH/8) + 1);
  subtype C_SIZE_MUX_POS              is natural range C_SIZE_MUX_BITS - 1 downto 0;
  
  constant C_MAX_SIZE_MUX_BITS        : natural := 3;
  subtype C_MAX_SIZE_MUX_POS          is natural range 2 ** C_MAX_SIZE_MUX_BITS - 1 downto 0;
  type SIZE_MUX_AXI_LEN_TYPE          is array(C_MAX_SIZE_MUX_POS) of AXI_LENGTH_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  subtype C_BYTE_MASK_POS             is natural range C_BYTE_LENGTH - 1 + 7 downto 7;
  subtype C_HALF_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 6 downto 6;
  subtype C_WORD_MASK_POS             is natural range C_BYTE_LENGTH - 1 + 5 downto 5;
  subtype C_DOUBLE_WORD_MASK_POS      is natural range C_BYTE_LENGTH - 1 + 4 downto 4;
  subtype C_QUAD_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 3 downto 3;
  subtype C_OCTA_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 2 downto 2;
  subtype C_HEXADECA_WORD_MASK_POS    is natural range C_BYTE_LENGTH - 1 + 1 downto 1;
  subtype C_TRIACONTADI_MASK_POS      is natural range C_BYTE_LENGTH - 1 + 0 downto 0;
  
  constant C_BYTE_RATIO               : natural := C_CURRENT_DATA_WIDTH / C_BYTE_WIDTH;
  constant C_HALF_WORD_RATIO          : natural := C_CURRENT_DATA_WIDTH / C_HALF_WORD_WIDTH;
  constant C_WORD_RATIO               : natural := C_CURRENT_DATA_WIDTH / C_WORD_WIDTH;
  constant C_DOUBLE_WORD_RATIO        : natural := C_CURRENT_DATA_WIDTH / C_DOUBLE_WORD_WIDTH;
  constant C_QUAD_WORD_RATIO          : natural := C_CURRENT_DATA_WIDTH / C_QUAD_WORD_WIDTH;
  constant C_OCTA_WORD_RATIO          : natural := C_CURRENT_DATA_WIDTH / C_OCTA_WORD_WIDTH;
  constant C_HEXADECA_WORD_RATIO      : natural := C_CURRENT_DATA_WIDTH / C_HEXADECA_WORD_WIDTH;
  constant C_TRIACONTADI_WORD_RATIO   : natural := C_CURRENT_DATA_WIDTH / C_TRIACONTADI_WORD_WIDTH;
  
  constant C_BYTE_RATIO_BITS              : natural := Log2(C_BYTE_RATIO);
  constant C_HALF_WORD_RATIO_BITS         : natural := Log2(C_HALF_WORD_RATIO);
  constant C_WORD_RATIO_BITS              : natural := Log2(C_WORD_RATIO);
  constant C_DOUBLE_WORD_RATIO_BITS       : natural := Log2(C_DOUBLE_WORD_RATIO);
  constant C_QUAD_WORD_RATIO_BITS         : natural := Log2(C_QUAD_WORD_RATIO);
  constant C_OCTA_WORD_RATIO_BITS         : natural := Log2(C_OCTA_WORD_RATIO);
  constant C_HEXADECA_WORD_RATIO_BITS     : natural := Log2(C_HEXADECA_WORD_RATIO);
  constant C_TRIACONTADI_WORD_RATIO_BITS  : natural := Log2(C_TRIACONTADI_WORD_RATIO);
  
  subtype C_DEFAULT_SCALE_POS         is natural range C_BYTE_RATIO_BITS             - 1 downto 0;
  subtype C_BYTE_SCALE_POS            is natural range C_BYTE_RATIO_BITS             - 1 downto 0;
  subtype C_HALF_WORD_SCALE_POS       is natural range C_HALF_WORD_RATIO_BITS        - 1 downto 0;
  subtype C_WORD_SCALE_POS            is natural range C_WORD_RATIO_BITS             - 1 downto 0;
  subtype C_DOUBLE_WORD_SCALE_POS     is natural range C_DOUBLE_WORD_RATIO_BITS      - 1 downto 0;
  subtype C_QUAD_WORD_SCALE_POS       is natural range C_QUAD_WORD_RATIO_BITS        - 1 downto 0;
  subtype C_OCTA_WORD_SCALE_POS       is natural range C_OCTA_WORD_RATIO_BITS        - 1 downto 0;
  subtype C_HEXADECA_WORD_SCALE_POS   is natural range C_HEXADECA_WORD_RATIO_BITS    - 1 downto 0;
  subtype C_TRIACONTADI_SCALE_POS     is natural range C_TRIACONTADI_WORD_RATIO_BITS - 1 downto 0;
  
  subtype C_DEFAULT_RATIO_POS         is natural range C_AXI_LENGTH_WIDTH - 1             downto 
                                                       0;
  subtype C_BYTE_RATIO_POS            is natural range C_BYTE_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1             downto 
                                                       C_BYTE_RATIO_BITS;
  subtype C_HALF_WORD_RATIO_POS       is natural range C_HALF_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1        downto 
                                                       C_HALF_WORD_RATIO_BITS;
  subtype C_WORD_RATIO_POS            is natural range C_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1             downto 
                                                       C_WORD_RATIO_BITS;
  subtype C_DOUBLE_WORD_RATIO_POS     is natural range C_DOUBLE_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1      downto 
                                                       C_DOUBLE_WORD_RATIO_BITS;
  subtype C_QUAD_WORD_RATIO_POS       is natural range C_QUAD_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1        downto 
                                                       C_QUAD_WORD_RATIO_BITS;
  subtype C_OCTA_WORD_RATIO_POS       is natural range C_OCTA_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1        downto 
                                                       C_OCTA_WORD_RATIO_BITS;
  subtype C_HEXADECA_WORD_RATIO_POS   is natural range C_HEXADECA_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1    downto 
                                                       C_HEXADECA_WORD_RATIO_BITS;
  subtype C_TRIACONTADI_RATIO_POS     is natural range C_TRIACONTADI_WORD_RATIO_BITS + C_AXI_LENGTH_WIDTH - 1 downto 
                                                       C_TRIACONTADI_WORD_RATIO_BITS;
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Local rest.
  subtype C_REST_POS                  is natural range C_REST_WIDTH - 1 downto 0;
  subtype REST_TYPE                   is std_logic_vector(C_REST_POS);
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_CACHELINE_MASK           : AXI_ADDR_TYPE := std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH * 4 - 1, 
                                                                                      C_MAX_ADDR_WIDTH));
  
  constant C_NATIVE_SIZE              : AXI_SIZE_TYPE := std_logic_vector(to_unsigned(Log2(C_CURRENT_DATA_WIDTH/8), 
                                                                                           AXI_SIZE_TYPE'length));
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or_n;
  
  component carry_latch_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and;
  
  component reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic_vector;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural;
      C_SIZE    : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic_vector(C_SIZE   - 1 downto 0);
      Q         : out std_logic_vector(C_SIZE   - 1 downto 0)
    );
  end component reg_ce;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  component bit_reg_ce_kill is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      KILL      : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce_kill;
  
  component sc_s_axi_length_generation is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      
      -- AXI4 Interface Specific.
      C_S_AXI_ADDR_WIDTH        : natural                       := 32;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      
      -- System Cache Specific.
      C_CACHE_LINE_LENGTH       : natural range  4 to  128      := 16;
      
      -- Data type and settings specific.
      C_ADDR_LENGTH_HI          : natural range  0 to   63      := 10;
      C_ADDR_LENGTH_LO          : natural range  0 to   63      :=  0;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Input Signals.
      
      arbiter_piperun           : in  std_logic;
      new_transaction           : in  std_logic;
      first_part                : in  std_logic;
      access_is_incr            : in  std_logic;
      access_is_wrap            : in  std_logic;
      access_byte_len           : in  AXI_ADDR_TYPE;
      aligned_addr              : in  AXI_ADDR_TYPE;
      allowed_max_wrap_len      : in  std_logic_vector(C_ADDR_LENGTH_HI downto C_ADDR_LENGTH_LO);
      full_line_beats           : in  std_logic_vector(C_ADDR_LENGTH_HI downto C_ADDR_LENGTH_LO);
      wrap_end_beats            : in  AXI_LENGTH_TYPE;
      adjusted_addr             : in  AXI_LENGTH_TYPE;
      wrap_split_mask           : in  AXI_LENGTH_TYPE;
      provided_port_len         : in  AXI_LENGTH_TYPE;
      S_AXI_ALEN_q              : in  AXI_LENGTH_TYPE;
      S_AXI_AADDR_q             : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Output Signals.
      
      fit_lx_line               : out std_logic;
      wrap_is_aligned           : out std_logic;
      access_must_split         : out std_logic;
      transaction_start_beats   : out AXI_LENGTH_TYPE;
      remaining_length          : out AXI_LENGTH_TYPE;
      wrap_fit_lx_line          : out std_logic;
      access_cross_line         : out std_logic;
      wrap_must_split           : out std_logic;
      access_fit_sys_line       : out std_logic;
      req_last                  : out std_logic;
      transaction_done          : out std_logic;
      port_access_len           : out AXI_LENGTH_TYPE;
      incr_need_extra           : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_length_generation;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  signal S_AXI_AADDR_I            : AXI_ADDR_TYPE;
  
  -- ----------------------------------------
  -- Buffer Incomming Transaction Information (AW, AR)
  
  signal S_AXI_AID_q              : std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
  signal S_AXI_AADDR_q            : AXI_ADDR_TYPE;
  signal S_AXI_ALEN_q             : AXI_LENGTH_TYPE;
  signal S_AXI_ASIZE_q            : AXI_SIZE_TYPE;
  signal S_AXI_ALOCK_q            : std_logic;
  signal S_AXI_ACACHE_q           : AXI_CACHE_TYPE;
  signal S_AXI_APROT_q            : AXI_PROT_TYPE;
  signal S_AXI_AVALID_cmb         : std_logic;
  signal S_AXI_AVALID_q           : std_logic;
  signal S_AXI_AREADY_I           : std_logic;
  signal first_part_cmb           : std_logic;
  signal first_part               : std_logic;
  signal is_wt_q                  : std_logic;
  
  
  -- ----------------------------------------
  -- Pre-Decode Transaction 
  
  signal access_is_incr_cmb       : std_logic;
  signal access_is_wrap_cmb       : std_logic;
  signal access_byte_len_cmb      : AXI_ADDR_TYPE;
  signal access_size_mask_cmb     : AXI_ADDR_TYPE;
  signal access_stp_bits_cmb      : ADDR_BYTE_TYPE;
  signal access_rest_max_cmb      : REST_TYPE;
  signal aligned_addr_cmb         : AXI_ADDR_TYPE;
  signal full_line_beats_cmb      : ADDR_LENGTH_TYPE;
  signal masked_addr_cmb          : AXI_ADDR_TYPE;
  signal wrap_end_beats_cmb       : AXI_LENGTH_TYPE;
  signal wrap_end_beats_vec       : SIZE_MUX_AXI_LEN_TYPE;
  signal allowed_max_wrap_len_cmb : ADDR_LENGTH_TYPE;
  
  
  -- ----------------------------------------
  -- Decode Transaction Information
  
  signal access_is_incr           : std_logic;
  signal access_is_wrap           : std_logic;
  signal extended_length          : std_logic_vector(C_BYTE_LENGTH - 1 + 7 downto 0);
  signal access_byte_len          : AXI_ADDR_TYPE;
  signal allowed_max_wrap_len     : ADDR_LENGTH_TYPE;
  signal aligned_addr             : AXI_ADDR_TYPE;
  signal fit_lx_line              : std_logic;
  signal wrap_fit_lx_line         : std_logic;
  signal wrap_is_aligned          : std_logic;
  signal access_fit_sys_line      : std_logic;
  signal access_cross_line        : std_logic;
  signal exclusive_too_long       : std_logic;
  signal exclusive_too_long_i     : std_logic;
  signal exclusive_not_killed     : std_logic;
  signal wrap_must_split          : std_logic;
  signal access_must_split        : std_logic;
  signal full_line_beats          : ADDR_LENGTH_TYPE;
  signal wrap_end_beats           : AXI_LENGTH_TYPE;
  signal access_stp_bits          : ADDR_BYTE_TYPE;
  signal access_use_bits          : ADDR_BYTE_TYPE;
  signal access_rest_max          : REST_TYPE;
  signal transaction_start_beats  : AXI_LENGTH_TYPE;
  signal wrap_split_beats         : AXI_LENGTH_TYPE;
  signal adjusted_addr_vec        : SIZE_MUX_AXI_LEN_TYPE;
  signal adjusted_addr            : AXI_LENGTH_TYPE;
  signal wrap_split_mask_vec      : SIZE_MUX_AXI_LEN_TYPE;
  signal wrap_split_mask          : AXI_LENGTH_TYPE;
  
  
  -- ----------------------------------------
  -- Handle Internal Transactions
  
  signal port_access_addr         : AXI_ADDR_TYPE;
  signal sequential_addr_step     : AXI_ADDR_TYPE;
  signal sequential_addr_i        : AXI_ADDR_TYPE;
  signal sequential_addr          : AXI_ADDR_TYPE;
  signal port_access_len          : AXI_LENGTH_TYPE;
  signal extended_port_access_len : std_logic_vector(C_AXI_LENGTH_WIDTH + 7 - 1 downto 0);
  signal scaled_port_access_len   : AXI_LENGTH_TYPE;
  signal provided_port_len        : AXI_LENGTH_TYPE;
  signal remaining_length         : AXI_LENGTH_TYPE;
  signal port_access_kind         : std_logic;
  signal req_last                 : std_logic;
  signal allocate_raw             : std_logic;
  signal other_alloc_raw          : std_logic;
  signal allocate_i               : std_logic;
  signal other_alloc              : std_logic;
  signal bufferable_i             : std_logic;
  signal modifiable_i             : std_logic;
  signal new_transaction          : std_logic;
  signal transaction_done         : std_logic;
  signal port_ready               : std_logic;
  signal port_ready_safe          : std_logic;
  signal port_ready_with_valid    : std_logic;
  signal port_want_new_access     : std_logic;
  signal port_exist_and_allowed   : std_logic;
  signal transaction_and_piperun  : std_logic_vector(1 downto 0);
  signal port_access_q            : COMMON_PORT_TYPE;
  signal incr_need_extra          : std_logic;
  signal incr_need_extra_q        : std_logic;

  
  -- ----------------------------------------
  -- Move Information to Next Stage
  
  signal req_last_q               : std_logic;
  signal exclusive_too_long_q     : std_logic;
  signal access_stp_bits_q        : ADDR_BYTE_TYPE;
  signal access_use_bits_new      : ADDR_BYTE_TYPE;
  signal access_use_bits_q        : ADDR_BYTE_TYPE;
  signal id_q                     : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal port_access_valid_i      : std_logic;
  signal port_access_valid        : std_logic;
  signal queue_done_cmb           : std_logic;
  signal queue_done               : std_logic;
  
  
  -- ----------------------------------------
  -- R-Channel Information
  
  signal read_req_valid_i         : std_logic;
  signal read_req_single_i        : std_logic;
  signal read_req_rest_i          : std_logic_vector(C_REST_WIDTH - 1 downto 0);
  signal read_req_rest_q          : std_logic_vector(C_REST_WIDTH - 1 downto 0);
    
    
  -- ----------------------------------------
  -- Create Write Transaction
  
  signal wr_valid_i               : std_logic;
  signal write_req_valid_i        : std_logic;
  signal wr_port_access_i         : WRITE_PORT_TYPE;
  signal wr_port_access_q         : WRITE_PORT_TYPE;
  
  
  -- ----------------------------------------
  -- Create Read Transaction
  
  signal rd_port_access_i         : READ_PORT_TYPE;
  signal rd_port_access_q         : READ_PORT_TYPE;
  
  
begin  -- architecture IMP
  
  -- Create internal signal with maximum width.
  S_AXI_AADDR_I <= fit_vec(S_AXI_AADDR, C_MAX_ADDR_WIDTH);
  
  -----------------------------------------------------------------------------
  -- Buffer Incomming Transaction Information (AW or AR)
  -- 
  -- The incomming commands are buffered in order to have good timing for
  -- maipulation of the trans action.
  -----------------------------------------------------------------------------
  
  Addr_Request_Valid : process (S_AXI_AREADY_I, S_AXI_AVALID, arbiter_piperun, transaction_done, 
                                S_AXI_AVALID_q, new_transaction, first_part) is
  begin  -- process Addr_Request_Valid
    if( S_AXI_AREADY_I = '1' ) then
      S_AXI_AVALID_cmb  <= S_AXI_AVALID;
    elsif( ( arbiter_piperun and transaction_done ) = '1' ) then
      S_AXI_AVALID_cmb  <= '0';
    else
      S_AXI_AVALID_cmb  <= S_AXI_AVALID_q;
    end if;
    
    if( S_AXI_AREADY_I = '1' ) then
      first_part_cmb    <= S_AXI_AVALID;
    elsif( ( arbiter_piperun and new_transaction ) = '1' ) then
      first_part_cmb    <= '0';
    else
      first_part_cmb    <= first_part;
    end if;
  end process Addr_Request_Valid;
  
  Valid_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => "1",
      D         => S_AXI_AVALID_cmb,
      Q         => S_AXI_AVALID_q
    );
    
  First_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '1',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => "1",
      D         => first_part_cmb,
      Q         => first_part
    );
    
  Addr_Request : process (ACLK) is
  begin  -- process Addr_Request
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET = '1' ) then             -- synchronous reset (active high)
        S_AXI_AID_q     <= (others=>'0');
        S_AXI_AADDR_q   <= (others=>'0');
        S_AXI_ALEN_q    <= (others=>'0');
        S_AXI_ASIZE_q   <= (others=>'0');
        S_AXI_ALOCK_q   <= '0';
        S_AXI_ACACHE_q  <= (others=>'0');
        S_AXI_APROT_q   <= (others=>'0');
        
      else
        if( S_AXI_AREADY_I = '1' ) then
          S_AXI_AID_q     <= S_AXI_AID;
          S_AXI_AADDR_q   <= S_AXI_AADDR_I;
          S_AXI_ALEN_q    <= S_AXI_ALEN;
          S_AXI_ASIZE_q   <= S_AXI_ASIZE;
          S_AXI_ALOCK_q   <= S_AXI_ALOCK;
          S_AXI_ACACHE_q  <= S_AXI_ACACHE;
          S_AXI_APROT_q   <= S_AXI_APROT;
          
        end if;
      end if;
    end if;
  end process Addr_Request;
  
  -- Ready to get new word.
  S_AXI_AREADY_I  <= ( not S_AXI_AVALID_q );
  S_AXI_AREADY    <= S_AXI_AREADY_I and not ARESET;
        
        
  -----------------------------------------------------------------------------
  -- Pre-Decode Transaction 
  -- 
  -- Information that need some predecoding in order to get good timing.
  -----------------------------------------------------------------------------
  
  -- Decode transaction type.
  access_is_incr_cmb    <= not access_is_wrap_cmb;
  access_is_wrap_cmb    <= '1' when S_AXI_ABURST = C_AW_WRAP else '0';
  
  -- Extend the length vector (help signal).
  extended_length       <= fit_vec("0000000000" & S_AXI_ALEN & "1111111", C_BYTE_LENGTH - 1 + 8);
  
  -- Figure out the maximum allowed wrap length for the current size.
  Gen_Wrap_Len: process (S_AXI_ASIZE) is
  begin  -- process Gen_Wrap_Len
    if( ( S_AXI_ASIZE        = C_NATIVE_SIZE      ) and 
        ( C_S_AXI_DATA_WIDTH = C_CURRENT_DATA_WIDTH ) and 
        ( C_S_AXI_DATA_WIDTH = C_M_AXI_DATA_WIDTH ) ) then
      allowed_max_wrap_len_cmb  <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH * 4 - 1, ADDR_LENGTH_TYPE'length));
    else
      allowed_max_wrap_len_cmb  <= std_logic_vector(to_unsigned(C_CURRENT_DATA_WIDTH / 8 - 1,  ADDR_LENGTH_TYPE'length));
    end if;
  end process Gen_Wrap_Len;
  
  -- Translate in to normalized length in bytesbyte .
  Gen_Real_Len: process (S_AXI_ASIZE, extended_length) is
  begin  -- process Gen_Real_Len
    access_byte_len_cmb <= (others=>'0');
    case S_AXI_ASIZE is
      when C_BYTE_SIZE          =>
        access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
      when C_HALF_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 16 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_HALF_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when C_WORD_SIZE          =>
        if( C_S_AXI_DATA_WIDTH >= 32 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when C_DOUBLE_WORD_SIZE   =>
        if( C_S_AXI_DATA_WIDTH >= 64 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_DOUBLE_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when C_QUAD_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 128 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_QUAD_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when C_OCTA_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 256 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_OCTA_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when C_HEXADECA_WORD_SIZE =>
        if( C_S_AXI_DATA_WIDTH >= 512 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_HEXADECA_WORD_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
      when others               =>
        if( C_S_AXI_DATA_WIDTH >= 1024 ) then
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_TRIACONTADI_MASK_POS);
        else
          access_byte_len_cmb(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        end if;
    end case;
  end process Gen_Real_Len;
  
  -- Generate transaction size mask, stp and rest maximum.
  Gen_Size_Info: process (S_AXI_ASIZE) is
  begin  -- process Gen_Size_Info
    case S_AXI_ASIZE is
      when C_BYTE_SIZE          =>
        access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
        access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
        access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
        full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
      when C_HALF_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 16 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE - 1,        C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   2, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*2 - 1,        C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when C_WORD_SIZE          =>
        if( C_S_AXI_DATA_WIDTH >= 32 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   4, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*1 - 1,        C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when C_DOUBLE_WORD_SIZE   =>
        if( C_S_AXI_DATA_WIDTH >= 64 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE - 1,      C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE,          C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   8, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH/2 - 1,        C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when C_QUAD_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 128 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE - 1,        C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -  16, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH/4 - 1,        C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when C_OCTA_WORD_SIZE     =>
        if( C_S_AXI_DATA_WIDTH >= 256 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE - 1,        C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -  32, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH/8 - 1,        C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when C_HEXADECA_WORD_SIZE =>
        if( C_S_AXI_DATA_WIDTH >= 512 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE - 1,    C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE,        C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -  64, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH/16 - 1,       C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
      when others               =>
        if( C_S_AXI_DATA_WIDTH >= 1024 ) then
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE - 1, C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE,     C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH - 128, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH/32 - 1,       C_BYTE_LENGTH));
        else
          access_size_mask_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE - 1,             C_MAX_ADDR_WIDTH));
          access_stp_bits_cmb   <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          access_rest_max_cmb   <= std_logic_vector(to_unsigned(max_of(2**C_REST_WIDTH -   1, 0), C_REST_WIDTH));
          full_line_beats_cmb   <= std_logic_vector(to_unsigned(C_CURRENT_LINE_LENGTH*4 - 1,        C_BYTE_LENGTH));
        end if;
    end case;
  end process Gen_Size_Info;
  
  -- Generate aligned start address.
  aligned_addr_cmb        <= S_AXI_AADDR_I and not access_size_mask_cmb;
  
  -- Mask out bits that are offset in the cache line.
  masked_addr_cmb         <= S_AXI_AADDR_I and C_CACHELINE_MASK;
  
  -- Beats fitting a Cache Line with current transaction size.
  Gen_Transaction_Len_Pre: process (masked_addr_cmb) is
  begin  -- process Gen_Transaction_Len_Pre
    wrap_end_beats_vec(0) <= masked_addr_cmb(7 downto 0);
    if( C_S_AXI_DATA_WIDTH >= 16 ) then
      wrap_end_beats_vec(1) <= masked_addr_cmb(8 downto 1);
    else
      wrap_end_beats_vec(1) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 32 ) then
      wrap_end_beats_vec(2) <= masked_addr_cmb(9 downto 2);
    else
      wrap_end_beats_vec(2) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 64 ) then
      wrap_end_beats_vec(3) <= masked_addr_cmb(10 downto 3);
    else
      wrap_end_beats_vec(3) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 128 ) then
      wrap_end_beats_vec(4) <= masked_addr_cmb(11 downto 4);
    else
      wrap_end_beats_vec(4) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 256 ) then
      wrap_end_beats_vec(5) <= masked_addr_cmb(12 downto 5);
    else
      wrap_end_beats_vec(5) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 512 ) then
      wrap_end_beats_vec(6) <= masked_addr_cmb(13 downto 6);
    else
      wrap_end_beats_vec(6) <= masked_addr_cmb(7 downto 0);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 1024 ) then
      wrap_end_beats_vec(7) <= masked_addr_cmb(14 downto 7);
    else
      wrap_end_beats_vec(7) <= masked_addr_cmb(7 downto 0);
    end if;
  end process Gen_Transaction_Len_Pre;
  wrap_end_beats_cmb  <= wrap_end_beats_vec(to_integer(unsigned(S_AXI_ASIZE(C_SIZE_MUX_POS))));
  
  Pre_Decode : process (ACLK) is
  begin  -- process Pre_Decode
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET = '1' ) then             -- synchronous reset (active high)
        access_is_incr        <= '1';
        access_is_wrap        <= '0';
        access_byte_len       <= (others=>'0');
        access_stp_bits       <= (others=>'0');
        access_rest_max       <= (others=>'0');
        aligned_addr          <= (others=>'0');
        full_line_beats       <= (others=>'0');
        wrap_end_beats        <= (others=>'0');
        allowed_max_wrap_len  <= (others=>'0');
        
      elsif( S_AXI_AREADY_I = '1' ) then
        access_is_incr        <= access_is_incr_cmb;
        access_is_wrap        <= access_is_wrap_cmb;
        access_byte_len       <= access_byte_len_cmb;
        access_stp_bits       <= access_stp_bits_cmb;
        access_rest_max       <= access_rest_max_cmb;
        aligned_addr          <= aligned_addr_cmb;
        full_line_beats       <= full_line_beats_cmb;
        wrap_end_beats        <= wrap_end_beats_cmb;
        allowed_max_wrap_len  <= allowed_max_wrap_len_cmb;
        
      end if;
    end if;
  end process Pre_Decode;
  
  
  -----------------------------------------------------------------------------
  -- Decode Transaction Information
  -- 
  -- The static information from the buffered command is decoded, this is then
  -- used to handle the transaction so that it can be forwarded through
  -- the internal interfaces to the affected parts.
  -- 
  -- Transactions can be forwarded either as one part or multiple depending
  -- on the transaction.
  -- 
  -- Much of the decoding has been moved to the dedicated length calculation
  -- module for timing purposes.
  -----------------------------------------------------------------------------
  
  -- Determine if Exclusive access fails because it passes cacheline boundaries.
--  exclusive_too_long  <= S_AXI_ALOCK_q and ( access_cross_line or not access_fit_sys_line );
  FE_Gen_Excl_And_Inst1: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => access_cross_line,
      A         => S_AXI_ALOCK_q,
      Carry_OUT => exclusive_too_long
    );
    
  -- Determine if Exclusive access must be killed or not.
--  exclusive_not_killed <= S_AXI_ALOCK_q and not exclusive_too_long;
  FE_Gen_Excl_Latch_And_Inst1: carry_latch_and
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => true
    )
    port map(
      Carry_IN  => exclusive_too_long,
      A         => S_AXI_ALOCK_q,
      O         => exclusive_not_killed,
      Carry_OUT => exclusive_too_long_i
    );
  
  -- Beats fitting a Cache Line with current transaction size.
  Gen_Transaction_Len: process (S_AXI_AADDR_q, access_byte_len) is
  begin  -- process Gen_Transaction_Len
    adjusted_addr_vec(0)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(0)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(1)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(1)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(2)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(2)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(3)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(3)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(4)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(4)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(5)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(5)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(6)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(6)  <= access_byte_len(7 downto 0);
    adjusted_addr_vec(7)    <=   S_AXI_AADDR_q(7 downto 0);
    wrap_split_mask_vec(7)  <= access_byte_len(7 downto 0);
    if( C_S_AXI_DATA_WIDTH >= 16 ) then
      adjusted_addr_vec(1)    <=   S_AXI_AADDR_q( 8 downto 1);
      wrap_split_mask_vec(1)  <= access_byte_len( 8 downto 1);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 32 ) then
      adjusted_addr_vec(2)    <=   S_AXI_AADDR_q( 9 downto 2);
      wrap_split_mask_vec(2)  <= access_byte_len( 9 downto 2);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 64 ) then
      adjusted_addr_vec(3)    <=   S_AXI_AADDR_q(10 downto 3);
      wrap_split_mask_vec(3)  <= access_byte_len(10 downto 3);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 128 ) then
      adjusted_addr_vec(4)    <=   S_AXI_AADDR_q(11 downto 4);
      wrap_split_mask_vec(4)  <= access_byte_len(11 downto 4);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 256 ) then
      adjusted_addr_vec(5)    <=   S_AXI_AADDR_q(12 downto 5);
      wrap_split_mask_vec(5)  <= access_byte_len(12 downto 5);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 512 ) then
      adjusted_addr_vec(6)    <=   S_AXI_AADDR_q(13 downto 6);
      wrap_split_mask_vec(6)  <= access_byte_len(13 downto 6);
    end if;
    if( C_S_AXI_DATA_WIDTH >= 1024 ) then
      adjusted_addr_vec(7)    <=   S_AXI_AADDR_q(14 downto 7);
      wrap_split_mask_vec(7)  <= access_byte_len(14 downto 7);
    end if;
  end process Gen_Transaction_Len;
  adjusted_addr     <= adjusted_addr_vec(to_integer(unsigned(S_AXI_ASIZE_q(C_SIZE_MUX_POS))));
  wrap_split_mask   <= wrap_split_mask_vec(to_integer(unsigned(S_AXI_ASIZE_q(C_SIZE_MUX_POS))));
  wrap_split_beats  <= adjusted_addr and wrap_split_mask;
  
  -- Generate use.
  access_use_bits <= access_byte_len(C_ADDR_BYTE_POS);
    
  
  -----------------------------------------------------------------------------
  -- Handle Internal Transactions
  -- 
  -- Depending on the transaction properties it might need to be manipulated,
  -- split into multiple peices or otherwise changed.
  -- 
  -- Transactions that cross Cache Line boundaries has to be split into 
  -- multiple pieces.
  -- An exclisive transaction cannot be split because it could lead to 
  -- inconsistencies (some parts fail others succeds).
  -- 
  -- Actions depending on burst type:
  -- Fix  - Always flows through untouched (same address, so it can never 
  --        cross cache line boundaries). Fix can appear with length 1-256.
  -- Incr - Never changes type but must be split when crossing a cache line
  --        boundary. Incr can appear with length 1-256.
  -- Wrap - Wrap transactions that cover more than an Lx cacheline has to be 
  --        split into at least two pieces, depending on the length. Otherwise
  --        it can pass untouched. Wrap an appear with length 2-16.
  -----------------------------------------------------------------------------
  
  -- Select transaction address.
  Gen_Addr: process (first_part, S_AXI_AADDR_q, access_is_wrap, sequential_addr, access_byte_len) is
    variable port_access_addr_i       : AXI_ADDR_TYPE;
  begin  -- process Gen_Addr
    port_access_addr_i  := S_AXI_AADDR_q;
    
    if( first_part = '0' ) then
      if( access_is_wrap = '1' ) then
        -- Insert line bits that are covered by the calculated byte length
        for I in access_byte_len'range loop
          if( access_byte_len(I) = '1' ) then
            port_access_addr_i(I)  := sequential_addr(I);
          end if;
        end loop;
        
      else
        -- Incr will use the complete new address
        port_access_addr_i  := sequential_addr;
        
        -- New address will always be on a cacheline boundary.
        port_access_addr_i(C_ADDR_OFFSET_POS) := (others=>'0');
      end if;
    end if;
    
    -- Fix unaffected bits.
    port_access_addr                      <= (others=>'0');
    port_access_addr(C_ADDR_PAGE_NUM_POS) <= S_AXI_AADDR_q(C_ADDR_PAGE_NUM_POS);
    port_access_addr(C_ADDR_PAGE_POS)     <= port_access_addr_i(C_ADDR_PAGE_POS);
    
  end process Gen_Addr;
  
  -- Generate Address step.
  Gen_Addr_Step: process (new_transaction) is
  begin  -- process Gen_Addr_Step
    -- Step by 4 * C_CURRENT_LINE_LENGTH when there is a new transaction.
    sequential_addr_step                                <= (others=>'0');
    sequential_addr_step(Log2(4 * C_CURRENT_LINE_LENGTH)) <= new_transaction;
  end process Gen_Addr_Step;
  
  -- Keep track of sequential address.
  Address_Handler : process (ACLK) is
  begin  -- process Address_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        sequential_addr_i <= (others=>'0');
      elsif( arbiter_piperun = '1' ) then
        -- Calculate next cache line.
        sequential_addr_i <= std_logic_vector(unsigned(port_access_addr) + unsigned(sequential_addr_step));
        
        -- Lower bits are never used.
        sequential_addr_i(C_ADDR_OFFSET_POS) <= (others=>'0');
      end if;
    end if;
  end process Address_Handler;
  
  -- Fix unaffected bits.
  sequential_addr(C_ADDR_PAGE_NUM_POS)  <= S_AXI_AADDR_q(C_ADDR_PAGE_NUM_POS);
  sequential_addr(C_ADDR_PAGE_POS)      <= sequential_addr_i(C_ADDR_PAGE_POS);
  
  -- Help signal for scaling.
  extended_port_access_len  <= "0000000" & port_access_len;
  
  -- Scale port length and size to internal size.
  Scale_Transaction: process (port_access_q.Size, extended_port_access_len) is
  begin  -- process Scale_Transaction
    case port_access_q.Size is
      when C_BYTE_SIZE          =>
        scaled_port_access_len                          <= extended_port_access_len(C_BYTE_RATIO_POS);
        provided_port_len                               <= extended_port_access_len(C_AXI_LENGTH_POS);
        provided_port_len(C_BYTE_SCALE_POS)             <= (others=>'1');
        
      when C_HALF_WORD_SIZE     =>
        if( C_CURRENT_DATA_WIDTH >= 16 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_HALF_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_HALF_WORD_SCALE_POS)      <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when C_WORD_SIZE          =>
        if( C_CURRENT_DATA_WIDTH >= 32 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_WORD_SCALE_POS)           <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when C_DOUBLE_WORD_SIZE   =>
        if( C_CURRENT_DATA_WIDTH >= 64 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_DOUBLE_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DOUBLE_WORD_SCALE_POS)    <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when C_QUAD_WORD_SIZE     =>
        if( C_CURRENT_DATA_WIDTH >= 128 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_QUAD_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_QUAD_WORD_SCALE_POS)      <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when C_OCTA_WORD_SIZE     =>
        if( C_CURRENT_DATA_WIDTH >= 256 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_OCTA_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_OCTA_WORD_SCALE_POS)      <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when C_HEXADECA_WORD_SIZE =>
        if( C_CURRENT_DATA_WIDTH >= 512 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_HEXADECA_WORD_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_HEXADECA_WORD_SCALE_POS)  <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
      when others               =>
        if( C_CURRENT_DATA_WIDTH >= 1024 ) then
          scaled_port_access_len                        <= extended_port_access_len(C_TRIACONTADI_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_TRIACONTADI_SCALE_POS)    <= (others=>'1');
        else
          scaled_port_access_len                        <= extended_port_access_len(C_DEFAULT_RATIO_POS);
          provided_port_len                             <= extended_port_access_len(C_AXI_LENGTH_POS);
          provided_port_len(C_DEFAULT_SCALE_POS)        <= (others=>'1');
        end if;
        
    end case;
  end process Scale_Transaction;
  
  -- Select transaction address.
  port_access_kind  <= C_KIND_WRAP when wrap_fit_lx_line = '1' else 
                       C_KIND_INCR;
  
  -- Get current ready signal (specialized handling for read and write).
--  port_ready        <= ( wr_port_ready or exclusive_too_long ) when ( C_IS_READ = 0 ) else rd_port_ready;
  Use_Write_Ready: if( C_IS_READ = 0 ) generate
  begin
    FE_Gen_Ready_And_Inst1: carry_or
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => exclusive_too_long_i,
        A         => wr_port_ready,
        Carry_OUT => port_ready
      );
  end generate Use_Write_Ready;
  Use_Read_Ready: if( C_IS_READ /= 0 ) generate
  begin
    port_ready        <= rd_port_ready;
  end generate Use_Read_Ready;
  
  -- Determine if new data really can fit in Arb Slot.
  port_ready_safe <= port_ready and arbiter_allowed;
  
  
  -----------------------------------------------------------------------------
  -- Optimized Length Counter
  -----------------------------------------------------------------------------
  
  Len_Gen_Inst: sc_s_axi_length_generation
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      
      -- AXI4 Interface Specific.
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH,
      
      -- System Cache Specific.
      C_CACHE_LINE_LENGTH       => C_CURRENT_LINE_LENGTH,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      
      -- Data type and settings specific.
      C_ADDR_LENGTH_HI          => C_ADDR_LENGTH_HI,
      C_ADDR_LENGTH_LO          => C_ADDR_LENGTH_LO,
      C_ADDR_LINE_HI            => C_ADDR_LINE_HI,
      C_ADDR_LINE_LO            => C_ADDR_LINE_LO,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_HI,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_LO,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_HI,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_LO
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
      
      
      -- ---------------------------------------------------
      -- Input Signals.
      
      arbiter_piperun           => arbiter_piperun,
      new_transaction           => new_transaction,
      first_part                => first_part,
      access_is_incr            => access_is_incr,
      access_is_wrap            => access_is_wrap,
      access_byte_len           => access_byte_len,
      aligned_addr              => aligned_addr,
      allowed_max_wrap_len      => allowed_max_wrap_len,
      full_line_beats           => full_line_beats,
      wrap_end_beats            => wrap_end_beats,
      adjusted_addr             => adjusted_addr,
      wrap_split_mask           => wrap_split_mask,
      provided_port_len         => provided_port_len,
      S_AXI_ALEN_q              => S_AXI_ALEN_q,
      S_AXI_AADDR_q             => S_AXI_AADDR_q(C_S_AXI_ADDR_WIDTH-1 downto 0),
      
      
      -- ---------------------------------------------------
      -- Output Signals.
      
      fit_lx_line               => fit_lx_line,
      wrap_is_aligned           => wrap_is_aligned,
      access_must_split         => access_must_split,
      transaction_start_beats   => transaction_start_beats,
      remaining_length          => remaining_length,
      wrap_fit_lx_line          => wrap_fit_lx_line,
      access_cross_line         => access_cross_line,
      wrap_must_split           => wrap_must_split,
      access_fit_sys_line       => access_fit_sys_line,
      req_last                  => req_last,
      transaction_done          => transaction_done,
      port_access_len           => port_access_len,
      incr_need_extra           => incr_need_extra,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => open
    );
  
  
  -----------------------------------------------------------------------------
  -- Move Information to Next Stage
  --
  -- Most registers are instantiated by special registers for timing purposes.
  -----------------------------------------------------------------------------
  
  port_access_valid_i <= '1' when ( C_IS_READ = 1 ) else not exclusive_too_long_i;
  
  Port_Valid_Inst: bit_reg_ce_kill
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      KILL      => port_ready_safe,
      CE        => transaction_and_piperun,
      D         => port_access_valid_i,
      Q         => port_access_valid
    );
    
  queue_done_cmb  <= not ( arbiter_piperun and new_transaction );
        
  Done_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '1',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => "1",
      D         => queue_done_cmb,
      Q         => queue_done
    );
    
  
  transaction_and_piperun <= new_transaction & arbiter_piperun;
  
  Addr_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (AXI_ADDR_TYPE'range=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => AXI_ADDR_TYPE'length
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => port_access_addr,
      Q         => port_access_q.Addr
    );
    
  Kind_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => port_access_kind,
      Q         => port_access_q.Kind
    );
    
  Size_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (AXI_SIZE_TYPE'range=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => AXI_SIZE_TYPE'length
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => S_AXI_ASIZE_q,
      Q         => port_access_q.Size
    );
    
  
  Use_Exclusive: if( C_S_AXI_PROHIBIT_EXCLUSIVE = 0 ) generate
  begin
    Exclusive_Inst: bit_reg_ce
      generic map(
        C_TARGET  => C_TARGET,
        C_IS_SET  => '0',
        C_CE_LOW  => (1 downto 0=>'0'),
        C_NUM_CE  => 2
      )
      port map(
        CLK       => ACLK,
        SR        => ARESET,
        CE        => transaction_and_piperun,
        D         => exclusive_not_killed,
        Q         => port_access_q.Exclusive
      );
  end generate Use_Exclusive;
  No_Exclusive: if( C_S_AXI_PROHIBIT_EXCLUSIVE /= 0 ) generate
  begin
    port_access_q.Exclusive <= '0';
  end generate No_Exclusive;
    
  allocate_raw    <= '1' when C_S_AXI_FORCE_ALLOCATE    /= 0 else
                     '0' when C_S_AXI_PROHIBIT_ALLOCATE /= 0 else
                     S_AXI_ACACHE_q(sel(C_IS_READ = 0, C_AWCACHE_WRITE_ALLOCATE_POS, C_ARCACHE_READ_ALLOCATE_POS));
  
  other_alloc_raw <= '1' when C_S_AXI_FORCE_OTHER_ALLOCATE    /= 0 else
                     '0' when C_S_AXI_PROHIBIT_OTHER_ALLOCATE /= 0 else
                     S_AXI_ACACHE_q(sel(C_IS_READ = 0, C_AWCACHE_OTHER_ALLOCATE_POS, C_ARCACHE_OTHER_ALLOCATE_POS));
  
  is_wt_q         <= ( allocate_raw or other_alloc_raw ) and
                     ( not bufferable_i                ) when is_mst_coherent(C_ENABLE_COHERENCY) else
                     '0';
  
  allocate_i      <= allocate_raw    and not is_wt_q;
  other_alloc     <= other_alloc_raw and not is_wt_q;
  
  Allocate_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => allocate_i,
      Q         => port_access_q.Allocate
    );
    
  Extra_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => incr_need_extra,
      Q         => incr_need_extra_q
    );
    
  Other_Allocate_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => other_alloc,
      Q         => port_access_q.Other_Allocate
    );
    
  bufferable_i  <= '1' when C_S_AXI_FORCE_BUFFER    /= 0 else
                   '0' when C_S_AXI_PROHIBIT_BUFFER /= 0 else
                   S_AXI_ACACHE_q(sel(C_IS_READ = 0, C_AWCACHE_BUFFERABLE_POS, C_ARCACHE_BUFFERABLE_POS));
  
  Bufferable_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => bufferable_i,
      Q         => port_access_q.Bufferable
    );
  
  modifiable_i  <= S_AXI_ACACHE_q(sel(C_IS_READ = 0, C_AWCACHE_MODIFIABLE_POS, C_ARCACHE_MODIFIABLE_POS));
  Modifiable_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => modifiable_i,
      Q         => port_access_q.Modifiable
    );
  

  Prot_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (AXI_PROT_TYPE'range=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => AXI_PROT_TYPE'length
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => S_AXI_APROT_q,
      Q         => port_access_q.Prot
    );
    
  Req_Last_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => req_last,
      Q         => req_last_q
    );
    
  Too_Long_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => exclusive_too_long_i,
      Q         => exclusive_too_long_q
    );
    
  Stp_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_ADDR_BYTE_POS=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => C_ADDR_BYTE_BITS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => access_stp_bits,
      Q         => access_stp_bits_q
    );
    
  access_use_bits_new <= access_use_bits or (C_ADDR_BYTE_POS=>access_is_incr);

  Use_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (C_ADDR_BYTE_POS=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => C_ADDR_BYTE_BITS
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => access_use_bits_new,
      Q         => access_use_bits_q
    );
    
  ID_Inst: reg_ce 
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => (S_AXI_AID_q'range=>'0'),
      C_CE_LOW  => (1 downto 0=>'0'),
      C_NUM_CE  => 2,
      C_SIZE    => C_S_AXI_ID_WIDTH
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => transaction_and_piperun,
      D         => S_AXI_AID_q,
      Q         => id_q
    );
    
  
  -----------------------------------------------------------------------------
  -- Create Write Transaction
  -- 
  -- There are 4 things needs to be performed when configured for 
  -- Address Write side:
  -- 
  --  * Extract and forward information that might be needed for W-Channel
  --    to manipulate data when necessary (WR interface).
  --  * Forward all transactions to B-Channel for Write Response manipulation.
  --  * Forward all transactions to the Cache on the internal interface.
  --  * Turn of all Read side interface signals (R and internal).
  -----------------------------------------------------------------------------
  
  Use_Write: if( C_IS_READ = 0 ) generate
  begin
    -- ----------------------------------------
    -- Internal Information
    
    port_exist_and_allowed <= S_AXI_AVALID_q and write_req_ready and wr_ready;
    
    FE_Gen_New_And_Inst1: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_ready,
        A         => port_access_valid,
        Carry_OUT => port_ready_with_valid
      );
    
    FE_Gen_New_Or_Inst1: carry_or_n
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_ready_with_valid,
        A_N       => port_access_valid,
        Carry_OUT => port_want_new_access
      );
    
    FE_Gen_New_And_Inst2: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_want_new_access,
        A         => port_exist_and_allowed,
        Carry_OUT => new_transaction
      );
    
    -- Assign output.
    Gen_Trans: process (port_access_q, port_access_valid, port_access_len, id_q) is
    begin  -- process Gen_Trans
      wr_port_access.ID             <= fit_vec(id_q, C_MAX_ID_WIDTH);
      wr_port_access.Addr           <= port_access_q.Addr;
      wr_port_access.Kind           <= port_access_q.Kind;
      wr_port_access.Size           <= port_access_q.Size;
      wr_port_access.Exclusive      <= port_access_q.Exclusive;
      wr_port_access.Allocate       <= port_access_q.Allocate;
      wr_port_access.Other_Allocate <= port_access_q.Other_Allocate;
      wr_port_access.Bufferable     <= port_access_q.Bufferable;
      wr_port_access.Modifiable     <= port_access_q.Modifiable;
      wr_port_access.Prot           <= port_access_q.Prot;
      
      -- Unused signals.
      wr_port_access.Snoop          <= C_AWSNOOP_WriteUnique;
      wr_port_access.Barrier        <= C_BAR_NORMAL_RESPECTING;
      wr_port_access.Domain         <= C_DOMAIN_INNER_SHAREABLE;
      
      -- Assign values that has been specially handled.
      wr_port_access.Valid          <= port_access_valid;
      wr_port_access.Len            <= port_access_len;
    end process Gen_Trans;
    
    
    -- ----------------------------------------
    -- W-Channel Information
    
    -- Handle data manipulation information.
    wr_valid    <= wr_valid_i;
    wr_valid_i  <= not queue_done;
    wr_last     <= req_last_q;
    wr_failed   <= exclusive_too_long_q;
    wr_offset   <= port_access_q.Addr(C_ADDR_BYTE_POS);
    wr_stp      <= access_stp_bits_q;
    wr_use      <= access_use_bits_q;
    wr_len      <= port_access_len;
    
    
    -- ----------------------------------------
    -- B-Channel Information
    
    write_req_valid   <= write_req_valid_i;
    write_req_valid_i <= not queue_done;
    write_req_ID      <= id_q;
    write_req_last    <= req_last_q;
    write_req_failed  <= exclusive_too_long_q;
    
    
    -- ----------------------------------------
    -- Unused port.
    
    read_req_valid            <= '0';
    read_req_valid_i          <= '0';
    read_req_ID               <= (others=>'0');
    read_req_last             <= '0';
    read_req_failed           <= '0';
    read_req_single_i         <= '0';
    read_req_rest_i           <= (others=>'0');
    read_req_rest_q           <= (others=>'0');
    read_req_offset           <= (others=>'0');
    read_req_stp              <= (others=>'0');
    read_req_use              <= (others=>'0');
    read_req_len              <= (others=>'0');
    rd_port_access            <= C_NULL_READ_PORT;
    
  end generate Use_Write;
  
  
  -----------------------------------------------------------------------------
  -- Create Read Transaction
  -- 
  -- There are 3 things needs to be performed when configured for 
  -- Address Read side:
  -- 
  --  * Forward all transactions to R-Channel for Read manipulation.
  --  * Forward all transactions to the Cache on the internal interface.
  --  * Turn of all Write side interface signals (WR, B and internal).
  -----------------------------------------------------------------------------
  
  Use_Read: if( C_IS_READ /= 0 ) generate
  begin
    -- ----------------------------------------
    -- Internal Information
    
    port_exist_and_allowed <= S_AXI_AVALID_q and read_req_ready;
    
    FE_Gen_New_And_Inst1: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_ready,
        A         => port_access_valid,
        Carry_OUT => port_ready_with_valid
      );
    
    FE_Gen_New_Or_Inst1: carry_or_n
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_ready_with_valid,
        A_N       => port_access_valid,
        Carry_OUT => port_want_new_access
      );
    
    FE_Gen_New_And_Inst2: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_want_new_access,
        A         => port_exist_and_allowed,
        Carry_OUT => new_transaction
      );
    
    -- Assign output.
    Gen_Trans: process (port_access_q, port_access_valid, port_access_len, scaled_port_access_len, incr_need_extra_q, 
                        id_q) is
    begin  -- process Gen_Trans
      rd_port_access.ID             <= fit_vec(id_q, C_MAX_ID_WIDTH);
      rd_port_access.Addr           <= port_access_q.Addr;
      rd_port_access.Kind           <= port_access_q.Kind;
      rd_port_access.Size           <= port_access_q.Size;
      rd_port_access.Exclusive      <= port_access_q.Exclusive;
      rd_port_access.Allocate       <= port_access_q.Allocate;
      rd_port_access.Other_Allocate <= port_access_q.Other_Allocate;
      rd_port_access.Bufferable     <= port_access_q.Bufferable;
      rd_port_access.Modifiable     <= port_access_q.Modifiable;
      rd_port_access.Prot           <= port_access_q.Prot;
      
      -- Unused signals.
      rd_port_access.Snoop          <= C_ARSNOOP_ReadOnce;
      rd_port_access.Barrier        <= C_BAR_NORMAL_RESPECTING;
      rd_port_access.Domain         <= C_DOMAIN_INNER_SHAREABLE;
      
      -- Assign values that has been specially handled.
      rd_port_access.Valid          <= port_access_valid;
      rd_port_access.Len            <= port_access_len;
      if( port_access_q.Allocate = '1' ) then
        if( incr_need_extra_q = '1' ) then
          rd_port_access.Len            <= std_logic_vector(unsigned(scaled_port_access_len) + 1);
        else
          rd_port_access.Len            <= scaled_port_access_len;
        end if;
        rd_port_access.Size           <= std_logic_vector(to_unsigned(Log2(C_CURRENT_DATA_WIDTH/8), 3));
      end if;
    end process Gen_Trans;
    
    
    -- ----------------------------------------
    -- R-Channel Information
    
    read_req_valid    <= read_req_valid_i;
    read_req_valid_i  <= not queue_done;
    read_req_ID       <= id_q;
    read_req_last     <= req_last_q;
    read_req_failed   <= exclusive_too_long_q;
    read_req_single_i <= '1' when ( ( port_access_q.Allocate = '0' ) ) else 
                         '0';
    read_req_offset   <= port_access_q.Addr(C_ADDR_BYTE_POS);
    read_req_stp      <= access_stp_bits_q;
    read_req_use      <= access_use_bits_q;
    read_req_len      <= port_access_len;
    
    Rem_Len_Handle : process (allocate_i, first_part, access_is_wrap, wrap_must_split, access_rest_max, 
                              S_AXI_AADDR_q, access_byte_len) is
    begin  -- process Rem_Len_Handle
      if( C_CURRENT_DATA_WIDTH > C_S_AXI_DATA_WIDTH ) and ( allocate_i = '0' ) then
        read_req_rest_i  <= (others=>'0');
      else
        if( first_part = '1' ) then
          if( ( access_is_wrap and not wrap_must_split ) = '1' ) then
            read_req_rest_i  <= access_byte_len(C_REST_POS) and access_rest_max;
          else
            read_req_rest_i  <= std_logic_vector(unsigned(access_rest_max) - 
                                unsigned(S_AXI_AADDR_q(C_REST_POS) and access_rest_max));
          end if;
        else
          read_req_rest_i  <= access_rest_max;
        end if;
      end if;
    end process Rem_Len_Handle;
    
    Rest_Inst: reg_ce 
      generic map(
        C_TARGET  => C_TARGET,
        C_IS_SET  => (C_REST_WIDTH - 1 downto 0=>'0'),
        C_CE_LOW  => (1 downto 0=>'0'),
        C_NUM_CE  => 2,
        C_SIZE    => C_REST_WIDTH
      )
      port map(
        CLK       => ACLK,
        SR        => ARESET,
        CE        => transaction_and_piperun,
        D         => read_req_rest_i,
        Q         => read_req_rest_q
      );
      
    
    -- ----------------------------------------
    -- Unused ports.
    
    wr_valid          <= '0';
    wr_valid_i        <= '0';
    wr_last           <= '0';
    wr_failed         <= '0';
    wr_offset         <= (others=>'0');
    wr_stp            <= (others=>'0');
    wr_use            <= (others=>'0');
    wr_len            <= (others=>'0');
    write_req_valid   <= '0';
    write_req_valid_i <= '0';
    write_req_ID      <= (others=>'0');
    write_req_last    <= '0';
    write_req_failed  <= '0';
    wr_port_access    <= C_NULL_WRITE_PORT;
    
  end generate Use_Read;
  
  -- Assign external.
  read_req_single <= read_req_single_i;
  read_req_rest   <= read_req_rest_q;
  
  
  -----------------------------------------------------------------------------
  -- Coherency Support
  -----------------------------------------------------------------------------
  
  No_Coherency: if( not is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
  end generate No_Coherency;
  
  Use_Coherency: if( is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
  end generate Use_Coherency;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_s_axi_gen_segments      <= C_NULL_STAT_POINT;
    
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal segment_update             : std_logic;
    signal segment_new                : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal segment_cnt                : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
  begin
    
    Trans_Handle : process (ACLK) is
    begin  -- process Trans_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          segment_update  <= '0';
          segment_new     <= (others=>'0');
          segment_cnt     <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
          
        else
          segment_update  <= '0';
          if( arbiter_piperun = '1' and new_transaction = '1' ) then
            if( req_last = '1' ) then
              segment_update  <= '1';
              segment_new     <= segment_cnt;
              segment_cnt     <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
            else
              segment_cnt     <= std_logic_vector(unsigned(segment_cnt) + 1);
            end if;
          end if;
        end if;
      end if;
    end process Trans_Handle;
    
    Segment_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => segment_update,
        counter                   => segment_new,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
      
        stat_data                 => stat_s_axi_gen_segments
      );
      
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_REST    : natural := min_of(5, C_REST_WIDTH);
    constant C_MY_BYTES   : natural := min_of(5, C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1);
    constant C_MY_LEN     : natural := min_of(8, C_LEN_WIDTH);
    constant C_MY_ID      : natural := min_of(4, C_S_AXI_ID_WIDTH);
    constant C_MY_ADDR    : natural := min_of(12, C_S_AXI_ADDR_WIDTH);
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          IF_DEBUG  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG      <= (others=>'0');
          
          -- AXI4/ACE Slave Interface Signals.
          IF_DEBUG(                              0) <= S_AXI_AVALID;
          IF_DEBUG(                              1) <= S_AXI_AREADY_I;
          
          if( C_IS_READ = 0 ) then
            -- Internal Interface Signals (Write data).
            IF_DEBUG(                             35) <= wr_valid_i;
            IF_DEBUG( 15 + C_MY_BYTES - 1 downto  15) <= port_access_q.Addr(C_MY_BYTES - 1 downto 0);  -- wr_offset
            IF_DEBUG( 20 + 3          - 1 downto  20) <= S_AXI_ASIZE_q;                           
            IF_DEBUG( 25 + C_MY_LEN   - 1 downto  25) <= port_access_len(C_MY_LEN - 1 downto 0);  -- wr_len
            IF_DEBUG(                             36) <= wr_ready;
            
            -- Write Response Information Interface Signals.
            IF_DEBUG(                              2) <= write_req_valid_i;
            IF_DEBUG(  3 + C_MY_ID    - 1 downto   3) <= id_q(C_MY_ID - 1 downto 0);        -- write_req_ID
            IF_DEBUG(                              7) <= req_last_q;                        -- write_req_last
            IF_DEBUG(                              8) <= exclusive_too_long_q;              -- write_req_failed
            IF_DEBUG(                             33) <= write_req_ready;
            
            -- Internal Interface Signals (Write request).
            IF_DEBUG(                             34) <= wr_port_ready;
          else
            -- Read Information Interface Signals.
            IF_DEBUG(                              2) <= read_req_valid_i;
            IF_DEBUG(  3 + C_MY_ID    - 1 downto   3) <= id_q(C_MY_ID - 1 downto 0);        -- read_req_ID
            IF_DEBUG(                              7) <= req_last_q;                        -- read_req_last
            IF_DEBUG(                              8) <= exclusive_too_long_q;              -- read_req_failed
            IF_DEBUG(                              9) <= read_req_single_i;
            IF_DEBUG( 10 + C_MY_REST  - 1 downto  10) <= read_req_rest_q(C_MY_REST - 1 downto 0);
            IF_DEBUG( 15 + C_MY_BYTES - 1 downto  15) <= port_access_q.Addr(C_MY_BYTES - 1 downto 0); 
                                                                                                      -- read_req_offset
            IF_DEBUG( 20 + C_MY_BYTES - 1 downto  20) <= access_stp_bits_q(C_MY_BYTES - 1 downto 0);  -- read_req_stp
            IF_DEBUG( 25 + C_MY_LEN   - 1 downto  25) <= port_access_len(C_MY_LEN - 1 downto 0);      -- read_req_len
            IF_DEBUG(                             33) <= read_req_ready;
            
            -- Internal Interface Signals (Read request).
            IF_DEBUG(                             34) <= rd_port_ready;
            IF_DEBUG(                             35) <= '0';
            IF_DEBUG(                             36) <= '0';
          end if;
          
          -- Buffer Incomming Transaction Information (AW, AR)
          IF_DEBUG(                             37) <= S_AXI_AVALID_q;
          IF_DEBUG(                             38) <= first_part;
          
          -- Decode Transaction Information
          IF_DEBUG(                             39) <= access_is_wrap;
          IF_DEBUG(                             40) <= fit_lx_line;
          IF_DEBUG(                             41) <= wrap_fit_lx_line;
          IF_DEBUG(                             42) <= wrap_is_aligned;
          IF_DEBUG(                             43) <= access_fit_sys_line;
          IF_DEBUG(                             44) <= access_cross_line;
          IF_DEBUG(                             45) <= exclusive_too_long_i;
          IF_DEBUG(                             46) <= wrap_must_split;
          IF_DEBUG(                             47) <= access_must_split;
          IF_DEBUG( 48 + C_MY_LEN   - 1 downto  48) <= wrap_end_beats(C_MY_LEN - 1 downto 0);
          IF_DEBUG( 56 + C_MY_LEN   - 1 downto  56) <= transaction_start_beats(C_MY_LEN - 1 downto 0);
          IF_DEBUG( 64 + C_MY_LEN   - 1 downto  64) <= S_AXI_ALEN_q(C_MY_LEN - 1 downto 0); 
                                                       -- wrap_tot_beats(C_MY_LEN - 1 downto 0);
          IF_DEBUG( 72 + C_MY_LEN   - 1 downto  72) <= wrap_split_beats(C_MY_LEN - 1 downto 0);
          IF_DEBUG( 80 + C_MY_ADDR  - 1 downto  80) <= access_byte_len(C_MY_ADDR - 1 downto 0);
          
          -- Handle Internal Transactions
          IF_DEBUG( 92 + C_MY_ADDR  - 1 downto  92) <= sequential_addr(C_MY_ADDR - 1 downto 0);
          IF_DEBUG(104 + C_MY_LEN   - 1 downto 104) <= (others=>'0'); -- remaining_length_new(C_MY_LEN - 1 downto 0);
          
          IF_DEBUG(                            104) <= port_access_valid;
          IF_DEBUG(                            105) <= port_exist_and_allowed;
          IF_DEBUG(                            106) <= '0';
          IF_DEBUG(                            107) <= '0';
          IF_DEBUG(                            108) <= '0';
          IF_DEBUG(                            109) <= '0';
          IF_DEBUG(                            110) <= port_ready_safe;
          IF_DEBUG(                            111) <= port_ready;
          
          IF_DEBUG(112 + C_MY_LEN   - 1 downto 112) <= remaining_length(C_MY_LEN - 1 downto 0);
          IF_DEBUG(                            120) <= port_access_kind;
          IF_DEBUG(                            121) <= new_transaction;
          IF_DEBUG(                            122) <= arbiter_piperun;
          IF_DEBUG(                            123) <= transaction_done;
          IF_DEBUG(                            124) <= port_ready;
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- None.
  
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_s_axi_w_channel.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_w_channel.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_w_channel.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-07-27    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_s_axi_w_channel is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- AXI4 Interface Specific.
    C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    
    -- Data type and settings specific.
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    
    -- System Cache Specific.
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Slave Interface Signals.
    
    -- W-Channel
    S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
    S_AXI_WLAST               : in  std_logic;
    S_AXI_WVALID              : in  std_logic;
    S_AXI_WREADY              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write data).
    
    wr_valid                  : in  std_logic;
    wr_last                   : in  std_logic;
    wr_failed                 : in  std_logic;
    wr_offset                 : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_stp                    : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_use                    : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
    wr_len                    : in  AXI_LENGTH_TYPE;
    wr_ready                  : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write Data).
    
    wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Synchronization).
    
    wc_valid                  : out std_logic;
    wc_ready                  : in  std_logic;
    
    write_fail_completed      : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_s_axi_wip            : out STAT_FIFO_TYPE;
    stat_s_axi_w              : out STAT_FIFO_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_w_channel;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_w_channel is

  
  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_WIP_QUEUE_ERROR           : natural :=  0;
  constant C_ASSERT_W_QUEUE_ERROR             : natural :=  1;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  2;
  
  
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  subtype BE_TYPE                     is std_logic_vector(C_S_AXI_DATA_WIDTH/8 - 1 downto 0);
  subtype DATA_TYPE                   is std_logic_vector(C_S_AXI_DATA_WIDTH - 1 downto 0);
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  -- Subtypes of the address from all points of view.
  
  -- Address related.
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  -- Subtypes for address parts.
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  type W_TYPE is record
    BE                : BE_TYPE;
    Data              : DATA_TYPE;
  end record W_TYPE;
  
  type WIP_TYPE is record
    Last              : std_logic;
    Failed            : std_logic;
    Offset            : ADDR_BYTE_TYPE;
    Stp_Bits          : ADDR_BYTE_TYPE;
    Use_Bits          : ADDR_BYTE_TYPE;
    Len               : AXI_LENGTH_TYPE;
  end record WIP_TYPE;
  
  -- Empty data structures.
  constant C_NULL_W                   : W_TYPE   := (BE=>(others=>'0'), Data=>(others=>'0'));
  constant C_NULL_WIP                 : WIP_TYPE := (Last=>'1', Failed=>'0', Offset=>(others=>'0'), 
                                                     Stp_Bits=>(others=>'0'), Use_Bits=>(others=>'0'), 
                                                     Len=>(others=>'0'));
  
  -- Types for information queue storage.
  type W_FIFO_MEM_TYPE            is array(QUEUE_ADDR_POS)      of W_TYPE;
  type WIP_FIFO_MEM_TYPE          is array(QUEUE_ADDR_POS)      of WIP_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component carry_compare_const is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIGNALS : natural := 1;
      C_SIZE   : natural;
      B_Vec    : std_logic_vector);
    port (
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In  : in  std_logic;
      Carry_Out : out std_logic);
  end component carry_compare_const;
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or_n;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Handle Transaction Information Queue
  
  signal wip_push                 : std_logic;
  signal wip_pop                  : std_logic;
  signal wip_refresh_reg          : std_logic;
  signal wip_exist                : std_logic;
  signal wip_read_fifo_addr       : QUEUE_ADDR_TYPE := (others=>'1');
  signal wip_fifo_mem             : WIP_FIFO_MEM_TYPE := (others=>C_NULL_WIP);
  signal wip_fifo_almost_full     : std_logic;
  signal wip_fifo_full            : std_logic;
  signal wip_last                 : std_logic;
  signal wip_failed               : std_logic;
  signal wip_offset               : ADDR_BYTE_TYPE;
  signal wip_stp_bits             : ADDR_BYTE_TYPE;
  signal wip_use_bits             : ADDR_BYTE_TYPE;
  signal wip_len                  : AXI_LENGTH_TYPE;
  signal wip_assert               : std_logic;
  signal wr_ready_i               : std_logic;
  
  
  -- ----------------------------------------
  -- Handle Length and Sequence Control
  
  signal first_wr_beat            : std_logic;
  signal first_wr_word            : std_logic;
  signal write_offset_cnt         : ADDR_BYTE_TYPE;
  signal len                      : AXI_LENGTH_TYPE;
  signal len_cnt                  : AXI_LENGTH_TYPE;
  signal last                     : std_logic;
  
  
  -- ----------------------------------------
  -- Write Queue Handling
  
  signal w_push                   : std_logic;
  signal w_push_safe              : std_logic;
  signal w_pop_part               : std_logic;
  signal w_pop                    : std_logic;
  signal w_pop_safe               : std_logic;
  signal w_fifo_full              : std_logic;
  signal w_fifo_empty             : std_logic;
  signal w_read_fifo_addr         : QUEUE_ADDR_TYPE;
  signal w_fifo_mem               : W_FIFO_MEM_TYPE; -- := (others=>C_NULL_W);
  signal w_valid                  : std_logic;
  signal w_be                     : BE_TYPE;
  signal w_data                   : DATA_TYPE;
  signal w_ready                  : std_logic;
  signal w_fail_ready             : std_logic;
  signal w_assert                 : std_logic;
  
  
  -- ----------------------------------------
  -- Write Complete tracking
  
  signal wc_push        : std_logic;
  signal wc_pop         : std_logic;
  signal wc_fifo_empty  : std_logic;
  
  
  -- ----------------------------------------
  -- Control W-Channel
  
  signal wr_port_data_valid_cmb   : std_logic;
  signal wr_port_data_valid_i     : std_logic;
  signal wr_port_data_be_i        : std_logic_vector(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
  signal wr_port_data_word_i      : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  signal write_next_offset        : ADDR_BYTE_TYPE;
  signal write_offset             : ADDR_BYTE_TYPE;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1             : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP

  
  -----------------------------------------------------------------------------
  -- Handle Transaction Information Queue
  --
  -- Write Information Port queue keeps track of all information that relates 
  -- to the transaction:
  --  * Last    - If this is the last segment of the original transaction.
  --  * Len     - Number of beats for this segment.
  --  * Failed  - If this is a failed transaction that has to be terminated
  --              instead of forwarded.
  --  * Size    - (optional) Size of transaction used for WSTRB generation
  --              when expanding data bus.
  --  * Offset  - (optional) Offset for first beat in a transaction that is 
  --              scaled up.
  -----------------------------------------------------------------------------
  
  -- Control signals for write information queue.
  wip_push        <= wr_valid and not wip_fifo_full;
--  wip_pop         <= w_pop_safe and last;
  WC_And_Inst4: carry_compare_const
    generic map(
      C_TARGET  => C_TARGET,
      C_SIGNALS => 3,
      C_SIZE    => 8,
      B_Vec     => (C_AXI_LENGTH_POS=>'0')
    )
    port map(
      Carry_In  => w_pop_safe,                -- [in  std_logic]
      A_Vec     => len,                       -- [in  std_logic_vector]
      Carry_Out => wip_pop                    -- [out std_logic]
    );
  
  FIFO_WIP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => true,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wip_push,
      queue_pop                 => wip_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => wip_refresh_reg,
      
      queue_almost_full         => wip_fifo_almost_full,
      queue_full                => wip_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => open,
      queue_exist               => wip_exist,
      queue_line_fit            => open,
      queue_index               => wip_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_wip,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => wip_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for WIP Channel FIFO.
  FIFO_WIP_Memory : process (ACLK) is
  begin  -- process FIFO_WIP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( wip_push = '1') then
        -- Insert new item.
        wip_fifo_mem(0).Last      <= wr_last;
        wip_fifo_mem(0).Failed    <= wr_failed;
        wip_fifo_mem(0).Len       <= wr_len;
        
        if( C_CACHE_DATA_WIDTH /= C_S_AXI_DATA_WIDTH ) then
          wip_fifo_mem(0).Offset    <= wr_offset;
          wip_fifo_mem(0).Stp_Bits  <= wr_stp;
          wip_fifo_mem(0).Use_Bits  <= wr_use;
        else
          wip_fifo_mem(0).Offset    <= (others=>'0');
          wip_fifo_mem(0).Stp_Bits  <= (others=>'0');
          wip_fifo_mem(0).Use_Bits  <= (others=>'0');
        end if;
        
        -- Shift FIFO contents.
        wip_fifo_mem(wip_fifo_mem'left downto 1) <= wip_fifo_mem(wip_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_WIP_Memory;
  
  -- Store WIP in register for good timing.
  WIP_Data_Registers : process (ACLK) is
  begin  -- process WIP_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        wip_last      <= C_NULL_WIP.Last;
        wip_failed    <= C_NULL_WIP.Failed;
        wip_offset    <= C_NULL_WIP.Offset;
        wip_stp_bits  <= C_NULL_WIP.Stp_Bits;
        wip_use_bits  <= C_NULL_WIP.Use_Bits;
        wip_len       <= C_NULL_WIP.Len;
      elsif( wip_refresh_reg = '1' ) then
        wip_last      <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Last;
        wip_failed    <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Failed;
        wip_offset    <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Offset;
        wip_stp_bits  <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Stp_Bits;
        wip_use_bits  <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Use_Bits;
        wip_len       <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Len;
      end if;
    end if;
  end process WIP_Data_Registers;
  
  -- Acknowledge new transaction information.
  wr_ready_i            <= ( not wip_fifo_full ) and ( not wip_fifo_almost_full );
  wr_ready              <= wr_ready_i;
  
  
  -----------------------------------------------------------------------------
  -- Handle Length and Sequence Control
  -- 
  -- Keep track of a segments of an burst of data. For a split burst new 
  -- WLAST has to be generated. Instead of merging original last with inserted
  -- ones, all WLAST are generated from the same mechanism.
  -----------------------------------------------------------------------------
  
  -- Select current length.
  len                   <= wip_len    when ( first_wr_word = '1' )          else len_cnt;
  
  -- Detect last word for this part.
  last                  <= '1'        when ( to_integer(unsigned(len))) = 0 else '0';
  
  -- Handle next offset that should be used.
  Write_Segment_Part_Handler : process (ACLK) is
  begin  -- process Write_Segment_Part_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        first_wr_beat     <= '1';
        first_wr_word     <= '1';
      else
        if ( wip_pop = '1' ) then
          first_wr_beat     <= wip_last;
          first_wr_word     <= '1';
        elsif ( w_pop_safe ) = '1' then
          first_wr_beat     <= '0';
          first_wr_word     <= '0';
        end if;
      end if;
    end if;
  end process Write_Segment_Part_Handler;
  
  Write_Segment_Cnt_Handler : process (ACLK) is
  begin  -- process Write_Segment_Cnt_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        write_offset_cnt  <= (others=>'0');
        len_cnt           <= (others=>'0');
      elsif ( w_pop_safe ) = '1' then
        write_offset_cnt  <= write_next_offset;
        len_cnt           <= std_logic_vector(unsigned(len) - 1);
      end if;
    end if;
  end process Write_Segment_Cnt_Handler;
  
  
  -----------------------------------------------------------------------------
  -- Write Queue Handling
  -----------------------------------------------------------------------------
  
  -- Control signals for read data queue.
  w_push          <= S_AXI_WVALID;
  w_push_safe     <= w_push and not w_fifo_full;
--  w_pop           <= ( w_ready or not wr_port_data_valid_i ) and wip_exist;
--  w_pop_safe      <= w_pop and not w_fifo_empty;
  WC_Or_Inst2: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_ready,
      A_N       => wr_port_data_valid_i,
      Carry_OUT => w_pop_part
    );
  WC_And_Inst2: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_pop_part,
      A         => wip_exist,
      Carry_OUT => w_pop
    );
  WC_And_Inst3: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_pop,
      A_N       => w_fifo_empty,
      Carry_OUT => w_pop_safe
    );
  
  FIFO_W_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => true,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => w_push,
      queue_pop                 => w_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => w_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => w_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => w_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_w,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => w_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for R Channel FIFO.
  FIFO_W_Memory : process (ACLK) is
  begin  -- process FIFO_W_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( w_push_safe = '1') then
        -- Insert new item.
        w_fifo_mem(0).BE    <= S_AXI_WSTRB;
        w_fifo_mem(0).Data  <= S_AXI_WDATA;
        
        -- Shift FIFO contents.
        w_fifo_mem(w_fifo_mem'left downto 1) <= w_fifo_mem(w_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_W_Memory;
  
  -- Forward ready.
  S_AXI_WREADY  <= not w_fifo_full;
  
  -- Rename signals.
  w_valid       <= not w_fifo_empty;
  w_be          <= w_fifo_mem(to_integer(unsigned(w_read_fifo_addr))).BE;
  w_data        <= w_fifo_mem(to_integer(unsigned(w_read_fifo_addr))).Data;
  
  
  -----------------------------------------------------------------------------
  -- Write Complete tracking
  -- 
  -- Queue level is always same or lower than BIP and that will prevent 
  -- this  queue from overrunning.
  -----------------------------------------------------------------------------
  
  wc_push <= wip_pop;
  wc_pop  <= wc_ready;
  
  FIFO_WC_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => false,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wc_push,
      queue_pop                 => wc_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => open,
      queue_almost_empty        => open,
      queue_empty               => wc_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => open,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => open,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  wc_valid  <= not wc_fifo_empty;
  
  
  -----------------------------------------------------------------------------
  -- Control W-Channel
  -- 
  -- Assign internal interface signals with data from the port. The data is 
  -- mirrored if the internal data is wider than external.
  -- New wider WSTRB is generated, if neccesary, for the new wider internal 
  -- data stream.
  -- 
  -- Failed (exclusive) data is terminated and never forwarded to the rest
  -- of the cache. The transaction information has already been stoped in AW.
  -----------------------------------------------------------------------------
  
  -- Simply forward Write data if internal width is same as interface.
  No_Write_Mirror: if( C_CACHE_DATA_WIDTH = C_S_AXI_DATA_WIDTH ) generate
  begin
    -- Just let data pass through untouched.
    wr_port_data_be_i   <= w_be;
    wr_port_data_word_i <= w_data;
    
    -- Not used for same width.
    write_next_offset <= (others=>'0');
    
  end generate No_Write_Mirror;
  
  -- Mirror Write data if internal width larger than interface.
  Use_Write_Mirror: if( C_CACHE_DATA_WIDTH /= C_S_AXI_DATA_WIDTH ) generate
    constant C_RATIO                : natural := C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH;
    subtype C_RATIO_POS             is natural range 0 to C_RATIO - 1;
    subtype RATIO_TYPE              is std_logic_vector(C_RATIO_POS);
    constant C_RATIO_BITS           : natural := Log2(C_RATIO);
    subtype C_RATIO_BITS_POS        is natural range C_ADDR_BYTE_HI downto C_ADDR_BYTE_HI - C_RATIO_BITS + 1;
    subtype RATIO_BITS_TYPE         is std_logic_vector(C_RATIO_BITS_POS);
    
  begin
    
    -- Select current offset.
    write_offset          <= wip_offset when ( first_wr_beat = '1' )          else write_offset_cnt;
    
    -- Generate next offset including wrap.
    Update_Offset_Select: process (write_offset, wip_stp_bits, wip_use_bits, wip_offset) is
      variable offset_cnt_next_cmb  : ADDR_BYTE_TYPE;
    begin  -- process Update_Offset_Select
      offset_cnt_next_cmb     := std_logic_vector(unsigned(write_offset) + unsigned(wip_stp_bits));
      
      for N in offset_cnt_next_cmb'range loop
        if( wip_use_bits(N) = '0' ) then
          write_next_offset(N)  <= wip_offset(N);
          
        else
          write_next_offset(N)  <= offset_cnt_next_cmb(N);
          
        end if;
      end loop;
    end process Update_Offset_Select;
    
    Gen_Write_Mirror: for N in 0 to C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH - 1 generate
    begin
      -- Generate mirrored data and steer byte enable.
      wr_port_data_be_i((N+1) * C_S_AXI_DATA_WIDTH / 8 - 1 downto N * C_S_AXI_DATA_WIDTH / 8) 
                          <= w_be when ( to_integer(unsigned(write_offset(C_RATIO_BITS_POS))) = N ) 
                             else (others=>'0');
      wr_port_data_word_i((N+1) * C_S_AXI_DATA_WIDTH - 1 downto N * C_S_AXI_DATA_WIDTH)       <= w_data;
      
    end generate Gen_Write_Mirror;
  end generate Use_Write_Mirror;
  
  Write_Data_Output_Valid : process (w_pop, w_valid, wip_exist, wip_failed, wr_port_data_ready, wr_port_data_valid_i) is
  begin  -- process Write_Data_Output_Valid
    if( w_pop = '1' ) then
      wr_port_data_valid_cmb  <= w_valid and wip_exist and not wip_failed;
    elsif( wr_port_data_ready(0) = '1' ) then
      wr_port_data_valid_cmb  <= '0';
    else
      wr_port_data_valid_cmb  <= wr_port_data_valid_i;
    end if;
  end process Write_Data_Output_Valid;
  
  Valid_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => ARESET,
      CE        => "1",
      D         => wr_port_data_valid_cmb,
      Q         => wr_port_data_valid_i
    );
    
  Write_Data_Output : process (ACLK) is
  begin  -- process Write_Data_Output
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        wr_port_data_info(0).Last <= '1';
        wr_port_data_info(0).BE   <= (C_MAX_DATA_WIDTH / 8 - 1 downto 0=>'0');
        wr_port_data_info(0).Data <= (C_MAX_DATA_WIDTH - 1 downto 0=>'0');
      elsif( w_pop = '1' ) then
        wr_port_data_info(0).Last <= last;
        wr_port_data_info(0).BE   <= fit_vec(wr_port_data_be_i, C_MAX_DATA_WIDTH / 8);
        wr_port_data_info(0).Data <= fit_vec(wr_port_data_word_i, C_MAX_DATA_WIDTH);
      end if;
    end if;
  end process Write_Data_Output;
  
  -- Assign output.
  wr_port_data_info(0).Valid  <= wr_port_data_valid_i;
  
  -- Forward ready.
--  w_ready           <= wr_port_data_ready or 
--                       ( wip_failed and wip_exist );
  WC_And_Inst1: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => wip_failed,
      A         => wip_exist,
      Carry_OUT => w_fail_ready
    );
  WC_Or_Inst1: carry_or 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_fail_ready,
      A         => wr_port_data_ready(0),
      Carry_OUT => w_ready
    );
  
  
  -----------------------------------------------------------------------------
  -- Synchronization
  --
  -- Syncronize with B-Channel that is waiting for the Write Data stream to be 
  -- terminated. Protocol requires all W data to be acknowledged before 
  -- B Response.
  -----------------------------------------------------------------------------
  
  Pipeline_Failed : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active true)
        write_fail_completed  <= '0';
      else
        write_fail_completed  <= wip_pop and wip_failed;
        
      end if;
    end if;
  end process Pipeline_Failed;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          IF_DEBUG  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG      <= (others=>'0');
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_WIP_QUEUE_ERROR)  <= wip_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_W_QUEUE_ERROR)    <= w_assert   when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_WIP_QUEUE_ERROR) /= '1' 
      report "AXI W Channel: Erroneous handling of WIP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_W_QUEUE_ERROR) /= '1' 
      report "AXI W Channel: Erroneous handling of W Queue, read from empty or push to full."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_s_axi_b_channel.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_b_channel.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_b_channel.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_s_axi_b_channel is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- System Cache Specific.
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    
    -- AXI4 Interface Specific.
    C_S_AXI_ID_WIDTH          : natural                       :=  1
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4/ACE Slave Interface Signals.
    
    -- B-Channel
    S_AXI_BRESP               : out std_logic_vector(1 downto 0);
    S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_BVALID              : out std_logic;
    S_AXI_BREADY              : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Write Response Information Interface Signals.
    
    write_req_valid           : in  std_logic;
    write_req_ID              : in  std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
    write_req_last            : in  std_logic;
    write_req_failed          : in  std_logic;
    write_req_ready           : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write request).
    
    wr_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Synchronization).
    
    write_fail_completed      : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write response).
    
    access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    wc_valid                  : in  std_logic;
    wc_ready                  : out std_logic;
    
    update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_s_axi_bip            : out STAT_FIFO_TYPE;
    stat_s_axi_bp             : out STAT_FIFO_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_b_channel;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_b_channel is
  

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_BIP_QUEUE_ERROR           : natural :=  0;
  constant C_ASSERT_BP_QUEUE_ERROR            : natural :=  1;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  2;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  

    
    
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  -- Types for AXI and port related signals (use S0 as reference, all has to be equal).
  subtype ID_TYPE                     is std_logic_vector(C_S_AXI_ID_WIDTH - 1 downto 0);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------

  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  type BP_TYPE is record
    Early             : std_logic;
  end record BP_TYPE;
  
  type BIP_TYPE is record
    Failed            : std_logic;
    Last              : std_logic;
    ID                : ID_TYPE;
  end record BIP_TYPE;
  
  -- Empty data structures.
  constant C_NULL_BP                  : BP_TYPE  := (Early=>'0');
  constant C_NULL_BIP                 : BIP_TYPE := (Failed=>'0', Last=>'0', ID=>(others=>'0'));
  
  -- Types for information queue storage.
  type BP_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of BP_TYPE;
  type BIP_FIFO_MEM_TYPE          is array(QUEUE_ADDR_POS)      of BIP_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Write Information Queue Handling
  
  signal bip_push                 : std_logic;
  signal bip_pop                  : std_logic;
  signal bip_read_fifo_addr       : QUEUE_ADDR_TYPE:= (others=>'1');
  signal bip_fifo_mem             : BIP_FIFO_MEM_TYPE; -- := (others=>C_NULL_BIP);
  signal bip_fifo_almost_full     : std_logic;
  signal bip_fifo_full            : std_logic;
  signal bip_fifo_empty           : std_logic;
  signal bip_last                 : std_logic;
  signal bip_failed               : std_logic;
  signal bip_id                   : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal bip_assert               : std_logic;
  
  
  -- ----------------------------------------
  -- Write Response Handling
  
  signal bp_pop                   : std_logic;
  signal bp_refresh_reg           : std_logic;
  signal bp_exist                 : std_logic;
  signal bp_valid_normal          : std_logic;
  signal bp_valid_failed          : std_logic;
  signal bp_valid                 : std_logic;
  signal bp_ready                 : std_logic;
  signal bp_read_fifo_addr        : QUEUE_ADDR_TYPE:= (others=>'1');
  signal bp_fifo_mem              : BP_FIFO_MEM_TYPE; -- := (others=>C_NULL_BP);
  signal bp_fifo_empty            : std_logic;
  signal bp_early                 : std_logic;
  signal bp_assert                : std_logic;
  
  
  -- ----------------------------------------
  -- Write Response Handling
  
  signal S_AXI_BVALID_I           : std_logic;
  signal S_AXI_BRESP_I            : std_logic_vector(1 downto 0);
  signal first_bresp              : std_logic;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Write Information Queue Handling
  -- 
  -- Push all control information needed into the queue to be able to do the 
  -- port specific modifications of the returned response.
  -----------------------------------------------------------------------------
  
  -- Control signals for read data queue.
  bip_push    <= write_req_valid and not bip_fifo_full;
  bip_pop     <= bp_ready and bp_valid;
  
  FIFO_BIP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => bip_push,
      queue_pop                 => bip_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => bip_fifo_almost_full,
      queue_full                => bip_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => bip_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => bip_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_bip,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bip_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for BIP Channel FIFO.
  FIFO_BIP_Memory : process (ACLK) is
  begin  -- process FIFO_BIP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( bip_push = '1') then
        -- Insert new item.
        bip_fifo_mem(0).ID      <= write_req_ID;
        bip_fifo_mem(0).Last    <= write_req_last;
        bip_fifo_mem(0).Failed  <= write_req_failed;
        
        -- Shift FIFO contents.
        bip_fifo_mem(bip_fifo_mem'left downto 1) <= bip_fifo_mem(bip_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BIP_Memory;
  
  -- Acknowledge new transaction information.
  write_req_ready       <= ( not bip_fifo_full ) and ( not bip_fifo_almost_full );
  
  -- Extract data.
  bip_last              <= bip_fifo_mem(to_integer(unsigned(bip_read_fifo_addr))).Last;
  bip_failed            <= bip_fifo_mem(to_integer(unsigned(bip_read_fifo_addr))).Failed;
  bip_id                <= bip_fifo_mem(to_integer(unsigned(bip_read_fifo_addr))).ID;
  
  -- Pull write complete when poping BIP.
  wc_ready              <= bip_pop;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Port Handling
  -- 
  -- Store Write Response Hit/Miss information with ID in a queue.
  -- 
  -- Hit are forwarded directly where as Miss has to wait for a BRESP from the 
  -- external memory.
  -----------------------------------------------------------------------------
  
  -- Generate control signals.
  bp_pop            <= bip_pop and not bip_failed;
  
  FIFO_BP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => access_bp_push(0).Valid,
      queue_pop                 => bp_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => bp_refresh_reg,
      
      queue_almost_full         => open,
      queue_full                => open,
      queue_almost_empty        => open,
      queue_empty               => bp_fifo_empty,
      queue_exist               => bp_exist,
      queue_line_fit            => open,
      queue_index               => bp_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_bp,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bp_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Miss FIFO.
  FIFO_BP_Memory : process (ACLK) is
  begin  -- process FIFO_BP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( access_bp_push(0).Valid = '1' ) then
        -- Insert new item.
        bp_fifo_mem(0).Early  <= access_bp_push(0).Early;
        
        -- Shift FIFO contents.
        bp_fifo_mem(bp_fifo_mem'left downto 1) <= bp_fifo_mem(bp_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BP_Memory;

  -- Store BP in register for good timing.
  BP_Data_Registers : process (ACLK) is
  begin  -- process BP_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        bp_early  <= C_NULL_BP.Early;
      elsif( bp_refresh_reg = '1' ) then
        -- Mux response on per port basis.
        bp_early  <= bp_fifo_mem(to_integer(unsigned(bp_read_fifo_addr))).Early;
      end if;
    end if;
  end process BP_Data_Registers;
  
  -- Generate valid for both hit and miss.
  bp_valid_normal       <= ( ( ( bp_early and wc_valid ) or (update_ext_bresp_info(0).Valid and not bp_early) ) and 
                             ( bp_exist ) );
  bp_valid_failed       <= ( bip_failed and write_fail_completed and not bip_fifo_empty );
  bp_valid              <= bp_valid_normal or bp_valid_failed;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Handling
  -- 
  -- Clock and hold the BRESP until it is acknowledged from AXI.
  -----------------------------------------------------------------------------
  
  Write_Response_Handler : process (ACLK) is
  begin  -- process Write_Response_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        first_bresp     <= '1';
        S_AXI_BVALID_I  <= '0';
        S_AXI_BRESP_I   <= (others=>'0');
        S_AXI_BID       <= (others=>'0');
      else
        -- Turn off when the data is acknowledged.
        if( bp_ready = '1' ) then
          S_AXI_BVALID_I  <= '0';
        end if;
        
        -- Start new when information is available.
        if( ( bp_valid and bp_ready ) = '1' ) then
          first_bresp     <= bip_last;
          S_AXI_BVALID_I  <= bip_last;
          S_AXI_BID       <= bip_id;
          if( first_bresp = '1' ) then
            if( bip_failed = '1' ) then
              S_AXI_BRESP_I   <= C_BRESP_OKAY;
            elsif( bp_early = '1' ) then
              S_AXI_BRESP_I   <= C_BRESP_OKAY;
            else
              S_AXI_BRESP_I   <= update_ext_bresp_info(0).BRESP;
            end if;
          elsif( bp_early = '0' ) then
            if( unsigned(update_ext_bresp_info(0).BRESP) > unsigned(S_AXI_BRESP_I) ) then
              S_AXI_BRESP_I   <= update_ext_bresp_info(0).BRESP;
            end if;
          end if;
        end if;
      end if;
    end if;
  end process Write_Response_Handler;
  
  -- Generate internal ready signal.
  bp_ready                  <= S_AXI_BREADY or not S_AXI_BVALID_I;
  
  -- Return ready when able to use miss BRESP.
  update_ext_bresp_ready(0) <= bp_ready and not bp_early and bp_exist;
  
  -- Rename the internal valid signal.
  S_AXI_BVALID              <= S_AXI_BVALID_I;
  S_AXI_BRESP               <= S_AXI_BRESP_I;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          IF_DEBUG  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG      <= (others=>'0');
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_BIP_QUEUE_ERROR)  <= bip_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_BP_QUEUE_ERROR)   <= bp_assert  when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BIP_QUEUE_ERROR) /= '1' 
      report "AXI B Channel: Erroneous handling of BIP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BP_QUEUE_ERROR) /= '1' 
      report "AXI B Channel: Erroneous handling of BP Queue, read from empty or push to full."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= assert_err;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_s_axi_r_channel.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_r_channel.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_r_channel.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_s_axi_r_channel is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- AXI4 Interface Specific.
    C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_S_AXI_ID_WIDTH          : natural                       :=  1;
    C_S_AXI_RRESP_WIDTH       : natural range  2 to    4      :=  2;
    
    -- Configuration.
    C_SUPPORT_SUBSIZED        : boolean                       := false;
    C_LEN_WIDTH               : natural range  0 to    8      :=  2;
    C_REST_WIDTH              : natural range  0 to    7      :=  2;
    
    -- Data type and settings specific.
    C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
    C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
    C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
    C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    
    -- Lx Cache Specific.
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    
    -- System Cache Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_NUM_WAYS                : natural range  1 to    8      :=  1;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_ENABLE_HAZARD_HANDLING  : natural range  0 to    1      :=  0;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4/ACE Slave Interface Signals.
    
    -- R-Channel
    S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH - 1 downto 0);
    S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH - 1 downto 0);
    S_AXI_RRESP               : out std_logic_vector(C_S_AXI_RRESP_WIDTH - 1 downto 0);
    S_AXI_RLAST               : out std_logic;
    S_AXI_RVALID              : out std_logic;
    S_AXI_RREADY              : in  std_logic;
    S_AXI_RACK                : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Read Information Interface Signals.
    
    read_req_valid            : in  std_logic;
    read_req_ID               : in  std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
    read_req_last             : in  std_logic;
    read_req_failed           : in  std_logic;
    read_req_single           : in  std_logic;
    read_req_dvm              : in  std_logic;
    read_req_addr             : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    read_req_rest             : in  std_logic_vector(C_REST_WIDTH - 1 downto 0);
    read_req_offset           : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_stp              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_use              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
    read_req_len              : in  std_logic_vector(C_LEN_WIDTH - 1  downto 0);
    read_req_ready            : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    rd_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
   
    -- ---------------------------------------------------
    -- Internal Interface Signals (Hazard).
    
    snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_set_read_hazard : in  std_logic;
    snoop_act_rst_read_hazard : in  std_logic;
    snoop_act_read_hazard     : in  std_logic;
    snoop_act_kill_locked     : in  std_logic;
    snoop_act_kill_by_snoop   : in  std_logic;
    snoop_act_kill_addr       : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    
    read_data_fetch_addr      : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    read_data_req_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    read_data_act_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    
    read_data_fetch_match     : out std_logic;
    read_data_req_match       : out std_logic;
    read_data_act_match       : out std_logic;
    read_data_ongoing         : out std_logic;
    read_data_block_nested    : out std_logic;
    read_data_release_block   : out std_logic;
    read_data_fetch_line_match: out std_logic;
    read_data_req_line_match  : out std_logic;
    read_data_act_line_match  : out std_logic;
    
    read_data_fud_we          : out std_logic;
    read_data_fud_addr        : out std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    read_data_fud_tag_valid   : out std_logic;
    read_data_fud_tag_unique  : out std_logic;
    read_data_fud_tag_dirty   : out std_logic;
    read_data_fud_tag_secure  : out std_logic;
    
    read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Snoop signals (Read Data & response).
    
    snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (Read Data).
    
    lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (Read Data).
    
    update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_s_axi_rip            : out STAT_FIFO_TYPE;
    stat_s_axi_r              : out STAT_FIFO_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_r_channel;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_r_channel is

  
  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_COLLIDING_DATA            : natural :=  0;
  constant C_ASSERT_RIP_QUEUE_ERROR           : natural :=  1;
  constant C_ASSERT_RI_QUEUE_ERROR            : natural :=  2;
  constant C_ASSERT_NO_RIP_INFO               : natural :=  3;
  constant C_ASSERT_NO_RI_INFO                : natural :=  4;
  constant C_ASSERT_RON_QUEUE_ERROR           : natural :=  5;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  6;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_MAX_PENDING_RACK         : natural             := 4;
    
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  -- Types for AXI and port related signals (use S0 as reference, all has to be equal).
  subtype ID_TYPE                     is std_logic_vector(C_S_AXI_ID_WIDTH - 1 downto 0);
  subtype RRESP_TYPE                  is std_logic_vector(C_S_AXI_RRESP_WIDTH - 1 downto 0);
  subtype CACHE_DATA_TYPE             is std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  subtype DATA_TYPE                   is std_logic_vector(C_S_AXI_DATA_WIDTH - 1 downto 0);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------

  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  -- Subtypes of the address from all points of view.
  
  -- Address related.
  subtype C_Lx_ADDR_DIRECT_POS        is natural range C_Lx_ADDR_DIRECT_HI  downto C_Lx_ADDR_DIRECT_LO;
  subtype C_Lx_ADDR_LINE_POS          is natural range C_Lx_ADDR_LINE_HI          downto C_Lx_ADDR_LINE_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  -- Subtypes for address parts.
  subtype Lx_ADDR_DIRECT_TYPE         is std_logic_vector(C_Lx_ADDR_DIRECT_POS);
  subtype Lx_ADDR_LINE_TYPE           is std_logic_vector(C_Lx_ADDR_LINE_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  -- Set related.
  subtype C_WAY_POS                   is natural range C_NUM_WAYS - 1 downto 0;
  
  subtype WAY_TYPE                    is std_logic_vector(C_WAY_POS);
  
  type SET_CACHE_DATA_TYPE            is array(C_WAY_POS) of CACHE_DATA_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  -- Types for Queue Length.
  constant C_DATA_QUEUE_LINE_LENGTH   : integer := ( 32 * C_Lx_CACHE_LINE_LENGTH / C_CACHE_DATA_WIDTH );
  constant C_DATA_QUEUE_LENGTH        : integer := max_of(16, 2 * ( 1 + is_slv_coherent(C_ENABLE_COHERENCY) ) * C_DATA_QUEUE_LINE_LENGTH);
  constant C_DATA_QUEUE_LENGTH_BITS   : integer := log2(C_DATA_QUEUE_LENGTH);

  constant C_LINE_LENGTH              : integer := max_of(1, C_DATA_QUEUE_LINE_LENGTH / 4);
  
  subtype RON_ADDR_POS                is natural range C_MAX_PENDING_RACK - 1 downto 0;
  subtype RON_ADDR_TYPE               is std_logic_vector(Log2(C_MAX_PENDING_RACK) - 1 downto 0);
  
  subtype DATA_QUEUE_ADDR_POS         is natural range C_DATA_QUEUE_LENGTH - 1 downto 0;
  subtype DATA_QUEUE_ADDR_TYPE        is std_logic_vector(C_DATA_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_HIT_QUEUE_LENGTH         : integer := ( 3 - is_slv_coherent(C_ENABLE_COHERENCY) ) * C_DATA_QUEUE_LENGTH / 4;
  constant C_HIT_QUEUE_LENGTH_BITS    : integer := log2(C_HIT_QUEUE_LENGTH + is_slv_coherent(C_ENABLE_COHERENCY));
  subtype HIT_QUEUE_ADDR_POS          is natural range C_HIT_QUEUE_LENGTH - 1 downto 0;
  subtype HIT_QUEUE_ADDR_TYPE         is std_logic_vector(C_HIT_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_SNOOP_QUEUE_LENGTH       : integer := 1 * C_DATA_QUEUE_LENGTH / 4;
  constant C_SNOOP_QUEUE_LENGTH_BITS  : integer := log2(C_SNOOP_QUEUE_LENGTH);
  subtype SNOOP_QUEUE_ADDR_POS        is natural range C_SNOOP_QUEUE_LENGTH - 1 downto 0;
  subtype SNOOP_QUEUE_ADDR_TYPE       is std_logic_vector(C_SNOOP_QUEUE_LENGTH_BITS - 1 downto 0);
  
  constant C_MISS_QUEUE_LENGTH        : integer := 1 * C_DATA_QUEUE_LENGTH / 4;
  constant C_MISS_QUEUE_LENGTH_BITS   : integer := log2(C_MISS_QUEUE_LENGTH);
  subtype MISS_QUEUE_ADDR_POS         is natural range C_MISS_QUEUE_LENGTH - 1 downto 0;
  subtype MISS_QUEUE_ADDR_TYPE        is std_logic_vector(C_MISS_QUEUE_LENGTH_BITS - 1 downto 0);
  
  -- Levels for Hit counters.
  constant C_HIT_QUEUE_EMPTY          : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(0,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_HIT_QUEUE_ALMOST_EMPTY   : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(2,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_HIT_QUEUE_ALMOST_FULL    : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_HIT_QUEUE_LENGTH - 3,                  C_DATA_QUEUE_LENGTH_BITS));
  constant C_HIT_QUEUE_LINE_LEVEL_UP  : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_HIT_QUEUE_LENGTH - C_LINE_LENGTH - 2,  C_DATA_QUEUE_LENGTH_BITS));
  constant C_HIT_QUEUE_LINE_LEVEL_DN  : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_HIT_QUEUE_LENGTH - C_LINE_LENGTH + 1,  C_DATA_QUEUE_LENGTH_BITS));
  constant C_HIT_WRAP_LEVEL           : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_HIT_QUEUE_LENGTH - 1,                  C_DATA_QUEUE_LENGTH_BITS));
  
  -- Levels for Snoop counters.
  constant C_SNOOP_QUEUE_EMPTY         : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(0,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_SNOOP_QUEUE_ALMOST_EMPTY  : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(2,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_SNOOP_QUEUE_ALMOST_FULL   : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_SNOOP_QUEUE_LENGTH - 3,                C_DATA_QUEUE_LENGTH_BITS));
  constant C_SNOOP_QUEUE_LINE_LEVEL_UP : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_SNOOP_QUEUE_LENGTH - C_LINE_LENGTH - 2,C_DATA_QUEUE_LENGTH_BITS));
  constant C_SNOOP_QUEUE_LINE_LEVEL_DN : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_SNOOP_QUEUE_LENGTH - C_LINE_LENGTH + 1,C_DATA_QUEUE_LENGTH_BITS));
  constant C_SNOOP_WRAP_LEVEL          : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - C_MISS_QUEUE_LENGTH - 1,
                                                                                            C_DATA_QUEUE_LENGTH_BITS));
  
  -- Levels for Miss counters.
  constant C_MISS_QUEUE_EMPTY         : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(0,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_MISS_QUEUE_ALMOST_EMPTY  : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(2,                                       C_DATA_QUEUE_LENGTH_BITS));
  constant C_MISS_QUEUE_ALMOST_FULL   : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_MISS_QUEUE_LENGTH - 3,                 C_DATA_QUEUE_LENGTH_BITS));
  constant C_MISS_QUEUE_LINE_LEVEL_UP : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_MISS_QUEUE_LENGTH - C_LINE_LENGTH - 2, C_DATA_QUEUE_LENGTH_BITS));
  constant C_MISS_QUEUE_LINE_LEVEL_DN : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_MISS_QUEUE_LENGTH - C_LINE_LENGTH + 1, C_DATA_QUEUE_LENGTH_BITS));
  constant C_MISS_WRAP_LEVEL          : DATA_QUEUE_ADDR_TYPE := 
                      std_logic_vector(to_unsigned(C_DATA_QUEUE_LENGTH - 1,                 C_DATA_QUEUE_LENGTH_BITS));
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Interface ratio.
  constant C_RATIO                    : natural := C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH;
  
  -- Local length.
  subtype C_LEN_POS                   is natural range C_LEN_WIDTH - 1 downto 0;
  subtype LEN_TYPE                    is std_logic_vector(C_LEN_POS);
  
  -- Local rest.
  subtype C_REST_POS                  is natural range C_REST_WIDTH - 1 downto 0;
  subtype REST_TYPE                   is std_logic_vector(C_REST_POS);
  
  -- RI response data.
  type RI_TYPE is record
    Hit               : std_logic;
    Snoop             : std_logic;
    Lx_Allocate       : std_logic;
  end record RI_TYPE;
  
  -- RON response data.
  type RON_TYPE is record
    Exclusive         : std_logic;
  end record RON_TYPE;
  
  -- R response data.
  type R_TYPE is record
    Last              : std_logic;
    Data              : CACHE_DATA_TYPE;
    Resp              : RRESP_TYPE;
  end record R_TYPE;
  
  -- RIP response information.
  type RIP_TYPE is record
    ID                : ID_TYPE;
    Last              : std_logic;
    Single            : std_logic;
    Rest              : REST_TYPE;
    Offset            : ADDR_BYTE_TYPE;
    Stp_Bits          : ADDR_BYTE_TYPE;
    Use_Bits          : ADDR_BYTE_TYPE;
    Len               : LEN_TYPE;
    DVM               : std_logic;
    Addr              : Lx_ADDR_DIRECT_TYPE;
  end record RIP_TYPE;
  
  -- RK data.
  type RK_TYPE is record
    Addr              : Lx_ADDR_LINE_TYPE;
  end record RK_TYPE;
  
  -- Empty data structures.
  constant C_NULL_RI                  : RI_TYPE  := (Hit=>'0', Snoop=>'0', Lx_Allocate=>'0');
  constant C_NULL_RON                 : RON_TYPE := (Exclusive=>'0');
  constant C_NULL_R                   : R_TYPE   := (Last=>'0', Data=>(others=>'0'), Resp=>(others=>'0'));
  constant C_NULL_RIP                 : RIP_TYPE := (ID=>(others=>'0'), Last=>'0', Single=>'0', Rest=>(others=>'0'), 
                                                     Offset=>(others=>'0'), Stp_Bits=>(others=>'0'), 
                                                     Use_Bits=>(others=>'0'), Len=>(others=>'0'), 
                                                     DVM=>'0', Addr=>(others=>'0'));
  constant C_NULL_RK                  : RK_TYPE  := (Addr=>(others=>'0'));
  
  -- Types for information queue storage.
  type RI_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of RI_TYPE;
  type RON_FIFO_MEM_TYPE          is array(RON_ADDR_POS)        of RON_TYPE;
  type R_FIFO_MEM_TYPE            is array(DATA_QUEUE_ADDR_POS) of R_TYPE;
  type RL_FIFO_MEM_TYPE           is array(DATA_QUEUE_ADDR_POS) of std_logic;
  type RW_FIFO_MEM_TYPE           is array(DATA_QUEUE_ADDR_POS) of CACHE_DATA_TYPE;
  type RR_FIFO_MEM_TYPE           is array(DATA_QUEUE_ADDR_POS) of RRESP_TYPE;
  type RIP_FIFO_MEM_TYPE          is array(QUEUE_ADDR_POS)      of RIP_TYPE;
  type RK_FIFO_MEM_TYPE           is array(QUEUE_ADDR_POS)      of RK_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_latch_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and;
  
  component carry_compare_const is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE;
      C_SIGNALS : natural := 1;
      C_SIZE   : natural;
      B_Vec    : std_logic_vector);
    port (
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_In  : in  std_logic;
      Carry_Out : out std_logic);
  end component carry_compare_const;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Prepare Lookup Read data
  
  signal lookup_data_word           : SET_CACHE_DATA_TYPE;
  signal lookup_read_data_word_i    : CACHE_DATA_TYPE;
  
  
  -- ----------------------------------------
  -- Read Hit/Miss Queue Handling
  
  signal ri_push                  : std_logic;
  signal ri_pop                   : std_logic;
  signal ri_exist                 : std_logic;
  signal ri_empty                 : std_logic;
  signal ri_refresh_reg           : std_logic;
  signal ri_read_fifo_addr        : QUEUE_ADDR_TYPE:= (others=>'1');
  signal ri_fifo_mem              : RI_FIFO_MEM_TYPE; -- := (others=>C_NULL_RI);
  signal next_ri_hit              : std_logic;
  signal next_ri_snoop            : std_logic;
  signal next_ri_lx_allocate      : std_logic;
  signal ri_hit                   : std_logic;
  signal ri_snoop                 : std_logic;
  signal ri_lx_allocate           : std_logic;
  signal ri_assert                : std_logic;
  
  
  -- ----------------------------------------
  -- Read Queue Handling (Queue/Buffer)
  
  signal r_hit_push               : std_logic;
  signal r_snoop_push             : std_logic;
  signal r_miss_push              : std_logic;
  signal r_push_safe              : std_logic;
  signal r_push_safe_vec          : std_logic_vector(0 downto 0);
  signal r_info_exist             : std_logic;
  signal r_pop_valid              : std_logic;
  signal r_pop                    : std_logic;
  signal r_pop_snoop_not_empty    : std_logic;
  signal r_pop_miss_not_empty     : std_logic;
  signal r_hit_pop                : std_logic;
  signal r_snoop_pop              : std_logic;
  signal r_miss_pop               : std_logic;
  signal r_pop_sel_safe           : std_logic;
  signal r_pop_safe_i             : std_logic;
  signal r_pop_safe               : std_logic;
  signal r_hit_refresh            : std_logic;
  signal r_snoop_refresh          : std_logic;
  signal r_miss_refresh           : std_logic;
  signal r_fifo_mem               : R_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
  signal rl_fifo_mem              : RL_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
  signal rl_snoop_fifo_mem        : RL_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
  signal rw_fifo_mem              : RW_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
  signal rr_fifo_mem              : RR_FIFO_MEM_TYPE; -- := (others=>C_NULL_R);
  signal r_fifo_true_empty        : std_logic;
  signal r_fifo_empty             : std_logic;
  signal r_assert                 : std_logic;
  signal r_hit_last               : std_logic;
  signal r_snoop_last             : std_logic;
  signal r_miss_last              : std_logic;
  signal r_last                   : std_logic;
  signal r_data                   : CACHE_DATA_TYPE;
  signal r_rresp                  : RRESP_TYPE;
  
  signal new_read_data_last       : std_logic;
  signal new_read_data_word       : CACHE_DATA_TYPE;
  signal new_read_data_resp       : RRESP_TYPE;
  
  attribute ram_style             : string;
  attribute ram_style             of r_fifo_mem         : signal is "distributed";
  attribute ram_style             of rl_fifo_mem        : signal is "distributed";
  attribute ram_style             of rl_snoop_fifo_mem  : signal is "distributed";
  attribute ram_style             of rw_fifo_mem        : signal is "distributed";
  attribute ram_style             of rr_fifo_mem        : signal is "distributed";
  
  
  -- ----------------------------------------
  -- Read Queue Hazard Handling
  
  signal rd_on_push                 : std_logic;
  signal rd_on_pop                  : std_logic;
  signal ron_almost_full            : std_logic;
  signal ron_full                   : std_logic;
  signal ron_almost_empty           : std_logic;
  signal ron_empty                  : std_logic;
  signal ron_read_fifo_addr         : RON_ADDR_TYPE;
  signal ron_fifo_mem               : RON_FIFO_MEM_TYPE; -- := (others=>C_NULL_RON);
  signal ron_exclusive              : std_logic;
  signal rd_active_push             : std_logic;
  signal rd_active_pop              : std_logic;
  signal read_data_cnt_ongoing      : rinteger range 0 to C_MAX_PENDING_RACK - 1; 
  signal read_data_any_running      : std_logic;
  signal read_data_started          : std_logic;
  signal read_data_possible_nested  : std_logic;
  signal set_max_concurrent         : std_logic;
  signal read_data_max_concurrent   : std_logic;
  signal read_data_release_block_i  : std_logic;
  signal ron_assert                 : std_logic;
  
  
  -- ----------------------------------------
  -- Read Queue Handling (Pointer & Flags)
  
  signal r_hit_write_fifo_addr    : HIT_QUEUE_ADDR_TYPE   := (others=>'0');
  signal r_snoop_write_fifo_addr  : SNOOP_QUEUE_ADDR_TYPE := (others=>'0');
  signal r_miss_write_fifo_addr   : MISS_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_write_fifo_addr        : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_hit_read_fifo_addr     : HIT_QUEUE_ADDR_TYPE   := (others=>'0');
  signal r_snoop_read_fifo_addr   : SNOOP_QUEUE_ADDR_TYPE := (others=>'0');
  signal r_miss_read_fifo_addr    : MISS_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_snoop_full_fifo_addr   : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_miss_full_fifo_addr    : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_read_fifo_addr         : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  
  signal r_hit_fifo_len           : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_snoop_fifo_len         : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  signal r_miss_fifo_len          : DATA_QUEUE_ADDR_TYPE  := (others=>'0');
  
  signal r_hit_almost_full_cmb    : std_logic;
  signal r_hit_almost_empty_cmb   : std_logic;
  signal r_hit_line_fit_up_cmb    : std_logic;
  signal r_hit_line_fit_dn_cmb    : std_logic;
  signal r_snoop_almost_full_cmb  : std_logic;
  signal r_snoop_almost_empty_cmb : std_logic;
  signal r_snoop_line_fit_up_cmb  : std_logic;
  signal r_snoop_line_fit_dn_cmb  : std_logic;
  signal r_miss_almost_full_cmb   : std_logic;
  signal r_miss_almost_empty_cmb  : std_logic;
  signal r_miss_line_fit_up_cmb   : std_logic;
  signal r_miss_line_fit_dn_cmb   : std_logic;
  
  signal r_hit_fifo_almost_full   : std_logic;
  signal r_hit_fifo_full          : std_logic;
  signal r_hit_fifo_almost_empty  : std_logic;
  signal r_hit_fifo_empty         : std_logic;
  signal r_hit_line_fit           : std_logic;
  signal r_snoop_fifo_almost_full : std_logic;
  signal r_snoop_fifo_full        : std_logic;
  signal r_snoop_fifo_almost_empty: std_logic;
  signal r_snoop_fifo_empty       : std_logic;
  signal r_snoop_line_fit         : std_logic;
  signal r_miss_fifo_almost_full  : std_logic;
  signal r_miss_fifo_full         : std_logic;
  signal r_miss_fifo_almost_empty : std_logic;
  signal r_miss_fifo_empty        : std_logic;
  signal r_miss_line_fit          : std_logic;
  
  
  -- ----------------------------------------
  -- Read Information Queue Handling
  
  signal rip_push                 : std_logic;
  signal rip_push_safe            : std_logic;
  signal rip_pop                  : std_logic;
  signal rip_refresh_reg          : std_logic;
  signal rip_read_fifo_addr       : QUEUE_ADDR_TYPE:= (others=>'1');
  signal rip_fifo_mem             : RIP_FIFO_MEM_TYPE; -- := (others=>C_NULL_RIP);
  signal rip_fifo_almost_full     : std_logic;
  signal rip_fifo_full            : std_logic;
  signal rip_exist                : std_logic;
  signal rip_id                   : ID_TYPE;
  signal rip_last                 : std_logic;
  signal rip_offset               : ADDR_BYTE_TYPE;
  signal rip_stp                  : ADDR_BYTE_TYPE;
  signal rip_use                  : ADDR_BYTE_TYPE;
  signal rip_single               : std_logic;
  signal rip_dvm                  : std_logic;
  signal rip_addr                 : Lx_ADDR_DIRECT_TYPE;
  signal rip_assert               : std_logic;
  
  
  -- ----------------------------------------
  -- Read Port Handling
  
  signal S_AXI_RLAST_I            : std_logic;
  signal S_AXI_RDATA_I            : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
  signal rd_pop                   : std_logic;
  signal rd_done                  : std_logic;
  
  
  -- ----------------------------------------
  -- 
  
  signal rk_empty                 : std_logic;
  signal read_data_fetch_line_match_i : std_logic;
  signal read_data_req_line_match_i   : std_logic;
  signal read_data_act_line_match_i   : std_logic;
  signal read_data_fud_is_dead    : std_logic;
  
    
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Prepare Lookup Read data
  -----------------------------------------------------------------------------
  
  -- Split to local array.
  Gen_Set_Data_Array: for K in 0 to C_NUM_WAYS - 1 generate
  begin
    lookup_data_word(K) <= lookup_read_data_info(0).Data(K)(C_CACHE_DATA_WIDTH - 1 downto 0);
    
  end generate Gen_Set_Data_Array;
  
  -- Non-pipelined read data has to be MUXed.
  No_Rd_Pipeline: if( not C_PIPELINE_LU_READ_DATA ) generate
  begin
    lookup_read_data_word_i <= lookup_data_word(get_way(lookup_read_data_info(0).Way, C_NUM_WAYS));
    
  end generate No_Rd_Pipeline;
  
  -- Pipeline data can be ORed together, save resources and improves timing.
  Use_Rd_Pipeline: if( C_PIPELINE_LU_READ_DATA ) generate
  begin
    process(lookup_data_word) is
      variable lookup_read_data_word_ii : CACHE_DATA_TYPE;
    begin
      lookup_read_data_word_ii := (others=>'0');
      for K in 0 to C_NUM_WAYS - 1 loop
        lookup_read_data_word_ii := lookup_read_data_word_ii or lookup_data_word(K);
      end loop;
      
      lookup_read_data_word_i <= lookup_read_data_word_ii;
    end process;
    
  end generate Use_Rd_Pipeline;
  
  
  -----------------------------------------------------------------------------
  -- Read Hit/Miss Queue Handling
  -- 
  -- Push Hit/Miss information into queue to determine which portion that shall
  -- be use the next time.
  -- 
  -----------------------------------------------------------------------------
  
  -- Control signals for read info queue.
  ri_push         <= lookup_read_data_new(0).Valid;
  ri_pop          <= rip_pop;

  FIFO_RI_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => false,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => C_PIPELINE_LU_READ_DATA,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => ri_push,
      queue_pop                 => ri_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => ri_refresh_reg,
      
      queue_almost_full         => read_info_status(0).Almost_Full,
      queue_full                => read_info_status(0).Full,
      queue_almost_empty        => open,
      queue_empty               => ri_empty,
      queue_exist               => ri_exist,
      queue_line_fit            => open,
      queue_index               => ri_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => ri_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for RI Channel FIFO.
  FIFO_RI_Memory : process (ACLK) is
  begin  -- process FIFO_RI_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( ri_push = '1') then
        ri_fifo_mem(0).Hit          <= lookup_read_data_new(0).Hit;
        ri_fifo_mem(0).Snoop        <= lookup_read_data_new(0).Snoop;
        ri_fifo_mem(0).Lx_Allocate  <= lookup_read_data_new(0).Lx_Allocate;
        
        -- Shift FIFO contents.
        ri_fifo_mem(ri_fifo_mem'left downto 1) <= ri_fifo_mem(ri_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_RI_Memory;
  
  -- Get next transaction info.
  next_ri_hit         <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Hit;
  next_ri_snoop       <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Snoop;
  next_ri_lx_allocate <= ri_fifo_mem(to_integer(unsigned(ri_read_fifo_addr))).Lx_Allocate;
    
  -- Rename or pipeline signals.
  No_Rd_Ctrl_Pipeline: if( not C_PIPELINE_LU_READ_DATA ) generate
  begin
    ri_hit              <= next_ri_hit;
    ri_snoop            <= next_ri_snoop;
    ri_lx_allocate      <= next_ri_lx_allocate;
    
    -- Select current read address depending on what is available from RI Queue.
    r_read_fifo_addr      <=   r_hit_read_fifo_addr when ( ri_hit   = '1' ) else
                             r_snoop_full_fifo_addr when ( ri_snoop = '1' ) else
                              r_miss_full_fifo_addr;
    
  end generate No_Rd_Ctrl_Pipeline;
  Use_Rd_Ctrl_Pipeline: if( C_PIPELINE_LU_READ_DATA ) generate
    signal r_next_fifo_addr         : DATA_QUEUE_ADDR_TYPE:= (others=>'0');
  begin
    -- Store RI in register for good timing.
    RI_Data_Registers : process (ACLK) is
    begin  -- process RI_Data_Registers
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
          ri_hit          <= C_NULL_RI.Hit;
          ri_snoop        <= C_NULL_RI.Snoop;
          ri_lx_allocate  <= C_NULL_RI.Lx_Allocate;
          
        elsif( ri_refresh_reg = '1' ) then
          ri_hit          <= next_ri_hit;
          ri_snoop        <= next_ri_snoop;
          ri_lx_allocate  <= next_ri_lx_allocate;
          
        end if;
      end if;
    end process RI_Data_Registers;
    
    -- Select current read address depending on what is available from RI Queue.
    RI_Addr_Registers : process (ACLK) is
    begin  -- process RI_Addr_Registers
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
          r_read_fifo_addr  <= (others=>'0');
        else
          if( ri_refresh_reg = '1' ) then
            if( next_ri_hit = '1' ) then
              if( r_pop_safe = '1' and ri_hit = '1' ) then
                r_read_fifo_addr  <= r_next_fifo_addr;
              else
                r_read_fifo_addr  <= r_hit_read_fifo_addr;
              end if;
            elsif( next_ri_snoop = '1' ) then
              if( r_pop_safe = '1' and ri_snoop = '1' ) then
                r_read_fifo_addr  <= r_next_fifo_addr;
              else
                r_read_fifo_addr  <= r_snoop_full_fifo_addr;
              end if;
            else
              if( r_pop_safe = '1' and ri_hit = '0' and ri_snoop = '0' ) then
                r_read_fifo_addr  <= r_next_fifo_addr;
              else
                r_read_fifo_addr  <= r_miss_full_fifo_addr;
              end if;
            end if;
          elsif( r_pop_safe = '1' ) then
            r_read_fifo_addr  <= r_next_fifo_addr;
          end if;
        end if;
      end if;
    end process RI_Addr_Registers;
    
    -- Generate next counter value.
    process(r_read_fifo_addr, ri_hit, ri_snoop) is
    begin
      if( ri_hit = '1' ) then
        if( r_read_fifo_addr = C_HIT_WRAP_LEVEL ) then
          r_next_fifo_addr  <= (others=>'0');
        else
          r_next_fifo_addr  <= std_logic_vector(unsigned(r_read_fifo_addr) + 1);
        end if;
      elsif( ri_snoop = '1' ) then
        if( r_read_fifo_addr = C_SNOOP_WRAP_LEVEL ) then
          r_next_fifo_addr  <= (others=>'0');
          r_next_fifo_addr(r_next_fifo_addr'left downto r_next_fifo_addr'left-1)  <= "10";
        else
          r_next_fifo_addr  <= std_logic_vector(unsigned(r_read_fifo_addr) + 1);
        end if;
      else
        if( r_read_fifo_addr = C_MISS_WRAP_LEVEL ) then
          r_next_fifo_addr  <= (others=>'0');
          r_next_fifo_addr(r_next_fifo_addr'left downto r_next_fifo_addr'left-1)  <= "11";
        else
          r_next_fifo_addr  <= std_logic_vector(unsigned(r_read_fifo_addr) + 1);
        end if;
      end if;
    end process;
    
    
  end generate Use_Rd_Ctrl_Pipeline;
  
  
  -----------------------------------------------------------------------------
  -- Read Queue Handling (Queue/Buffer)
  -- 
  -- Push read data into the queue/buffer together with all control information 
  -- needed.
  -- 
  -- There are two possible data sources for the read data:
  --  * Lookup (read hit)
  --  * Update (read miss)
  -----------------------------------------------------------------------------
  
  -- Control signals for read data buffer.
  Use_RTL_1: if( C_TARGET = RTL or is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    r_hit_push      <= lookup_read_data_info(0).Valid and not   r_hit_fifo_full;
    r_miss_push     <= update_read_data_info(0).Valid and not  r_miss_fifo_full and 
                       not   r_hit_push;
    r_snoop_push    <= snoop_read_data_info(0).Valid  and not r_snoop_fifo_full and 
                       not   r_hit_push and 
                       not  r_miss_push;
    r_push_safe     <= r_hit_push or r_snoop_push or r_miss_push;
    
    r_hit_refresh   <=   r_hit_push xor   r_hit_pop;
    r_snoop_refresh <= r_snoop_push xor r_snoop_pop;
    r_miss_refresh  <=  r_miss_push xor  r_miss_pop;
    
  end generate Use_RTL_1;
  
  Use_FPGA_1: if( C_TARGET /= RTL and not is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    LUT_Hit_Inst: LUT6_2
      generic map(
        INIT => X"2222D22222222222"
      )
      port map(
        O5 => r_hit_push,                     -- [out std_logic]
        O6 => r_hit_refresh,                  -- [out std_logic]
        I0 => lookup_read_data_info(0).Valid, -- [in  std_logic]
        I1 => r_hit_fifo_full,                -- [in  std_logic]
        I2 => r_pop,                          -- [in  std_logic]
        I3 => ri_hit,                         -- [in  std_logic]
        I4 => r_hit_fifo_empty,               -- [in  std_logic]
        I5 => '1'                             -- [in  std_logic]
      );
      
    LUT_Refresh_Inst: LUT6_2
      generic map(
        INIT => X"0D000D00F2FF0D00"
      )
      port map(
        O5 => open,                           -- [out std_logic]
        O6 => r_miss_refresh,                 -- [out std_logic]
        I0 => lookup_read_data_info(0).Valid, -- [in  std_logic]
        I1 => r_hit_fifo_full,                -- [in  std_logic]
        I2 => r_miss_fifo_full,               -- [in  std_logic]
        I3 => update_read_data_info(0).Valid, -- [in  std_logic]
        I4 => r_pop_miss_not_empty,           -- [in  std_logic]
        I5 => ri_hit                          -- [in  std_logic]
      );
      
    LUT_Push_Inst: LUT6_2
      generic map(
        INIT => X"2F222F220D000D00"
      )
      port map(
        O5 => r_miss_push,                    -- [out std_logic]
        O6 => r_push_safe,                    -- [out std_logic]
        I0 => lookup_read_data_info(0).Valid, -- [in  std_logic]
        I1 => r_hit_fifo_full,                -- [in  std_logic]
        I2 => r_miss_fifo_full,               -- [in  std_logic]
        I3 => update_read_data_info(0).Valid, -- [in  std_logic]
        I4 => '0',                            -- [in  std_logic]
        I5 => '1'                             -- [in  std_logic]
      );
      
    -- Unused signals.
    r_snoop_push    <= '0';
    r_snoop_refresh <= '0';
    
  end generate Use_FPGA_1;
  
  r_push_safe_vec <= (others=>r_push_safe);
  
--  r_pop           <= ( S_AXI_RREADY and rd_done ) and ri_exist and rip_exist;
  r_info_exist  <= ri_exist and rip_exist and not snoop_act_read_hazard and not read_data_max_concurrent;
  RC_And_Inst3: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => rd_done,
      A         => r_info_exist,
      Carry_OUT => r_pop_valid
    );
  
  RC_And_Inst4: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => r_pop_valid,
      A         => S_AXI_RREADY,
      Carry_OUT => r_pop
    );
  
--  r_hit_pop       <= ( r_pop and     ri_hit                  ) and not   r_hit_fifo_empty;
--  r_snoop_pop     <= ( r_pop and                    ri_snoop ) and not r_snoop_fifo_empty;
--  r_miss_pop      <= ( r_pop and not ri_hit and not ri_snoop ) and not  r_miss_fifo_empty;
  r_snoop_pop     <= ( r_pop_snoop_not_empty and                    ri_snoop );
  r_miss_pop      <= ( r_pop_miss_not_empty  and not ri_hit and not ri_snoop );
--  r_pop_safe      <= r_hit_pop or r_snoop_pop or r_miss_pop;
  r_pop_sel_safe  <=   r_hit_fifo_empty when ( ri_hit   = '1' ) else 
                     r_snoop_fifo_empty when ( ri_snoop = '1' ) else 
                      r_miss_fifo_empty;
  RC_And_Inst5: carry_and_n
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => r_pop,
      A_N       => r_pop_sel_safe,
      Carry_OUT => r_pop_safe_i
    );
  
  r_pop_snoop_not_empty <= r_pop_safe;
  r_pop_miss_not_empty  <= r_pop_safe;
      
  RC_Latch_Inst1: carry_latch_and
    generic map(
      C_TARGET  => C_TARGET,
      C_NUM_PAD => 0,
      C_INV_C   => false
    )
    port map(
      Carry_IN  => r_pop_safe_i,
      A         => ri_hit,
      O         => r_hit_pop,
      Carry_OUT => r_pop_safe
    );
  
  
  -- Select current write address depending on what Queue levels and whats available.
  r_write_fifo_addr <=          r_hit_write_fifo_addr when ( r_hit_push   = '1' ) else
                       "10" & r_snoop_write_fifo_addr when ( r_snoop_push = '1' ) else
                       "11" &  r_miss_write_fifo_addr;
  
  -- Select data for R Channel FIFO.
  Sel_R_Data : process (r_hit_push, r_snoop_push, 
                        lookup_read_data_info, lookup_read_data_word_i, 
                        snoop_read_data_info,
                        update_read_data_info) is
  begin  -- process Sel_R_Data
    -- Insert new item.
    if( r_hit_push = '1' ) then
      new_read_data_last  <= lookup_read_data_info(0).Last;
      new_read_data_word  <= lookup_read_data_word_i;
      new_read_data_resp  <= lookup_read_data_info(0).RRESP(C_S_AXI_RRESP_WIDTH - 1 downto 0);
      
    elsif( r_snoop_push = '1' ) then
      new_read_data_last  <= snoop_read_data_info(0).Last;
      new_read_data_word  <= snoop_read_data_info(0).Data(C_CACHE_DATA_WIDTH - 1 downto 0);
      new_read_data_resp  <= snoop_read_data_info(0).RRESP(C_S_AXI_RRESP_WIDTH - 1 downto 0);
      
    else
      new_read_data_last  <= update_read_data_info(0).Last;
      new_read_data_word  <= update_read_data_info(0).Data(C_CACHE_DATA_WIDTH - 1 downto 0);
      new_read_data_resp  <= update_read_data_info(0).RRESP(C_S_AXI_RRESP_WIDTH - 1 downto 0);
      
    end if;
  end process Sel_R_Data;
  
  -- Handle memory for R Channel FIFO.
  FIFO_R_Memory_Last : process (ACLK) is
  begin  -- process FIFO_R_Memory_Last
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( r_push_safe = '1') then
        -- Insert new item.
        rl_fifo_mem(to_integer(unsigned(r_write_fifo_addr)))  <= new_read_data_last;
      end if;
    end if;
  end process FIFO_R_Memory_Last;
  
  FIFO_R_Snoop_Memory_Last : process (ACLK) is
  begin  -- process FIFO_R_Snoop_Memory_Last
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( r_push_safe = '1') then
        -- Insert new item.
        rl_snoop_fifo_mem(to_integer(unsigned(r_write_fifo_addr)))  <= new_read_data_last;
      end if;
    end if;
  end process FIFO_R_Snoop_Memory_Last;
  
  FIFO_R_Memory_Word : process (ACLK) is
  begin  -- process FIFO_R_Memory_Word
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( r_push_safe = '1') then
        -- Insert new item.
        rw_fifo_mem(to_integer(unsigned(r_write_fifo_addr)))  <= new_read_data_word;
      end if;
    end if;
  end process FIFO_R_Memory_Word;
  
  FIFO_R_Memory_Resp : process (ACLK) is
  begin  -- process FIFO_R_Memory_Resp
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( r_push_safe = '1') then
        -- Insert new item.
        rr_fifo_mem(to_integer(unsigned(r_write_fifo_addr)))  <= new_read_data_resp;
      end if;
    end if;
  end process FIFO_R_Memory_Resp;
  
  -- Rename signals.
--  r_last                <= rl_fifo_mem(to_integer(unsigned(r_hit_read_fifo_addr)))    when ( ri_hit   = '1' ) else
--                           rl_fifo_mem(to_integer(unsigned(r_snoop_read_fifo_addr)))  when ( ri_snoop = '1' ) else
--                           rl_fifo_mem(to_integer(unsigned(r_miss_full_fifo_addr)));
  r_hit_last            <=       rl_fifo_mem(to_integer(unsigned(  r_hit_read_fifo_addr)));
  r_snoop_last          <= rl_snoop_fifo_mem(to_integer(unsigned(r_snoop_full_fifo_addr)));
  r_miss_last           <=       rl_fifo_mem(to_integer(unsigned( r_miss_full_fifo_addr)));
  r_last                <= r_hit_last   when ( ri_hit   = '1' ) else
                           r_snoop_last when ( ri_snoop = '1' ) else
                           r_miss_last;
  r_data                <= rw_fifo_mem(to_integer(unsigned(r_read_fifo_addr)));
  r_rresp               <= rr_fifo_mem(to_integer(unsigned(r_read_fifo_addr)));
    
  -- Determine if there are data in any one of the queues.
  -- For the coherent case will a snoop-data hazard force a virtually empty queue when there is a 
  -- risk for returning data in the forbidden window.
  r_fifo_true_empty     <= ( (     ri_hit                  and   r_hit_fifo_empty ) or 
                             (                    ri_snoop and r_snoop_fifo_empty ) or 
                             ( not ri_hit and not ri_snoop and  r_miss_fifo_empty ) ) or 
                           ( not ri_exist );
  r_fifo_empty          <= r_fifo_true_empty or snoop_act_read_hazard or read_data_max_concurrent;
  
  
  -----------------------------------------------------------------------------
  -- Read Queue Hazard Handling
  -- 
  -- Track read data flow:
  --  * Ongoing - Data is flowing, between first word and master ack
  --  * Active  - Data is flowing, between first word and last word
  -----------------------------------------------------------------------------
  
  
  rd_on_push      <= ( not r_fifo_empty) and S_AXI_RREADY and ( not read_data_started );
  rd_on_pop       <= S_AXI_RACK;
  
  rd_active_push  <= rd_on_push;
  rd_active_pop   <= ri_pop;
  
  No_Hazard_Handling: if(C_ENABLE_HAZARD_HANDLING = 0 ) generate
  begin
    read_data_cnt_ongoing           <= 0;
    read_data_any_running           <= '0';
    read_data_started               <= '0';
    read_data_possible_nested       <= '0';
    set_max_concurrent              <= '0';
    read_data_max_concurrent        <= '0';
    read_data_fetch_match           <= '0';
    read_data_req_match             <= '0';
    read_data_act_match             <= '0';
    read_data_ongoing               <= '0';
    read_data_release_block_i       <= '0';
    read_data_block_nested          <= '0';
    read_data_fetch_line_match_i    <= '0';
    read_data_req_line_match_i      <= '0';
    read_data_act_line_match_i      <= '0';
    read_data_fud_we                <= '0';
    read_data_fud_addr              <= (others=>'0');
    read_data_fud_tag_valid         <= '0';
    read_data_fud_tag_unique        <= '0';
    read_data_fud_tag_dirty         <= '0';
    read_data_fud_tag_secure        <= '0';
    read_trans_comp_info(0)         <= C_NULL_READ_COMPLETE;
    ron_assert                      <= '0';
    rk_empty                        <= '1';
    read_data_fud_is_dead           <= '0';
    
  end generate No_Hazard_Handling;
  
  Use_Hazard_Handling: if( C_ENABLE_HAZARD_HANDLING /= 0  ) generate
    
    signal rk_push                : std_logic;
    signal rk_pop                 : std_logic;
    signal rk_almost_full         : std_logic;
    signal rk_full                : std_logic;
    signal rk_read_fifo_addr      : QUEUE_ADDR_TYPE:= (others=>'1');
    signal rk_fifo_mem            : RK_FIFO_MEM_TYPE; -- := (others=>C_NULL_RK);
    signal rk_addr                : Lx_ADDR_LINE_TYPE;
    signal rk_assert              : std_logic;
    
  begin
    
    FIFO_RON_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => false,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => Log2(C_MAX_PENDING_RACK),
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => rd_on_push,
        queue_pop                 => rd_on_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => ron_almost_full,
        queue_full                => ron_full,
        queue_almost_empty        => ron_almost_empty,
        queue_empty               => ron_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => ron_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => open,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => ron_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for RON Channel FIFO.
    FIFO_RON_Memory : process (ACLK) is
    begin  -- process FIFO_RON_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( rd_on_push = '1') then
          if( r_rresp = C_RRESP_EXOKAY(r_rresp'range) ) then
            ron_fifo_mem(0).Exclusive <= '1';
          else
            ron_fifo_mem(0).Exclusive <= '0';
          end if;
          
          -- Shift FIFO contents.
          ron_fifo_mem(ron_fifo_mem'left downto 1) <= ron_fifo_mem(ron_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_RON_Memory;
    
    -- Get current Exclusive status.
    ron_exclusive <= ron_fifo_mem(to_integer(unsigned(ron_read_fifo_addr))).Exclusive;
        
    Track_Ongoing : process (ACLK) is
    begin  -- process Track_Ongoing
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
--          read_data_cnt_ongoing     <= 0;
          read_data_any_running     <= '0';
          read_data_started         <= '0';
          read_data_possible_nested <= '0';
          read_data_max_concurrent  <= '0';
          
        else
--          -- Count ongoing read data transactions that have RACK pending.
--          if( rd_on_push = '1' and rd_on_pop = '0' ) then
--            read_data_cnt_ongoing     <= read_data_cnt_ongoing + 1;
--          elsif( rd_on_push = '0' and rd_on_pop = '1' ) then
--            read_data_cnt_ongoing     <= read_data_cnt_ongoing - 1;
--          end if;
          
--          -- Status bit for any ongoing transactions.
--          if( rd_on_push = '0' and rd_on_pop = '1' and read_data_cnt_ongoing = 1 ) then
--            read_data_any_running     <= '0';
--          elsif( rd_on_push = '1' ) then
--            read_data_any_running     <= '1';
--          end if;
          
          -- Track data flow from first to last bit.
          if( rd_active_push = '1' and rd_active_pop = '0' ) then
            read_data_started         <= '1';
          elsif( rd_active_push = '0' and rd_active_pop = '1' ) then
            read_data_started         <= '0';
          end if;
          
          -- Determine if this is nested read situation.
          if( read_data_release_block_i = '1' ) then
            read_data_possible_nested  <= '0';
          elsif( rd_active_pop = '1' ) then
            read_data_possible_nested  <= '1';
          end if;
          
          -- Detect if maximum ongoing read data transactions has been reached.
          if( read_data_release_block_i = '1' ) then
            read_data_max_concurrent  <= '0';
          elsif( set_max_concurrent = '1' ) then
            read_data_max_concurrent  <= '1';
          end if;
     
        end if;
      end if;
    end process Track_Ongoing;
    
    read_trans_comp_info(0).Valid   <= rd_on_pop and ron_exclusive;
    read_trans_comp_info(0).Ex_Rack <= rd_on_pop and ron_exclusive;
    
    -- Evaluate condition to set
--    set_max_concurrent        <= rd_on_push when ( read_data_cnt_ongoing = C_MAX_PENDING_RACK - 2 ) else 
--                                 '0';
    set_max_concurrent        <= rd_on_push and ron_almost_full;
    
    -- Detect if this is a hit for the pending or ongoing read data.
    -- Need to use RI Exist since RIP Exist is too early and can make out of order kill issues.
    -- (Transactions in Act can include RIP which is in available before the source has been determined in RI).
    read_data_fetch_match     <= '1' when ( ri_exist = '1' ) and
                                          ( ri_lx_allocate = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_DIRECT_POS) = read_data_fetch_addr ) and
                                          ( rip_dvm = '0' ) else
                                 '0';
    read_data_req_match       <= '1' when ( ri_exist = '1' ) and
                                          ( ri_lx_allocate = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_DIRECT_POS) = read_data_req_addr   ) and
                                          ( rip_dvm = '0' ) else
                                 '0';
    read_data_act_match       <= '1' when ( ri_exist = '1' ) and
                                          ( ri_lx_allocate = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_DIRECT_POS) = read_data_act_addr   ) and
                                          ( rip_dvm = '0' ) else
                                 '0';
     
    -- Determine if any data is ongoing.
--    read_data_ongoing         <= read_data_any_running or not r_fifo_empty;
    read_data_ongoing         <= not ron_empty or not r_fifo_empty;
    
    -- Determine when it is possible to release the block of nested.
--    read_data_release_block_i <= rd_on_pop and not rd_on_push when ( read_data_cnt_ongoing = 1 ) else
--                                 '0';
    read_data_release_block_i <= rd_on_pop and not rd_on_push and ron_almost_empty;
    
    -- Determine if the read data hazard windows are still nested.
    read_data_block_nested    <= ( read_data_possible_nested and not read_data_release_block_i );
    
    -- Determine if snoop filter should be updated.
    read_data_fud_we          <= ri_pop and ri_lx_allocate and not read_data_fud_is_dead;
    
    -- Tag information.
    read_data_fud_tag_valid   <= '1';
    No_Coherency_Bits: if( C_S_AXI_RRESP_WIDTH <= 2  ) generate
    begin
      read_data_fud_tag_unique  <= '0';
      read_data_fud_tag_dirty   <= '0';
    end generate No_Coherency_Bits;
    Use_Coherency_Bits: if( C_S_AXI_RRESP_WIDTH > 2  ) generate
    begin
      read_data_fud_tag_unique  <= not r_rresp(C_RRESP_ISSHARED_POS);
      read_data_fud_tag_dirty   <=     r_rresp(C_RRESP_PASSDIRTY_POS);
    end generate Use_Coherency_Bits;
    read_data_fud_addr        <= rip_addr;
-- TODO: secure
    read_data_fud_tag_secure  <= '0';
    
    
    -----------------------------------------------------------------------------
    -- Read Lock Killed Queue
    -- 
    -- Handle Read requests that has been killed due to reuse of cache line.
    -- 
    -----------------------------------------------------------------------------
    
    -- Control signals for read info queue.
    rk_push         <= snoop_act_kill_locked   or 
                       snoop_act_kill_by_snoop;
    rk_pop          <= read_data_fud_is_dead and ri_pop;
  
    FIFO_RK_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => false,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => rk_push,
        queue_pop                 => rk_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => rk_almost_full,
        queue_full                => rk_full,
        queue_almost_empty        => open,
        queue_empty               => rk_empty,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => rk_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => open,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => rk_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Handle memory for RI Channel FIFO.
    FIFO_RI_Memory : process (ACLK) is
    begin  -- process FIFO_RI_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( rk_push = '1') then
          rk_fifo_mem(0).Addr <= snoop_act_kill_addr(C_Lx_ADDR_LINE_POS);
          
          -- Shift FIFO contents.
          rk_fifo_mem(rk_fifo_mem'left downto 1) <= rk_fifo_mem(rk_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_RI_Memory;
    
    -- Get cacheline address that has been killed.
    rk_addr                       <= rk_fifo_mem(to_integer(unsigned(rk_read_fifo_addr))).Addr;
    
    -- Detect if this is a conflict with current read address.
    read_data_fud_is_dead         <= not rk_empty when ( rk_addr = rip_addr(C_Lx_ADDR_LINE_POS) ) else 
                                     '0';
    
    -- Detect that there is a line conflict.
    read_data_fetch_line_match_i  <= '1' when 
                                          ( rip_exist = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_LINE_POS) = read_data_fetch_addr(C_Lx_ADDR_LINE_POS) ) 
                                         else '0';
    read_data_req_line_match_i    <= '1' when
                                          ( rip_exist = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_LINE_POS) = read_data_req_addr(C_Lx_ADDR_LINE_POS) ) 
                                         else '0';
    read_data_act_line_match_i    <= '1' when 
                                          ( rip_exist = '1' ) and
                                          ( rip_addr(C_Lx_ADDR_LINE_POS) = read_data_act_addr(C_Lx_ADDR_LINE_POS) ) 
                                         else '0';
    
  end generate Use_Hazard_Handling;
  
  -- Assign output.
  read_data_fetch_line_match    <= read_data_fetch_line_match_i;
  read_data_req_line_match      <= read_data_req_line_match_i;
  read_data_act_line_match      <= read_data_act_line_match_i;
  
  -- Assign external signal.
  read_data_release_block   <= read_data_release_block_i;
  
  
  -----------------------------------------------------------------------------
  -- Read Queue Handling (Pointer & Flags)
  -- 
  -- Push read data into the queue/buffer together with all control information 
  -- needed.
  -- 
  -- There are two possible data sources for the read data:
  --  * Lookup (read hit)
  --  * Update (read miss)
  -----------------------------------------------------------------------------
  
  -- Handle pointers to Queue.
  FIFO_WR_Hit_Pointer : process (ACLK) is
  begin  -- process FIFO_WR_Hit_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_hit_write_fifo_addr  <= (others=>'0');
      elsif( r_hit_push = '1' ) then
        if( r_hit_write_fifo_addr = C_HIT_WRAP_LEVEL ) then
          r_hit_write_fifo_addr  <= (others=>'0');
        else
          r_hit_write_fifo_addr  <= std_logic_vector(unsigned(r_hit_write_fifo_addr) + 1);
        end if;
      end if;
    end if;
  end process FIFO_WR_Hit_Pointer;
  
  FIFO_WR_Snoop_Pointer : process (ACLK) is
  begin  -- process FIFO_WR_Snoop_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_snoop_write_fifo_addr  <= (others=>'0');
      elsif( r_snoop_push = '1' ) then
        r_snoop_write_fifo_addr  <= std_logic_vector(unsigned(r_snoop_write_fifo_addr) + 1);
      end if;
    end if;
  end process FIFO_WR_Snoop_Pointer;
  
  FIFO_WR_Miss_Pointer : process (ACLK) is
  begin  -- process FIFO_WR_Miss_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_miss_write_fifo_addr  <= (others=>'0');
      elsif( r_miss_push = '1' ) then
        r_miss_write_fifo_addr  <= std_logic_vector(unsigned(r_miss_write_fifo_addr) + 1);
      end if;
    end if;
  end process FIFO_WR_Miss_Pointer;
  
  FIFO_RD_Hit_Pointer : process (ACLK) is
  begin  -- process FIFO_RD_Hit_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_hit_read_fifo_addr  <= (others=>'0');
      elsif( r_hit_pop = '1' ) then
        if( r_hit_read_fifo_addr = C_HIT_WRAP_LEVEL ) then
          r_hit_read_fifo_addr  <= (others=>'0');
        else
          r_hit_read_fifo_addr  <= std_logic_vector(unsigned(r_hit_read_fifo_addr) + 1);
        end if;
      end if;
    end if;
  end process FIFO_RD_Hit_Pointer;
  
  FIFO_RD_Snoop_Pointer : process (ACLK) is
  begin  -- process FIFO_RD_Snoop_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_snoop_read_fifo_addr  <= (others=>'0');
      elsif( r_snoop_pop = '1' ) then
        r_snoop_read_fifo_addr  <= std_logic_vector(unsigned(r_snoop_read_fifo_addr) + 1);
      end if;
    end if;
  end process FIFO_RD_Snoop_Pointer;
  
  r_snoop_full_fifo_addr <= "10" & r_snoop_read_fifo_addr;
  
  FIFO_RD_Miss_Pointer : process (ACLK) is
  begin  -- process FIFO_RD_Miss_Pointer
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_miss_read_fifo_addr <= (others=>'0');
      elsif( r_miss_pop = '1' ) then
        r_miss_read_fifo_addr <= std_logic_vector(unsigned(r_miss_read_fifo_addr) + 1);
      end if;
    end if;
  end process FIFO_RD_Miss_Pointer;
  
  r_miss_full_fifo_addr <= "11" & r_miss_read_fifo_addr;
  
  FIFO_Hit_Length : process (ACLK) is
  begin  -- process FIFO_Hit_Length
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_hit_fifo_len  <= (others=>'0');
      elsif( r_hit_refresh = '1' ) then
        if ( r_hit_push = '1' ) then
          r_hit_fifo_len  <= std_logic_vector(unsigned(r_hit_fifo_len) + 1);
        else
          r_hit_fifo_len  <= std_logic_vector(unsigned(r_hit_fifo_len) - 1);
        end if;
      end if;
    end if;
  end process FIFO_Hit_Length;
  
  FIFO_Snoop_Length : process (ACLK) is
  begin  -- process FIFO_Snoop_Length
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_snoop_fifo_len <= (others=>'0');
      elsif( r_snoop_refresh = '1' ) then
        if ( r_snoop_push = '1' ) then
          r_snoop_fifo_len  <= std_logic_vector(unsigned(r_snoop_fifo_len) + 1);
        else
          r_snoop_fifo_len  <= std_logic_vector(unsigned(r_snoop_fifo_len) - 1);
        end if;
      end if;
    end if;
  end process FIFO_Snoop_Length;
  
  FIFO_Miss_Length : process (ACLK) is
  begin  -- process FIFO_Miss_Length
    if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
      if( ARESET = '1' ) then              -- synchronous reset (active high)
        r_miss_fifo_len <= (others=>'0');
      elsif( r_miss_refresh = '1' ) then
        if ( r_miss_push = '1' ) then
          r_miss_fifo_len <= std_logic_vector(unsigned(r_miss_fifo_len) + 1);
        else
          r_miss_fifo_len <= std_logic_vector(unsigned(r_miss_fifo_len) - 1);
        end if;
      end if;
    end if;
  end process FIFO_Miss_Length;
  
  -- Calculate Queue Status.
  r_hit_almost_full_cmb     <= '1' when (r_hit_fifo_len   =  C_HIT_QUEUE_ALMOST_FULL)     else '0';
  r_hit_almost_empty_cmb    <= '1' when (r_hit_fifo_len   =  C_HIT_QUEUE_ALMOST_EMPTY)    else '0';
  r_hit_line_fit_up_cmb     <= '1' when (r_hit_fifo_len   =  C_HIT_QUEUE_EMPTY) or         
                                        (r_hit_fifo_len   <  C_HIT_QUEUE_LINE_LEVEL_UP)   else '0';
  r_hit_line_fit_dn_cmb     <= '1' when (r_hit_fifo_len   <  C_HIT_QUEUE_LINE_LEVEL_DN)   else '0';
  
  r_snoop_almost_full_cmb   <= '1' when (r_snoop_fifo_len =  C_SNOOP_QUEUE_ALMOST_FULL)   else '0';
  r_snoop_almost_empty_cmb  <= '1' when (r_snoop_fifo_len =  C_SNOOP_QUEUE_ALMOST_EMPTY)  else '0';
  r_snoop_line_fit_up_cmb   <= '1' when (r_snoop_fifo_len =  C_SNOOP_QUEUE_EMPTY) or         
                                        (r_snoop_fifo_len <  C_SNOOP_QUEUE_LINE_LEVEL_UP) else '0';
  r_snoop_line_fit_dn_cmb   <= '1' when (r_snoop_fifo_len <  C_SNOOP_QUEUE_LINE_LEVEL_DN) else '0';
  
  r_miss_almost_full_cmb    <= '1' when (r_miss_fifo_len  = C_MISS_QUEUE_ALMOST_FULL)     else '0';
  r_miss_almost_empty_cmb   <= '1' when (r_miss_fifo_len  = C_MISS_QUEUE_ALMOST_EMPTY)    else '0';
  r_miss_line_fit_up_cmb    <= '1' when (r_miss_fifo_len  = C_MISS_QUEUE_EMPTY) or         
                                        (r_miss_fifo_len  < C_MISS_QUEUE_LINE_LEVEL_UP)   else '0';
  r_miss_line_fit_dn_cmb    <= '1' when (r_miss_fifo_len  < C_MISS_QUEUE_LINE_LEVEL_DN)   else '0';
  
  Use_RTL_Flag: if( C_TARGET = RTL ) generate
  begin
    -- Handle flags to Miss Queue.
    Miss_Flag_Handling : process (ACLK) is
    begin  -- process Miss_Flag_Handling
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          r_miss_fifo_almost_full   <= '0';
          r_miss_fifo_full          <= '0';
          r_miss_fifo_almost_empty  <= '0';
          r_miss_fifo_empty         <= '1';
          if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH - 1 ) then
            r_miss_line_fit           <= '0';
          else
            r_miss_line_fit           <= '1';
          end if;
          
        elsif( r_miss_refresh = '1' ) then
          if ( r_miss_push = '1' ) then
            r_miss_fifo_almost_full   <= r_miss_almost_full_cmb;
            r_miss_fifo_full          <= r_miss_fifo_almost_full;
            r_miss_fifo_almost_empty  <= r_miss_fifo_empty;
            r_miss_fifo_empty         <= '0';
            if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH - 1 ) then
              r_miss_line_fit           <= '0';
            else
              r_miss_line_fit           <= r_miss_line_fit_up_cmb;
            end if;
            
          else
            r_miss_fifo_almost_full   <= r_miss_fifo_full;
            r_miss_fifo_full          <= '0';
            r_miss_fifo_almost_empty  <= r_miss_almost_empty_cmb;
            r_miss_fifo_empty         <= r_miss_fifo_almost_empty;
            if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH - 1 ) then
              r_miss_line_fit           <= '0';
            else
              r_miss_line_fit           <= r_miss_line_fit_dn_cmb;
            end if;
            
          end if;
        end if;
      end if;
    end process Miss_Flag_Handling;
    
    -- Handle flags to Snoop Queue.
    Snoop_Flag_Handling : process (ACLK) is
    begin  -- process Snoop_Flag_Handling
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          r_snoop_fifo_almost_full  <= '0';
          r_snoop_fifo_full         <= '0';
          r_snoop_fifo_almost_empty <= '0';
          r_snoop_fifo_empty        <= '1';
          if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) then
            r_snoop_line_fit          <= '0';
          else
            r_snoop_line_fit          <= '1';
          end if;
          
        elsif( r_snoop_refresh = '1' ) then
          if ( r_snoop_push = '1' ) then
            r_snoop_fifo_almost_full  <= r_snoop_almost_full_cmb;
            r_snoop_fifo_full         <= r_snoop_fifo_almost_full;
            r_snoop_fifo_almost_empty <= r_snoop_fifo_empty;
            r_snoop_fifo_empty        <= '0';
            if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) then
              r_snoop_line_fit          <= '0';
            else
              r_snoop_line_fit          <= r_snoop_line_fit_up_cmb;
            end if;
            
          else
            r_snoop_fifo_almost_full  <= r_snoop_fifo_full;
            r_snoop_fifo_full         <= '0';
            r_snoop_fifo_almost_empty <= r_snoop_almost_empty_cmb;
            r_snoop_fifo_empty        <= r_snoop_fifo_almost_empty;
            if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) then
              r_snoop_line_fit          <= '0';
            else
              r_snoop_line_fit          <= r_snoop_line_fit_dn_cmb;
            end if;
            
          end if;
        end if;
      end if;
    end process Snoop_Flag_Handling;
      
    -- Handle flags to Hit Queue.
    Hit_Flag_Handling : process (ACLK) is
    begin  -- process Hit_Flag_Handling
      if( ACLK'event and ACLK = '1' ) then   -- rising clock edge
        if( ARESET = '1' ) then              -- synchronous reset (active high)
          r_hit_fifo_almost_full  <= '0';
          r_hit_fifo_full         <= '0';
          r_hit_fifo_almost_empty <= '0';
          r_hit_fifo_empty        <= '1';
          if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) then
            r_hit_line_fit          <= '0';
          else
            r_hit_line_fit          <= '1';
          end if;
          
        elsif( r_hit_refresh = '1' ) then
          if ( r_hit_push = '1' ) then
            r_hit_fifo_almost_full  <= r_hit_almost_full_cmb;
            r_hit_fifo_full         <= r_hit_fifo_almost_full;
            r_hit_fifo_almost_empty <= r_hit_fifo_empty;
            r_hit_fifo_empty        <= '0';
            if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) then
              r_hit_line_fit          <= '0';
            else
              r_hit_line_fit          <= r_hit_line_fit_up_cmb;
            end if;
            
          else
            r_hit_fifo_almost_full  <= r_hit_fifo_full;
            r_hit_fifo_full         <= '0';
            r_hit_fifo_almost_empty <= r_hit_almost_empty_cmb;
            r_hit_fifo_empty        <= r_hit_fifo_almost_empty;
            if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) then
              r_hit_line_fit          <= '0';
            else
              r_hit_line_fit          <= r_hit_line_fit_dn_cmb;
            end if;
            
          end if;
        end if;
      end if;
    end process Hit_Flag_Handling;
      
  end generate Use_RTL_Flag;
  
  Use_FPGA_Flag_Hit: if( C_TARGET /= RTL ) generate
    signal queue_almost_full_next   : std_logic;
    signal queue_full_next          : std_logic;
    signal queue_almost_empty_next  : std_logic;
    signal queue_empty_next         : std_logic;
    signal queue_line_fit_next      : std_logic;
    
  begin
    
    -- Handle flags to Queue.
    Flag_Handling : process (r_hit_refresh, r_hit_push, 
                             r_hit_fifo_full, 
                             r_hit_almost_full_cmb, r_hit_fifo_almost_full, 
                             r_hit_almost_empty_cmb, r_hit_fifo_almost_empty, 
                             r_hit_fifo_empty, 
                             r_hit_line_fit_up_cmb, r_hit_line_fit_dn_cmb, r_hit_line_fit) is
    begin  -- process Flag_Handling
      if( r_hit_refresh = '1' ) then
        if ( r_hit_push = '1' ) then
          queue_almost_full_next  <= r_hit_almost_full_cmb;
          queue_full_next         <= r_hit_fifo_almost_full;
          queue_almost_empty_next <= r_hit_fifo_empty;
          queue_empty_next        <= '0';
          if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_hit_line_fit_up_cmb;
          end if;
          
        else
          queue_almost_full_next  <= r_hit_fifo_full;
          queue_full_next         <= '0';
          queue_almost_empty_next <= r_hit_almost_empty_cmb;
          queue_empty_next        <= r_hit_fifo_almost_empty;
          if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_hit_line_fit_dn_cmb;
          end if;
          
        end if;
      else
        queue_almost_full_next  <= r_hit_fifo_almost_full;
        queue_full_next         <= r_hit_fifo_full;
        queue_almost_empty_next <= r_hit_fifo_almost_empty;
        queue_empty_next        <= r_hit_fifo_empty;
        queue_line_fit_next     <= r_hit_line_fit;
      end if;
    end process Flag_Handling;
      
    Almost_Full_Inst : FDR
      port map (
        Q  => r_hit_fifo_almost_full,       -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_full_next,       -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Full_Inst : FDR
      port map (
        Q  => r_hit_fifo_full,              -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_full_next,              -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Almost_Empty_Inst : FDR
      port map (
        Q  => r_hit_fifo_almost_empty,      -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_empty_next,      -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Empty_Inst : FDS
      port map (
        Q  => r_hit_fifo_empty,             -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_empty_next,             -- [in  std_logic]
        S  => ARESET                        -- [in  std_logic]
      );
    
    Use_Normal_Line: if( C_LINE_LENGTH < C_HIT_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDS
        port map (
          Q  => r_hit_line_fit,               -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Normal_Line;
    Use_Long_Line: if( C_LINE_LENGTH >= C_HIT_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDR
        port map (
          Q  => r_hit_line_fit,               -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          R  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Long_Line;
  end generate Use_FPGA_Flag_Hit;
  
  Use_FPGA_Flag_Snoop: if( C_TARGET /= RTL ) generate
    signal queue_almost_full_next   : std_logic;
    signal queue_full_next          : std_logic;
    signal queue_almost_empty_next  : std_logic;
    signal queue_empty_next         : std_logic;
    signal queue_line_fit_next      : std_logic;
    
  begin
    
    -- Handle flags to Queue.
    Flag_Handling : process (r_snoop_refresh, r_snoop_push, 
                             r_snoop_fifo_full, 
                             r_snoop_almost_full_cmb, r_snoop_fifo_almost_full, 
                             r_snoop_almost_empty_cmb, r_snoop_fifo_almost_empty, 
                             r_snoop_fifo_empty, 
                             r_snoop_line_fit_up_cmb, r_snoop_line_fit_dn_cmb, r_snoop_line_fit) is
    begin  -- process Flag_Handling
      if( r_snoop_refresh = '1' ) then
        if ( r_snoop_push = '1' ) then
          queue_almost_full_next  <= r_snoop_almost_full_cmb;
          queue_full_next         <= r_snoop_fifo_almost_full;
          queue_almost_empty_next <= r_snoop_fifo_empty;
          queue_empty_next        <= '0';
          if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_snoop_line_fit_up_cmb;
          end if;
          
        else
          queue_almost_full_next  <= r_snoop_fifo_full;
          queue_full_next         <= '0';
          queue_almost_empty_next <= r_snoop_almost_empty_cmb;
          queue_empty_next        <= r_snoop_fifo_almost_empty;
          if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_snoop_line_fit_dn_cmb;
          end if;
          
        end if;
      else
        queue_almost_full_next  <= r_snoop_fifo_almost_full;
        queue_full_next         <= r_snoop_fifo_full;
        queue_almost_empty_next <= r_snoop_fifo_almost_empty;
        queue_empty_next        <= r_snoop_fifo_empty;
        queue_line_fit_next     <= r_snoop_line_fit;
      end if;
    end process Flag_Handling;
      
    Almost_Full_Inst : FDR
      port map (
        Q  => r_snoop_fifo_almost_full,       -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_full_next,       -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Full_Inst : FDR
      port map (
        Q  => r_snoop_fifo_full,            -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_full_next,              -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Almost_Empty_Inst : FDR
      port map (
        Q  => r_snoop_fifo_almost_empty,    -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_empty_next,      -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Empty_Inst : FDS
      port map (
        Q  => r_snoop_fifo_empty,           -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_empty_next,             -- [in  std_logic]
        S  => ARESET                        -- [in  std_logic]
      );
    
    Use_Normal_Line: if( C_LINE_LENGTH < C_SNOOP_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDS
        port map (
          Q  => r_snoop_line_fit,             -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Normal_Line;
    Use_Long_Line: if( C_LINE_LENGTH >= C_SNOOP_QUEUE_LENGTH - 1 ) generate
    begin
      Line_Fit_Inst : FDR
        port map (
          Q  => r_snoop_line_fit,             -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          R  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Long_Line;
  end generate Use_FPGA_Flag_Snoop;
  
  Use_FPGA_Flag_Miss: if( C_TARGET /= RTL ) generate
    signal queue_almost_full_next   : std_logic;
    signal queue_full_next          : std_logic;
    signal queue_almost_empty_next  : std_logic;
    signal queue_empty_next         : std_logic;
    signal queue_line_fit_next      : std_logic;
    
  begin
    
    -- Handle flags to Queue.
    Flag_Handling : process (r_miss_refresh, r_miss_push, 
                             r_miss_fifo_full, 
                             r_miss_almost_full_cmb, r_miss_fifo_almost_full, 
                             r_miss_almost_empty_cmb, r_miss_fifo_almost_empty, 
                             r_miss_fifo_empty, 
                             r_miss_line_fit_up_cmb, r_miss_line_fit_dn_cmb, r_miss_line_fit) is
    begin  -- process Flag_Handling
      if( r_miss_refresh = '1' ) then
        if ( r_miss_push = '1' ) then
          queue_almost_full_next  <= r_miss_almost_full_cmb;
          queue_full_next         <= r_miss_fifo_almost_full;
          queue_almost_empty_next <= r_miss_fifo_empty;
          queue_empty_next        <= '0';
          if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH_BITS - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_miss_line_fit_up_cmb;
          end if;
          
        else
          queue_almost_full_next  <= r_miss_fifo_full;
          queue_full_next         <= '0';
          queue_almost_empty_next <= r_miss_almost_empty_cmb;
          queue_empty_next        <= r_miss_fifo_almost_empty;
          if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH_BITS - 1 ) then
            queue_line_fit_next     <= '0';
          else
            queue_line_fit_next     <= r_miss_line_fit_dn_cmb;
          end if;
          
        end if;
      else
        queue_almost_full_next  <= r_miss_fifo_almost_full;
        queue_full_next         <= r_miss_fifo_full;
        queue_almost_empty_next <= r_miss_fifo_almost_empty;
        queue_empty_next        <= r_miss_fifo_empty;
        queue_line_fit_next     <= r_miss_line_fit;
      end if;
    end process Flag_Handling;
      
    Almost_Full_Inst : FDR
      port map (
        Q  => r_miss_fifo_almost_full,      -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_full_next,       -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Full_Inst : FDR
      port map (
        Q  => r_miss_fifo_full,             -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_full_next,              -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Almost_Empty_Inst : FDR
      port map (
        Q  => r_miss_fifo_almost_empty,     -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_almost_empty_next,      -- [in  std_logic]
        R  => ARESET                        -- [in  std_logic]
      );
          
    Empty_Inst : FDS
      port map (
        Q  => r_miss_fifo_empty,            -- [out std_logic]
        C  => ACLK,                         -- [in  std_logic]
        D  => queue_empty_next,             -- [in  std_logic]
        S  => ARESET                        -- [in  std_logic]
      );
    
    Use_Normal_Line: if( C_LINE_LENGTH < C_MISS_QUEUE_LENGTH_BITS - 1 ) generate
    begin
      Line_Fit_Inst : FDS
        port map (
          Q  => r_miss_line_fit,              -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          S  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Normal_Line;
    Use_Long_Line: if( C_LINE_LENGTH >= C_MISS_QUEUE_LENGTH_BITS - 1 ) generate
    begin
      Line_Fit_Inst : FDR
        port map (
          Q  => r_miss_line_fit,              -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => queue_line_fit_next,          -- [in  std_logic]
          R  => ARESET                        -- [in  std_logic]
        );
    end generate Use_Long_Line;
    
  end generate Use_FPGA_Flag_Miss;
  
  -- Assign external signals.
  read_data_status(0).Hit_Pop         <= r_hit_pop;
  read_data_status(0).Hit_Almost_Full <= r_hit_fifo_almost_full;
  read_data_status(0).Hit_Full        <= r_hit_fifo_full;
  read_data_status(0).Hit_Fit         <= r_hit_line_fit;
-- TODO: looks like it is unused...  
  read_data_status(0).Miss_Full       <= r_miss_fifo_full or r_snoop_push or r_hit_push;
  
  -- Return ready signal for throttling.
  lookup_read_data_ready(0) <= not r_hit_fifo_full;
  update_read_data_ready(0) <= not r_miss_fifo_full and 
                               not ( lookup_read_data_info(0).Valid and not   r_hit_fifo_full );
  snoop_read_data_ready(0)  <= not r_snoop_fifo_full and 
                               not ( update_read_data_info(0).Valid and not  r_miss_fifo_full ) and 
                               not ( lookup_read_data_info(0).Valid and not   r_hit_fifo_full );
  
  
  -----------------------------------------------------------------------------
  -- Read Information Queue Handling
  -- 
  -- Push all control information needed into the queue to be able to do the 
  -- port specific modifications of the returned data.
  -----------------------------------------------------------------------------
  
  -- Control signals for read data queue.
  rip_push      <= read_req_valid;
  rip_push_safe <= rip_push and not rip_fifo_full;
--  rip_pop       <= r_pop_safe and r_last;
  RC_And_Inst6: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => r_pop_safe,
      A         => r_last,
      Carry_OUT => rip_pop
    );
  
  FIFO_RIP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => true,
      C_ENABLE_PROTECTION       => true,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => true,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 2
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => rip_push,
      queue_pop                 => rip_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => rip_refresh_reg,
      
      queue_almost_full         => rip_fifo_almost_full,
      queue_full                => rip_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => open,
      queue_exist               => rip_exist,
      queue_line_fit            => read_req_ready,
      queue_index               => rip_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_rip,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => rip_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for RIP Channel FIFO.
  FIFO_RIP_Memory : process (ACLK) is
  begin  -- process FIFO_RIP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( rip_push_safe = '1') then
        -- Insert new item.
        rip_fifo_mem(0).ID        <= read_req_ID;
        rip_fifo_mem(0).Last      <= read_req_last;
        rip_fifo_mem(0).Offset    <= read_req_offset;
        rip_fifo_mem(0).Rest      <= read_req_rest;
        rip_fifo_mem(0).Stp_Bits  <= read_req_stp;
        rip_fifo_mem(0).Use_Bits  <= read_req_use;
        rip_fifo_mem(0).Len       <= read_req_len;
        rip_fifo_mem(0).Single    <= read_req_single;
        rip_fifo_mem(0).DVM       <= read_req_dvm;
        rip_fifo_mem(0).Addr      <= read_req_addr;
        
        -- Shift FIFO contents.
        rip_fifo_mem(rip_fifo_mem'left downto 1) <= rip_fifo_mem(rip_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_RIP_Memory;
  
  -- Store RIP in register for good timing.
  RIP_Data_Registers : process (ACLK) is
  begin  -- process RIP_Data_Registers
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET = '1') then              -- synchronous reset (active high)
        rip_id      <= C_NULL_RIP.ID;
        rip_last    <= C_NULL_RIP.Last;
        rip_offset  <= C_NULL_RIP.Offset;
        rip_stp     <= C_NULL_RIP.Stp_Bits;
        rip_use     <= C_NULL_RIP.Use_Bits;
        rip_single  <= C_NULL_RIP.Single;
        rip_dvm     <= C_NULL_RIP.DVM;
        rip_addr    <= C_NULL_RIP.Addr;
        
      elsif( rip_refresh_reg = '1' ) then
        rip_id      <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).ID;
        rip_last    <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Last;
        rip_offset  <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Offset;
        rip_stp     <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Stp_Bits;
        rip_use     <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Use_Bits;
        rip_single  <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Single;
        rip_dvm     <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).DVM;
        rip_addr    <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Addr;
        
      end if;
    end if;
  end process RIP_Data_Registers;
  
  
  -----------------------------------------------------------------------------
  -- Read Port Handling
  -- 
  -- Serialize read data when neccessary.
  -- 
  -- Input data signals for serialization
  -- rip_offset - Contains starting point in the internal word
  -- rip_last   - If this is the last part of a split transaction (only generic
  --              has the capability to split)
  -- rip_stp    - Size of each part that shall be extracted (only generic
  --              has the capability to use non 32bit words)
  -- rip_rest   - How much that remains of the first word. Set to non-max for
  --              unaligned transactions. Max value together with rip_offset
  --              can be used to create wrap access, but that only works for
  --              one word MicroBlaze wrap (longer wrap are not supported
  --              internally).
  -- rip_len    - Total number of data beats that are needed.
  -----------------------------------------------------------------------------
  
  -- Expand for narrow interface.
  Read_External_Narrow: if( C_S_AXI_DATA_WIDTH < C_CACHE_DATA_WIDTH or C_SUPPORT_SUBSIZED ) generate
  
    subtype RATIO_POS                   is natural range C_RATIO - 1 downto 0;
    subtype R_DATA_TYPE                 is std_logic_vector(C_S_AXI_DATA_WIDTH - 1 downto 0);
    type R_DATA_MUX_TYPE                is array(RATIO_POS) of R_DATA_TYPE;
    
    subtype C_RATIO_BITS_POS            is natural range Log2(C_CACHE_DATA_WIDTH/8) - 1 downto 
                                                         Log2(C_S_AXI_DATA_WIDTH/8);
    subtype RATIO_BITS_TYPE             is std_logic_vector(C_RATIO_BITS_POS);
    
    signal offset_cnt_next              : ADDR_BYTE_TYPE;
    signal offset                       : ADDR_BYTE_TYPE;
    signal length_cnt                   : LEN_TYPE;
    signal rd_length                    : LEN_TYPE;
    signal rest_cnt                     : REST_TYPE;
    signal rd_rest                      : REST_TYPE;
    signal r_data_i                     : R_DATA_MUX_TYPE;
    
    signal rd_length_zero               : std_logic;
    signal rd_rest_zero                 : std_logic;
    signal rd_pop_part                  : std_logic;
    
  begin
    Data_Offset : process (ACLK) is
    begin  -- process Data_Offset
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
          offset    <= C_NULL_RIP.Offset;
          rd_length <= C_NULL_RIP.Len;
          rd_rest   <= C_NULL_RIP.Rest;
        else
          if( rip_refresh_reg = '1' ) then
            offset    <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Offset;
            rd_length <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Len;
            rd_rest   <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).Rest;
          elsif( ( S_AXI_RREADY and not r_fifo_empty ) = '1' ) then
            offset    <= offset_cnt_next;
            rd_length <= std_logic_vector(unsigned(rd_length) - 1);
            rd_rest   <= std_logic_vector(unsigned(rd_rest)   - unsigned(rip_stp));
          end if;
        end if;
      end if;
    end process Data_Offset;
  
    -- Generate next offset including wrap.
    Update_Offset_Select: process (offset, rip_stp, rip_use, rip_offset) is
      variable offset_cnt_next_cmb  : ADDR_BYTE_TYPE;
    begin  -- process Update_Offset_Select
      offset_cnt_next_cmb     := std_logic_vector(unsigned(offset) + unsigned(rip_stp));
      
      for N in offset_cnt_next_cmb'range loop
        if( rip_use(N) = '0' ) then
          offset_cnt_next(N)  <= rip_offset(N);
          
        else
          offset_cnt_next(N)  <= offset_cnt_next_cmb(N);
          
        end if;
      end loop;
    end process Update_Offset_Select;
    
    -- Determine if this data word has been completely used.
--    rd_done   <= '1' when to_integer(unsigned(rd_length)) = 0 else rd_pop;
--    rd_pop    <= '1' when to_integer(unsigned(rd_rest))   = 0 else rip_single;
    rd_rest_zero    <= '1' when to_integer(unsigned(rd_rest))   = 0 else '0';
    RC_And_Inst1: carry_compare_const
      generic map(
        C_TARGET  => C_TARGET,
        C_SIGNALS => 1,
        C_SIZE    => LEN_TYPE'length,
        B_Vec     => (C_LEN_POS=>'0')
      )
      port map(
        Carry_In  => '1',                 -- [in  std_logic]
        A_Vec     => rd_length,           -- [in  std_logic_vector]
        Carry_Out => rd_length_zero       -- [out std_logic]
      );
    RC_Or_Inst1: carry_or 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => rd_length_zero,
        A         => rd_rest_zero,
        Carry_OUT => rd_pop
      );
    RC_Or_Inst2: carry_or 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => rd_pop,
        A         => rip_single,
        Carry_OUT => rd_done
      );
      
    -- Generate array for easy extraction.
    Gen_Read_Array: for N in 0 to C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH - 1 generate
    begin
      -- Generate mirrored data and steer byte enable.
      r_data_i(N) <= r_data((N+1) * C_S_AXI_DATA_WIDTH - 1 downto N * C_S_AXI_DATA_WIDTH);
    end generate Gen_Read_Array;
    
    -- Generate output.
    S_AXI_RLAST_I <= r_last and rd_done and rip_last;
    S_AXI_RDATA_I <= r_data_i(to_integer(unsigned(offset(C_RATIO_BITS_POS))));
    
    Use_Debug: if( C_USE_DEBUG ) generate
      constant C_MY_DATA    : natural := min_of(32, C_S_AXI_DATA_WIDTH);
      constant C_MY_RESP    : natural := min_of( 4, C_S_AXI_RRESP_WIDTH);
      constant C_MY_ID      : natural := min_of( 4, C_S_AXI_ID_WIDTH);
      constant C_MY_REST    : natural := min_of( 6, C_REST_WIDTH);
      constant C_MY_OFF     : natural := min_of( 6, C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1);
      constant C_MY_LEN     : natural := min_of( 6, C_LEN_WIDTH);
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET = '1') then              -- synchronous reset (active true)
            IF_DEBUG(255 downto 196)                  <= (others=>'0');
          else
            -- Default assignment.
            IF_DEBUG(255 downto 196)                  <= (others=>'0');
            
            IF_DEBUG(196 + C_MY_OFF   - 1 downto 196) <= rip_use(C_MY_OFF - 1 downto 0);
            IF_DEBUG(202 + C_MY_OFF   - 1 downto 202) <= rip_stp(C_MY_OFF - 1 downto 0);
            IF_DEBUG(208 + C_MY_OFF   - 1 downto 208) <= rip_offset(C_MY_OFF - 1 downto 0);
            IF_DEBUG(                            214) <= rip_last;
            IF_DEBUG(                            215) <= rip_single;
            IF_DEBUG(216 + C_MY_OFF   - 1 downto 216) <= offset(C_MY_OFF - 1 downto 0);
            IF_DEBUG(222 + C_MY_LEN   - 1 downto 222) <= rd_length(C_MY_LEN - 1 downto 0);
            IF_DEBUG(228 + C_MY_REST  - 1 downto 228) <= rd_rest(C_MY_REST - 1 downto 0);
            IF_DEBUG(                            234) <= rd_pop;
            IF_DEBUG(                            235) <= rd_done;
            IF_DEBUG(                            236) <= r_last;
            IF_DEBUG(                            237) <= ri_lx_allocate;
            IF_DEBUG(                            238) <= ri_hit;
            IF_DEBUG(                            239) <= ri_snoop;
            IF_DEBUG(                            240) <= lookup_read_data_new(0).Valid;
            IF_DEBUG(                            241) <= lookup_read_data_new(0).Hit;
            IF_DEBUG(                            242) <= lookup_read_data_new(0).Snoop;
            IF_DEBUG(                            243) <= lookup_read_data_new(0).Lx_Allocate;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
  end generate Read_External_Narrow;
  
  Read_External_Same: if( C_S_AXI_DATA_WIDTH = C_CACHE_DATA_WIDTH  and not C_SUPPORT_SUBSIZED) generate
  begin
    -- Same size, word is always done.
    rd_done       <= '1';
    
    -- Size matches, just forward all signals.
    S_AXI_RLAST_I <= r_last and rip_last;
    S_AXI_RDATA_I <= r_data;
    
    Use_Debug: if( C_USE_DEBUG ) generate
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET = '1') then              -- synchronous reset (active true)
            IF_DEBUG(255 downto 196)                  <= (others=>'0');
          else
            -- Default assignment.
            IF_DEBUG(255 downto 196)                  <= (others=>'0');
            
            IF_DEBUG(                            214) <= rip_last;
            IF_DEBUG(                            235) <= rd_done;
            IF_DEBUG(                            236) <= r_last;
            IF_DEBUG(                            237) <= ri_lx_allocate;
            IF_DEBUG(                            238) <= ri_hit;
            IF_DEBUG(                            239) <= ri_snoop;
            IF_DEBUG(                            240) <= lookup_read_data_new(0).Valid;
            IF_DEBUG(                            241) <= lookup_read_data_new(0).Hit;
            IF_DEBUG(                            242) <= lookup_read_data_new(0).Snoop;
            IF_DEBUG(                            243) <= lookup_read_data_new(0).Lx_Allocate;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
  end generate Read_External_Same;
  
  Use_RTL_2: if( C_TARGET = RTL ) generate
  begin
    S_AXI_RVALID  <= not r_fifo_empty;
    
  end generate Use_RTL_2;
  
  Use_FPGA_2: if( C_TARGET /= RTL ) generate
    
    signal ri_miss                  : std_logic;
    signal next_ri_miss             : std_logic;
    signal r_hit_one                : std_logic;
    signal r_snoop_one              : std_logic;
    signal r_miss_one               : std_logic;
    signal r_hit_exist              : std_logic;
    signal r_snoop_exist            : std_logic;
    signal r_miss_exist             : std_logic;
    signal r_hit_available          : std_logic;
    signal r_snoop_available        : std_logic;
    signal r_miss_available         : std_logic;
    signal r_next_hit_available     : std_logic;
    signal r_next_snoop_available   : std_logic;
    signal r_next_miss_available    : std_logic;
    
  begin
--    r_fifo_true_empty     <= ( (     ri_hit                  and   r_hit_fifo_empty ) or 
--                               (                    ri_snoop and r_snoop_fifo_empty ) or 
--                               ( not ri_hit and not ri_snoop and  r_miss_fifo_empty ) ) or 
--                             ( not ri_exist );
--    r_fifo_empty          <= r_fifo_true_empty or snoop_act_read_hazard or read_data_max_concurrent;
    
    -- Help signals for non-hit and non-snoop => miss. 
    ri_miss                 <= not      ri_hit and not      ri_snoop; 
    next_ri_miss            <= not next_ri_hit and not next_ri_snoop; 
    
    -- Only one data word available (this word).
    r_hit_one               <= r_hit_fifo_almost_empty;
    r_snoop_one             <= r_snoop_fifo_almost_empty;
    r_miss_one              <= r_miss_fifo_almost_empty;
    
    -- Help signal for data available.
    r_hit_exist             <= not r_hit_fifo_empty;
    r_snoop_exist           <= not r_snoop_fifo_empty;
    r_miss_exist            <= not r_miss_fifo_empty;
    
    -- Detect if data is available per type.
    --  * Push will always make data available, regardless of current depth.
    --  * Data is also available if the last item isn't pop'ed this cycle (with no new arriving).
    r_hit_available         <= ( r_hit_push   or ( r_hit_exist   and not ( r_hit_pop   and r_hit_one   ) ) ) and 
                               ri_hit;
    r_snoop_available       <= ( r_snoop_push or ( r_snoop_exist and not ( r_snoop_pop and r_snoop_one ) ) ) and 
                               ri_snoop;
    r_miss_available        <= ( r_miss_push  or ( r_miss_exist  and not ( r_miss_pop  and r_miss_one  ) ) ) and 
                               ri_miss;
    
    r_next_hit_available    <= ( r_hit_push   or ( r_hit_exist   and not ( r_hit_pop   and r_hit_one   ) ) ) and 
                               next_ri_hit;
    r_next_snoop_available  <= ( r_snoop_push or ( r_snoop_exist and not ( r_snoop_pop and r_snoop_one ) ) ) and 
                               next_ri_snoop;
    r_next_miss_available   <= ( r_miss_push  or ( r_miss_exist  and not ( r_miss_pop  and r_miss_one  ) ) ) and 
                               next_ri_miss;
    
    Data_Offset : process (ACLK) is
    begin  -- process Data_Offset
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active high)
          S_AXI_RVALID  <= '0';
        else
          if( ( (                               snoop_act_set_read_hazard and     snoop_req_piperun(0) ) = '1' ) or
              ( ( snoop_act_read_hazard and not snoop_act_rst_read_hazard and not snoop_req_piperun(0) ) = '1' ) or
              ( ( set_max_concurrent       and not read_data_release_block_i ) = '1' ) or
              ( ( read_data_max_concurrent and not read_data_release_block_i ) = '1' ) ) then
            -- The equivalent of having "snoop_act_read_hazard or read_data_max_concurrent" in the empty expression
            -- => Turn off valid until it is safe again. 
            S_AXI_RVALID  <= '0';
            
          else
            -- There is the posiblity of data from RI Queue may have information of next data.
            if( ( ri_exist = '0' ) or ( ri_pop = '1') ) then
              -- Information must come from the Next stage because of non existant or used information i Reg stage.
              if( ri_empty = '1' ) then
                -- No Information => No data.
                S_AXI_RVALID  <= '0';
                
              else
                -- If data is available or will become available next cycle.
                S_AXI_RVALID  <= r_next_hit_available or r_next_snoop_available or r_next_miss_available;
                
              end if;
            else
              -- Pipeline information exist that can be used to determine if data is available or 
              -- will become available next cycle.
              S_AXI_RVALID  <= r_hit_available or r_snoop_available or r_miss_available;
              
            end if;
          end if;
        end if;
      end if;
    end process Data_Offset;
  end generate Use_FPGA_2;
  
  -- Forward untouche signals (width independent).
  S_AXI_RLAST   <= S_AXI_RLAST_I;
  S_AXI_RID     <= rip_id;
  S_AXI_RRESP   <= r_rresp;
  S_AXI_RDATA   <= S_AXI_RDATA_I;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Statistics: if( not C_USE_STATISTICS ) generate
  begin
    stat_s_axi_r  <= C_NULL_STAT_FIFO;
  end generate No_Statistics;
  
  Use_Statistics: if( C_USE_STATISTICS ) generate
  begin
    Fake_FIFO_R_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => false,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => false,
        C_QUEUE_ADDR_WIDTH        => C_DATA_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 2
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => r_push_safe,
        queue_pop                 => r_pop_safe_i,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => open,
        
        queue_almost_full         => open,
        queue_full                => open,
        queue_almost_empty        => open,
        queue_empty               => open,
        queue_exist               => open,
        queue_line_fit            => open,
        queue_index               => open,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_s_axi_r,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => open,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
  end generate Use_Statistics;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_DATA    : natural := min_of(32, C_S_AXI_DATA_WIDTH);
    constant C_MY_RESP    : natural := min_of( 4, C_S_AXI_RRESP_WIDTH);
    constant C_MY_ID      : natural := min_of( 4, C_S_AXI_ID_WIDTH);
    constant C_MY_REST    : natural := min_of( 6, C_REST_WIDTH);
    constant C_MY_OFF     : natural := min_of( 6, C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1);
    constant C_MY_LEN     : natural := min_of( 6, C_LEN_WIDTH);
    constant C_MY_DQ      : natural := min_of( 6, C_DATA_QUEUE_LENGTH_BITS);
    constant C_MY_HQ      : natural := min_of( 6, C_HIT_QUEUE_LENGTH_BITS);
    constant C_MY_MQ      : natural := min_of( 4, C_MISS_QUEUE_LENGTH_BITS);
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET = '1') then              -- synchronous reset (active true)
          IF_DEBUG(195 downto 0)                    <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG(195 downto 0)                    <= (others=>'0');
          
          -- R-Channel
          IF_DEBUG(  0 + C_MY_ID    - 1 downto   0) <= rip_fifo_mem(to_integer(unsigned(rip_read_fifo_addr))).ID(C_MY_ID - 1 downto 0); -- S_AXI_RID
          IF_DEBUG(  4 + C_MY_DATA  - 1 downto   4) <= S_AXI_RDATA_I(C_MY_DATA - 1 downto 0);
          IF_DEBUG( 36 + C_MY_RESP  - 1 downto  36) <= rr_fifo_mem(to_integer(unsigned(r_read_fifo_addr)))(C_MY_RESP - 1 downto 0); -- S_AXI_RRESP
          IF_DEBUG(                             40) <= S_AXI_RLAST_I;
          IF_DEBUG(                             41) <= not r_fifo_empty; -- S_AXI_RVALID
          IF_DEBUG(                             42) <= S_AXI_RREADY;
          
          -- Read Information Interface Signals.
          IF_DEBUG(                             43) <= read_req_valid;
          IF_DEBUG( 44 + C_MY_ID    - 1 downto  44) <= read_req_ID(C_MY_ID - 1 downto 0);
          IF_DEBUG(                             48) <= read_req_last;
          IF_DEBUG(                             49) <= read_req_failed;
          IF_DEBUG(                             50) <= read_req_single;
          IF_DEBUG( 51 + C_MY_REST  - 1 downto  51) <= read_req_rest(C_MY_REST - 1 downto 0);
          IF_DEBUG( 57 + C_MY_OFF   - 1 downto  57) <= read_req_offset(C_MY_OFF - 1 downto 0);
          IF_DEBUG( 63 + C_MY_OFF   - 1 downto  63) <= read_req_stp(C_MY_OFF - 1 downto 0);
          IF_DEBUG( 69 + C_MY_LEN   - 1 downto  69) <= read_req_len(C_MY_LEN - 1 downto 0);
          IF_DEBUG(                             75) <= not rip_fifo_full; -- read_req_ready;
          
          -- Internal Interface Signals (Read request).
          IF_DEBUG(                             76) <= rd_port_ready;
          
          -- Internal Interface Signals (Read Data).
          IF_DEBUG(                             77) <= '0';
          IF_DEBUG(                             78) <= '0';
          
          -- Lookup signals (Read Data).
          IF_DEBUG(                             79) <= lookup_read_data_info(0).Valid;
          IF_DEBUG(                             80) <= lookup_read_data_info(0).Last;
          IF_DEBUG( 81 + C_MY_RESP  - 1 downto  81) <= lookup_read_data_info(0).RRESP(C_MY_RESP - 1 downto 0);
          IF_DEBUG( 85 + C_MY_DATA  - 1 downto  85) <= lookup_read_data_word_i(C_MY_DATA - 1 downto 0);
          IF_DEBUG(                            117) <= not r_hit_fifo_full; -- lookup_read_data_ready
          
          -- Update signals (Read Data).
          IF_DEBUG(                            118) <= update_read_data_info(0).Valid;
          IF_DEBUG(                            119) <= update_read_data_info(0).Last;
          IF_DEBUG(120 + C_MY_RESP  - 1 downto 120) <= update_read_data_info(0).RRESP(C_MY_RESP - 1 downto 0);
          IF_DEBUG(124 + C_MY_DATA  - 1 downto 124) <= update_read_data_info(0).Data(C_MY_DATA - 1 downto 0);
          IF_DEBUG(                            156) <= not r_miss_fifo_full and not ( lookup_read_data_info(0).Valid and not r_hit_fifo_full ); 
                                                       -- update_read_data_ready
          
          -- Access signals (Read Data).
--          IF_DEBUG(                            157) <= '0'; -- snoop_read_data_info(0).Valid;
--          IF_DEBUG(                            158) <= '0'; -- snoop_read_data_info(0).Last;
--          IF_DEBUG(159 + C_MY_RESP  - 1 downto 159) <= (others=>'0'); -- snoop_read_data_info(0).RRESP(C_MY_RESP - 1 downto 0);
--          IF_DEBUG(163 + C_MY_DATA  - 1 downto 163) <= (others=>'0'); -- snoop_read_data_info(0).Data(C_MY_DATA - 1 downto 0);
--          IF_DEBUG(                            195) <= '0';
          
          IF_DEBUG(                            157) <= ri_push;
          IF_DEBUG(                            158) <= ri_pop;
          IF_DEBUG(                            159) <= ri_exist;
          IF_DEBUG(                            160) <= ri_hit;
  
          IF_DEBUG(                            161) <= r_hit_push;
          IF_DEBUG(                            162) <= r_miss_push;
          IF_DEBUG(                            163) <= r_push_safe;
          IF_DEBUG(                            164) <= r_pop;
          IF_DEBUG(                            165) <= r_hit_pop;
          IF_DEBUG(                            166) <= r_miss_pop;
          IF_DEBUG(                            167) <= r_pop_safe;
          IF_DEBUG(                            168) <= r_hit_refresh;
          IF_DEBUG(                            169) <= r_miss_refresh;
  
          IF_DEBUG(                            170) <= r_hit_fifo_almost_full;
          IF_DEBUG(                            171) <= r_hit_fifo_full;
          IF_DEBUG(                            172) <= r_hit_fifo_almost_empty;
          IF_DEBUG(                            173) <= r_hit_fifo_empty;
          IF_DEBUG(                            174) <= r_hit_line_fit;
          IF_DEBUG(                            175) <= r_miss_fifo_almost_full;
          IF_DEBUG(                            176) <= r_miss_fifo_full;
          IF_DEBUG(                            177) <= r_miss_fifo_almost_empty;
          IF_DEBUG(                            178) <= r_miss_fifo_empty;
          IF_DEBUG(                            179) <= r_miss_line_fit;
  
          IF_DEBUG(                            180) <= ri_assert;
          IF_DEBUG(                            181) <= rip_assert;
          IF_DEBUG(                            182) <= assert_err(C_ASSERT_NO_RI_INFO);
  
          IF_DEBUG(124 + 6          - 1 downto 124) <= (others=>'0');
          IF_DEBUG(130 + 6          - 1 downto 130) <= (others=>'0');
          IF_DEBUG(136 + 4          - 1 downto 136) <= (others=>'0');
          IF_DEBUG(140 + 6          - 1 downto 140) <= (others=>'0');
          IF_DEBUG(146 + 4          - 1 downto 146) <= (others=>'0');
          IF_DEBUG(124 + C_MY_DQ    - 1 downto 124) <= fit_vec(ri_read_fifo_addr, C_MY_DQ);
          IF_DEBUG(130 + C_MY_HQ    - 1 downto 130) <= fit_vec(r_hit_write_fifo_addr, C_MY_HQ);
          IF_DEBUG(136 + C_MY_MQ    - 1 downto 136) <= fit_vec(r_miss_write_fifo_addr, C_MY_MQ);
          IF_DEBUG(140 + C_MY_HQ    - 1 downto 140) <= fit_vec(r_hit_read_fifo_addr, C_MY_HQ);
          IF_DEBUG(146 + C_MY_MQ    - 1 downto 146) <= fit_vec(r_miss_read_fifo_addr, C_MY_MQ);
          IF_DEBUG(                            150) <= rk_empty;
          IF_DEBUG(                            151) <= read_data_fud_is_dead;
          IF_DEBUG(                            152) <= read_data_fetch_line_match_i;
          IF_DEBUG(                            153) <= read_data_req_line_match_i;
          IF_DEBUG(                            154) <= read_data_act_line_match_i;
          
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_COLLIDING_DATA)   <= ( lookup_read_data_info(0).Valid and update_read_data_info(0).Valid ) when
                                                  C_USE_ASSERTIONS else
                                             '0';
    
    -- Detect condition
    assert_err(C_ASSERT_RIP_QUEUE_ERROR)  <= rip_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_RI_QUEUE_ERROR)   <= ri_assert  when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_NO_RIP_INFO)      <= ( lookup_read_data_info(0).Valid or 
                                               update_read_data_info(0).Valid ) and not rip_exist when 
                                                  C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_NO_RI_INFO)       <= ( not r_hit_fifo_empty or 
                                               not r_miss_fifo_empty ) and not ri_exist when 
                                                  C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_RON_QUEUE_ERROR)  <= ron_assert when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_COLLIDING_DATA) /= '1' 
      report "AXI R Channel: Read data collision, multiple sources are streaming data simultaneously."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_RIP_QUEUE_ERROR) /= '1' 
      report "AXI R Channel: Erroneous handling of RIP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_RI_QUEUE_ERROR) /= '1' 
      report "AXI R Channel: Erroneous handling of RI Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_NO_RIP_INFO) /= '1' 
      report "AXI R Channel: No RIP Information available when read data arrives."
        severity error;
    
    assert assert_err_1(C_ASSERT_NO_RI_INFO) /= '1' 
      report "AXI R Channel: No RI Information available when read data present."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_RON_QUEUE_ERROR) /= '1' 
      report "AXI R Channel: Erroneous handling of RON Queue, read from empty or push to full."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;





-------------------------------------------------------------------------------
-- sc_s_axi_opt_interface.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_opt_interface.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_opt_interface.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_s_axi_opt_interface is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_OPT_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_OPT_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- AXI4 Interface Specific.
    C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
    C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_S_AXI_ADDR_WIDTH        : natural                       := 32;
    C_S_AXI_RRESP_WIDTH       : natural range  2 to    4      :=  2;
    C_S_AXI_ID_WIDTH          : natural                       :=  1;
    C_S_AXI_SUPPORT_UNIQUE    : natural range  0 to    1      :=  1;
    C_S_AXI_SUPPORT_DIRTY     : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    C_Lx_ADDR_REQ_HI          : natural range  2 to   63      := 27;
    C_Lx_ADDR_REQ_LO          : natural range  2 to   63      :=  7;
    C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
    C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
    C_Lx_ADDR_DATA_HI         : natural range  2 to   63      := 14;
    C_Lx_ADDR_DATA_LO         : natural range  2 to   63      :=  2;
    C_Lx_ADDR_TAG_HI          : natural range  4 to   63      := 27;
    C_Lx_ADDR_TAG_LO          : natural range  4 to   63      := 14;
    C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
    C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
    C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
    C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
    C_Lx_ADDR_WORD_HI         : natural range  2 to   63      :=  6;
    C_Lx_ADDR_WORD_LO         : natural range  2 to   63      :=  2;
    C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
    C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
    
    -- Lx Cache Specific.
    C_Lx_CACHE_SIZE           : natural                       := 1024;
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
    C_Lx_NUM_ADDR_TAG_BITS    : natural range  1 to   63      :=  8;
    
    -- System Cache Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_NUM_WAYS                : natural range  1 to    8      :=  1;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_PORT_NUM                : natural range  0 to   31      :=  0;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4/ACE Slave Interface Signals.
    
    -- AW-Channel
    S_AXI_AWID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_AWADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    S_AXI_AWLEN               : in  std_logic_vector(7 downto 0);
    S_AXI_AWSIZE              : in  std_logic_vector(2 downto 0);
    S_AXI_AWBURST             : in  std_logic_vector(1 downto 0);
    S_AXI_AWLOCK              : in  std_logic;
    S_AXI_AWCACHE             : in  std_logic_vector(3 downto 0);
    S_AXI_AWPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_AWQOS               : in  std_logic_vector(3 downto 0);
    S_AXI_AWVALID             : in  std_logic;
    S_AXI_AWREADY             : out std_logic;
    S_AXI_AWDOMAIN            : in  std_logic_vector(1 downto 0);                      -- For ACE
    S_AXI_AWSNOOP             : in  std_logic_vector(2 downto 0);                      -- For ACE
    S_AXI_AWBAR               : in  std_logic_vector(1 downto 0);                      -- For ACE

    -- W-Channel
    S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
    S_AXI_WLAST               : in  std_logic;
    S_AXI_WVALID              : in  std_logic;
    S_AXI_WREADY              : out std_logic;

    -- B-Channel
    S_AXI_BRESP               : out std_logic_vector(1 downto 0);
    S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_BVALID              : out std_logic;
    S_AXI_BREADY              : in  std_logic;
    S_AXI_WACK                : in  std_logic;                                         -- For ACE

    -- AR-Channel
    S_AXI_ARID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_ARADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    S_AXI_ARLEN               : in  std_logic_vector(7 downto 0);
    S_AXI_ARSIZE              : in  std_logic_vector(2 downto 0);
    S_AXI_ARBURST             : in  std_logic_vector(1 downto 0);
    S_AXI_ARLOCK              : in  std_logic;
    S_AXI_ARCACHE             : in  std_logic_vector(3 downto 0);
    S_AXI_ARPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_ARQOS               : in  std_logic_vector(3 downto 0);
    S_AXI_ARVALID             : in  std_logic;
    S_AXI_ARREADY             : out std_logic;
    S_AXI_ARDOMAIN            : in  std_logic_vector(1 downto 0);                      -- For ACE
    S_AXI_ARSNOOP             : in  std_logic_vector(3 downto 0);                      -- For ACE
    S_AXI_ARBAR               : in  std_logic_vector(1 downto 0);                      -- For ACE

    -- R-Channel
    S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    S_AXI_RRESP               : out std_logic_vector(C_S_AXI_RRESP_WIDTH-1 downto 0);
    S_AXI_RLAST               : out std_logic;
    S_AXI_RVALID              : out std_logic;
    S_AXI_RREADY              : in  std_logic;
    S_AXI_RACK                : in  std_logic;                                         -- For ACE

    -- AC-Channel (coherency only)
    S_AXI_ACVALID             : out std_logic;                                         -- For ACE
    S_AXI_ACADDR              : out std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);   -- For ACE
    S_AXI_ACSNOOP             : out std_logic_vector(3 downto 0);                      -- For ACE
    S_AXI_ACPROT              : out std_logic_vector(2 downto 0);                      -- For ACE
    S_AXI_ACREADY             : in  std_logic;                                         -- For ACE

    -- CR-Channel (coherency only)
    S_AXI_CRVALID             : in  std_logic;                                         -- For ACE
    S_AXI_CRRESP              : in  std_logic_vector(4 downto 0);                      -- For ACE
    S_AXI_CRREADY             : out std_logic;                                         -- For ACE

    -- CD-Channel (coherency only)
    S_AXI_CDVALID             : in  std_logic;                                         -- For ACE
    S_AXI_CDDATA              : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);   -- For ACE
    S_AXI_CDLAST              : in  std_logic;                                         -- For ACE
    S_AXI_CDREADY             : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (All request).
    
    arbiter_piperun           : in  std_logic;
    arbiter_allowed           : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write request).
    
    wr_port_access            : out WRITE_PORT_TYPE;
    wr_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    rd_port_access            : out READ_PORT_TYPE;
    rd_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Snoop communication).
    
    -- Snoop Fetch Stage Signals
    snoop_fetch_piperun       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_fetch_info          : in  SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_fetch_pos_hazard    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Request Stage Signals.
    snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_req_info            : in  SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Action Stage Signals.
    snoop_act_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_info            : in  SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_tag_info        : out SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_ack_info        : out SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    snoop_tag_status_info     : in  SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    snoop_tag_new_info        : out SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    snoop_resp_info           : out SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_resp_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    snoop_data_info           : out SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Complete Transaction Signals.
    read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write Data).
    
    wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write response).
    
    access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Snoop signals (Read Data & response).
    
    snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (Read Data).
    
    lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (Read Data).
    
    update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                      : in  std_logic;
    stat_enable                     : in  std_logic;
    
    stat_s_axi_rd_segments          : out STAT_POINT_TYPE;
    stat_s_axi_wr_segments          : out STAT_POINT_TYPE;
    stat_s_axi_rip                  : out STAT_FIFO_TYPE;
    stat_s_axi_r                    : out STAT_FIFO_TYPE;
    stat_s_axi_bip                  : out STAT_FIFO_TYPE;
    stat_s_axi_bp                   : out STAT_FIFO_TYPE;
    stat_s_axi_wip                  : out STAT_FIFO_TYPE;
    stat_s_axi_w                    : out STAT_FIFO_TYPE;
    stat_s_axi_rd_latency           : out STAT_POINT_TYPE;
    stat_s_axi_wr_latency           : out STAT_POINT_TYPE;
    stat_s_axi_rd_latency_conf      : in  STAT_CONF_TYPE;
    stat_s_axi_wr_latency_conf      : in  STAT_CONF_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_opt_interface;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_opt_interface is

  
  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Optimized AXI4/ACE Slave port that only support MicroBlaze like 
  -- transactions, i.e. a MicroBlaze or any other IP that limit it self to
  -- the set of transactions that MicroBlaze can generate under the same  
  -- configuration. 
  -- 
  -- A number of FIFOs/Queues are used to improve throughput and communicate 
  -- between the AXI channels, when required.
  -- 
  -- 
  --  ____            ___________         
  -- | W  |--------->| W   Queue |--------+------------------------------>
  -- |____|          |___________|        |
  --                                      |
  --  ____            ___________         |
  -- | AW |-----+--->| WIP Queue |--------|          
  -- |____|     |    |___________|        
  --            |                         
  --            |     ___________         
  --            |--->| BIP Queue |--|
  --                 |___________|  |     
  --                                |     
  --  ____                          |     ___________ 
  -- | B  |<------------------------+----| BP Queue  |<-------------------
  -- |____|                              |___________|
  -- 
  --  ____          ___________ 
  -- | R  |<-------| R Channel |<-----------------------------------------
  -- |____|        |___________|
  --                     ^
  --  ____               |
  -- | AR |--------------|              
  -- |____|              
  -- 
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_WIP_QUEUE_ERROR           : natural :=  0;
  constant C_ASSERT_W_QUEUE_ERROR             : natural :=  1;
  constant C_ASSERT_BIP_QUEUE_ERROR           : natural :=  2;
  constant C_ASSERT_BP_QUEUE_ERROR            : natural :=  3;
  constant C_ASSERT_R_CHANNEL_ERROR           : natural :=  4;
  constant C_ASSERT_SYNC_ERROR                : natural :=  5;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  6;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ENABLE_HAZARD_HANDLING   : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), 1, 0);
  
  constant C_NO_SNOOP_FILTER          : boolean := ( C_Lx_NUM_WAYS > 1 );
  
  constant C_ADDR_BYTE_BITS           : natural := C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1;
  
  constant C_LEN_WIDTH                : natural := C_ADDR_BYTE_BITS;
  constant C_REST_WIDTH               : natural := C_LEN_WIDTH;
  
  subtype C_LEN_POS                   is natural range C_LEN_WIDTH - 1 downto 0;
  subtype C_REST_POS                  is natural range C_REST_WIDTH - 1 downto 0;
  subtype LEN_TYPE                    is std_logic_vector(C_LEN_POS);
  subtype REST_TYPE                   is std_logic_vector(C_REST_POS);
  
  constant C_BYTE_LENGTH              : natural := 8 + Log2(C_S_AXI_DATA_WIDTH/8);
  constant C_ADDR_LENGTH_HI           : natural := C_BYTE_LENGTH - 1;
  constant C_ADDR_LENGTH_LO           : natural := C_ADDR_BYTE_LO;
  
  subtype C_ADDR_LENGTH_POS           is natural range C_ADDR_LENGTH_HI     downto C_ADDR_LENGTH_LO;
  
  subtype C_BYTE_MASK_POS             is natural range C_BYTE_LENGTH - 1 + 7 downto 7;
  subtype C_HALF_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 6 downto 6;
  subtype C_WORD_MASK_POS             is natural range C_BYTE_LENGTH - 1 + 5 downto 5;
  subtype C_DOUBLE_WORD_MASK_POS      is natural range C_BYTE_LENGTH - 1 + 4 downto 4;
  subtype C_QUAD_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 3 downto 3;
  subtype C_OCTA_WORD_MASK_POS        is natural range C_BYTE_LENGTH - 1 + 2 downto 2;
  subtype C_HEXADECA_WORD_MASK_POS    is natural range C_BYTE_LENGTH - 1 + 1 downto 1;
  subtype C_TRIACONTADI_MASK_POS      is natural range C_BYTE_LENGTH - 1 + 0 downto 0;
  
  
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  -- Types for AXI and port related signals (use S0 as reference, all has to be equal).
  constant C_RRESP_WIDTH              : integer             := C_S_AXI_RRESP_WIDTH;
  
  subtype ID_TYPE                     is std_logic_vector(C_S_AXI_ID_WIDTH - 1 downto 0);
  subtype RRESP_TYPE                  is std_logic_vector(C_RRESP_WIDTH - 1 downto 0);
  subtype CACHE_DATA_TYPE             is std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  subtype BE_TYPE                     is std_logic_vector(C_S_AXI_DATA_WIDTH/8 - 1 downto 0);
  subtype DATA_TYPE                   is std_logic_vector(C_S_AXI_DATA_WIDTH - 1 downto 0);
  
  constant C_STAT_ONE                 : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0) := 
                                                              std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
  
  -- Address bit parts
  subtype C_Lx_ADDR_REQ_POS           is natural range C_Lx_ADDR_REQ_HI           downto C_Lx_ADDR_REQ_LO;
  subtype C_Lx_ADDR_DIRECT_POS        is natural range C_Lx_ADDR_DIRECT_HI        downto C_Lx_ADDR_DIRECT_LO;
  subtype C_Lx_ADDR_DATA_POS          is natural range C_Lx_ADDR_DATA_HI          downto C_Lx_ADDR_DATA_LO;
  subtype C_Lx_ADDR_TAG_POS           is natural range C_Lx_ADDR_TAG_HI           downto C_Lx_ADDR_TAG_LO;
  subtype C_Lx_ADDR_LINE_POS          is natural range C_Lx_ADDR_LINE_HI          downto C_Lx_ADDR_LINE_LO;
  subtype C_Lx_ADDR_OFFSET_POS        is natural range C_Lx_ADDR_OFFSET_HI        downto C_Lx_ADDR_OFFSET_LO;
  subtype C_Lx_ADDR_WORD_POS          is natural range C_Lx_ADDR_WORD_HI          downto C_Lx_ADDR_WORD_LO;
  subtype C_Lx_ADDR_BYTE_POS          is natural range C_Lx_ADDR_BYTE_HI          downto C_Lx_ADDR_BYTE_LO;
  
  subtype Lx_ADDR_REQ_TYPE            is std_logic_vector(C_Lx_ADDR_REQ_POS);
  subtype Lx_ADDR_DIRECT_TYPE         is std_logic_vector(C_Lx_ADDR_DIRECT_POS);
  subtype Lx_ADDR_DATA_TYPE           is std_logic_vector(C_Lx_ADDR_DATA_POS);
  subtype Lx_ADDR_TAG_TYPE            is std_logic_vector(C_Lx_ADDR_TAG_POS);
  subtype Lx_ADDR_LINE_TYPE           is std_logic_vector(C_Lx_ADDR_LINE_POS);
  subtype Lx_ADDR_OFFSET_TYPE         is std_logic_vector(C_Lx_ADDR_OFFSET_POS);
  subtype Lx_ADDR_WORD_TYPE           is std_logic_vector(C_Lx_ADDR_WORD_POS);
  subtype Lx_ADDR_BYTE_TYPE           is std_logic_vector(C_Lx_ADDR_BYTE_POS);
  
  
  -- Ranges for TAG information parts.
  constant C_Lx_NUM_STATUS_BITS       : natural := 1 + 1 + 
                                                   C_S_AXI_SUPPORT_UNIQUE + 
                                                   C_S_AXI_SUPPORT_DIRTY  + 
                                                   C_ENABLE_NON_SECURE;
  constant C_Lx_TAG_SIZE              : natural := C_Lx_NUM_ADDR_TAG_BITS + C_Lx_NUM_STATUS_BITS;
  constant C_Lx_TAG_UNIQUE_POS        : natural := C_Lx_NUM_ADDR_TAG_BITS + 0;
  constant C_Lx_TAG_SECURE_POS        : natural := C_Lx_TAG_UNIQUE_POS    + C_ENABLE_NON_SECURE;
  constant C_Lx_TAG_DIRTY_POS         : natural := C_Lx_TAG_SECURE_POS    + C_S_AXI_SUPPORT_UNIQUE;
  constant C_Lx_TAG_LOCKED_POS        : natural := C_Lx_TAG_DIRTY_POS     + C_S_AXI_SUPPORT_DIRTY;
  constant C_Lx_TAG_VALID_POS         : natural := C_Lx_TAG_LOCKED_POS    + 1;
  subtype C_Lx_TAG_ADDR_POS           is natural range C_Lx_NUM_ADDR_TAG_BITS - 1 downto 0;
  subtype C_Lx_TAG_POS                is natural range C_Lx_TAG_SIZE - 1          downto 0;
  subtype Lx_TAG_ADDR_TYPE            is std_logic_vector(C_Lx_TAG_ADDR_POS);
  subtype Lx_TAG_TYPE                 is std_logic_vector(C_Lx_TAG_POS);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------

  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  -- Subtypes of the address from all points of view.
  
  -- Address related.
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  -- Subtypes for address parts.
  subtype ADDR_DIRECT_TYPE            is std_logic_vector(C_ADDR_DIRECT_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Interface ratio.
  constant C_RATIO                    : natural := C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH;
  constant C_RATIO_BITS               : natural := Log2(C_RATIO);
  
  subtype C_RATIO_POS                 is natural range Log2(C_CACHE_DATA_WIDTH/8) - 1 downto Log2(C_S_AXI_DATA_WIDTH/8);
  subtype RATIO_TYPE                  is std_logic_vector(C_RATIO_POS);
  
  type WIP_TYPE is record
    Offset            : ADDR_BYTE_TYPE;
    Incr              : std_logic;
    Size              : AXI_SIZE_TYPE;
    Len               : AXI_LENGTH_TYPE;
  end record WIP_TYPE;
  
  type W_TYPE is record
    Last              : std_logic;
    BE                : BE_TYPE;
    Data              : DATA_TYPE;
  end record W_TYPE;
  
  type INT_W_TYPE is record
    Last              : std_logic;
    Data              : DATA_TYPE;
  end record INT_W_TYPE;
  
  type BP_TYPE is record
    Early             : std_logic;
    Barrier           : std_logic;
  end record BP_TYPE;
  
  type BIP_TYPE is record
    ID                : ID_TYPE;
  end record BIP_TYPE;
  
  type ARI_TYPE is record
    Resp              : AXI_CRRESP_TYPE;
  end record ARI_TYPE;
  
  -- Empty data structures.
  constant C_NULL_WIP                 : WIP_TYPE   := (Offset=>(others=>'0'), Incr=>'0', 
                                                       Size=>(others=>'0'), Len=>(others=>'0'));
  constant C_NULL_W                   : W_TYPE     := (Last=>'0', BE=>(others=>'0'), Data=>(others=>'0'));
  constant C_NULL_INT_W               : INT_W_TYPE := (Last=>'0', Data=>(others=>'0'));
  constant C_NULL_BP                  : BP_TYPE    := (Early=>'0', Barrier=>'0');
  constant C_NULL_BIP                 : BIP_TYPE   := (ID=>(others=>'0'));
  constant C_NULL_ARI                 : ARI_TYPE   := (Resp=>(others=>'0'));
  
  -- Types for information queue storage.
  type WIP_FIFO_MEM_TYPE              is array(QUEUE_ADDR_POS) of WIP_TYPE;
  type W_FIFO_MEM_TYPE                is array(QUEUE_ADDR_POS) of W_TYPE;
  type INT_W_FIFO_MEM_TYPE            is array(QUEUE_ADDR_POS) of INT_W_TYPE;
  type BP_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS) of BP_TYPE;
  type BIP_FIFO_MEM_TYPE              is array(QUEUE_ADDR_POS) of BIP_TYPE;
  type ARI_FIFO_MEM_TYPE              is array(QUEUE_ADDR_POS) of ARI_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_s_axi_r_channel is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_S_AXI_ID_WIDTH          : natural                       :=  1;
      C_S_AXI_RRESP_WIDTH       : natural range  2 to    4      :=  2;
      
      -- Configuration.
      C_SUPPORT_SUBSIZED        : boolean                       := false;
      C_LEN_WIDTH               : natural range  0 to    8      :=  2;
      C_REST_WIDTH              : natural range  0 to    7      :=  2;
      
      -- Data type and settings specific.
      C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
      C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_NUM_WAYS                : natural range  1 to    8      :=  1;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_ENABLE_HAZARD_HANDLING  : natural range  0 to    1      :=  0;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- R-Channel
      S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_RRESP               : out std_logic_vector(C_S_AXI_RRESP_WIDTH-1 downto 0);
      S_AXI_RLAST               : out std_logic;
      S_AXI_RVALID              : out std_logic;
      S_AXI_RREADY              : in  std_logic;
      S_AXI_RACK                : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            : in  std_logic;
      read_req_ID               : in  std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
      read_req_last             : in  std_logic;
      read_req_failed           : in  std_logic;
      read_req_single           : in  std_logic;
      read_req_dvm              : in  std_logic;
      read_req_addr             : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_req_rest             : in  std_logic_vector(C_REST_WIDTH - 1 downto 0);
      read_req_offset           : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_stp              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_use              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_len              : in  std_logic_vector(C_LEN_WIDTH - 1  downto 0);
      read_req_ready            : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Hazard).
      
      snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_set_read_hazard : in  std_logic;
      snoop_act_rst_read_hazard : in  std_logic;
      snoop_act_read_hazard     : in  std_logic;
      snoop_act_kill_locked     : in  std_logic;
      snoop_act_kill_by_snoop   : in  std_logic;
      snoop_act_kill_addr       : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      
      read_data_fetch_addr      : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_req_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_act_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      
      read_data_fetch_match     : out std_logic;
      read_data_req_match       : out std_logic;
      read_data_act_match       : out std_logic;
      read_data_ongoing         : out std_logic;
      read_data_block_nested    : out std_logic;
      read_data_release_block   : out std_logic;
      read_data_fetch_line_match: out std_logic;
      read_data_req_line_match  : out std_logic;
      read_data_act_line_match  : out std_logic;
      
      read_data_fud_we          : out std_logic;
      read_data_fud_addr        : out std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_fud_tag_valid   : out std_logic;
      read_data_fud_tag_unique  : out std_logic;
      read_data_fud_tag_dirty   : out std_logic;
      read_data_fud_tag_secure  : out std_logic;
      
      read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_s_axi_rip            : out STAT_FIFO_TYPE;
      stat_s_axi_r              : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_r_channel;
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component sc_stat_latency is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_LATENCY_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_LATENCY_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      ar_start                  : in  std_logic;
      ar_ack                    : in  std_logic;
      rd_valid                  : in  std_logic;
      rd_last                   : in  std_logic;
      aw_start                  : in  std_logic;
      aw_ack                    : in  std_logic;
      wr_valid                  : in  std_logic;
      wr_last                   : in  std_logic;
      wr_resp                   : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_rd_latency           : out STAT_POINT_TYPE;    -- External Read Latency
      stat_wr_latency           : out STAT_POINT_TYPE;    -- External Write Latency
      stat_rd_latency_conf      : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_wr_latency_conf      : in  STAT_CONF_TYPE      -- External Write Latency Configuration
    );
  end component sc_stat_latency;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  component sc_ram_module is
    generic (
      C_TARGET        : TARGET_FAMILY_TYPE;
      C_WE_A_WIDTH    : positive              := 1;
      C_DATA_A_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_A_WIDTH  : natural range 1 to 18 := 11;
      C_WE_B_WIDTH    : positive              := 1;
      C_DATA_B_WIDTH  : positive              := 18;  -- No upper limit
      C_ADDR_B_WIDTH  : natural range 1 to 18 := 11;
      C_FORCE_BRAM    : boolean               := true;
      C_FORCE_LUTRAM  : boolean               := false
    );
    port (
      -- PORT A
      CLKA            : in  std_logic;
      ENA             : in  std_logic;
      WEA             : in  std_logic_vector(C_WE_A_WIDTH-1 downto 0);
      ADDRA           : in  std_logic_vector(C_ADDR_A_WIDTH-1 downto 0);
      DATA_INA        : in  std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      DATA_OUTA       : out std_logic_vector(C_DATA_A_WIDTH-1 downto 0);
      -- PORT B
      CLKB            : in  std_logic;
      ENB             : in  std_logic;
      WEB             : in  std_logic_vector(C_WE_B_WIDTH-1 downto 0);
      ADDRB           : in  std_logic_vector(C_ADDR_B_WIDTH-1 downto 0);
      DATA_INB        : in  std_logic_vector(C_DATA_B_WIDTH-1 downto 0);
      DATA_OUTB       : out std_logic_vector(C_DATA_B_WIDTH-1 downto 0)
    );
  end component sc_ram_module;
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE
    );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_or_n;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  signal snoop_req_complete_target  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal snoop_info_tag_valid       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Slave Bus Interface (AW and AR)
  
  signal S_AXI_AWVALID_I            : std_logic;
  signal S_AXI_ARVALID_I            : std_logic;
  signal S_AXI_AWREADY_I            : std_logic;
  signal S_AXI_ARREADY_I            : std_logic;
  signal S_AXI_ARADDR_I             : AXI_ADDR_TYPE;
  signal S_AXI_AWADDR_I             : AXI_ADDR_TYPE;
  signal ar_allocate                : std_logic;
  signal ar_other_allocate          : std_logic;
  signal ar_is_wt                   : std_logic;
  signal aw_allocate                : std_logic;
  signal aw_other_allocate          : std_logic;
  signal aw_is_wt                   : std_logic;
  
  
  -- ----------------------------------------
  -- Write Transaction Information Queue
  
  signal wr_port_access_i           : WRITE_PORT_TYPE;
  signal wip_push                   : std_logic;
  signal wip_pop                    : std_logic;
  signal wip_refresh_reg            : std_logic;
  signal wip_exist                  : std_logic;
  signal wip_read_fifo_addr         : QUEUE_ADDR_TYPE := (others=>'1');
  signal wip_fifo_mem               : WIP_FIFO_MEM_TYPE := (others=>C_NULL_WIP);
  signal wip_offset                 : ADDR_BYTE_TYPE;
  signal wip_stp_bits               : ADDR_BYTE_TYPE;
  signal wip_use_bits               : ADDR_BYTE_TYPE;
  signal wip_assert                 : std_logic;
  
  
  -- ----------------------------------------
  -- Write Queue Handling
  
  signal w_push                     : std_logic;
  signal w_push_safe                : std_logic;
  signal w_pop_part                 : std_logic;
  signal w_pop                      : std_logic;
  signal w_pop_safe                 : std_logic;
  signal w_fifo_full                : std_logic;
  signal w_fifo_empty               : std_logic;
  signal w_read_fifo_addr           : QUEUE_ADDR_TYPE;
  signal w_fifo_mem                 : W_FIFO_MEM_TYPE; -- := (others=>C_NULL_W);
  signal w_valid                    : std_logic;
  signal w_last                     : std_logic;
  signal w_be                       : BE_TYPE;
  signal w_data                     : DATA_TYPE;
  signal w_ready                    : std_logic;
  signal w_assert                   : std_logic;
  signal S_AXI_WREADY_I             : std_logic;
  
  
  -- ----------------------------------------
  -- Write Complete tracking
  
  signal wc_push        : std_logic;
  signal wc_pop         : std_logic;
  signal wc_fifo_empty  : std_logic;
  
  
  -- ----------------------------------------
  -- Control R-Channel
  
  signal rd_port_access_i           : READ_PORT_TYPE;
  signal read_req_valid             : std_logic;
  signal read_req_ID                : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal read_req_single            : std_logic;
  signal read_req_dvm               : std_logic;
  signal read_req_addr              : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
  signal read_req_rest              : std_logic_vector(C_REST_WIDTH - 1 downto 0);
  signal read_req_offset            : std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
  signal read_req_stp               : std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
  signal read_req_use               : std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
  signal read_req_len               : std_logic_vector(C_LEN_WIDTH - 1  downto 0);
  signal read_req_ready             : std_logic;
  signal r_assert                   : std_logic;
  signal RIF_DEBUG                  : std_logic_vector(255 downto 0);
  signal S_AXI_RVALID_I             : std_logic;
  signal S_AXI_RLAST_I              : std_logic;
  
  
  -- ----------------------------------------
  -- Write Information Queue Handling
  
  signal bip_push                   : std_logic;
  signal bip_pop                    : std_logic;
  signal bip_read_fifo_addr         : QUEUE_ADDR_TYPE:= (others=>'1');
  signal bip_fifo_mem               : BIP_FIFO_MEM_TYPE; -- := (others=>C_NULL_BIP);
  signal bip_fifo_full              : std_logic;
  signal bip_id                     : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal bip_assert                 : std_logic;
  
  
  -- ----------------------------------------
  -- Write Data Handling
  
  signal wr_port_data_valid_i       : std_logic;
  signal wr_port_data_last_i        : std_logic;
  signal wr_port_data_be_i          : std_logic_vector(C_CACHE_DATA_WIDTH/8 - 1 downto 0);
  signal wr_port_data_word_i        : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Write Response Handling
  
  signal bp_pop                     : std_logic;
  signal bp_valid                   : std_logic;
  signal bp_ready                   : std_logic;
  signal bp_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
  signal bp_fifo_mem                : BP_FIFO_MEM_TYPE; -- := (others=>C_NULL_BP);
  signal bp_fifo_empty              : std_logic;
  signal bp_early                   : std_logic;
  signal bp_barrier                 : std_logic;
  signal S_AXI_BVALID_I             : std_logic;
  signal update_ext_bresp_ready_i   : std_logic;
  signal bp_fifo_full_i             : std_logic;
  signal bp_assert                  : std_logic;
  
  
  -- ---------------------------------------------------
  -- Internal Interface Signals (Hazard).
  
  signal snoop_act_set_read_hazard : std_logic;
  signal snoop_act_rst_read_hazard : std_logic;
  signal snoop_act_read_hazard     : std_logic;
  signal snoop_act_kill_locked     : std_logic;
  signal snoop_act_kill_by_snoop   : std_logic;
  signal snoop_act_already_killed  : std_logic;
  signal snoop_act_just_done       : std_logic;
  signal snoop_act_kill_addr       : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
  
  signal read_data_fetch_addr      : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
  signal read_data_req_addr        : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
  signal read_data_act_addr        : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
    
  signal read_data_req_match       : std_logic;
  signal read_data_act_match       : std_logic;
  signal read_data_ongoing         : std_logic;
  signal read_data_block_nested    : std_logic;
  signal read_data_release_block   : std_logic;
  signal read_data_fetch_line_match: std_logic;
  signal read_data_req_line_match  : std_logic;
  signal read_data_act_line_match  : std_logic;
  
  signal read_data_fud_we          : std_logic;
  signal read_data_fud_addr        : std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
  signal read_data_fud_tag_valid   : std_logic;
  signal read_data_fud_tag_unique  : std_logic;
  signal read_data_fud_tag_secure  : std_logic;
  signal read_data_fud_tag_dirty   : std_logic;
  
  
  -- ---------------------------------------------------
  -- Snoop signals (Read Data & response).
  
  signal snoop_read_data_ready_i    : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ---------------------------------------------------
  -- Lookup signals (Read Data).
  
  signal lookup_read_data_ready_i   : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ---------------------------------------------------
  -- Update signals (Read Data).
  
  signal update_read_data_ready_i   : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal sync_assert                : std_logic;
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
begin  -- architecture IMP
  
  
  -- Create internal signal with maximum width.
  S_AXI_ARADDR_I <= fit_vec(S_AXI_ARADDR, C_MAX_ADDR_WIDTH);
  S_AXI_AWADDR_I <= fit_vec(S_AXI_AWADDR, C_MAX_ADDR_WIDTH);
  
  -----------------------------------------------------------------------------
  -- Transform Input data
  -----------------------------------------------------------------------------
  
  Gen_Input_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    snoop_req_complete_target(I)  <= snoop_req_info(0).Complete_Target(I);
    snoop_info_tag_valid(I)       <= snoop_tag_status_info(0, I).Valid; -- TODO: Really need one vector for each block
    
  end generate Gen_Input_Array;
  
  
  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Slave Bus Interface (AW and AR)
  -----------------------------------------------------------------------------
  
  -- Throttle inputs.
  -- No need to throttle write with WIP FIFO because it can never be deeper than BIP.
  S_AXI_AWVALID_I                 <= S_AXI_AWVALID and not bip_fifo_full;
  S_AXI_ARVALID_I                 <= S_AXI_ARVALID and read_req_ready;
  
  -- AW-Channel.
  wr_port_access_i.Valid          <= S_AXI_AWVALID_I;
  wr_port_access_i.ID             <= fit_vec(S_AXI_AWID, C_MAX_ID_WIDTH);
  wr_port_access_i.Addr           <= S_AXI_AWADDR_I;
  wr_port_access_i.Len            <= S_AXI_AWLEN;
  wr_port_access_i.Kind           <= C_KIND_WRAP  when S_AXI_AWBURST = C_AW_WRAP            else 
                                     C_KIND_INCR;
  wr_port_access_i.Exclusive      <= S_AXI_AWLOCK when C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 else
                                     '0';
  aw_allocate                     <= '1'          when C_S_AXI_FORCE_WRITE_ALLOCATE    /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_AWLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_WRITE_ALLOCATE /= 0 else
                                     S_AXI_AWCACHE(C_AWCACHE_WRITE_ALLOCATE_POS);
  aw_other_allocate               <= '1'          when C_S_AXI_FORCE_READ_ALLOCATE     /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_AWLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_READ_ALLOCATE  /= 0 else
                                     S_AXI_AWCACHE(C_AWCACHE_OTHER_ALLOCATE_POS);
  aw_is_wt                        <= ( aw_allocate or aw_other_allocate ) and
                                     ( not wr_port_access_i.Bufferable  ) when is_mst_coherent(C_ENABLE_COHERENCY) else
                                     '0';
  wr_port_access_i.Allocate       <= aw_allocate       and not aw_is_wt;
  wr_port_access_i.Other_Allocate <= aw_other_allocate and not aw_is_wt;
  wr_port_access_i.Bufferable     <= '1'          when C_S_AXI_FORCE_WRITE_BUFFER      /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_AWLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_WRITE_BUFFER   /= 0 else
                                     S_AXI_AWCACHE(C_AWCACHE_BUFFERABLE_POS);
  wr_port_access_i.Modifiable     <= S_AXI_AWCACHE(C_AWCACHE_MODIFIABLE_POS);
  wr_port_access_i.Prot           <= S_AXI_AWPROT;
  wr_port_access_i.Snoop          <= S_AXI_AWSNOOP;
  wr_port_access_i.Barrier        <= S_AXI_AWBAR;
  wr_port_access_i.Domain         <= S_AXI_AWDOMAIN;
  wr_port_access_i.Size           <= S_AXI_AWSIZE;
  wr_port_access                  <= wr_port_access_i;
  S_AXI_AWREADY_I                 <= wr_port_ready and not bip_fifo_full;
  S_AXI_AWREADY                   <= S_AXI_AWREADY_I;
  
  -- AR-Channel.
  rd_port_access_i.Valid          <= S_AXI_ARVALID_I;
  rd_port_access_i.ID             <= fit_vec(S_AXI_ARID, C_MAX_ID_WIDTH);
  rd_port_access_i.Addr           <= S_AXI_ARADDR_I;
  rd_port_access_i.Kind           <= C_KIND_WRAP  when S_AXI_ARBURST = C_AR_WRAP            else 
                                     C_KIND_INCR;
  rd_port_access_i.Exclusive      <= S_AXI_ARLOCK when C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 else
                                     '0';
  ar_allocate                     <= '1'          when C_S_AXI_FORCE_READ_ALLOCATE     /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_ARLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_READ_ALLOCATE  /= 0 else
                                     S_AXI_ARCACHE(C_ARCACHE_READ_ALLOCATE_POS);
  ar_other_allocate               <= '1'          when C_S_AXI_FORCE_WRITE_ALLOCATE    /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_ARLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_WRITE_ALLOCATE /= 0 else
                                     S_AXI_ARCACHE(C_ARCACHE_OTHER_ALLOCATE_POS);
  ar_is_wt                        <= ( ar_allocate or ar_other_allocate ) and
                                     ( not rd_port_access_i.Bufferable  ) when is_mst_coherent(C_ENABLE_COHERENCY) else
                                     '0';
  rd_port_access_i.Allocate       <= ar_allocate       and not ar_is_wt;
  rd_port_access_i.Other_Allocate <= ar_other_allocate and not ar_is_wt;
  rd_port_access_i.Bufferable     <= '1'          when C_S_AXI_FORCE_READ_BUFFER       /= 0 else
                                     '1'          when is_mst_coherent(C_ENABLE_COHERENCY)  and
                                                       C_S_AXI_PROHIBIT_EXCLUSIVE       = 0 and
                                                       S_AXI_ARLOCK = '1'                   else
                                     '0'          when C_S_AXI_PROHIBIT_READ_BUFFER    /= 0 else
                                     S_AXI_ARCACHE(0);
  rd_port_access_i.Modifiable     <= S_AXI_ARCACHE(C_ARCACHE_MODIFIABLE_POS);
  rd_port_access_i.Prot           <= S_AXI_ARPROT;
  rd_port_access_i.Snoop          <= S_AXI_ARSNOOP;
  rd_port_access_i.Barrier        <= S_AXI_ARBAR;
  rd_port_access_i.Domain         <= S_AXI_ARDOMAIN;
  rd_port_access                  <= rd_port_access_i;
  S_AXI_ARREADY_I                 <= rd_port_ready and read_req_ready;
  S_AXI_ARREADY                   <= S_AXI_ARREADY_I;
  
  -- AR-Channel adjustable.
  External_Narrow: if( C_S_AXI_DATA_WIDTH < C_CACHE_DATA_WIDTH ) generate
  begin
    rd_port_access_i.Len        <= (C_RATIO_BITS - 1 downto 0=>'0') & S_AXI_ARLEN(8 - 1 downto C_RATIO_BITS);

    Adjust_Transaction: process (S_AXI_ARCACHE, S_AXI_ARLOCK, S_AXI_ARSIZE) is
    begin  -- process Gen_Rem_Len
      if( ( S_AXI_ARCACHE(2) = '0' ) and ( S_AXI_ARLOCK = '1' ) ) then
        rd_port_access_i.Size       <= S_AXI_ARSIZE;
      else
        rd_port_access_i.Size       <= std_logic_vector(to_unsigned(Log2(C_CACHE_DATA_WIDTH/8), 3));
      end if;
    end process Adjust_Transaction;
  end generate External_Narrow;
  
  External_Same: if( C_S_AXI_DATA_WIDTH = C_CACHE_DATA_WIDTH ) generate
  begin
    rd_port_access_i.Len        <= S_AXI_ARLEN;
    rd_port_access_i.Size       <= S_AXI_ARSIZE;
  end generate External_Same;
  
  
  -----------------------------------------------------------------------------
  -- Write Transaction Information Queue
  -- 
  -- Only needed when up-sizing.
  -- The address Offset is needed to start WSTRB at the correct position
  -- in the upsized data.
  -----------------------------------------------------------------------------
  
  No_WIP: if( C_CACHE_DATA_WIDTH = C_S_AXI_DATA_WIDTH ) generate
  begin
    wip_push        <= '0';
    wip_pop         <= '0';
    wip_refresh_reg <= '0';
    wip_exist       <= '1';
    wip_offset      <= C_NULL_WIP.Offset;
    wip_stp_bits    <= C_NULL_WIP.Offset;
    wip_use_bits    <= C_NULL_WIP.Offset;
    
    -- No WIP FIFO.
    wip_assert      <= '0';
    stat_s_axi_wip  <= C_NULL_STAT_FIFO;
    
  end generate No_WIP;
  
  Use_WIP: if( C_CACHE_DATA_WIDTH /= C_S_AXI_DATA_WIDTH ) generate
  
    signal access_is_incr   : std_logic;
    signal extended_length  : std_logic_vector(C_BYTE_LENGTH - 1 + 7 downto 0);
    signal access_byte_len  : AXI_ADDR_TYPE;
    signal use_bits_cmb     : ADDR_BYTE_TYPE;
    signal wip_fifo_mem_vec : ADDR_BYTE_TYPE;
    signal stp_bits_cmb     : ADDR_BYTE_TYPE;
    
  begin
    -- Control signals for write information queue.
    wip_push        <= S_AXI_AWVALID_I and wr_port_ready;
--    wip_pop         <= w_pop_safe and w_last;
    WC_And_Inst4: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => w_pop_safe,
        A         => w_last,
        Carry_OUT => wip_pop
      );
    
    FIFO_WIP_Pointer: sc_srl_fifo_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Configuration.
        C_PUSH_ON_CARRY           => false,
        C_POP_ON_CARRY            => true,
        C_ENABLE_PROTECTION       => false,
        C_USE_QUALIFIER           => false,
        C_QUALIFIER_LEVEL         => 0,
        C_USE_REGISTER_OUTPUT     => true,
        C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
        C_LINE_LENGTH             => 1
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET_I,
    
        -- ---------------------------------------------------
        -- Queue Counter Interface
        
        queue_push                => wip_push,
        queue_pop                 => wip_pop,
        queue_push_qualifier      => '0',
        queue_pop_qualifier       => '0',
        queue_refresh_reg         => wip_refresh_reg,
        
        queue_almost_full         => open,
        queue_full                => open,
        queue_almost_empty        => open,
        queue_empty               => open,
        queue_exist               => wip_exist,
        queue_line_fit            => open,
        queue_index               => wip_read_fifo_addr,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_data                 => stat_s_axi_wip,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => wip_assert,
        
        
        -- ---------------------------------------------------
        -- Debug Signals
        
        DEBUG                     => open
      );
      
    -- Predecode.
    access_is_incr    <= '1' when S_AXI_AWBURST = C_AW_INCR else '0';
    
    -- Handle memory for WIP Channel FIFO.
    FIFO_WIP_Memory : process (ACLK) is
    begin  -- process FIFO_WIP_Memory
      if (ACLK'event and ACLK = '1') then    -- rising clock edge
        if ( wip_push = '1') then
          -- Insert new item.
          wip_fifo_mem(0).Offset  <= S_AXI_AWADDR_I(C_ADDR_BYTE_POS);
          wip_fifo_mem(0).Incr    <= access_is_incr;
          wip_fifo_mem(0).Size    <= S_AXI_AWSIZE;
          wip_fifo_mem(0).Len     <= S_AXI_AWLEN;
          
          -- Shift FIFO contents.
          wip_fifo_mem(wip_fifo_mem'left downto 1) <= wip_fifo_mem(wip_fifo_mem'left-1 downto 0);
        end if;
      end if;
    end process FIFO_WIP_Memory;
    
    -- Extend the length vector (help signal).
    extended_length   <= fit_vec("0000000000" & wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Len & "1111111", C_BYTE_LENGTH - 1 + 8);
    
    -- Create Use/Stp vectors.
    Gen_Real_Len: process (wip_fifo_mem, wip_read_fifo_addr, extended_length) is
    begin  -- process Gen_Real_Len
      access_byte_len <= (others=>'0');
      case wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Size is
        when C_BYTE_SIZE          =>
          access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        when C_HALF_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 16 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_HALF_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_WORD_SIZE          =>
          if( C_S_AXI_DATA_WIDTH >= 32 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_DOUBLE_WORD_SIZE   =>
          if( C_S_AXI_DATA_WIDTH >= 64 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_DOUBLE_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_QUAD_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 128 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_QUAD_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_OCTA_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 256 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_OCTA_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_HEXADECA_WORD_SIZE =>
          if( C_S_AXI_DATA_WIDTH >= 512 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_HEXADECA_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when others               =>
          if( C_S_AXI_DATA_WIDTH >= 1024 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_TRIACONTADI_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
      end case;
    end process Gen_Real_Len;

    wip_fifo_mem_vec <= (others => wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Incr);
    use_bits_cmb <= access_byte_len(C_ADDR_BYTE_POS) or 
                    wip_fifo_mem_vec;
    
    Gen_Stp_Info: process (wip_fifo_mem, wip_read_fifo_addr) is
    begin  -- process Gen_Stp_Info
      case wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Size is
        when C_BYTE_SIZE          =>
          stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
        when C_HALF_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 16 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_WORD_SIZE          =>
          if( C_S_AXI_DATA_WIDTH >= 32 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_DOUBLE_WORD_SIZE   =>
          if( C_S_AXI_DATA_WIDTH >= 64 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE,          C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_QUAD_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 128 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_OCTA_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 256 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_HEXADECA_WORD_SIZE =>
          if( C_S_AXI_DATA_WIDTH >= 512 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE,        C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when others               =>
          if( C_S_AXI_DATA_WIDTH >= 1024 ) then
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE,     C_ADDR_BYTE_BITS));
          else
            stp_bits_cmb  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
      end case;
    end process Gen_Stp_Info;
    
    -- Store WIP in register for good timing.
    WIP_Data_Registers : process (ACLK) is
    begin  -- process WIP_Data_Registers
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          wip_offset    <= C_NULL_WIP.Offset;
          wip_stp_bits  <= C_NULL_WIP.Offset;
          wip_use_bits  <= C_NULL_WIP.Offset;
        elsif( wip_refresh_reg = '1' ) then
          wip_offset    <= wip_fifo_mem(to_integer(unsigned(wip_read_fifo_addr))).Offset;
          wip_stp_bits  <= stp_bits_cmb;
          wip_use_bits  <= use_bits_cmb;
        end if;
      end if;
    end process WIP_Data_Registers;
    
  end generate Use_WIP;
  
  
  -----------------------------------------------------------------------------
  -- Write Queue Handling
  -- 
  -- Queue write data. Assuming the AW and W information is available at the
  -- same time there are at least three clock cycles available for 
  -- pre-processing and timing enhancements.
  -----------------------------------------------------------------------------
  
  -- Control signals for read data queue.
  w_push          <= S_AXI_WVALID;
  w_push_safe     <= w_push and not w_fifo_full;
--  w_pop           <= ( w_ready or not wr_port_data_valid_i ) and wip_exist;
--  w_pop_safe      <= w_pop and not w_fifo_empty;
  WC_Or_Inst2: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_ready,
      A_N       => wr_port_data_valid_i,
      Carry_OUT => w_pop_part
    );
  WC_And_Inst2: carry_and 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_pop_part,
      A         => wip_exist,
      Carry_OUT => w_pop
    );
  WC_And_Inst3: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => w_pop,
      A_N       => w_fifo_empty,
      Carry_OUT => w_pop_safe
    );
  
  FIFO_W_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => true,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => w_push,
      queue_pop                 => w_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => w_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => w_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => w_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_w,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => w_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for R Channel FIFO.
  FIFO_W_Memory : process (ACLK) is
  begin  -- process FIFO_W_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( w_push_safe = '1') then
        -- Insert new item.
        w_fifo_mem(0).Last  <= S_AXI_WLAST;
        w_fifo_mem(0).BE    <= S_AXI_WSTRB;
        w_fifo_mem(0).Data  <= S_AXI_WDATA;
        
        -- Shift FIFO contents.
        w_fifo_mem(w_fifo_mem'left downto 1) <= w_fifo_mem(w_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_W_Memory;
  
  -- Forward ready.
  S_AXI_WREADY_I  <= not w_fifo_full;
  S_AXI_WREADY    <= S_AXI_WREADY_I;
  
  -- Rename signals.
  w_valid         <= ( not w_fifo_empty ) and wip_exist;
  w_last          <= w_fifo_mem(to_integer(unsigned(w_read_fifo_addr))).Last;
  w_be            <= w_fifo_mem(to_integer(unsigned(w_read_fifo_addr))).BE;
  w_data          <= w_fifo_mem(to_integer(unsigned(w_read_fifo_addr))).Data;
  
  
  -----------------------------------------------------------------------------
  -- Write Complete tracking
  -- 
  -- Use quadruple normal queue size to avoid need to check full, impossible
  -- to get quadruple the amount of completed compared to W Queue.
  -----------------------------------------------------------------------------
  
  wc_push <= w_push_safe and     S_AXI_WLAST;
  wc_pop  <= bp_pop      and not bp_barrier;
  
  FIFO_WC_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => false,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => 2 + C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => wc_push,
      queue_pop                 => wc_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => open,
      queue_almost_empty        => open,
      queue_empty               => wc_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => open,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => open,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => open,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  
  -----------------------------------------------------------------------------
  -- Write Data Handling
  -- 
  -- Assign internal interface signals with data from the port. The data is 
  -- mirrored if the internal data is wider than external.
  -- WSTRB is assigned to the currently active word in the upsized data.
  -- 
  -----------------------------------------------------------------------------
  
  -- Simply forward Write data if internal width is same as interface.
  No_Write_Mirror: if( C_CACHE_DATA_WIDTH = C_S_AXI_DATA_WIDTH ) generate
  begin
    wr_port_data_be_i   <= w_be;
    wr_port_data_word_i <= w_data;
  end generate No_Write_Mirror;
  
  -- Mirror Write data if internal width larger than interface.
  Use_Write_Mirror: if( C_CACHE_DATA_WIDTH /= C_S_AXI_DATA_WIDTH ) generate
    subtype C_RATIO_BITS_POS  is natural range C_ADDR_BYTE_HI downto C_ADDR_BYTE_HI - C_RATIO_BITS + 1;
    subtype RATIO_BITS_TYPE   is std_logic_vector(C_RATIO_BITS_POS);
    
    signal first_w_word       : std_logic;
    signal write_offset       : ADDR_BYTE_TYPE;
    signal write_next_offset  : ADDR_BYTE_TYPE;
    signal write_offset_cnt   : ADDR_BYTE_TYPE;
  begin
    -- Select current offset.
    write_offset <= wip_offset when ( first_w_word = '1' ) else write_offset_cnt;
    
    -- Generate next offset including wrap.
    Update_Offset_Select: process (write_offset, wip_stp_bits, wip_use_bits, wip_offset) is
      variable offset_cnt_next_cmb  : ADDR_BYTE_TYPE;
    begin  -- process Update_Offset_Select
      offset_cnt_next_cmb     := std_logic_vector(unsigned(write_offset) + unsigned(wip_stp_bits));
      
      for N in offset_cnt_next_cmb'range loop
        if( wip_use_bits(N) = '0' ) then
          write_next_offset(N)  <= wip_offset(N);
          
        else
          write_next_offset(N)  <= offset_cnt_next_cmb(N);
          
        end if;
      end loop;
    end process Update_Offset_Select;
    
    -- Handle next offset that should be used.
    Write_Miss_Part_Handler : process (ACLK) is
    begin  -- process Write_Miss_Part_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          first_w_word      <= '1';
          write_offset_cnt  <= (others=>'0');
        else
          if ( w_pop_safe and w_last ) = '1' then
            first_w_word      <= '1';
          elsif ( w_pop_safe ) = '1' then
            first_w_word      <= '0';
            write_offset_cnt  <= write_next_offset;
          end if;
        end if;
      end if;
    end process Write_Miss_Part_Handler;
    
    Gen_Write_Mirror: for N in 0 to C_CACHE_DATA_WIDTH / C_S_AXI_DATA_WIDTH - 1 generate
    begin
      -- Generate mirrored data and steer byte enable.
      wr_port_data_be_i((N+1) * C_S_AXI_DATA_WIDTH / 8 - 1 downto N * C_S_AXI_DATA_WIDTH / 8) 
                          <= w_be when ( to_integer(unsigned(write_offset(C_RATIO_BITS_POS))) = N ) 
                             else (others=>'0');
      wr_port_data_word_i((N+1) * C_S_AXI_DATA_WIDTH - 1 downto N * C_S_AXI_DATA_WIDTH)       <= w_data;
      
    end generate Gen_Write_Mirror;
  end generate Use_Write_Mirror;
  
  Write_Data_Output : process (ACLK) is
  begin  -- process Write_Data_Output
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        wr_port_data_valid_i      <= '0';
        wr_port_data_last_i       <= '1';
        wr_port_data_info(0).BE   <= (C_MAX_DATA_WIDTH / 8 - 1 downto 0=>'0');
        wr_port_data_info(0).Data <= (C_MAX_DATA_WIDTH - 1 downto 0=>'0');
      elsif( w_pop = '1' ) then
        wr_port_data_valid_i      <= w_valid;
        wr_port_data_last_i       <= w_last;
        wr_port_data_info(0).BE   <= fit_vec(wr_port_data_be_i, C_MAX_DATA_WIDTH / 8);
        wr_port_data_info(0).Data <= fit_vec(wr_port_data_word_i, C_MAX_DATA_WIDTH);
      elsif( wr_port_data_ready(0) = '1' ) then
        wr_port_data_valid_i      <= '0';
      end if;
    end if;
  end process Write_Data_Output;
  
  -- Assign output.
  wr_port_data_info(0).Valid  <= wr_port_data_valid_i;
  wr_port_data_info(0).Last   <= wr_port_data_last_i;
  
  -- Forward ready.
--  w_ready     <= wr_port_data_ready;
  WC_Or_Inst1: carry_or 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => '0',
      A         => wr_port_data_ready(0),
      Carry_OUT => w_ready
    );
  
  
  -----------------------------------------------------------------------------
  -- Control R-Channel
  -- 
  -- Generate signals for the R-Channel handling. Most signals are directly
  -- from the input of constants for the current configuration.
  -- 
  -----------------------------------------------------------------------------
  
  -- Setup information for R-Channel
  read_req_valid  <= S_AXI_ARVALID_I and rd_port_ready;
  read_req_ID     <= S_AXI_ARID;
  read_req_single <= S_AXI_ARLOCK and not S_AXI_ARCACHE(2) when ( C_S_AXI_DATA_WIDTH < C_CACHE_DATA_WIDTH ) else 
                     '0';
  read_req_dvm    <= '1' when ( S_AXI_ARSNOOP = C_ACSNOOP_DVMComplete ) or 
                              ( S_AXI_ARSNOOP = C_ACSNOOP_DVMMessage  ) else 
                     '0';
  read_req_addr   <= S_AXI_ARADDR_I(C_Lx_ADDR_DIRECT_POS);
  read_req_rest   <= S_AXI_ARLEN(C_REST_WIDTH - 2 - 1 downto 0) & "00";
  read_req_offset <= S_AXI_ARADDR_I(C_ADDR_BYTE_POS);
  read_req_len    <= S_AXI_ARLEN(C_LEN_POS);
  
  Req_Same_Width: if( C_CACHE_DATA_WIDTH = C_S_AXI_DATA_WIDTH ) generate
  begin
    read_req_stp    <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE, C_ADDR_BYTE_BITS));
    read_req_use    <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE * C_Lx_CACHE_LINE_LENGTH - 1, C_ADDR_BYTE_BITS));
    
  end generate Req_Same_Width;
  
  Req_Wider_Width: if( C_CACHE_DATA_WIDTH /= C_S_AXI_DATA_WIDTH ) generate
  
    signal access_is_incr   : std_logic;
    signal extended_length  : std_logic_vector(C_BYTE_LENGTH - 1 + 7 downto 0);
    signal access_byte_len  : AXI_ADDR_TYPE;
    signal use_bits_cmb     : ADDR_BYTE_TYPE;
    signal req_incr_vec     : ADDR_BYTE_TYPE;
    signal stp_bits_cmb     : ADDR_BYTE_TYPE;
    
  begin
      
    -- Predecode.
    access_is_incr    <= '1' when S_AXI_ARBURST = C_AR_INCR else '0';
    
    -- Extend the length vector (help signal).
    extended_length   <= fit_vec("0000000000" & S_AXI_ARLEN & "1111111", C_BYTE_LENGTH - 1 + 8);
    
    -- Create Use/Stp vectors.
    Gen_Real_Len: process (S_AXI_ARSIZE, extended_length) is
    begin  -- process Gen_Real_Len
      access_byte_len <= (others=>'0');
      case S_AXI_ARSIZE is
        when C_BYTE_SIZE          =>
          access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
        when C_HALF_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 16 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_HALF_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_WORD_SIZE          =>
          if( C_S_AXI_DATA_WIDTH >= 32 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_DOUBLE_WORD_SIZE   =>
          if( C_S_AXI_DATA_WIDTH >= 64 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_DOUBLE_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_QUAD_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 128 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_QUAD_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_OCTA_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 256 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_OCTA_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when C_HEXADECA_WORD_SIZE =>
          if( C_S_AXI_DATA_WIDTH >= 512 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_HEXADECA_WORD_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
        when others               =>
          if( C_S_AXI_DATA_WIDTH >= 1024 ) then
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_TRIACONTADI_MASK_POS);
          else
            access_byte_len(C_ADDR_LENGTH_POS)  <= extended_length(C_BYTE_MASK_POS);
          end if;
      end case;
    end process Gen_Real_Len;

    req_incr_vec <= (others => access_is_incr);
    read_req_use <= access_byte_len(C_ADDR_BYTE_POS) or 
                    req_incr_vec;
    
    Gen_Stp_Info: process (S_AXI_ARSIZE) is
    begin  -- process Gen_Stp_Info
      case S_AXI_ARSIZE is
        when C_BYTE_SIZE          =>
          read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
        when C_HALF_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 16 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_WORD_SIZE          =>
          if( C_S_AXI_DATA_WIDTH >= 32 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_DOUBLE_WORD_SIZE   =>
          if( C_S_AXI_DATA_WIDTH >= 64 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE,          C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_QUAD_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 128 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_OCTA_WORD_SIZE     =>
          if( C_S_AXI_DATA_WIDTH >= 256 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE,            C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when C_HEXADECA_WORD_SIZE =>
          if( C_S_AXI_DATA_WIDTH >= 512 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE,        C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
        when others               =>
          if( C_S_AXI_DATA_WIDTH >= 1024 ) then
            read_req_stp  <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE,     C_ADDR_BYTE_BITS));
          else
            read_req_stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE,                 C_ADDR_BYTE_BITS));
          end if;
      end case;
    end process Gen_Stp_Info;
    
  end generate Req_Wider_Width;
  
  R_Channel: sc_s_axi_r_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      C_S_AXI_ID_WIDTH          => C_S_AXI_ID_WIDTH,
      C_S_AXI_RRESP_WIDTH       => C_S_AXI_RRESP_WIDTH,
      
      -- Configuration.
      C_SUPPORT_SUBSIZED        => false,
      C_LEN_WIDTH               => C_LEN_WIDTH,
      C_REST_WIDTH              => C_REST_WIDTH,
      
      -- Data type and settings specific.
      C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_POS'high,
      C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_POS'low,
      C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_POS'high,
      C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_ENABLE_HAZARD_HANDLING  => C_ENABLE_HAZARD_HANDLING,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- R-Channel
      S_AXI_RID                 => S_AXI_RID,
      S_AXI_RDATA               => S_AXI_RDATA,
      S_AXI_RRESP               => S_AXI_RRESP,
      S_AXI_RLAST               => S_AXI_RLAST_I,
      S_AXI_RVALID              => S_AXI_RVALID_I,
      S_AXI_RREADY              => S_AXI_RREADY,
      S_AXI_RACK                => S_AXI_RACK,
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            => read_req_valid,
      read_req_ID               => read_req_ID,
      read_req_last             => '1',
      read_req_failed           => '0',
      read_req_single           => read_req_single,
      read_req_dvm              => read_req_dvm,
      read_req_addr             => read_req_addr,
      read_req_rest             => read_req_rest,
      read_req_offset           => read_req_offset,
      read_req_stp              => read_req_stp,
      read_req_use              => read_req_use,
      read_req_len              => read_req_len,
      read_req_ready            => read_req_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_ready             => rd_port_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      => lookup_read_data_new,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Hazard).
      
      snoop_req_piperun         => snoop_req_piperun,
      snoop_act_set_read_hazard => snoop_act_set_read_hazard,
      snoop_act_rst_read_hazard => snoop_act_rst_read_hazard,
      snoop_act_read_hazard     => snoop_act_read_hazard,
      snoop_act_kill_locked     => snoop_act_kill_locked,
      snoop_act_kill_by_snoop   => snoop_act_kill_by_snoop,
      snoop_act_kill_addr       => snoop_act_kill_addr,
      
      read_data_fetch_addr      => read_data_fetch_addr,
      read_data_req_addr        => read_data_req_addr,
      read_data_act_addr        => read_data_act_addr,
      
      read_data_fetch_match     => open,
      read_data_req_match       => read_data_req_match,
      read_data_act_match       => read_data_act_match,
      read_data_ongoing         => read_data_ongoing,
      read_data_block_nested    => read_data_block_nested,
      read_data_release_block   => read_data_release_block,
      read_data_fetch_line_match=> read_data_fetch_line_match,
      read_data_req_line_match  => read_data_req_line_match,
      read_data_act_line_match  => read_data_act_line_match,
      
      read_data_fud_we          => read_data_fud_we,
      read_data_fud_addr        => read_data_fud_addr,
      read_data_fud_tag_valid   => read_data_fud_tag_valid,
      read_data_fud_tag_unique  => read_data_fud_tag_unique,
      read_data_fud_tag_dirty   => read_data_fud_tag_dirty,
      read_data_fud_tag_secure  => read_data_fud_tag_secure,
      
      read_trans_comp_info      => read_trans_comp_info,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          => read_info_status,
      read_data_status          => read_data_status,
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      => snoop_read_data_info,
      snoop_read_data_ready     => snoop_read_data_ready_i,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     => lookup_read_data_info,
      lookup_read_data_ready    => lookup_read_data_ready_i,
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     => update_read_data_info,
      update_read_data_ready    => update_read_data_ready_i,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_rip            => stat_s_axi_rip,
      stat_s_axi_r              => stat_s_axi_r,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => r_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => RIF_DEBUG 
    );
  
  S_AXI_RVALID            <= S_AXI_RVALID_I;
  S_AXI_RLAST             <= S_AXI_RLAST_I;
  
  snoop_read_data_ready   <= snoop_read_data_ready_i;
  lookup_read_data_ready  <= lookup_read_data_ready_i;
  update_read_data_ready  <= update_read_data_ready_i;
  
  
  -----------------------------------------------------------------------------
  -- Write Information Queue Handling
  -- 
  -- Push all control information needed into the queue to be able to do the 
  -- port specific modifications of the returned response.
  -----------------------------------------------------------------------------
  
  -- Control signals for read data queue.
  bip_push    <= S_AXI_AWVALID_I and wr_port_ready;
  bip_pop     <= bp_pop;
  
  FIFO_BIP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => bip_push,
      queue_pop                 => bip_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => bip_fifo_full,
      queue_almost_empty        => open,
      queue_empty               => open,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => bip_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_bip,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bip_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for RIP Channel FIFO.
  FIFO_BIP_Memory : process (ACLK) is
  begin  -- process FIFO_BIP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( bip_push = '1') then
        -- Insert new item.
        bip_fifo_mem(0).ID      <= S_AXI_AWID;
        
        -- Shift FIFO contents.
        bip_fifo_mem(bip_fifo_mem'left downto 1) <= bip_fifo_mem(bip_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BIP_Memory;
  
  -- Get ID.
  bip_id                <= bip_fifo_mem(to_integer(unsigned(bip_read_fifo_addr))).ID;
  
  
  -----------------------------------------------------------------------------
  -- Write Response Handling
  -- 
  -- Store Write Response Hit/Miss information with ID in a queue.
  -- 
  -- Hit are forwarded directly where as Miss has to wait for a BRESP from the 
  -- external memory.
  -- 
  -- Clock and hold the BRESP until it is acknowledged from AXI.
  -----------------------------------------------------------------------------
  
  -- Generate control signals.
  bp_pop      <= bp_valid and bp_ready;

  FIFO_BP_Pointer: sc_srl_fifo_counter
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Configuration.
      C_PUSH_ON_CARRY           => false,
      C_POP_ON_CARRY            => false,
      C_ENABLE_PROTECTION       => false,
      C_USE_QUALIFIER           => false,
      C_QUALIFIER_LEVEL         => 0,
      C_USE_REGISTER_OUTPUT     => false,
      C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
      C_LINE_LENGTH             => 1
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                => access_bp_push(0).Valid,
      queue_pop                 => bp_pop,
      queue_push_qualifier      => '0',
      queue_pop_qualifier       => '0',
      queue_refresh_reg         => open,
      
      queue_almost_full         => open,
      queue_full                => bp_fifo_full_i,
      queue_almost_empty        => open,
      queue_empty               => bp_fifo_empty,
      queue_exist               => open,
      queue_line_fit            => open,
      queue_index               => bp_read_fifo_addr,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_data                 => stat_s_axi_bp,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => bp_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     => open
    );
    
  -- Handle memory for Write Miss FIFO.
  FIFO_BP_Memory : process (ACLK) is
  begin  -- process FIFO_BP_Memory
    if (ACLK'event and ACLK = '1') then    -- rising clock edge
      if ( access_bp_push(0).Valid = '1' ) then
        -- Insert new item.
        bp_fifo_mem(0).Early    <= access_bp_push(0).Early;
        bp_fifo_mem(0).Barrier  <= access_bp_push(0).Barrier;
        
        -- Shift FIFO contents.
        bp_fifo_mem(bp_fifo_mem'left downto 1) <= bp_fifo_mem(bp_fifo_mem'left-1 downto 0);
      end if;
    end if;
  end process FIFO_BP_Memory;
  
  -- Mux response on per port basis.
  bp_early    <= bp_fifo_mem(to_integer(unsigned(bp_read_fifo_addr))).Early;
  bp_barrier  <= bp_fifo_mem(to_integer(unsigned(bp_read_fifo_addr))).Barrier;
  
  -- Generate valid for both hit and miss.
  bp_valid  <= ( ( bp_early and not wc_fifo_empty ) or 
                 ( bp_early and     bp_barrier    ) or 
                 ( update_ext_bresp_info(0).Valid and not bp_early ) ) and 
               not bp_fifo_empty;
                                     
  Write_Response_Handler : process (ACLK) is
  begin  -- process Write_Response_Handler
    if (ACLK'event and ACLK = '1') then   -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active high)
        S_AXI_BVALID_I  <= '0';
        S_AXI_BRESP     <= (others=>'0');
        S_AXI_BID       <= (others=>'0');
      else
        -- Turn off when the data is acknowledged.
        if( bp_ready = '1' ) then
          S_AXI_BVALID_I  <= '0';
        end if;
        
        -- Start new when information is available.
        if( ( bp_valid and bp_ready ) = '1' ) then
          S_AXI_BVALID_I  <= '1';
          S_AXI_BID       <= bip_id;
          if( bp_early = '1' ) then
            S_AXI_BRESP     <= C_BRESP_OKAY;
          else
            S_AXI_BRESP     <= update_ext_bresp_info(0).BRESP;
          end if;
        end if;
      end if;
    end if;
  end process Write_Response_Handler;
  
  -- Generate internal ready signal.
  bp_ready                  <= S_AXI_BREADY or not S_AXI_BVALID_I;
  
  -- Return ready when able to use miss BRESP.
  update_ext_bresp_ready(0) <= update_ext_bresp_ready_i;
  update_ext_bresp_ready_i  <= bp_ready and not bp_early and not bp_fifo_empty;
  
  -- Rename the internal valid signal.
  S_AXI_BVALID              <= S_AXI_BVALID_I;
  
  
  -----------------------------------------------------------------------------
  -- Coherency support
  -----------------------------------------------------------------------------
  
  No_Coherency: if( not is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    -- Internal interfaces:
    
    read_data_fetch_addr      <= (others=>'0');
    read_data_req_addr        <= (others=>'0');
    read_data_act_addr        <= (others=>'0');
    
    snoop_fetch_pos_hazard    <= (others=>'0');
    
    snoop_act_set_read_hazard <= '0';
    snoop_act_rst_read_hazard <= '0';
    snoop_act_read_hazard     <= '0';
    snoop_act_kill_locked     <= '0';
    snoop_act_kill_by_snoop   <= '0';
    snoop_act_kill_addr       <= (others=>'0');
    
    snoop_act_tag_info(0)     <= C_NULL_SNOOP_ACT_TAG;
    
    snoop_act_ack_info(0)     <= C_NULL_SNOOP_ACT_ACK;
    
    snoop_tag_new_info(0)     <= C_NULL_SNOOP_TAG;
    
    snoop_resp_info(0)        <= C_NULL_SNOOP_CRRESP;
    
    snoop_data_info(0)        <= C_NULL_SNOOP_DATA;
      
    
    -- External interfaces:
    
    -- AC-Channel (coherency only)
    S_AXI_ACVALID             <= '0';
    S_AXI_ACADDR              <= (others=>'0');
    S_AXI_ACSNOOP             <= (others=>'0');
    S_AXI_ACPROT              <= "010";               -- Normal and non-secure Data access only

    -- CR-Channel (coherency only)
    S_AXI_CRREADY             <= '0';

    -- CD-Channel (coherency only)
    S_AXI_CDREADY             <= '0';
    
    -- No_Debug
    IF_DEBUG(255                  downto  74) <= (others=>'0');
    
  end generate No_Coherency;
  
  Use_Coherency: if( is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  
    -- ----------------------------------------
    -- Snoop Filter Fetch
    
    signal snoop_fetch_addr_i         : Lx_ADDR_LINE_TYPE;
    signal snoop_fetch_pos_hazard_i   : std_logic;
    
    -- ----------------------------------------
    -- Snoop Request Evaluation
    
    signal snoop_req_tag_valid        : std_logic;
    signal snoop_req_tag_locked       : std_logic;
    signal snoop_req_tag_dirty        : std_logic;
    signal snoop_req_tag_unique       : std_logic;
    signal snoop_req_tag_secure       : std_logic;
    signal snoop_req_tag_addr         : Lx_TAG_ADDR_TYPE;
    signal snoop_req_current_tag      : Lx_TAG_TYPE;
    
    signal snoop_req_tag_overwritten  : std_logic;
    signal snoop_req_new_tag_valid    : std_logic;
    signal snoop_req_new_tag_dirty    : std_logic;
    signal snoop_req_new_tag_unique   : std_logic;
    signal snoop_req_new_tag_secure   : std_logic;
    signal snoop_req_new_tag_addr     : Lx_TAG_ADDR_TYPE;
    
    signal snoop_req_tag_hit          : std_logic;
    signal snoop_req_hit              : std_logic;
    signal snoop_req_hazard           : std_logic;
    signal snoop_req_prot_access      : std_logic;
    signal snoop_req_fud_protected    : std_logic;
    
    
    -- ----------------------------------------
    -- Snoop Update
    
    signal snoop_update_we_i          : std_logic;
    signal snoop_update_we            : std_logic_vector(0 downto 0);
    signal snoop_update_addr          : Lx_ADDR_LINE_TYPE;
    signal snoop_update_tag_valid     : std_logic;
    signal snoop_update_tag_lock      : std_logic;
    signal snoop_update_tag_dirty     : std_logic;
    signal snoop_update_tag_unique    : std_logic;
    signal snoop_update_tag_secure    : std_logic;
    signal snoop_update_tag_addr      : Lx_TAG_ADDR_TYPE;
    signal snoop_update_new_tag       : Lx_TAG_TYPE;
    signal snoop_update_new_tag_valid : std_logic;
    signal snoop_update_new_tag_lock  : std_logic;
    signal snoop_update_new_tag_dirty : std_logic;
    signal snoop_update_new_tag_unique: std_logic;
    signal snoop_update_new_tag_secure: std_logic;
    signal snoop_update_new_tag_addr  : Lx_TAG_ADDR_TYPE;
    
    
    -- ----------------------------------------
    -- Snoop Action
    
    signal snoop_act_tag_valid_i      : std_logic;
    signal snoop_act_tag_locked_i     : std_logic;
    signal snoop_act_tag_dirty_i      : std_logic;
    signal snoop_act_tag_unique_i     : std_logic;
    signal snoop_act_tag_secure_i     : std_logic;
    signal snoop_act_tag_addr_i       : Lx_TAG_ADDR_TYPE;
    signal snoop_act_wait_for_pipe    : std_logic;
    signal snoop_act_completed_ac     : std_logic;
    signal snoop_act_want_ac          : std_logic;
    signal snoop_act_waiting_4_cr     : std_logic;
    signal snoop_act_current_num_ac   : natural range 0 to 15;
    signal snoop_act_allowed_ac       : std_logic;
    signal snoop_act_read_blocked     : std_logic;
    signal snoop_act_ac_hazard        : std_logic;
    signal snoop_act_ac_safe          : std_logic;
    signal snoop_act_ac_cmb_done      : std_logic;
    signal snoop_act_ac_done          : std_logic;
    signal snoop_act_cr_done          : std_logic;
    signal S_AXI_ACVALID_I            : std_logic;
    signal snoop_act_done_i           : std_logic;
    signal snoop_act_fud_we           : std_logic;
    signal snoop_act_fud_valid        : std_logic;
    signal snoop_act_fud_hit          : std_logic;
    signal snoop_act_fud_protected    : std_logic;
    signal snoop_act_release_prot     : std_logic;
    signal snoop_act_fud_want_valid   : std_logic;
    signal snoop_act_fud_want_invalid : std_logic;
    signal snoop_act_fud_want_unique  : std_logic;
    signal snoop_act_fud_want_shared  : std_logic;
    signal snoop_act_fud_want_clean   : std_logic;
    signal snoop_act_write_blocking_i : std_logic;
    signal snoop_act_tag_collision    : std_logic;
    
    signal crresp_keep                : std_logic;
    signal crresp_pass_dirty          : std_logic;
    signal snoop_act_fud_make_valid   : std_logic;
    signal snoop_act_fud_make_invalid : std_logic;
    signal snoop_act_fud_make_unique  : std_logic;
    signal snoop_act_fud_make_shared  : std_logic;
    signal snoop_act_fud_make_clean   : std_logic;
    
    
    -- ----------------------------------------
    -- Read Data Filter Update
    
    signal snoop_read_data_filter_we  : std_logic;
    
    
    -- ----------------------------------------
    -- Snoop Response
    
    signal ari_push                   : std_logic;
    signal ari_pop                    : std_logic;
    signal ari_fifo_full              : std_logic;
    signal ari_fifo_empty             : std_logic;
    signal ari_read_fifo_addr         : QUEUE_ADDR_TYPE:= (others=>'1');
    signal ari_fifo_mem               : ARI_FIFO_MEM_TYPE; -- := (others=>C_NULL_ARI);
    signal ari_assert                 : std_logic;

    signal current_resp_info          : SNOOP_CRRESP_TYPE;
    signal snoop_resp_info_i          : SNOOP_CRRESP_TYPE;
    
    
    -- ----------------------------------------
    -- Sync Handling
    
    subtype C_COMPLETE_POS              is natural range C_NUM_PORTS - 2 downto 0;
    
    subtype COMPLETE_TYPE               is std_logic_vector(C_COMPLETE_POS);

    constant complete_one_vec         : COMPLETE_TYPE := (others => '1');

    signal snoop_req_complete_done    : std_logic;
    signal snoop_act_ac_complete      : std_logic;
    signal snoop_req_comp_with_cur    : COMPLETE_TYPE;
    signal complete_request_detected  : COMPLETE_TYPE;
    
    signal snoop_act_ac_read_once     : std_logic;
    signal snoop_act_no_filter_ac     : std_logic;
    
  begin
    
    -----------------------------------------------------------------------------
    -- Snoop Filter Fetch
    -----------------------------------------------------------------------------
    
    -- Extract line address bits.
    snoop_fetch_addr_i  <= snoop_fetch_info(0).Addr(C_Lx_ADDR_LINE_POS);
    
    -- No filter.
    No_Filter: if( C_NO_SNOOP_FILTER ) generate
    begin
      snoop_req_current_tag <= (others=>'0');
      
    end generate No_Filter;
    
    -- Snoop filter instantiation.
    One_Liner: if( ( Lx_ADDR_LINE_TYPE'length = 0 ) and ( not C_NO_SNOOP_FILTER ) ) generate
    begin
      One_Line_Filter_Handler : process (ACLK) is
        variable my_tag   : Lx_TAG_TYPE;
      begin  -- process One_Line_Filter_Handler
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            my_tag  := (others=>'0');
            
          else
            if( snoop_fetch_piperun(0) = '1' ) then
              -- "Port A" - Read only
              snoop_req_current_tag <= my_tag;
            end if;
            if( ( snoop_update_we_i = '1' ) and ( snoop_update_we = "1" ) ) then
              -- "Port B" - Write only
              my_tag                := snoop_update_new_tag;
            end if;
          end if;
        end if;
      end process One_Line_Filter_Handler;
    
    end generate One_Liner;
    Use_Multi: if( ( Lx_ADDR_LINE_TYPE'length /= 0 ) and ( not C_NO_SNOOP_FILTER ) ) generate
    begin
      Filter: sc_ram_module 
        generic map(
          C_TARGET                  => C_TARGET,
          C_WE_A_WIDTH              => 1,
          C_DATA_A_WIDTH            => C_Lx_TAG_SIZE,
          C_ADDR_A_WIDTH            => Lx_ADDR_LINE_TYPE'length,
          C_WE_B_WIDTH              => 1,
          C_DATA_B_WIDTH            => C_Lx_TAG_SIZE,
          C_ADDR_B_WIDTH            => Lx_ADDR_LINE_TYPE'length,
          C_FORCE_BRAM              => false,
          C_FORCE_LUTRAM            => false
        )
        port map(
          -- PORT A
          CLKA                      => ACLK,
          ENA                       => snoop_fetch_piperun(0),
          WEA                       => "0",
          ADDRA                     => snoop_fetch_addr_i,
          DATA_INA                  => (C_Lx_TAG_POS=>'0'),
          DATA_OUTA                 => snoop_req_current_tag,
          -- PORT B
          CLKB                      => ACLK,
          ENB                       => snoop_update_we_i,
          WEB                       => snoop_update_we,
          ADDRB                     => snoop_update_addr,
          DATA_INB                  => snoop_update_new_tag,
          DATA_OUTB                 => open
        );
      
    end generate Use_Multi;
    
    
    -----------------------------------------------------------------------------
    -- Snoop Request Evaluation
    -----------------------------------------------------------------------------
    
    -- Extract TAG bits
    snoop_req_tag_valid     <= snoop_req_current_tag(C_Lx_TAG_VALID_POS);
    snoop_req_tag_locked    <= snoop_req_current_tag(C_Lx_TAG_LOCKED_POS);
    snoop_req_tag_dirty     <= snoop_req_current_tag(C_Lx_TAG_DIRTY_POS);
    snoop_req_tag_unique    <= snoop_req_current_tag(C_Lx_TAG_UNIQUE_POS);
    snoop_req_tag_secure    <= snoop_req_current_tag(C_Lx_TAG_SECURE_POS) when ( C_ENABLE_NON_SECURE > 0 ) else '0';
    snoop_req_tag_addr      <= snoop_req_current_tag(C_Lx_TAG_ADDR_POS);
    
    -- Detect Locked Hazard.
    snoop_req_prot_access   <= '1' when ( ( snoop_req_info(0).Wr = '1' ) or 
                                          ( snoop_req_info(0).Snoop = C_ACSNOOP_CleanInvalid ) ) else
                               '0';
    snoop_req_fud_protected <= snoop_req_hit and snoop_req_prot_access and snoop_req_tag_locked and 
                               not snoop_req_tag_overwritten;
    
    -- Detect tag and snoop hit.
    snoop_req_tag_hit       <= snoop_req_tag_valid when ( snoop_req_info(0).Addr(C_Lx_ADDR_TAG_POS) = 
                                                          snoop_req_tag_addr ) and
                                                        ( not C_NO_SNOOP_FILTER ) else 
                               '0';
    snoop_req_hit           <= ( ( snoop_req_tag_hit and snoop_req_info(0).Want ) or 
                                 ( snoop_req_info(0).Always ) ) and 
                               snoop_req_info(0).Valid;
    
    
    -- Move Snoop Request to Snoop Update (Information).
    Snoop_Update_Handler : process (ACLK) is
    begin  -- process Snoop_Update_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_fud_valid         <= '0';
          snoop_act_fud_hit           <= '0';
          snoop_act_fud_want_valid    <= '0';
          snoop_act_fud_want_invalid  <= '0';
          snoop_act_fud_want_unique   <= '0';
          snoop_act_fud_want_shared   <= '0';
          snoop_act_fud_want_clean    <= '0';
          snoop_act_ac_complete       <= '0';
          snoop_act_ac_read_once      <= '0';
          snoop_act_no_filter_ac      <= '0';
          
        elsif( snoop_req_piperun(0) = '1' ) then
          -- Set Filter Update acording to request.
          snoop_act_fud_valid         <= snoop_req_hit or 
                                         ( snoop_req_info(0).Valid and snoop_req_info(0).Update_Filter and 
                                           not b2s(C_NO_SNOOP_FILTER) );
          snoop_act_fud_hit           <= snoop_req_hit;
          
          -- Default assignment
          snoop_act_fud_want_valid    <= '0';
          snoop_act_fud_want_invalid  <= '0';
          snoop_act_fud_want_unique   <= '0';
          snoop_act_fud_want_shared   <= '0';
          snoop_act_fud_want_clean    <= '0';
          snoop_act_ac_read_once      <= '0';
          snoop_act_no_filter_ac      <= '0';
          
          -- Transfer
          snoop_act_ac_complete       <= snoop_req_info(0).Valid and 
                                         ( snoop_req_info(0).Complete and snoop_req_complete_done );
          
          -- AR an AC snoop has the same encoding (use AC where possible).
          case snoop_req_info(0).Snoop is
            when C_ACSNOOP_ReadOnce           =>
              -- A ReadOnce has special handling to snoop Peer caches since it will not affect the cache line status.
              -- A barrier has the same Snoop value and must be ignored for this purpose.
              if( snoop_req_info(0).Barrier = '0' ) then
                snoop_act_ac_read_once      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself;
              end if;
              
            when C_ACSNOOP_ReadShared         =>
              -- Allocate myself and make others shared.
              snoop_act_fud_want_valid    <= snoop_req_info(0).Myself;
              snoop_act_fud_want_shared   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and not snoop_req_info(0).Myself;
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_ReadClean          =>
              -- Allocate myself and make others shared.
              snoop_act_fud_want_valid    <= snoop_req_info(0).Myself;
              snoop_act_fud_want_shared   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and not snoop_req_info(0).Myself;
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_ReadNotSharedDirty =>
              -- Allocate myself and make others shared.
              snoop_act_fud_want_valid    <= snoop_req_info(0).Myself;
              snoop_act_fud_want_shared   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and not snoop_req_info(0).Myself;
              snoop_act_fud_want_clean    <= int_to_std(C_S_AXI_SUPPORT_DIRTY)  and
                                             ( not snoop_req_info(0).Myself );
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_ReadUnique         =>
              -- Make invalid except for myself.
              snoop_act_fud_want_valid    <= snoop_req_info(0).Myself;
              snoop_act_fud_want_unique   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and     snoop_req_info(0).Myself;
              snoop_act_fud_want_invalid  <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and not snoop_req_info(0).Myself;
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ARSNOOP_CleanUnique        =>
              -- Fake AR Snoop in order to update Snoop filter to reflect that this transaction 
              -- need special handling in order to make the Line Unique.
              -- Make myself unique, invalidate others.
              snoop_act_fud_want_unique   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and     snoop_req_info(0).Myself;
              snoop_act_fud_want_invalid  <= ( not snoop_req_info(0).Myself );
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ARSNOOP_MakeUnique         =>
              -- Fake AR Snoop in order to update Snoop filter to reflect that this transaction 
              -- need special handling in order to make the Line Unique.
              -- Make myself unique, invalidate others (dumping their potential Dirty contents).
              snoop_act_fud_want_unique   <= int_to_std(C_S_AXI_SUPPORT_UNIQUE) and     snoop_req_info(0).Myself;
              snoop_act_fud_want_invalid  <= ( not snoop_req_info(0).Myself );
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_CleanShared        =>
              -- Force others to write a dirty line.
              snoop_act_fud_want_clean    <= int_to_std(C_S_AXI_SUPPORT_DIRTY)  and
                                             ( not snoop_req_info(0).Myself );
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_CleanInvalid       =>
              -- Make all cached copies invalid and write dirty data to memory.
              snoop_act_fud_want_invalid  <= '1';
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_MakeInvalid        =>
              -- Make all caches invalid ignore dirty data.
              snoop_act_fud_want_invalid  <= '1';
              snoop_act_no_filter_ac      <= snoop_req_info(0).Valid and not snoop_req_info(0).Myself and 
                                             b2s(C_NO_SNOOP_FILTER) and not snoop_req_info(0).Init_Cmd;
              
            when C_ACSNOOP_DVMComplete        =>
              -- No Filter changes.
              null;
              
            when C_ACSNOOP_DVMMessage         =>
              -- No Filter changes.
              null;
              
            when others                       =>
              -- Illegal operation.
              null;
              
          end case;
          
        else
          -- Remember effect of CRRESP information.
          if( current_resp_info.Valid = '1' ) then
            snoop_act_fud_want_valid    <= snoop_act_fud_make_valid;
            snoop_act_fud_want_invalid  <= snoop_act_fud_make_invalid;
            snoop_act_fud_want_unique   <= snoop_act_fud_make_unique;
            snoop_act_fud_want_shared   <= snoop_act_fud_make_shared;
            snoop_act_fud_want_clean    <= snoop_act_fud_make_clean;
            
          end if;
          
          if( snoop_act_piperun(0) = '1' ) then
            -- When transaction leaves stage restore valid signal.
            snoop_act_fud_valid         <= '0';
            snoop_act_ac_complete       <= '0';
            snoop_act_ac_read_once      <= '0';
            snoop_act_no_filter_ac      <= '0';
            
          end if;
        end if;
      end if;
    end process Snoop_Update_Handler;
  
    
    -- Protect Locked cache line.
    Snoop_Protect_Handler : process (ACLK) is
    begin  -- process Snoop_Protect_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_fud_protected    <= '0';
          
        elsif( snoop_req_piperun(0) = '1' ) then
          -- Set protection when.
          snoop_act_fud_protected    <= snoop_req_fud_protected;
          
        elsif( snoop_act_release_prot = '1' ) then
          -- Release protection when conflict is solved.
          snoop_act_fud_protected    <= '0';
          
        end if;
      end if;
    end process Snoop_Protect_Handler;
    
    -- Move Snoop Request to Snoop Action (Information).
    Pipeline_Stage_Snoop_Act : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_tag_valid_i   <= '0';
          snoop_act_tag_locked_i  <= '0';
          snoop_act_tag_dirty_i   <= '0';
          snoop_act_tag_unique_i  <= '0';
          snoop_act_tag_secure_i  <= '0';
          snoop_act_tag_addr_i    <= (others=>'0');
          snoop_act_just_done     <= '0';
          
        elsif( snoop_req_piperun(0) = '1' ) then
          if( snoop_req_tag_overwritten = '1' ) then
            -- Tag has been updated while transaction has been stalling in Req, new
            -- values need to be used.
            snoop_act_tag_valid_i   <= snoop_req_new_tag_valid;
            snoop_act_tag_locked_i  <= '0';
            snoop_act_tag_dirty_i   <= snoop_req_new_tag_dirty;
            snoop_act_tag_unique_i  <= snoop_req_new_tag_unique;
            snoop_act_tag_secure_i  <= snoop_req_new_tag_secure;
            snoop_act_tag_addr_i    <= snoop_req_new_tag_addr;
            
          else
            -- Ordinary pipeline flow.
            snoop_act_tag_valid_i   <= snoop_req_tag_valid;
            snoop_act_tag_locked_i  <= snoop_req_tag_locked;
            snoop_act_tag_dirty_i   <= snoop_req_tag_dirty;
            snoop_act_tag_unique_i  <= snoop_req_tag_unique;
            snoop_act_tag_secure_i  <= snoop_req_tag_secure;
            snoop_act_tag_addr_i    <= snoop_req_tag_addr;
            
          end if;
          
          snoop_act_just_done     <= read_data_req_line_match and read_data_fud_we;
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act;
    
    -- Handle situation where data in req is superseded by read data FUD.
    Pipeline_Stage_Snoop_Overwrite : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Overwrite
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_req_tag_overwritten <= '0';
          snoop_req_new_tag_valid   <= '0';
          snoop_req_new_tag_dirty   <= '0';
          snoop_req_new_tag_unique  <= '0';
          snoop_req_new_tag_secure  <= '0';
          snoop_req_new_tag_addr    <= (others=>'0');
          
        else
          -- Data handling.
          if( ( ( read_data_req_line_match   = '1' ) and ( snoop_read_data_filter_we = '1' ) ) or 
              ( ( read_data_fetch_line_match = '1' ) and ( snoop_read_data_filter_we = '1' ) and 
                ( snoop_fetch_info(0).Myself = '1' ) ) ) then
            -- Remember that the Tag has just been updated by read data FUD.
            snoop_req_new_tag_valid   <= read_data_fud_tag_valid;
            snoop_req_new_tag_dirty   <= read_data_fud_tag_dirty;
            snoop_req_new_tag_unique  <= read_data_fud_tag_unique;
            snoop_req_new_tag_secure  <= read_data_fud_tag_secure;
            snoop_req_new_tag_addr    <= read_data_fud_addr(C_Lx_ADDR_TAG_POS);
            
          end if;
          
          -- Control handling.
          if( ( read_data_req_line_match = '1' ) and ( snoop_read_data_filter_we = '1' ) ) then
            -- Remember that the Tag has just been updated by read data FUD.
            snoop_req_tag_overwritten <= '1';
            
          elsif( snoop_fetch_piperun(0) = '1' ) then
            -- Refreshing my own snoop filter will not stall.
            snoop_req_tag_overwritten <= read_data_fetch_line_match and snoop_read_data_filter_we and 
                                         snoop_fetch_info(0).Myself;
            
          elsif( snoop_req_piperun(0) = '1' ) then
            -- Refreshing my own snoop filter will not stall.
            snoop_req_tag_overwritten <= '0';
            
          end if;
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Overwrite;
    
    -- Forward address to be checked for hazards.
    read_data_fetch_addr  <= snoop_fetch_info(0).Addr(C_Lx_ADDR_DIRECT_POS);
    read_data_req_addr    <= snoop_req_info(0).Addr(C_Lx_ADDR_DIRECT_POS);
    read_data_act_addr    <= snoop_act_info(0).Addr(C_Lx_ADDR_DIRECT_POS);
    
    -- Determine if this transaction is a hazard in next pipe stage.
    snoop_req_hazard      <= '1' when ( snoop_req_info(0).Valid = '1' )                    and 
                                      ( read_data_req_match     = '1' )                    and
                                      ( snoop_req_info(0).Snoop /= C_ACSNOOP_DVMComplete ) and 
                                      ( snoop_req_info(0).Snoop /= C_ACSNOOP_DVMMessage )  else
                             '0';
    
    -- Move Snoop Request to Snoop Action (Hazard).
    Pipeline_Stage_Snoop_Act_Hazard_AC : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Hazard_AC
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_ac_hazard     <= '0';
          snoop_act_read_blocked  <= '0';
          
        elsif( snoop_req_piperun(0) = '1' ) then
          if( ( ( snoop_req_hazard = '1' ) and 
                ( ( read_data_ongoing = '1' ) or ( read_data_block_nested = '1' ) ) ) or
              ( snoop_req_fud_protected = '1' ) ) then
            snoop_act_ac_hazard     <= '1';
            snoop_act_read_blocked  <= read_data_block_nested;
          else
            snoop_act_ac_hazard     <= '0';
            snoop_act_read_blocked  <= '0';
          end if;
          
        elsif( snoop_act_piperun(0) = '1' ) then
          snoop_act_ac_hazard     <= '0';
          snoop_act_read_blocked  <= '0';
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Hazard_AC;
    
    -- Set and reset condition for Act Read Hazard.
    snoop_act_set_read_hazard <= snoop_req_hazard and not read_data_ongoing and not read_data_block_nested;
    snoop_act_rst_read_hazard <= (     snoop_act_fud_protected ) or
                                 ( not snoop_act_want_ac ) or
                                 (     snoop_act_want_ac and snoop_act_completed_ac and not snoop_act_waiting_4_cr );
    
    Pipeline_Stage_Snoop_Act_Read_AC : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Read_AC
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_read_hazard <= '0';
          
        elsif( snoop_req_piperun(0) = '1' ) then
          snoop_act_read_hazard <= snoop_act_set_read_hazard;
          
        elsif( snoop_act_rst_read_hazard = '1' ) then
          snoop_act_read_hazard <= '0';
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Read_AC;
    
    -- Track outstanding AR transaction.
    Pipeline_Stage_Snoop_Act_Track_AC : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Read_AC
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_waiting_4_cr    <= '0';
          snoop_act_current_num_ac  <= 0;
          
        else
          if( ( (S_AXI_ACVALID_I and S_AXI_ACREADY) = '1' ) and ( ari_push = '0' ) ) then
            snoop_act_waiting_4_cr    <= '1';
            snoop_act_current_num_ac  <= snoop_act_current_num_ac + 1;
          elsif( ( (S_AXI_ACVALID_I and S_AXI_ACREADY) = '0' ) and ( ari_push = '1' ) ) then
            if( snoop_act_current_num_ac = 1 ) then
              snoop_act_waiting_4_cr    <= '0';
            end if;
            snoop_act_current_num_ac  <= snoop_act_current_num_ac - 1;
          end if;
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Track_AC;
    
    Pipeline_Stage_Snoop_Act_Killing : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Killing
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then             -- synchronous reset (active high)
          snoop_act_already_killed  <= '0';
          
        else
          if( snoop_req_piperun(0) = '1' ) then
            snoop_act_already_killed  <= '0';
            
          elsif( snoop_act_kill_by_snoop = '1' ) then
            snoop_act_already_killed  <= '1';
            
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Killing;
    
    
    -- Determine when it is safe to snoop.
    snoop_act_ac_safe       <= ( ( not snoop_act_ac_hazard ) or
                                 (     snoop_act_ac_hazard and     snoop_act_read_blocked and read_data_release_block ) or
                                 (     snoop_act_ac_hazard and not read_data_ongoing ) ) and
                               ( ( not snoop_act_fud_protected ) or 
                                 (     snoop_act_fud_protected and snoop_act_release_prot ) );
    
    
    snoop_act_release_prot  <= snoop_read_data_filter_we when 
                                      read_data_fud_addr(C_Lx_ADDR_LINE_POS) = snoop_act_info(0).Addr(C_Lx_ADDR_LINE_POS) else
                               '0';
    
    -- Determine if a cache line has been reused (killed).
    snoop_act_kill_locked   <= snoop_act_info(0).Valid and snoop_act_info(0).Myself and not snoop_act_info(0).Wr and 
                               snoop_act_fud_we and snoop_act_tag_locked_i and not snoop_act_just_done and 
                               not ( snoop_act_tag_collision and read_data_act_line_match ) and 
                               not snoop_act_info(0).Waiting_4_Pipe;
    
    -- Detect if a Peer cache snooping me will have an affect on my allocation.
    snoop_act_kill_by_snoop <= snoop_act_info(0).Valid and 
                               ( not snoop_act_info(0).Myself         ) and       -- Peer cache
                               ( not snoop_act_info(0).Wr             ) and       -- From read channel
                               (     snoop_act_fud_we                 ) and       -- Updating filter
                               (     (     read_data_act_match      and
                                           snoop_act_tag_valid_i    and
                                           current_resp_info.Valid  and 
                                       not crresp_keep              and           -- CRRESP informs that L1 has removed line
                                       not snoop_act_info(0).AnyDVM ) ) and       -- Cannot be DVM message.
                               ( not snoop_act_just_done              ) and       -- 
                               ( not snoop_act_already_killed         ) and       -- Only once per Act cycle
                               ( not ( snoop_act_tag_collision      and 
                                       read_data_act_line_match     ) );          -- No collision between Read and Act
    
    -- Kill address is always Act address.
    snoop_act_kill_addr     <= snoop_act_info(0).Addr(C_Lx_ADDR_DIRECT_POS);
    
    
    -----------------------------------------------------------------------------
    -- Snoop Update
    -- 
    -- Update the snoop filter according to current transaction/snoop. The info 
    -- handled are: Valid, Unique/Shared, Dirty/Clean and address.
    -- 
    -----------------------------------------------------------------------------
    
    -- Decode CRRESP values.
    crresp_keep                 <= current_resp_info.Valid and
                                   current_resp_info.CRRESP(C_CRRESP_ISSHARED_POS);
    crresp_pass_dirty           <= current_resp_info.Valid and
                                   current_resp_info.CRRESP(C_CRRESP_PASSDIRTY_POS);
    
    -- Modify desired Transaction manipulation with CR information.
    snoop_act_fud_make_valid   <= snoop_act_fud_want_valid and 
                                  not ( current_resp_info.Valid and not crresp_keep );
    snoop_act_fud_make_invalid <= snoop_act_fud_want_invalid or
                                      ( current_resp_info.Valid and not crresp_keep and not snoop_act_info(0).AnyDVM );
    snoop_act_fud_make_unique  <= snoop_act_fud_want_unique;
    snoop_act_fud_make_shared  <= snoop_act_fud_want_shared;
    snoop_act_fud_make_clean   <= snoop_act_fud_want_clean or
                                      ( crresp_pass_dirty );
    
    
    -- Determine if snoop filter should indeed be updated.
    snoop_update_we         <= (others=>snoop_update_we_i);
    snoop_update_we_i       <= snoop_read_data_filter_we or snoop_act_fud_we;
    snoop_act_fud_we        <= snoop_act_fud_valid and 
                               ( ( snoop_act_fud_make_valid   and 
                                   ( not snoop_act_tag_valid_i or not snoop_act_fud_hit )    ) or
                                 ( snoop_act_fud_make_invalid and     snoop_act_tag_valid_i  ) or
                                 ( snoop_act_fud_make_clean   and     snoop_act_tag_valid_i  ) or
                                 ( snoop_act_fud_make_unique  and not snoop_act_tag_unique_i ) or
                                 ( snoop_act_fud_make_shared  and     snoop_act_tag_unique_i ) );
    
    -- Get address for current Tag.
    snoop_update_addr       <= read_data_fud_addr(C_Lx_ADDR_LINE_POS) when (snoop_read_data_filter_we  = '1' ) else
                               snoop_act_info(0).Addr(C_Lx_ADDR_LINE_POS);
    
    -- Generate new Tag contents.
    snoop_update_tag_valid  <= ( snoop_act_fud_make_valid or snoop_act_tag_valid_i ) and 
                               not snoop_act_fud_make_invalid;
    snoop_update_tag_lock   <= snoop_act_fud_make_valid and 
                               not snoop_act_fud_hit;
    snoop_update_tag_dirty  <= snoop_act_tag_dirty_i and 
                               not snoop_act_fud_make_clean;
    snoop_update_tag_unique <= ( ( snoop_act_fud_make_valid and 
                                   not reduce_or_except(snoop_info_tag_valid, C_PORT_NUM) ) or 
                                 ( snoop_act_fud_make_unique ) ) and 
                                int_to_std(C_S_AXI_SUPPORT_UNIQUE);
    snoop_update_tag_secure <= snoop_act_info(0).Prot(C_PROT_SECURE_POS) when ( snoop_act_fud_make_valid = '1' ) else 
                               snoop_act_tag_secure_i;
    snoop_update_tag_addr   <= snoop_act_info(0).Addr(C_Lx_ADDR_TAG_POS) when ( snoop_act_fud_make_valid = '1' ) else 
                               snoop_act_tag_addr_i;
    
    Gen_Filter_Tag: process (snoop_update_tag_valid, snoop_update_tag_dirty, snoop_update_tag_unique, 
                             snoop_update_tag_addr, snoop_update_tag_lock, snoop_update_tag_secure, 
                             snoop_read_data_filter_we, read_data_fud_tag_valid, read_data_fud_tag_secure, 
                             read_data_fud_tag_dirty, read_data_fud_tag_unique, read_data_fud_addr) is
    begin  -- process Gen_Filter_Tag
      if( snoop_read_data_filter_we = '1' ) then
        -- Modification by allocating read moving to master.
        snoop_update_new_tag_valid  <= read_data_fud_tag_valid;
        snoop_update_new_tag_lock   <= '0';
        
        if( C_S_AXI_SUPPORT_DIRTY /= 0 ) then
          snoop_update_new_tag_dirty  <= read_data_fud_tag_dirty;
        else
          snoop_update_new_tag_dirty  <= '0';
        end if;
        
        if( C_S_AXI_SUPPORT_UNIQUE /= 0 ) then
          snoop_update_new_tag_unique <= read_data_fud_tag_unique;
        else
          snoop_update_new_tag_unique <= '0';
        end if;
        
        if( C_ENABLE_NON_SECURE /= 0 ) then
          snoop_update_new_tag_secure <= read_data_fud_tag_secure;
        else
          snoop_update_new_tag_secure <= '0';
        end if;
        
        snoop_update_new_tag_addr   <= read_data_fud_addr(C_Lx_ADDR_TAG_POS);
      else
        -- Direct modification by pipeline.
        snoop_update_new_tag_valid  <= snoop_update_tag_valid;
        snoop_update_new_tag_lock   <= snoop_update_tag_lock;
        
        if( C_S_AXI_SUPPORT_DIRTY /= 0 ) then
          snoop_update_new_tag_dirty  <= snoop_update_tag_dirty;
        else
          snoop_update_new_tag_dirty  <= '0';
        end if;
        
        if( C_S_AXI_SUPPORT_UNIQUE /= 0 ) then
          snoop_update_new_tag_unique <= snoop_update_tag_unique;
        else
          snoop_update_new_tag_unique <= '0';
        end if;
        
        if( C_ENABLE_NON_SECURE /= 0 ) then
          snoop_update_new_tag_secure <= snoop_update_tag_secure;
        else
          snoop_update_new_tag_secure <= '0';
        end if;
        
        snoop_update_new_tag_addr   <= snoop_update_tag_addr;
      end if;
    end process Gen_Filter_Tag;
    
    New_Tag_Handle: process (snoop_update_new_tag_valid, snoop_update_new_tag_lock, snoop_update_new_tag_dirty, 
                             snoop_update_new_tag_unique, snoop_update_new_tag_secure, snoop_update_new_tag_addr) is
    begin  -- process New_Tag_Handle
      -- Default value.
      snoop_update_new_tag                      <= (others=>'0');
      
      snoop_update_new_tag(C_Lx_TAG_VALID_POS)  <= snoop_update_new_tag_valid;
      snoop_update_new_tag(C_Lx_TAG_LOCKED_POS) <= snoop_update_new_tag_lock;
      
      if( C_S_AXI_SUPPORT_DIRTY /= 0 ) then
        snoop_update_new_tag(C_Lx_TAG_DIRTY_POS)  <= snoop_update_new_tag_dirty;
      end if;
      
      if( C_S_AXI_SUPPORT_UNIQUE /= 0 ) then
        snoop_update_new_tag(C_Lx_TAG_UNIQUE_POS) <= snoop_update_new_tag_unique;
      end if;
      
      if( C_ENABLE_NON_SECURE /= 0 ) then
        snoop_update_new_tag(C_Lx_TAG_SECURE_POS) <= snoop_update_new_tag_secure;
      end if;
      
      snoop_update_new_tag(C_Lx_TAG_ADDR_POS)   <= snoop_update_new_tag_addr;
    end process New_Tag_Handle;
    
    -- Forward end value.
    snoop_tag_new_info(0).Valid  <= snoop_update_tag_valid;
    snoop_tag_new_info(0).Unique <= snoop_update_tag_unique;
    snoop_tag_new_info(0).Dirty  <= snoop_update_tag_dirty;
    snoop_tag_new_info(0).Secure <= snoop_update_tag_secure;
    
    
    -----------------------------------------------------------------------------
    -- Snoop Action
    -----------------------------------------------------------------------------
    
    -- Make sure Action is only performed once.
    Pipeline_Stage_Snoop_Act_Wait : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Wait
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_wait_for_pipe <= '0';
          snoop_act_completed_ac  <= '0';
        else
          if( snoop_act_piperun(0) = '1' ) then
            snoop_act_wait_for_pipe <= '0';
            snoop_act_completed_ac  <= '0';
          elsif( snoop_act_done_i = '1' ) then
            snoop_act_wait_for_pipe <= '1';
            snoop_act_completed_ac  <= snoop_act_allowed_ac;
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Wait;
    
    -- .
    Pipeline_Stage_Snoop_AC_Done : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_AC_Done
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_ac_done <= '0';
        else
          if( snoop_act_piperun(0) = '1' ) then
            snoop_act_ac_done <= '0';
          elsif( snoop_act_ac_cmb_done = '1' ) then
            snoop_act_ac_done <= '1';
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_AC_Done;
    
    -- Is there or has a transaction been completed.
    snoop_act_ack_info(0).Use_External  <= snoop_act_completed_ac or snoop_act_want_ac;
    
    -- Determine when Snoop should go external:
    --  * A valid update situation that is acted on, or
    --  * A DVM Complete needs has been collected.
    snoop_act_want_ac       <= ( snoop_act_fud_valid and 
                                 ( ( snoop_act_fud_we and not snoop_act_info(0).Myself ) or 
                                   ( snoop_act_info(0).Always                          ) ) ) or
                               ( snoop_act_ac_complete  ) or
                               ( snoop_act_no_filter_ac ) or
                               ( snoop_act_ac_read_once );
    snoop_act_allowed_ac    <= snoop_act_want_ac and snoop_act_ac_safe;
    S_AXI_ACVALID_I         <= snoop_act_allowed_ac and not snoop_act_ac_done;
    
    -- Forward AC snoop information.
    S_AXI_ACVALID           <= S_AXI_ACVALID_I;
    S_AXI_ACADDR            <= fit_vec(snoop_act_info(0).Addr, C_S_AXI_ADDR_WIDTH);
    S_AXI_ACSNOOP           <= snoop_act_info(0).Snoop;
    S_AXI_ACPROT            <= snoop_act_info(0).Prot;
    
    -- Channel handshakes signal.
    snoop_act_ac_cmb_done   <= ( S_AXI_ACVALID_I and S_AXI_ACREADY   );
    
    -- Determine when stage is done:
    --  * Acknowledged AC message, or
    --  * No external message at all.
    snoop_act_ack_info(0).Done  <= snoop_act_done_i;
    snoop_act_done_i            <= snoop_act_info(0).Valid and
                                   ( not snoop_act_tag_collision ) and 
                                   ( ( snoop_act_cr_done     and 
                                       snoop_act_ac_done     ) or
                                     ( not snoop_act_want_ac ) );
    
    -- Assign output.
    snoop_act_tag_info(0).Valid   <= snoop_act_tag_valid_i;
    snoop_act_tag_info(0).Dirty   <= snoop_act_tag_dirty_i;
    snoop_act_tag_info(0).Unique  <= snoop_act_tag_unique_i;
    snoop_act_tag_info(0).Secure  <= snoop_act_tag_secure_i;
    
    
    -----------------------------------------------------------------------------
    -- Snoop Response Handling
    -----------------------------------------------------------------------------
    
    -- Track and collect snoop response signals.
    Pipeline_Stage_Snoop_CR_Done : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_CR_Done
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_cr_done         <= '0';
          current_resp_info         <= C_NULL_SNOOP_CRRESP;
          
        else
          if( snoop_act_piperun(0) = '1' ) then
            snoop_act_cr_done         <= '0';
            current_resp_info.Valid   <= '0';
            
          elsif( ari_push = '1' ) then
            snoop_act_cr_done         <= '1';
            current_resp_info.Valid   <= '1';
            current_resp_info.CRRESP  <= S_AXI_CRRESP;
            
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_CR_Done;
    
    Use_Dirty_L1: if( C_ANY_SUPPORT_DIRTY > 0 ) generate
    begin
      -- Channel handshakes signal.
      S_AXI_CRREADY           <= not snoop_act_cr_done;
      
      -- Fake queue handling.
      ari_push                <= ( S_AXI_CRVALID and not snoop_act_cr_done );
      ari_pop                 <= '0';
      ari_fifo_full           <= '0';
      ari_fifo_empty          <= not snoop_act_cr_done;
      ari_read_fifo_addr      <= (others=>'0');
      ari_assert              <= '0';
      
      -- Only one Snoop response at the time.
      snoop_resp_info_i       <= current_resp_info;
      
    end generate Use_Dirty_L1;
    
    Use_Clean_L1: if( C_ANY_SUPPORT_DIRTY = 0 ) generate
    begin
-- OPTIMIZE: With a DVM AC->CR queue for DVM tracking the following stall calculation can be used:
-- "                                  ( ( ( snoop_act_cr_done or
--                                          ( snoop_act_info(0).AnyDVM and b2s( C_ANY_SUPPORT_DIRTY = 0 ) ) ) and 
--                                        snoop_act_ac_done ) or "
--    
-- it also requires:
--            snoop_act_cr_done         <= not cr_is_dvm; -- From queue
--
-- This will remove master stalls on CR for DVM propagating to the System Cache pipeline.

      -- CR-Channel (coherency only)
      -- Only write-through MicroBlaze is supported as master at this point, 
      -- ignore response except error information (since nothing can be dirty).
      S_AXI_CRREADY           <= not ari_fifo_full;

      -- Control signals for ACE Response Information queue.
      ari_push                <= S_AXI_CRVALID and not ari_fifo_full;
      ari_pop                 <= snoop_resp_ready(0) and not ari_fifo_empty;
      
      FIFO_ARI_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => ari_push,
          queue_pop                 => ari_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => ari_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => ari_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => ari_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_ari(I),
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => ari_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for ARI Channel FIFO.
      FIFO_ARI_Memory : process (ACLK) is
      begin  -- process FIFO_ARI_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( ari_push = '1' ) then
            -- Insert new item.
            ari_fifo_mem(0).Resp  <= S_AXI_CRRESP;
            
            -- Shift FIFO contents.
            ari_fifo_mem(ari_fifo_mem'left downto 1) <= ari_fifo_mem(ari_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_ARI_Memory;
      
      -- Extract data.
      snoop_resp_info_i.Valid  <= not ari_fifo_empty;
      snoop_resp_info_i.CRRESP <= ari_fifo_mem(to_integer(unsigned(ari_read_fifo_addr))).Resp;
      
    end generate Use_Clean_L1;
    
    -- Assign external.
    snoop_resp_info(0)  <= snoop_resp_info_i;
    
    
    -----------------------------------------------------------------------------
    -- Snoop Data Handling
    -----------------------------------------------------------------------------
    
    Use_Dirty_L1_Data: if( C_ANY_SUPPORT_DIRTY > 0 ) generate
      
      signal cd_push                    : std_logic;
      signal cd_pop                     : std_logic;
      signal cd_fifo_full               : std_logic;
      signal cd_fifo_empty              : std_logic;
      signal cd_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
      signal cd_fifo_mem                : INT_W_FIFO_MEM_TYPE; -- := (others=>C_NULL_INT_W);
      signal cd_assert                  : std_logic;
      
    begin
      -- Acknowledge data as long as there are room in the FIFO.
      S_AXI_CDREADY           <= not cd_fifo_full;
    
      -- Control signals for ACE Response Information queue.
      cd_push                 <= S_AXI_CDVALID and not cd_fifo_full;
      cd_pop                  <= snoop_data_ready(0) and not cd_fifo_empty;
      
      FIFO_CD_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => cd_push,
          queue_pop                 => cd_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => cd_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => cd_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => cd_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_cd(I),
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => cd_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for ARI Channel FIFO.
      FIFO_CD_Memory : process (ACLK) is
      begin  -- process FIFO_CD_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( cd_push = '1' ) then
            -- Insert new item.
            cd_fifo_mem(0).Last   <= S_AXI_CDLAST;
            cd_fifo_mem(0).Data   <= S_AXI_CDDATA;
            
            -- Shift FIFO contents.
            cd_fifo_mem(cd_fifo_mem'left downto 1) <= cd_fifo_mem(cd_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_CD_Memory;
      
      -- Extract data.
      snoop_data_info(0).Valid  <= not cd_fifo_empty;
      snoop_data_info(0).Last   <=         cd_fifo_mem(to_integer(unsigned(cd_read_fifo_addr))).Last;
      snoop_data_info(0).Data   <= fit_vec(cd_fifo_mem(to_integer(unsigned(cd_read_fifo_addr))).Data, C_MAX_DATA_WIDTH);
      
    end generate Use_Dirty_L1_Data;
    
    Use_Clean_L1_Data: if( C_ANY_SUPPORT_DIRTY = 0 ) generate
    begin
      -- CD-Channel (coherency only)
      -- Only write-through MicroBlaze is supported as master at this point, 
      -- ignore response since nothing can be dirty.
      S_AXI_CDREADY             <= '1';
      
      snoop_data_info(0).Valid  <= '0';
      snoop_data_info(0).Last   <= '1';
      snoop_data_info(0).Data   <= (others=>'0');
      
    end generate Use_Clean_L1_Data;
    
    
    -----------------------------------------------------------------------------
    -- Sync Handling
    -----------------------------------------------------------------------------
    
    -- Generate current complete collection.
    Complete_Handler : process (complete_request_detected, snoop_req_complete_target) is
    begin  -- process Complete_Handler
      for I in 0 to C_NUM_PORTS - 2 loop
        if( I >= C_NUM_OPTIMIZED_PORTS - 1 ) then
          snoop_req_comp_with_cur(I)  <= '1';
          
        elsif( I < C_PORT_NUM ) then
          snoop_req_comp_with_cur(I)  <= complete_request_detected(I) or snoop_req_complete_target(I);
          
        elsif( I >= C_PORT_NUM ) then
          snoop_req_comp_with_cur(I)  <= complete_request_detected(I) or snoop_req_complete_target(I+1);
          
        end if;
      end loop;
    end process Complete_Handler;
    
    -- Handle the tracking of Sync to all Complete received.
    Sync_Handler : process (ACLK) is
    begin  -- process Sync_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          complete_request_detected <= (others=>'1');
          for I in 0 to C_NUM_PORTS - 2 loop
            if( I >= C_NUM_OPTIMIZED_PORTS - 1 ) then
              complete_request_detected(I)  <= '1';
            end if;
          end loop;
          
        else
          if( ( snoop_fetch_piperun(0) = '1' ) and ( snoop_fetch_info(0).Valid = '1' ) and ( snoop_fetch_info(0).Sync = '1' ) )then
            complete_request_detected <= (others=>'0');
            
          elsif( ( snoop_req_piperun(0) = '1' ) and ( snoop_req_info(0).Complete = '1' ) ) then
            complete_request_detected <= snoop_req_comp_with_cur;
          end if;
        end if;
      end if;
    end process Sync_Handler;
    
    -- Determine if complete phase is done.
    snoop_req_complete_done <= snoop_req_info(0).Complete when ( snoop_req_comp_with_cur = complete_one_vec ) else 
                               '0';
    
    -- Detect condition where an illgal second Sync is issued before the first has completed.
    sync_assert             <= snoop_fetch_piperun(0) and snoop_fetch_info(0).Valid and snoop_fetch_info(0).Sync when 
                                      ( snoop_req_comp_with_cur /= complete_one_vec ) else 
                               '0';
    
    
    -----------------------------------------------------------------------------
    -- Read Data Filter Update
    -----------------------------------------------------------------------------
    
    -- Generate write signal.
    snoop_read_data_filter_we   <= read_data_fud_we;
    
    -- Stall pipe to make sure current is data is seen for next transaction.
    snoop_fetch_pos_hazard_i    <= (     read_data_fetch_line_match and 
                                         read_data_ongoing          and 
                                         snoop_fetch_info(0).Valid  and 
                                     not snoop_fetch_info(0).Myself ) or
                                   (     read_data_fetch_line_match and 
                                         snoop_fetch_info(0).Valid  and 
                                         snoop_fetch_info(0).Wr     and 
                                     not snoop_fetch_info(0).Myself );
    snoop_fetch_pos_hazard(0)   <= snoop_fetch_pos_hazard_i;
    
    -- Stall pipe
    snoop_act_write_blocking_i            <= read_data_req_line_match and snoop_read_data_filter_we;
    snoop_act_ack_info(0).Write_Blocking  <= snoop_act_write_blocking_i;
    
    -- Detect Collision in write to tag.
    snoop_act_tag_collision     <= ( snoop_act_fud_we and snoop_read_data_filter_we );
    
    
    -----------------------------------------------------------------------------
    -- Debug 
    -----------------------------------------------------------------------------
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      IF_DEBUG(255                  downto  74) <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
      constant C_MY_QCNT    : natural := min_of( 4, C_QUEUE_LENGTH_BITS);
      constant C_MY_TAG     : natural := min_of(16, C_Lx_NUM_ADDR_TAG_BITS);
      constant C_MY_ADDR    : natural := min_of(16, C_Lx_ADDR_LINE_HI - C_Lx_ADDR_LINE_LO + 1);
      constant C_MY_DADDR   : natural := min_of(28, C_Lx_ADDR_DIRECT_HI - C_Lx_ADDR_DIRECT_LO + 1);
      constant C_MY_PORT    : natural := min_of( 4, C_NUM_PORTS);
      constant C_MY_COMP    : natural := min_of( 3, C_NUM_PORTS - 1);
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            IF_DEBUG(255                  downto  74) <= (others=>'0');
          else
            -- Default assignment.
            IF_DEBUG(255                  downto  74) <= (others=>'0');
            
            IF_DEBUG(                             74) <= snoop_req_info(0).Valid;
            IF_DEBUG(                             75) <= snoop_req_info(0).Wr;
            IF_DEBUG(                             76) <= snoop_req_info(0).Myself;
            IF_DEBUG(                             77) <= snoop_req_info(0).Always;
            IF_DEBUG(                             78) <= snoop_req_info(0).Update_Filter;
            IF_DEBUG(                             79) <= snoop_req_info(0).Want;
            IF_DEBUG(                             80) <= snoop_act_info(0).Valid;
            IF_DEBUG(                             81) <= snoop_act_info(0).Myself;
            IF_DEBUG(                             82) <= snoop_act_info(0).Always;
            IF_DEBUG(                             83) <= snoop_act_tag_valid_i;
            IF_DEBUG(                             84) <= snoop_act_tag_dirty_i;
            IF_DEBUG(                             85) <= snoop_act_tag_unique_i;
            IF_DEBUG(                             86) <= snoop_act_done_i;
            IF_DEBUG(                             87) <= snoop_act_completed_ac or snoop_act_want_ac; -- snoop_act_ack_info(0).Use_External
            IF_DEBUG(                             88) <= not ari_fifo_empty;                          -- snoop_resp_info(0).Valid
            IF_DEBUG(                             89) <= snoop_resp_ready(0);
            IF_DEBUG(                             90) <= snoop_read_data_info(0).Valid;
            IF_DEBUG(                             91) <= snoop_read_data_info(0).Last;
            IF_DEBUG(                             92) <= snoop_read_data_ready_i(0);
            IF_DEBUG(                             93) <= ari_push;
            IF_DEBUG(                             94) <= ari_pop;
            IF_DEBUG(                             95) <= ari_fifo_full;
            IF_DEBUG(                             96) <= ari_fifo_empty;
            IF_DEBUG(                             97) <= ari_assert;
            IF_DEBUG(                             98) <= S_AXI_ACVALID_I;
            IF_DEBUG(                             99) <= snoop_act_want_ac;
            IF_DEBUG(                            100) <= snoop_act_completed_ac;
            IF_DEBUG(                            101) <= snoop_act_wait_for_pipe;
            IF_DEBUG(                            102) <= snoop_act_fud_valid;
            IF_DEBUG(                            103) <= snoop_act_fud_make_valid;
            IF_DEBUG(                            104) <= snoop_act_fud_make_invalid;
            IF_DEBUG(                            105) <= snoop_act_fud_make_unique;
            IF_DEBUG(                            106) <= snoop_act_fud_make_shared;
            IF_DEBUG(                            107) <= snoop_act_fud_make_clean;
            IF_DEBUG(                            108) <= snoop_act_fud_we;
            IF_DEBUG(                            109) <= snoop_update_tag_valid;
            IF_DEBUG(                            110) <= snoop_update_tag_dirty;
            IF_DEBUG(                            111) <= snoop_update_tag_unique;
            IF_DEBUG(                            112) <= snoop_req_tag_hit;
            IF_DEBUG(                            113) <= snoop_req_hit;
            IF_DEBUG(                            114) <= snoop_req_tag_valid;
            IF_DEBUG(                            115) <= snoop_req_tag_dirty;
            IF_DEBUG(                            116) <= snoop_req_tag_unique;
            IF_DEBUG(                            117) <= snoop_read_data_filter_we;
            IF_DEBUG(                            118) <= snoop_act_read_blocked;
            IF_DEBUG(                            119) <= snoop_act_ac_hazard;
            IF_DEBUG(                            120) <= snoop_act_ac_safe;
            
            IF_DEBUG(                            121) <= snoop_fetch_info(0).Myself;
            IF_DEBUG(                            122) <= snoop_fetch_pos_hazard_i;
            IF_DEBUG(                            123) <= snoop_req_hazard;
            IF_DEBUG(                            124) <= snoop_req_tag_overwritten;
            IF_DEBUG(                            125) <= snoop_req_new_tag_valid;
            IF_DEBUG(                            126) <= snoop_req_new_tag_dirty;
            IF_DEBUG(                            127) <= snoop_req_new_tag_unique;
            IF_DEBUG(                            128) <= snoop_act_write_blocking_i;
            IF_DEBUG(                            129) <= snoop_act_read_hazard;
            IF_DEBUG(                            130) <= read_data_fetch_line_match;
            IF_DEBUG(                            131) <= read_data_req_match;
            IF_DEBUG(                            132) <= read_data_ongoing;
            IF_DEBUG(                            133) <= read_data_block_nested;
            IF_DEBUG(                            134) <= read_data_release_block;
            IF_DEBUG(                            135) <= read_data_fud_we;
            IF_DEBUG(                            136) <= read_data_fud_tag_valid;
            IF_DEBUG(                            137) <= read_data_fud_tag_unique;
            IF_DEBUG(                            138) <= read_data_fud_tag_dirty;
            IF_DEBUG(                            139) <= snoop_act_allowed_ac;
            IF_DEBUG(                            140) <= snoop_act_waiting_4_cr;
            IF_DEBUG(                            141) <= snoop_fetch_info(0).Sync;
            IF_DEBUG(                            142) <= snoop_req_complete_done;
            IF_DEBUG(                            143) <= snoop_req_info(0).Complete;
            IF_DEBUG(                            144) <= snoop_act_ac_complete;
            IF_DEBUG(                            145) <= snoop_act_fud_hit;
            IF_DEBUG(                            146) <= snoop_act_fud_protected;
            IF_DEBUG(                            147) <= snoop_req_tag_locked;
            IF_DEBUG(                            148) <= snoop_update_tag_lock;
            IF_DEBUG(                            149) <= snoop_act_release_prot;
            IF_DEBUG(                            150) <= snoop_req_fud_protected;
            IF_DEBUG(                            151) <= lookup_read_data_new(0).Lx_Allocate;
            IF_DEBUG(                            152) <= snoop_fetch_info(0).Valid;
            IF_DEBUG(                            153) <= snoop_act_kill_locked;
            IF_DEBUG(                            154) <= snoop_act_info(0).Waiting_4_Pipe;
            IF_DEBUG(                            155) <= snoop_act_tag_locked_i;
            IF_DEBUG(                            156) <= snoop_act_info(0).Wr;
            IF_DEBUG(                            155) <= RIF_DEBUG(150); -- rk_empty;
            IF_DEBUG(                            156) <= RIF_DEBUG(151); -- read_data_fud_is_dead;
            IF_DEBUG(                            157) <= read_data_req_line_match;
            IF_DEBUG(                            158) <= read_data_act_line_match;
            IF_DEBUG(                            159) <= snoop_act_just_done;
            
            
            IF_DEBUG(160 + C_MY_ADDR  - 1 downto 160) <= snoop_fetch_addr_i(C_Lx_ADDR_LINE_LO + C_MY_ADDR - 1 downto C_Lx_ADDR_LINE_LO);
            IF_DEBUG(176 + C_MY_TAG   - 1 downto 176) <= snoop_req_new_tag_addr(C_MY_TAG - 1 downto 0);
            IF_DEBUG(192 + C_MY_DADDR - 1 downto 192) <= read_data_fud_addr(C_Lx_ADDR_DIRECT_LO + C_MY_DADDR - 1 downto C_Lx_ADDR_DIRECT_LO);
            IF_DEBUG(220 + C_MY_QCNT  - 1 downto 220) <= ari_read_fifo_addr(C_MY_QCNT - 1 downto 0);
            IF_DEBUG(224 + C_MY_PORT  - 1 downto 224) <= snoop_req_complete_target(C_MY_PORT - 1 downto 0);
            IF_DEBUG(228 + C_MY_COMP  - 1 downto 228) <= complete_request_detected(C_MY_COMP - 1 downto 0);
            
            IF_DEBUG(                            160) <= RIF_DEBUG( 42); -- S_AXI_RREADY;
            IF_DEBUG(                            161) <= RIF_DEBUG(157); -- ri_push;
            IF_DEBUG(                            162) <= RIF_DEBUG(158); -- ri_pop;
            IF_DEBUG(                            163) <= RIF_DEBUG(159); -- ri_exist;
            IF_DEBUG(                            164) <= RIF_DEBUG(160); -- ri_hit;
            IF_DEBUG(                            165) <= RIF_DEBUG(165); -- r_hit_pop;
            IF_DEBUG(                            166) <= RIF_DEBUG(166); -- r_miss_pop;
            IF_DEBUG(                            167) <= RIF_DEBUG(167); -- r_pop_safe;
            IF_DEBUG(                            168) <= RIF_DEBUG(236); -- r_last;
            IF_DEBUG(                            169) <= RIF_DEBUG(237); -- ri_allocate;
            
            IF_DEBUG(                            170) <= snoop_req_prot_access;
            IF_DEBUG(                            171) <= snoop_act_ac_done;
            
          end if;
        end if;
      end process Debug_Handle;
    
--      IF_DEBUG(255                  downto  74)  <= RIF_DEBUG(255 downto 74);
      
    end generate Use_Debug;
    
  end generate Use_Coherency;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_s_axi_rd_segments      <= C_NULL_STAT_POINT;
    stat_s_axi_wr_segments      <= C_NULL_STAT_POINT;
    stat_s_axi_rd_latency       <= C_NULL_STAT_POINT;
    stat_s_axi_wr_latency       <= C_NULL_STAT_POINT;
    
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal ar_start                   : std_logic;
    signal ar_done                    : std_logic;
    signal ar_ack                     : std_logic;
    signal rd_valid                   : std_logic;
    signal rd_last                    : std_logic;
    signal aw_start                   : std_logic;
    signal aw_done                    : std_logic;
    signal aw_ack                     : std_logic;
    signal wr_valid                   : std_logic;
    signal wr_last                    : std_logic;
    signal wr_resp                    : std_logic;
  begin
    
    -- Detect conditions.
    Trans_Handle : process (ACLK) is
    begin  -- process Trans_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          ar_start  <= '0';
          ar_done   <= '0';
          ar_ack    <= '0';
          rd_valid  <= '0';
          rd_last   <= '0';
          aw_start  <= '0';
          aw_done   <= '0';
          aw_ack    <= '0';
          wr_valid  <= '0';
          wr_last   <= '0';
          wr_resp   <= '0';
          
        else
          ar_start  <= S_AXI_ARVALID  and not ar_done;
          ar_ack    <= S_AXI_ARVALID  and S_AXI_ARREADY_I;
          rd_valid  <= S_AXI_RVALID_I and S_AXI_RREADY;
          rd_last   <= S_AXI_RVALID_I and S_AXI_RREADY and S_AXI_RLAST_I;
          
          aw_start  <= S_AXI_AWVALID  and not aw_done;
          aw_ack    <= S_AXI_AWVALID  and S_AXI_AWREADY_I;
          wr_valid  <= S_AXI_WVALID   and S_AXI_WREADY_I;
          wr_last   <= S_AXI_WVALID   and S_AXI_WREADY_I and S_AXI_WLAST ;
          wr_resp   <= S_AXI_BVALID_I and S_AXI_BREADY;
          
          if( S_AXI_ARREADY_I = '1' ) then
            ar_done   <= '0';
          elsif( S_AXI_ARVALID = '1' ) then
            ar_done   <= '1';
          end if;
          
          if( S_AXI_AWREADY_I = '1' ) then
            aw_done   <= '0';
          elsif( S_AXI_AWVALID = '1' ) then
            aw_done   <= '1';
          end if;
          
        end if;
      end if;
    end process Trans_Handle;
    
    Wr_Segments_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => aw_start,
        counter                   => C_STAT_ONE,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
      
        stat_data                 => stat_s_axi_wr_segments
      );
      
    Rd_Segments_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => ar_start,
        counter                   => C_STAT_ONE,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_s_axi_rd_segments
      );
      
    Latency_Inst: sc_stat_latency
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_LATENCY_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_LATENCY_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        ar_start                  => ar_start,
        ar_ack                    => ar_ack,
        rd_valid                  => rd_valid,
        rd_last                   => rd_last,
        aw_start                  => aw_start,
        aw_ack                    => aw_ack,
        wr_valid                  => wr_valid,
        wr_last                   => wr_last,
        wr_resp                   => wr_resp,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_rd_latency           => stat_s_axi_rd_latency,
        stat_wr_latency           => stat_s_axi_wr_latency,
        stat_rd_latency_conf      => stat_s_axi_rd_latency_conf,
        stat_wr_latency_conf      => stat_s_axi_wr_latency_conf
      );
    
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG( 73                  downto   0)  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_QCNT    : natural := min_of( 4, C_QUEUE_LENGTH_BITS);
    constant C_MY_ADDR    : natural := min_of(16, C_Lx_ADDR_LINE_HI - C_Lx_ADDR_LINE_LO + 1);
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          IF_DEBUG( 73                  downto   0)  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG( 73                  downto   0)  <= (others=>'0');
          
          IF_DEBUG(  0 + C_MY_QCNT  - 1 downto   0) <= wip_read_fifo_addr(C_MY_QCNT - 1 downto 0);
          IF_DEBUG(  4 + C_MY_QCNT  - 1 downto   4) <= w_read_fifo_addr(C_MY_QCNT - 1 downto 0);
          IF_DEBUG(  8 + C_MY_QCNT  - 1 downto   8) <= bip_read_fifo_addr(C_MY_QCNT - 1 downto 0);
          IF_DEBUG( 12 + C_MY_QCNT  - 1 downto  12) <= bp_read_fifo_addr(C_MY_QCNT - 1 downto 0);
          IF_DEBUG(                             16) <= access_bp_push(0).Early;
          IF_DEBUG(                             17) <= bp_fifo_full_i;
          IF_DEBUG(                             18) <= update_ext_bresp_info(0).Valid;
          IF_DEBUG(                             19) <= update_ext_bresp_ready_i;
          IF_DEBUG(                             20) <= wr_port_data_valid_i;
          IF_DEBUG(                             21) <= wr_port_data_last_i;
          IF_DEBUG(                             22) <= wr_port_data_ready(0);
          IF_DEBUG(                             23) <= wip_push;
          IF_DEBUG(                             24) <= wip_pop;
          IF_DEBUG(                             25) <= wip_refresh_reg;
          IF_DEBUG(                             26) <= wip_exist;
          IF_DEBUG(                             27) <= wip_assert;
          IF_DEBUG(                             28) <= w_push;
          IF_DEBUG(                             29) <= w_push_safe;
          IF_DEBUG(                             30) <= w_pop;
          IF_DEBUG(                             31) <= w_pop_safe;
          IF_DEBUG(                             32) <= w_fifo_full;
          IF_DEBUG(                             33) <= w_fifo_empty;
          IF_DEBUG(                             34) <= w_valid;
          IF_DEBUG(                             35) <= w_last;
          IF_DEBUG(                             36) <= w_ready;
          IF_DEBUG(                             37) <= w_assert;
          IF_DEBUG(                             38) <= S_AXI_WREADY_I;
          IF_DEBUG(                             39) <= read_req_valid;
          IF_DEBUG(                             40) <= read_req_single;
          IF_DEBUG(                             41) <= read_req_ready;
          IF_DEBUG(                             42) <= S_AXI_RVALID_I;
          IF_DEBUG(                             43) <= S_AXI_RLAST_I;
          IF_DEBUG(                             44) <= bip_push;
          IF_DEBUG(                             45) <= bip_pop;
          IF_DEBUG(                             46) <= bip_fifo_full;
          IF_DEBUG(                             47) <= bip_assert;
          IF_DEBUG(                             48) <= bp_pop;
          IF_DEBUG(                             49) <= bp_valid;
          IF_DEBUG(                             50) <= bp_ready;
          IF_DEBUG(                             51) <= bp_fifo_empty;
          IF_DEBUG(                             52) <= bp_early;
          IF_DEBUG(                             53) <= S_AXI_BVALID_I;
          IF_DEBUG(                             54) <= bp_assert;
          IF_DEBUG(                             55) <= S_AXI_BREADY;
          IF_DEBUG(                             56) <= access_bp_push(0).Valid;
          IF_DEBUG(                             57) <= lookup_read_data_new(0).Valid;
          IF_DEBUG(                             58) <= lookup_read_data_new(0).Hit;
          IF_DEBUG(                             59) <= lookup_read_data_new(0).Snoop;
          IF_DEBUG(                             60) <= wr_port_access_i.Valid;
          IF_DEBUG(                             61) <= wr_port_ready;
          IF_DEBUG(                             62) <= rd_port_access_i.Valid;
          IF_DEBUG(                             63) <= rd_port_ready;
          IF_DEBUG(                             64) <= arbiter_piperun;
          IF_DEBUG(                             65) <= snoop_fetch_piperun(0);
          IF_DEBUG(                             66) <= snoop_req_piperun(0);
          IF_DEBUG(                             67) <= snoop_act_piperun(0);
          IF_DEBUG(                             68) <= lookup_read_data_info(0).Valid;
          IF_DEBUG(                             69) <= lookup_read_data_info(0).Last;
          IF_DEBUG(                             70) <= lookup_read_data_ready_i(0);
          IF_DEBUG(                             71) <= update_read_data_info(0).Valid;
          IF_DEBUG(                             72) <= update_read_data_info(0).Last;
          IF_DEBUG(                             73) <= update_read_data_ready_i(0);
          
        end if;
      end if;
    end process Debug_Handle;
  
--    IF_DEBUG( 73                  downto   0)  <= RIF_DEBUG(73 downto 0);
    
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_WIP_QUEUE_ERROR)  <= wip_assert   when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_W_QUEUE_ERROR)    <= w_assert     when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_BIP_QUEUE_ERROR)  <= bip_assert   when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_BP_QUEUE_ERROR)   <= bp_assert    when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_R_CHANNEL_ERROR)  <= r_assert     when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_SYNC_ERROR)       <= sync_assert  when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_WIP_QUEUE_ERROR) /= '1' 
      report "Optimized AXI: Erroneous handling of WIP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_W_QUEUE_ERROR) /= '1' 
      report "Optimized AXI: Erroneous handling of W Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BIP_QUEUE_ERROR) /= '1' 
      report "Optimized AXI: Erroneous handling of BIP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BP_QUEUE_ERROR) /= '1' 
      report "Optimized AXI: Erroneous handling of BP Queue, read from empty or push to full."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_R_CHANNEL_ERROR) /= '1' 
      report "Optimized AXI: R Channel error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_SYNC_ERROR) /= '1' 
      report "Optimized AXI: Sync before all Complete has been received."
        severity error;

    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_s_axi_gen_interface.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_gen_interface.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_gen_interface.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-07-27    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_s_axi_gen_interface is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_GEN_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_GEN_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- AXI4 Interface Specific.
    C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
    C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_S_AXI_ADDR_WIDTH        : natural                       := 32;
    C_S_AXI_ID_WIDTH          : natural                       :=  1;
    C_S_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    
    -- Lx Cache Specific.
    C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
    C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
    C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
    C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
    C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
    C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
    C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
    C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
    C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_Lx_CACHE_SIZE           : natural                       := 1024;
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
    
    -- IP Specific.
    C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
    C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0;
    
    -- System Cache Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_NUM_WAYS                : natural range  1 to    8      :=  1;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_PORT_NUM                : natural range  0 to   32      :=  0;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- AXI4/ACE Slave Interface Signals.
    
    -- AW-Channel
    S_AXI_AWID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_AWADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    S_AXI_AWLEN               : in  std_logic_vector(7 downto 0);
    S_AXI_AWSIZE              : in  std_logic_vector(2 downto 0);
    S_AXI_AWBURST             : in  std_logic_vector(1 downto 0);
    S_AXI_AWLOCK              : in  std_logic;
    S_AXI_AWCACHE             : in  std_logic_vector(3 downto 0);
    S_AXI_AWPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_AWQOS               : in  std_logic_vector(3 downto 0);
    S_AXI_AWVALID             : in  std_logic;
    S_AXI_AWREADY             : out std_logic;

    -- W-Channel
    S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
    S_AXI_WLAST               : in  std_logic;
    S_AXI_WVALID              : in  std_logic;
    S_AXI_WREADY              : out std_logic;

    -- B-Channel
    S_AXI_BRESP               : out std_logic_vector(1 downto 0);
    S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_BVALID              : out std_logic;
    S_AXI_BREADY              : in  std_logic;

    -- AR-Channel
    S_AXI_ARID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_ARADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    S_AXI_ARLEN               : in  std_logic_vector(7 downto 0);
    S_AXI_ARSIZE              : in  std_logic_vector(2 downto 0);
    S_AXI_ARBURST             : in  std_logic_vector(1 downto 0);
    S_AXI_ARLOCK              : in  std_logic;
    S_AXI_ARCACHE             : in  std_logic_vector(3 downto 0);
    S_AXI_ARPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_ARQOS               : in  std_logic_vector(3 downto 0);
    S_AXI_ARVALID             : in  std_logic;
    S_AXI_ARREADY             : out std_logic;

    -- R-Channel
    S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
    S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    S_AXI_RRESP               : out std_logic_vector(1 downto 0);
    S_AXI_RLAST               : out std_logic;
    S_AXI_RVALID              : out std_logic;
    S_AXI_RREADY              : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (All request).
    
    arbiter_piperun           : in  std_logic;
    arbiter_allowed           : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write request).
    
    wr_port_access            : out WRITE_PORT_TYPE;
    wr_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    rd_port_access            : out READ_PORT_TYPE;
    rd_port_ready             : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Snoop communication).
    
    -- Snoop Fetch Stage Signals
    snoop_fetch_piperun       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_fetch_info          : in  SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_fetch_pos_hazard    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Request Stage Signals.
    snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_req_info            : in  SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Action Stage Signals.
    snoop_act_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_info            : in  SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_tag_info        : out SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_act_ack_info        : out SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    snoop_tag_status_info     : in  SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    snoop_tag_new_info        : out SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
    -- Snoop Response Information Signals.
    snoop_resp_info           : out SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_resp_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    snoop_data_info           : out SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Complete Transaction Signals.
    read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write Data).
    
    wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write response).
    
    access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Snoop signals (Read Data & response).
    
    snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (Read Data).
    
    lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (Read Data).
    
    update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                      : in  std_logic;
    stat_enable                     : in  std_logic;
    
    stat_s_axi_gen_rd_segments      : out STAT_POINT_TYPE; -- Per transaction
    stat_s_axi_gen_wr_segments      : out STAT_POINT_TYPE; -- Per transaction
    stat_s_axi_gen_rip              : out STAT_FIFO_TYPE;
    stat_s_axi_gen_r                : out STAT_FIFO_TYPE;
    stat_s_axi_gen_bip              : out STAT_FIFO_TYPE;
    stat_s_axi_gen_bp               : out STAT_FIFO_TYPE;
    stat_s_axi_gen_wip              : out STAT_FIFO_TYPE;
    stat_s_axi_gen_w                : out STAT_FIFO_TYPE;
    stat_s_axi_gen_rd_latency       : out STAT_POINT_TYPE;
    stat_s_axi_gen_wr_latency       : out STAT_POINT_TYPE;
    stat_s_axi_gen_rd_latency_conf  : in  STAT_CONF_TYPE;
    stat_s_axi_gen_wr_latency_conf  : in  STAT_CONF_TYPE;
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug Signals.
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_gen_interface;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_gen_interface is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Top level for the Generic AXI4 port. No actual logic only connection
  -- between the different AXI channel modules.
  -- 
  --  ____                          ___________         
  -- | W  |----------------------->| W Channel |------------------------->
  -- |____|                        |___________|        
  --                                      ^
  --  ____            ___________         |
  -- | AW |--------->| A Channel |--------+          
  -- |____|          |___________|        |
  --                                      v
  --  ____                          ___________ 
  -- | B  |<-----------------------| B Channel |<-------------------------
  -- |____|                        |___________|
  -- 
  --  ____                          ___________ 
  -- | R  |<-----------------------| R Channel |<-------------------------
  -- |____|                        |___________|
  --                                      ^
  --  ____            ___________         |
  -- | AR |--------->| A Channel |--------|              
  -- |____|          |___________|  
  -- 
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_W_CHANNEL_ERROR           : natural :=  0;
  constant C_ASSERT_B_CHANNEL_ERROR           : natural :=  1;
  constant C_ASSERT_R_CHANNEL_ERROR           : natural :=  2;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  3;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  constant C_REAL_CACHE_LINE_LENGTH   : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_CACHE_LINE_LENGTH, 
                                                                                            C_CACHE_LINE_LENGTH);
  constant C_REAL_ADDR_LINE_HI        : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_LINE_HI,
                                                                                            C_ADDR_LINE_HI);
  constant C_REAL_ADDR_LINE_LO        : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_LINE_LO,
                                                                                            C_ADDR_LINE_LO);
  constant C_REAL_ADDR_OFFSET_HI      : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_OFFSET_HI,
                                                                                            C_ADDR_OFFSET_HI);
  constant C_REAL_ADDR_OFFSET_LO      : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_OFFSET_LO,
                                                                                            C_ADDR_OFFSET_LO);
  constant C_REAL_ADDR_BYTE_HI        : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_BYTE_HI,
                                                                                            C_ADDR_BYTE_HI);
  constant C_REAL_ADDR_BYTE_LO        : natural := sel(is_slv_coherent(C_ENABLE_COHERENCY), C_Lx_ADDR_BYTE_LO,
                                                                                            C_ADDR_BYTE_LO);
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  
  -- Address related.
  subtype C_ADDR_LINE_POS             is natural range C_REAL_ADDR_LINE_HI    downto C_REAL_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_REAL_ADDR_OFFSET_HI  downto C_REAL_ADDR_OFFSET_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_REAL_ADDR_BYTE_HI    downto C_REAL_ADDR_BYTE_LO;
  
  -- Subtypes for address parts.
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  -- Address related.
  subtype C_Lx_ADDR_DIRECT_POS        is natural range C_Lx_ADDR_DIRECT_HI    downto C_Lx_ADDR_DIRECT_LO;
  subtype C_Lx_ADDR_LINE_POS          is natural range C_Lx_ADDR_LINE_HI      downto C_Lx_ADDR_LINE_LO;
  subtype C_Lx_ADDR_OFFSET_POS        is natural range C_Lx_ADDR_OFFSET_HI    downto C_Lx_ADDR_OFFSET_LO;
  subtype C_Lx_ADDR_BYTE_POS          is natural range C_Lx_ADDR_BYTE_HI      downto C_Lx_ADDR_BYTE_LO;
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Size)
  -----------------------------------------------------------------------------
  
  -- Size related.
  subtype C_BYTE_MASK_POS             is natural range C_ADDR_OFFSET_HI + 7 downto 7;
  subtype C_HALF_WORD_MASK_POS        is natural range C_ADDR_OFFSET_HI + 6 downto 6;
  subtype C_WORD_MASK_POS             is natural range C_ADDR_OFFSET_HI + 5 downto 5;
  subtype C_DOUBLE_WORD_MASK_POS      is natural range C_ADDR_OFFSET_HI + 4 downto 4;
  subtype C_QUAD_WORD_MASK_POS        is natural range C_ADDR_OFFSET_HI + 3 downto 3;
  subtype C_OCTA_WORD_MASK_POS        is natural range C_ADDR_OFFSET_HI + 2 downto 2;
  subtype C_HEXADECA_WORD_MASK_POS    is natural range C_ADDR_OFFSET_HI + 1 downto 1;
  subtype C_TRIACONTADI_MASK_POS      is natural range C_ADDR_OFFSET_HI + 0 downto 0;
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ADDR_OFFSET_BITS         : natural := C_ADDR_OFFSET_HI - C_ADDR_OFFSET_LO + 1;
  constant C_ADDR_BYTE_BITS           : natural := C_ADDR_BYTE_HI - C_ADDR_BYTE_LO + 1;
  
  constant C_LEN_WIDTH                : natural := 8;
  constant C_REST_WIDTH               : natural := Log2(C_CACHE_DATA_WIDTH/8);
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_s_axi_a_channel is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_S_AXI_ADDR_WIDTH        : natural                       := 32;
      C_S_AXI_ID_WIDTH          : natural                       :=  1;
      C_S_AXI_FORCE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_ALLOCATE : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_OTHER_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_OTHER_ALLOCATE : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_BUFFER      : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_BUFFER   : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_EXCLUSIVE: natural range  0 to    1      :=  1;
      
      -- Configuration.
      C_IS_READ                 : natural range  0 to    1      :=  0;
      C_LEN_WIDTH               : natural range  0 to    8      :=  2;
      C_REST_WIDTH              : natural range  0 to    7      :=  2;
      
      -- Data type and settings specific.
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
      
      -- IP Specific.
      C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
      C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0;
      C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
      
      -- System Cache Specific.
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  4 to  128      := 16;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- AW-Channel
      S_AXI_AID                 : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_AADDR               : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      S_AXI_ALEN                : in  std_logic_vector(7 downto 0);
      S_AXI_ASIZE               : in  std_logic_vector(2 downto 0);
      S_AXI_ABURST              : in  std_logic_vector(1 downto 0);
      S_AXI_ALOCK               : in  std_logic;
      S_AXI_ACACHE              : in  std_logic_vector(3 downto 0);
      S_AXI_APROT               : in  std_logic_vector(2 downto 0);
      S_AXI_AQOS                : in  std_logic_vector(3 downto 0);
      S_AXI_AVALID              : in  std_logic;
      S_AXI_AREADY              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write data).
      
      wr_valid                  : out std_logic;
      wr_last                   : out std_logic;
      wr_failed                 : out std_logic;
      wr_offset                 : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_stp                    : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_use                    : out std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_len                    : out AXI_LENGTH_TYPE;
      wr_ready                  : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Write Response Information Interface Signals.
      
      write_req_valid           : out std_logic;
      write_req_ID              : out std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
      write_req_last            : out std_logic;
      write_req_failed          : out std_logic;
      write_req_ready           : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            : out std_logic;
      read_req_ID               : out std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
      read_req_last             : out std_logic;
      read_req_failed           : out std_logic;
      read_req_single           : out std_logic;
      read_req_rest             : out std_logic_vector(C_REST_WIDTH - 1 downto 0);
      read_req_offset           : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_stp              : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_use              : out std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_len              : out std_logic_vector(C_LEN_WIDTH - 1  downto 0);
      read_req_ready            : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      arbiter_piperun           : in  std_logic;
      arbiter_allowed           : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            : out WRITE_PORT_TYPE;
      wr_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            : out READ_PORT_TYPE;
      rd_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_s_axi_gen_segments   : out STAT_POINT_TYPE; -- Per transaction
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_a_channel;
  
  component sc_s_axi_w_channel is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      
      -- Data type and settings specific.
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      
      -- System Cache Specific.
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4 Slave Interface Signals.
      
      -- W-Channel
      S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
      S_AXI_WLAST               : in  std_logic;
      S_AXI_WVALID              : in  std_logic;
      S_AXI_WREADY              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write data).
      
      wr_valid                  : in  std_logic;
      wr_last                   : in  std_logic;
      wr_failed                 : in  std_logic;
      wr_offset                 : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_stp                    : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_use                    : in  std_logic_vector(C_ADDR_BYTE_HI downto C_ADDR_BYTE_LO);
      wr_len                    : in  AXI_LENGTH_TYPE;
      wr_ready                  : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write Data).
      
      wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Synchronization).
      
      wc_valid                  : out std_logic;
      wc_ready                  : in  std_logic;
      
      write_fail_completed      : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_s_axi_wip            : out STAT_FIFO_TYPE;
      stat_s_axi_w              : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_w_channel;
  
  component sc_s_axi_b_channel is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- System Cache Specific.
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      
      -- AXI4 Interface Specific.
      C_S_AXI_ID_WIDTH          : natural                       :=  1
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- B-Channel
      S_AXI_BRESP               : out std_logic_vector(1 downto 0);
      S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_BVALID              : out std_logic;
      S_AXI_BREADY              : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Write Response Information Interface Signals.
      
      write_req_valid           : in  std_logic;
      write_req_ID              : in  std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
      write_req_last            : in  std_logic;
      write_req_failed          : in  std_logic;
      write_req_ready           : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Synchronization).
      
      wc_valid                  : in  std_logic;
      wc_ready                  : out std_logic;
      
      write_fail_completed      : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write response).
      
      access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_s_axi_bip            : out STAT_FIFO_TYPE;
      stat_s_axi_bp             : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_b_channel;
  
  component sc_s_axi_r_channel is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_S_AXI_ID_WIDTH          : natural                       :=  1;
      C_S_AXI_RRESP_WIDTH       : natural                       :=  2;
      
      -- Configuration.
      C_SUPPORT_SUBSIZED        : boolean                       := false;
      C_LEN_WIDTH               : natural range  0 to    8      :=  2;
      C_REST_WIDTH              : natural range  0 to    7      :=  2;
      
      -- Data type and settings specific.
      C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
      C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_NUM_WAYS                : natural range  1 to    8      :=  1;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_ENABLE_HAZARD_HANDLING  : natural range  0 to    1      :=  0;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- R-Channel
      S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_RRESP               : out std_logic_vector(C_S_AXI_RRESP_WIDTH-1 downto 0);
      S_AXI_RLAST               : out std_logic;
      S_AXI_RVALID              : out std_logic;
      S_AXI_RREADY              : in  std_logic;
      S_AXI_RACK                : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            : in  std_logic;
      read_req_ID               : in  std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
      read_req_last             : in  std_logic;
      read_req_failed           : in  std_logic;
      read_req_single           : in  std_logic;
      read_req_dvm              : in  std_logic;
      read_req_addr             : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_req_rest             : in  std_logic_vector(C_REST_WIDTH - 1 downto 0);
      read_req_offset           : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_stp              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_use              : in  std_logic_vector(C_ADDR_BYTE_HI   downto C_ADDR_BYTE_LO);
      read_req_len              : in  std_logic_vector(C_LEN_WIDTH - 1  downto 0);
      read_req_ready            : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Hazard).
      
      snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_set_read_hazard : in  std_logic;
      snoop_act_rst_read_hazard : in  std_logic;
      snoop_act_read_hazard     : in  std_logic;
      snoop_act_kill_locked     : in  std_logic;
      snoop_act_kill_by_snoop   : in  std_logic;
      snoop_act_kill_addr       : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      
      read_data_fetch_addr      : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_req_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_act_addr        : in  std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      
      read_data_fetch_match     : out std_logic;
      read_data_req_match       : out std_logic;
      read_data_act_match       : out std_logic;
      read_data_ongoing         : out std_logic;
      read_data_block_nested    : out std_logic;
      read_data_release_block   : out std_logic;
      read_data_fetch_line_match: out std_logic;
      read_data_req_line_match  : out std_logic;
      read_data_act_line_match  : out std_logic;
      
      read_data_fud_we          : out std_logic;
      read_data_fud_addr        : out std_logic_vector(C_Lx_ADDR_DIRECT_HI   downto C_Lx_ADDR_DIRECT_LO);
      read_data_fud_tag_valid   : out std_logic;
      read_data_fud_tag_unique  : out std_logic;
      read_data_fud_tag_dirty   : out std_logic;
      read_data_fud_tag_secure  : out std_logic;
      
      read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_s_axi_rip            : out STAT_FIFO_TYPE;
      stat_s_axi_r              : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_r_channel;
  
  component sc_stat_latency is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_LATENCY_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_LATENCY_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      ar_start                  : in  std_logic;
      ar_ack                    : in  std_logic;
      rd_valid                  : in  std_logic;
      rd_last                   : in  std_logic;
      aw_start                  : in  std_logic;
      aw_ack                    : in  std_logic;
      wr_valid                  : in  std_logic;
      wr_last                   : in  std_logic;
      wr_resp                   : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_rd_latency           : out STAT_POINT_TYPE;    -- External Read Latency
      stat_wr_latency           : out STAT_POINT_TYPE;    -- External Write Latency
      stat_rd_latency_conf      : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_wr_latency_conf      : in  STAT_CONF_TYPE      -- External Write Latency Configuration
    );
  end component sc_stat_latency;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Control AW-Channel
  
  signal AWIF_DEBUG                 : std_logic_vector(255 downto 0);
  signal S_AXI_AWREADY_I            : std_logic;
  
  
  -- ----------------------------------------
  -- Control AW-Channel
  
  signal ARIF_DEBUG                 : std_logic_vector(255 downto 0);
  signal S_AXI_ARREADY_I            : std_logic;
  
  
  -- ----------------------------------------
  -- Control W-Channel
  
  signal wr_valid                   : std_logic;
  signal wr_last                    : std_logic;
  signal wr_failed                  : std_logic;
  signal wr_offset                  : ADDR_BYTE_TYPE;
  signal wr_stp                     : ADDR_BYTE_TYPE;
  signal wr_use                     : ADDR_BYTE_TYPE;
  signal wr_len                     : AXI_LENGTH_TYPE;
  signal wr_ready                   : std_logic;
  signal wc_valid                   : std_logic;
  signal wc_ready                   : std_logic;
  signal write_fail_completed       : std_logic;
  signal WIF_DEBUG                  : std_logic_vector(255 downto 0);
  signal w_assert                   : std_logic;
  signal S_AXI_WREADY_I             : std_logic;
  
  
  -- ----------------------------------------
  -- Control B-Channel
  
  signal write_req_valid            : std_logic;
  signal write_req_ID               : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal write_req_last             : std_logic;
  signal write_req_failed           : std_logic;
  signal write_req_ready            : std_logic;
  signal BIF_DEBUG                  : std_logic_vector(255 downto 0);
  signal b_assert                   : std_logic;
  signal S_AXI_BVALID_I             : std_logic;
  
  
  -- ----------------------------------------
  -- Control R-Channel
  
  signal read_req_valid             : std_logic;
  signal read_req_ID                : std_logic_vector(C_S_AXI_ID_WIDTH - 1   downto 0);
  signal read_req_last              : std_logic;
  signal read_req_failed            : std_logic;
  signal read_req_single            : std_logic;
  signal read_req_rest              : std_logic_vector(C_REST_WIDTH - 1 downto 0);
  signal read_req_offset            : ADDR_BYTE_TYPE;
  signal read_req_stp               : ADDR_BYTE_TYPE;
  signal read_req_use               : ADDR_BYTE_TYPE;
  signal read_req_len               : std_logic_vector(C_LEN_WIDTH - 1  downto 0);
  signal read_req_ready             : std_logic;
  signal RIF_DEBUG                  : std_logic_vector(255 downto 0);
  signal r_assert                   : std_logic;
  signal S_AXI_RVALID_I             : std_logic;
  signal S_AXI_RLAST_I              : std_logic;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
begin  -- architecture IMP

  
  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- AW-Channel
  -----------------------------------------------------------------------------
  
  AW_Channel: sc_s_axi_a_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- AXI4 Interface Specific.
      C_S_AXI_BASEADDR          => C_S_AXI_BASEADDR,
      C_S_AXI_HIGHADDR          => C_S_AXI_HIGHADDR,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH,
      C_S_AXI_ID_WIDTH          => C_S_AXI_ID_WIDTH,
      C_S_AXI_FORCE_ALLOCATE    => C_S_AXI_FORCE_WRITE_ALLOCATE,
      C_S_AXI_PROHIBIT_ALLOCATE => C_S_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S_AXI_FORCE_OTHER_ALLOCATE    => C_S_AXI_FORCE_READ_ALLOCATE,
      C_S_AXI_PROHIBIT_OTHER_ALLOCATE => C_S_AXI_PROHIBIT_READ_ALLOCATE,
      C_S_AXI_FORCE_BUFFER      => C_S_AXI_FORCE_WRITE_BUFFER,
      C_S_AXI_PROHIBIT_BUFFER   => C_S_AXI_PROHIBIT_WRITE_BUFFER,
      C_S_AXI_PROHIBIT_EXCLUSIVE=> C_S_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Configuration.
      C_IS_READ                 => 0,
      C_LEN_WIDTH               => C_LEN_WIDTH,
      C_REST_WIDTH              => C_REST_WIDTH,
      
      -- Data type and settings specific.
      C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
      C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
      
      -- IP Specific.
      C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
      C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
      
      -- System Cache Specific.
      C_ID_WIDTH                => C_ID_WIDTH,
      C_CACHE_LINE_LENGTH       => C_REAL_CACHE_LINE_LENGTH,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
  
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- AW-Channel
      S_AXI_AID                 => S_AXI_AWID,
      S_AXI_AADDR               => S_AXI_AWADDR,
      S_AXI_ALEN                => S_AXI_AWLEN,
      S_AXI_ASIZE               => S_AXI_AWSIZE,
      S_AXI_ABURST              => S_AXI_AWBURST,
      S_AXI_ALOCK               => S_AXI_AWLOCK,
      S_AXI_ACACHE              => S_AXI_AWCACHE,
      S_AXI_APROT               => S_AXI_AWPROT,
      S_AXI_AQOS                => S_AXI_AWQOS,
      S_AXI_AVALID              => S_AXI_AWVALID,
      S_AXI_AREADY              => S_AXI_AWREADY_I,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write data).
      
      wr_valid                  => wr_valid,
      wr_last                   => wr_last,
      wr_failed                 => wr_failed,
      wr_offset                 => wr_offset,
      wr_stp                    => wr_stp,
      wr_use                    => wr_use,
      wr_len                    => wr_len,
      wr_ready                  => wr_ready,
      
      
      -- ---------------------------------------------------
      -- Write Response Information Interface Signals.
      
      write_req_valid           => write_req_valid,
      write_req_ID              => write_req_ID,
      write_req_last            => write_req_last,
      write_req_failed          => write_req_failed,
      write_req_ready           => write_req_ready,
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            => open,
      read_req_ID               => open,
      read_req_last             => open,
      read_req_failed           => open,
      read_req_single           => open,
      read_req_rest             => open,
      read_req_offset           => open,
      read_req_stp              => open,
      read_req_use              => open,
      read_req_len              => open,
      read_req_ready            => '1',
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      arbiter_piperun           => arbiter_piperun,
      arbiter_allowed           => arbiter_allowed,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            => wr_port_access,
      wr_port_ready             => wr_port_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            => open,
      rd_port_ready             => rd_port_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_gen_segments   => stat_s_axi_gen_wr_segments,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => AWIF_DEBUG
    );
  
  S_AXI_AWREADY <= S_AXI_AWREADY_I;
  
  
  -----------------------------------------------------------------------------
  -- AR-Channel
  -----------------------------------------------------------------------------
  
  AR_Channel: sc_s_axi_a_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- AXI4 Interface Specific.
      C_S_AXI_BASEADDR          => C_S_AXI_BASEADDR,
      C_S_AXI_HIGHADDR          => C_S_AXI_HIGHADDR,
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH,
      C_S_AXI_ID_WIDTH          => C_S_AXI_ID_WIDTH,
      C_S_AXI_FORCE_ALLOCATE    => C_S_AXI_FORCE_READ_ALLOCATE,
      C_S_AXI_PROHIBIT_ALLOCATE => C_S_AXI_PROHIBIT_READ_ALLOCATE,
      C_S_AXI_FORCE_OTHER_ALLOCATE    => C_S_AXI_FORCE_WRITE_ALLOCATE,
      C_S_AXI_PROHIBIT_OTHER_ALLOCATE => C_S_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S_AXI_FORCE_BUFFER      => C_S_AXI_FORCE_READ_BUFFER,
      C_S_AXI_PROHIBIT_BUFFER   => C_S_AXI_PROHIBIT_READ_BUFFER,
      C_S_AXI_PROHIBIT_EXCLUSIVE=> C_S_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Configuration.
      C_IS_READ                 => 1,
      C_LEN_WIDTH               => C_LEN_WIDTH,
      C_REST_WIDTH              => C_REST_WIDTH,
      
      -- Data type and settings specific.
      C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
      C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
      
      -- IP Specific.
      C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
      C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
      
      -- System Cache Specific.
      C_ID_WIDTH                => C_ID_WIDTH,
      C_CACHE_LINE_LENGTH       => C_REAL_CACHE_LINE_LENGTH,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
  
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- AW-Channel
      S_AXI_AID                 => S_AXI_ARID,
      S_AXI_AADDR               => S_AXI_ARADDR,
      S_AXI_ALEN                => S_AXI_ARLEN,
      S_AXI_ASIZE               => S_AXI_ARSIZE,
      S_AXI_ABURST              => S_AXI_ARBURST,
      S_AXI_ALOCK               => S_AXI_ARLOCK,
      S_AXI_ACACHE              => S_AXI_ARCACHE,
      S_AXI_APROT               => S_AXI_ARPROT,
      S_AXI_AQOS                => S_AXI_ARQOS,
      S_AXI_AVALID              => S_AXI_ARVALID,
      S_AXI_AREADY              => S_AXI_ARREADY_I,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write data).
      
      wr_valid                  => open,
      wr_last                   => open,
      wr_failed                 => open,
      wr_offset                 => open,
      wr_stp                    => open,
      wr_use                    => open,
      wr_len                    => open,
      wr_ready                  => '1',
      
      
      -- ---------------------------------------------------
      -- Write Response Information Interface Signals.
      
      write_req_valid           => open,
      write_req_ID              => open,
      write_req_last            => open,
      write_req_failed          => open,
      write_req_ready           => '1',
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            => read_req_valid,
      read_req_ID               => read_req_ID,
      read_req_last             => read_req_last,
      read_req_failed           => read_req_failed,
      read_req_single           => read_req_single,
      read_req_rest             => read_req_rest,
      read_req_offset           => read_req_offset,
      read_req_stp              => read_req_stp,
      read_req_use              => read_req_use,
      read_req_len              => read_req_len,
      read_req_ready            => read_req_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      arbiter_piperun           => arbiter_piperun,
      arbiter_allowed           => arbiter_allowed,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            => open,
      wr_port_ready             => wr_port_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            => rd_port_access,
      rd_port_ready             => rd_port_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_gen_segments   => stat_s_axi_gen_rd_segments,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => ARIF_DEBUG
    );
  
  S_AXI_ARREADY <= S_AXI_ARREADY_I;
  
  
  -----------------------------------------------------------------------------
  -- Control W-Channel
  -----------------------------------------------------------------------------
  
  W_Channel: sc_s_axi_w_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      
      -- Data type and settings specific.
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      
      -- System Cache Specific.
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
      
      -- ---------------------------------------------------
      -- AXI4 Slave Interface Signals.
      
      -- W-Channel
      S_AXI_WDATA               => S_AXI_WDATA,
      S_AXI_WSTRB               => S_AXI_WSTRB,
      S_AXI_WLAST               => S_AXI_WLAST,
      S_AXI_WVALID              => S_AXI_WVALID,
      S_AXI_WREADY              => S_AXI_WREADY_I,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write data).
      
      wr_valid                  => wr_valid,
      wr_last                   => wr_last,
      wr_failed                 => wr_failed,
      wr_offset                 => wr_offset,
      wr_stp                    => wr_stp,
      wr_use                    => wr_use,
      wr_len                    => wr_len,
      wr_ready                  => wr_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write Data).
      
      wr_port_data_info         => wr_port_data_info,
      wr_port_data_ready        => wr_port_data_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Synchronization).
      
      wc_valid                  => wc_valid,
      wc_ready                  => wc_ready,
      
      write_fail_completed      => write_fail_completed,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_wip            => stat_s_axi_gen_wip,
      stat_s_axi_w              => stat_s_axi_gen_w,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => w_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => WIF_DEBUG
    );
  
  S_AXI_WREADY  <= S_AXI_WREADY_I;
  
  
  -----------------------------------------------------------------------------
  -- Control B-Channel
  -----------------------------------------------------------------------------
  
  B_Channel: sc_s_axi_b_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- System Cache Specific.
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      
      -- AXI4 Interface Specific.
      C_S_AXI_ID_WIDTH          => C_S_AXI_ID_WIDTH
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- B-Channel
      S_AXI_BRESP               => S_AXI_BRESP,
      S_AXI_BID                 => S_AXI_BID,
      S_AXI_BVALID              => S_AXI_BVALID_I,
      S_AXI_BREADY              => S_AXI_BREADY,
      
      
      -- ---------------------------------------------------
      -- Write Response Information Interface Signals.
      
      write_req_valid           => write_req_valid,
      write_req_ID              => write_req_ID,
      write_req_last            => write_req_last,
      write_req_failed          => write_req_failed,
      write_req_ready           => write_req_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_ready             => wr_port_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Synchronization).
      
      wc_valid                  => wc_valid,
      wc_ready                  => wc_ready,
      
      write_fail_completed      => write_fail_completed,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write response).
      
      access_bp_push            => access_bp_push,
      
      update_ext_bresp_info     => update_ext_bresp_info,
      update_ext_bresp_ready    => update_ext_bresp_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_bip            => stat_s_axi_gen_bip,
      stat_s_axi_bp             => stat_s_axi_gen_bp,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => b_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => BIF_DEBUG
    );
  
  S_AXI_BVALID  <= S_AXI_BVALID_I;
  
  
  -----------------------------------------------------------------------------
  -- Control R-Channel
  -----------------------------------------------------------------------------
  
  R_Channel: sc_s_axi_r_channel
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- AXI4 Interface Specific.
      C_S_AXI_DATA_WIDTH        => C_S_AXI_DATA_WIDTH,
      C_S_AXI_ID_WIDTH          => C_S_AXI_ID_WIDTH,
      C_S_AXI_RRESP_WIDTH       => 2,
      
      -- Configuration.
      C_SUPPORT_SUBSIZED        => true,
      C_LEN_WIDTH               => C_LEN_WIDTH,
      C_REST_WIDTH              => C_REST_WIDTH,
      
      -- Data type and settings specific.
      C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_POS'high,
      C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_POS'low,
      C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_POS'high,
      C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      
      -- Lx Cache Specific.
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_ENABLE_HAZARD_HANDLING  => 0,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET_I,
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- R-Channel
      S_AXI_RID                 => S_AXI_RID,
      S_AXI_RDATA               => S_AXI_RDATA,
      S_AXI_RRESP               => S_AXI_RRESP,
      S_AXI_RLAST               => S_AXI_RLAST_I,
      S_AXI_RVALID              => S_AXI_RVALID_I,
      S_AXI_RREADY              => S_AXI_RREADY,
      S_AXI_RACK                => '1',
      
      
      -- ---------------------------------------------------
      -- Read Information Interface Signals.
      
      read_req_valid            => read_req_valid,
      read_req_ID               => read_req_ID,
      read_req_last             => read_req_last,
      read_req_failed           => read_req_failed,
      read_req_single           => read_req_single,
      read_req_dvm              => '0',
      read_req_addr             => (C_Lx_ADDR_DIRECT_HI downto C_Lx_ADDR_DIRECT_LO=>'0'),
      read_req_rest             => read_req_rest,
      read_req_offset           => read_req_offset,
      read_req_stp              => read_req_stp,
      read_req_use              => read_req_use,
      read_req_len              => read_req_len,
      read_req_ready            => read_req_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_ready             => rd_port_ready,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      => lookup_read_data_new,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Hazard).
      
      snoop_req_piperun         => (C_CACHE_BLOCKS - 1 downto 0=>'0'),
      snoop_act_set_read_hazard => '0',
      snoop_act_rst_read_hazard => '0',
      snoop_act_read_hazard     => '0',
      snoop_act_kill_locked     => '0',
      snoop_act_kill_by_snoop   => '0',
      snoop_act_kill_addr       => (C_Lx_ADDR_DIRECT_HI downto C_Lx_ADDR_DIRECT_LO=>'0'),
      
      read_data_fetch_addr      => (C_Lx_ADDR_DIRECT_HI downto C_Lx_ADDR_DIRECT_LO=>'0'),
      read_data_req_addr        => (C_Lx_ADDR_DIRECT_HI downto C_Lx_ADDR_DIRECT_LO=>'0'),
      read_data_act_addr        => (C_Lx_ADDR_DIRECT_HI downto C_Lx_ADDR_DIRECT_LO=>'0'),
      
      read_data_fetch_match     => open,
      read_data_req_match       => open,
      read_data_act_match       => open,
      read_data_ongoing         => open,
      read_data_block_nested    => open,
      read_data_release_block   => open,
      read_data_fetch_line_match=> open,
      read_data_req_line_match  => open,
      read_data_act_line_match  => open,
      
      read_data_fud_we          => open,
      read_data_fud_addr        => open,
      read_data_fud_tag_valid   => open,
      read_data_fud_tag_unique  => open,
      read_data_fud_tag_dirty   => open,
      read_data_fud_tag_secure  => open,
      
      read_trans_comp_info      => open,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          => read_info_status,
      read_data_status          => read_data_status,
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      => snoop_read_data_info,
      snoop_read_data_ready     => snoop_read_data_ready,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     => lookup_read_data_info,
      lookup_read_data_ready    => lookup_read_data_ready,
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     => update_read_data_info,
      update_read_data_ready    => update_read_data_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      stat_s_axi_rip            => stat_s_axi_gen_rip,
      stat_s_axi_r              => stat_s_axi_gen_r,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => r_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  => RIF_DEBUG 
    );
  
  S_AXI_RVALID  <= S_AXI_RVALID_I;
  S_AXI_RLAST   <= S_AXI_RLAST_I;
  
  
  -----------------------------------------------------------------------------
  -- Coherency: Not supported
  -----------------------------------------------------------------------------
  
  snoop_fetch_pos_hazard(0)             <= '0';
  
  snoop_act_tag_info(0)                 <= C_NULL_SNOOP_ACT_TAG;
  
  snoop_act_ack_info(0).Done            <= '1';
  snoop_act_ack_info(0).Use_External    <= '0';
  snoop_act_ack_info(0).Write_Blocking  <= '0';
  
  snoop_tag_new_info(0)                 <= C_NULL_SNOOP_TAG;
  
  snoop_resp_info(0).Valid              <= '1';
  snoop_resp_info(0).CRRESP             <= (others=>'0');
  
  snoop_data_info(0).Valid              <= '1';
  snoop_data_info(0).Last               <= '1';
  snoop_data_info(0).Data               <= (others=>'0');
  
  read_trans_comp_info(0)               <= C_NULL_READ_COMPLETE;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_s_axi_gen_rd_latency       <= C_NULL_STAT_POINT;
    stat_s_axi_gen_wr_latency       <= C_NULL_STAT_POINT;
    
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    signal ar_start                   : std_logic;
    signal ar_done                    : std_logic;
    signal ar_ack                     : std_logic;
    signal rd_valid                   : std_logic;
    signal rd_last                    : std_logic;
    signal aw_start                   : std_logic;
    signal aw_done                    : std_logic;
    signal aw_ack                     : std_logic;
    signal wr_valid                   : std_logic;
    signal wr_last                    : std_logic;
    signal wr_resp                    : std_logic;
  begin
    
    -- Detect conditions.
    Trans_Handle : process (ACLK) is
    begin  -- process Trans_Handle
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( stat_reset = '1' ) then         -- synchronous reset (active high)
          ar_start  <= '0';
          ar_done   <= '0';
          ar_ack    <= '0';
          rd_valid  <= '0';
          rd_last   <= '0';
          aw_start  <= '0';
          aw_done   <= '0';
          aw_ack    <= '0';
          wr_valid  <= '0';
          wr_last   <= '0';
          wr_resp   <= '0';
          
        else
          ar_start  <= S_AXI_ARVALID  and not ar_done;
          ar_ack    <= S_AXI_ARVALID  and S_AXI_ARREADY_I;
          rd_valid  <= S_AXI_RVALID_I and S_AXI_RREADY;
          rd_last   <= S_AXI_RVALID_I and S_AXI_RREADY and S_AXI_RLAST_I;
          
          aw_start  <= S_AXI_AWVALID  and not aw_done;
          aw_ack    <= S_AXI_AWVALID  and S_AXI_AWREADY_I;
          wr_valid  <= S_AXI_WVALID   and S_AXI_WREADY_I;
          wr_last   <= S_AXI_WVALID   and S_AXI_WREADY_I and S_AXI_WLAST ;
          wr_resp   <= S_AXI_BVALID_I and S_AXI_BREADY;
          
          if( S_AXI_ARREADY_I = '1' ) then
            ar_done   <= '0';
          elsif( S_AXI_ARVALID = '1' ) then
            ar_done   <= '1';
          end if;
          
          if( S_AXI_AWREADY_I = '1' ) then
            aw_done   <= '0';
          elsif( S_AXI_AWVALID = '1' ) then
            aw_done   <= '1';
          end if;
          
        end if;
      end if;
    end process Trans_Handle;
    
    Latency_Inst: sc_stat_latency
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_LATENCY_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_LATENCY_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        ar_start                  => ar_start,
        ar_ack                    => ar_ack,
        rd_valid                  => rd_valid,
        rd_last                   => rd_last,
        aw_start                  => aw_start,
        aw_ack                    => aw_ack,
        wr_valid                  => wr_valid,
        wr_last                   => wr_last,
        wr_resp                   => wr_resp,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_rd_latency           => stat_s_axi_gen_rd_latency,
        stat_wr_latency           => stat_s_axi_gen_wr_latency,
        stat_rd_latency_conf      => stat_s_axi_gen_rd_latency_conf,
        stat_wr_latency_conf      => stat_s_axi_gen_wr_latency_conf
      );
    
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
--    IF_DEBUG(255 downto 128)  <= ARIF_DEBUG(127 downto   0);
--    IF_DEBUG(127 downto   0)  <= AWIF_DEBUG(127 downto   0);
--    IF_DEBUG(123 downto 0)  <= ARIF_DEBUG(123 downto 0);
--    IF_DEBUG(255 downto 124)  <= RIF_DEBUG(255 downto 124);
    IF_DEBUG  <= RIF_DEBUG;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_W_CHANNEL_ERROR)  <= w_assert when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_B_CHANNEL_ERROR)  <= b_assert when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_R_CHANNEL_ERROR)  <= r_assert when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_W_CHANNEL_ERROR) /= '1' 
      report "Generic AXI: W Channel error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_B_CHANNEL_ERROR) /= '1' 
      report "Generic AXI: B Channel error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_R_CHANNEL_ERROR) /= '1' 
      report "Generic AXI: R Channel error."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;






    
    
    
    


-------------------------------------------------------------------------------
-- sc_s_axi_ctrl_interface.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_s_axi_ctrl_interface.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              sc_s_axi_ctrl_interface.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2006-10-19    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;

entity sc_s_axi_ctrl_interface is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
    C_ENABLE_AUTOMATIC_CLEAN  : natural range  0 to    1      :=  0;
    C_AUTOMATIC_CLEAN_MODE    : natural range  0 to    1      :=  0;
    
    -- Data type and settings specific.
    C_ADDR_ALL_WAYS_HI        : natural range  4 to   31      := 14;
    C_ADDR_ALL_WAYS_LO        : natural range  4 to   31      :=  7;
    
    -- IP Specific.
    C_ENABLE_STATISTICS       : natural range  0 to  255      := 255;
    C_ENABLE_VERSION_REGISTER : natural range  0 to    3      :=  0;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EXCLUSIVE        : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_NUM_WAYS                : natural range  2 to    8      :=  2;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_CACHE_SIZE              : natural                       := 32768;
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  4;
    C_Lx_CACHE_SIZE           : natural                       := 1024;
    C_S_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32;
    C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    
    -- AXI4-Lite Interface Specific.
    C_S_AXI_CTRL_BASEADDR     : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
    C_S_AXI_CTRL_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
    C_S_AXI_CTRL_DATA_WIDTH   : natural range 32 to   64      := 32;
    C_S_AXI_CTRL_ADDR_WIDTH   : natural range 17 to   64      := 32
  );
  port (
    -- ---------------------------------------------------
    -- Common signals
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4-Lite Slave Interface Signals
    
    -- AW-Channel
    S_AXI_CTRL_AWADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    S_AXI_CTRL_AWPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_CTRL_AWVALID             : in  std_logic;
    S_AXI_CTRL_AWREADY             : out std_logic;

    -- W-Channel
    S_AXI_CTRL_WDATA               : in  std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
    S_AXI_CTRL_WVALID              : in  std_logic;
    S_AXI_CTRL_WREADY              : out std_logic;

    -- B-Channel
    S_AXI_CTRL_BRESP               : out std_logic_vector(1 downto 0);
    S_AXI_CTRL_BVALID              : out std_logic;
    S_AXI_CTRL_BREADY              : in  std_logic;

    -- AR-Channel
    S_AXI_CTRL_ARADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    S_AXI_CTRL_ARPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_CTRL_ARVALID             : in  std_logic;
    S_AXI_CTRL_ARREADY             : out std_logic;

    -- R-Channel
    S_AXI_CTRL_RDATA               : out std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
    S_AXI_CTRL_RRESP               : out std_logic_vector(1 downto 0);
    S_AXI_CTRL_RVALID              : out std_logic;
    S_AXI_CTRL_RREADY              : in  std_logic;

    
    -- ---------------------------------------------------
    -- Control If Transactions.
    
    ctrl_arbiter_allow              : out std_logic;
    ctrl_access                     : out ARBITRATION_TYPE;
    ctrl_ready                      : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Automatic Clean Information.
    
    update_auto_clean_push          : in  std_logic;
    update_auto_clean_addr          : in  AXI_ADDR_TYPE;
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_access_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    ctrl_lookup_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    ctrl_update_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    ctrl_backend_done               : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_bar_req                    : out INTERNAL_BAR_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_bar_done                   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_insert_running             : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Sync Request.
    
    ctrl_dvm_req                    : out INTERNAL_DVM_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
    ctrl_dvm_done                   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    -- General.
    
    stat_reset                      : out std_logic;
    stat_enable                     : out std_logic;
    
    -- Optimized ports.
    stat_s_axi_rd_segments          : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_wr_segments          : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_rip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_r                    : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_bip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_bp                   : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_w                    : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_rd_latency           : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wr_latency           : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_rd_latency_conf      : out STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wr_latency_conf      : out STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);

    -- Generic ports.
    stat_s_axi_gen_rd_segments      : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_gen_wr_segments      : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_gen_rip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_r                : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_bip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_bp               : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_w                : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_rd_latency       : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wr_latency       : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_rd_latency_conf  : out STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wr_latency_conf  : out STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    
    -- Arbiter
    stat_arb_valid                  : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid transactions exist
    stat_arb_concurrent_accesses    : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Transactions available each time command is arbitrated
    stat_arb_opt_read_blocked       : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
    stat_arb_gen_read_blocked       : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                                     -- Time valid read is blocked by prohibit
    
    -- Access
    stat_access_valid               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid per transaction
    stat_access_stall               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction
    stat_access_fetch_stall         : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (fetch)
    stat_access_req_stall           : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (req)
    stat_access_act_stall           : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (act)
    
    -- Lookup
    stat_lu_opt_write_hit           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss          : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_write_miss_dirty    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_hit            : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_read_miss_dirty     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_write_hit    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_locked_read_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_lu_opt_first_write_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    
    stat_lu_gen_write_hit           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss          : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_write_miss_dirty    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_hit            : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_read_miss_dirty     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_write_hit    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_locked_read_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_lu_gen_first_write_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
    
    stat_lu_stall                   : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_fetch_stall             : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_mem_stall               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_stall              : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_hit_stall          : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    stat_lu_data_miss_stall         : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
    
    -- Update
    stat_ud_stall                   : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time transactions are stalled
    stat_ud_tag_free                : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles tag is free
    stat_ud_data_free               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles data is free
    stat_ud_ri                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read Information
    stat_ud_r                       : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read data (optional)
    stat_ud_e                       : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Evict
    stat_ud_bs                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- BRESP Source
    stat_ud_wm                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss
    stat_ud_wma                     : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss Allocate (reserved)
    
    -- Backend
    stat_be_aw                      : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
    stat_be_w                       : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
    stat_be_ar                      : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
    stat_be_ar_search_depth         : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
    stat_be_ar_stall                : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
    stat_be_ar_protect_stall        : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
    stat_be_rd_latency              : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Read Latency
    stat_be_wr_latency              : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Write Latency
    stat_be_rd_latency_conf         : out STAT_CONF_TYPE;     -- External Read Latency Configuration
    stat_be_wr_latency_conf         : out STAT_CONF_TYPE;     -- External Write Latency Configuration
    
    
    -- ---------------------------------------------------
    -- Debug Signals
    
    IF_DEBUG                  : out std_logic_vector(255 downto 0)
  );
end entity sc_s_axi_ctrl_interface;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_s_axi_ctrl_interface is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Control interface for statistics and configuration.
  -- Statistics read data are pipelined to ensure timing.
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Custom types (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural:= 18;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ENABLE_STATISTICS_MASK   : std_logic_vector(7 downto 0) := int_to_std(C_ENABLE_STATISTICS, 8);
  
  
  subtype C_VERSION_REGISTER_POS      is natural range 31 downto 0;
  
  subtype VERSION_REGISTER_TYPE       is std_logic_vector(C_VERSION_REGISTER_POS);
  
  type VERSION_REGISTER_MEM_TYPE      is array (0 to 1) of VERSION_REGISTER_TYPE;
  
  constant C_NULL_VR                  : VERSION_REGISTER_TYPE     := (others=>'0');
  constant C_NULL_VR_MEM              : VERSION_REGISTER_MEM_TYPE := (others=>C_NULL_VR);
  
  function Populate_VR return VERSION_REGISTER_MEM_TYPE is
    variable VR : VERSION_REGISTER_MEM_TYPE := C_NULL_VR_MEM;
  begin
    -- VR0:
      VR(0)(31) := '0';  -- reserved
    if C_ENABLE_VERSION_REGISTER > 1 then
      VR(0)(30) := '1';
    else 
      VR(0)(30) := '0';
    end if;
    VR(0)(29 downto 25)  := int_to_std(C_NUM_GENERIC_PORTS,             5);
    VR(0)(24 downto 20)  := int_to_std(C_NUM_OPTIMIZED_PORTS,           5);
    VR(0)(19 downto 18)  := int_to_std(C_ENABLE_EXCLUSIVE,              2);
    VR(0)(17 downto 16)  := int_to_std(C_ENABLE_COHERENCY,              2);
    VR(0)(15 downto  8)  := C_ENABLE_STATISTICS_MASK;
    VR(0)( 7 downto  0)  := int_to_std(C_SYSTEM_CACHE_VERSION,          8);
    
    
    -- VR1:
    VR(1)(31 downto 22)  := int_to_std(0,                              10); -- reserved
    VR(1)(21 downto 19)  := int_to_std(Log2(C_Lx_CACHE_LINE_LENGTH/4),  3);
    VR(1)(18 downto 15)  := int_to_std(Log2(C_Lx_CACHE_SIZE/64),        4);
    VR(1)(14 downto 12)  := int_to_std(Log2(C_CACHE_LINE_LENGTH/4),     3);
    VR(1)(11 downto  8)  := int_to_std(Log2(C_CACHE_SIZE/64),           4);
    VR(1)( 7 downto  5)  := int_to_std(Log2(C_CACHE_DATA_WIDTH/8),      3);
    VR(1)( 4 downto  2)  := int_to_std(Log2(C_M_AXI_DATA_WIDTH/8),      3);
    VR(1)( 1 downto  0)  := int_to_std(Log2(C_NUM_WAYS/2),              2);

    return VR;
  end;
  
  constant C_VERSION_REGISTER         : VERSION_REGISTER_MEM_TYPE    := Populate_VR;
  
  
  -----------------------------------------------------------------------------
  -- Custom types (AXI)
  -----------------------------------------------------------------------------
  
  subtype C_ADDR_ALL_WAYS_POS         is natural range C_ADDR_ALL_WAYS_HI downto C_ADDR_ALL_WAYS_LO;
  
  subtype ADDR_ALL_WAYS_TYPE          is std_logic_vector(C_ADDR_ALL_WAYS_POS);
  
  constant C_INIT_CNT_MAX             : ADDR_ALL_WAYS_TYPE := (others=>'1');
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------

  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  
  -- 
  -- Address bit utilization for statistics addresses (category 0 to 6):
  -- 
  --   16           14 13      13 12         10 9         5 4        3 2         2 1   0
  --  |_______________|__________|_____________|___________|__________|___________|_____
  --  |_______________|__________|_____________|___________|__________|___________|_____|
  --                             
  --   \_____________/ \________/ \___________/ \_________/ \________/ \_________/ \___/
  --    |               |          |             |           |          |           |                 
  --    Category Addr   Reserved   Number Addr   Info Addr   Sub Addr   Word Addr   Byte Addr
  -- 
  -- 
  -- Category - The category group: Ports, pipeline stages and configuration.
  -- Number   - Port number.
  -- Info     - Statistics information type.
  -- Sub      - Sub element of information type.
  -- Word     - High/Low word in statistics data.
  -- 
  -- 
  -- 
  -- Address bit utilization for configuration addresses (category 7):
  -- 
  --   16           14 13                             7 6            3 2         2 1   0
  --  |_______________|________________________________|______________|___________|_____
  --  |_______________|________________________________|______________|___________|_____|
  --                                                            
  --   \_____________/ \______________________________/ \____________/ \_________/ \___/
  --    |               |                                |              |           |                 
  --    Category Addr   Reserved                         Config Addr    Word Addr   Byte Addr
  -- 
  -- 
  -- Config    - Configuration parameter address.
  -- 
  -- 
  
  subtype C_STAT_CATEGORY_ADDR_POS    is natural range 16 downto 14;
  subtype C_STAT_NUMBER_ADDR_POS      is natural range 12 downto 10;
  subtype C_STAT_INFO_ADDR_POS        is natural range  9 downto  5;
  subtype C_STAT_SUB_ADDR_POS         is natural range  4 downto  3;
  subtype C_STAT_CONFIG_ADDR_POS      is natural range  6 downto  3;
  subtype C_STAT_WORD_ADDR_POS        is natural range  2 downto  2;
  
  subtype STAT_CATEGORY_ADDR_TYPE     is std_logic_vector(C_STAT_CATEGORY_ADDR_POS);
  subtype STAT_NUMBER_ADDR_TYPE       is std_logic_vector(C_STAT_NUMBER_ADDR_POS);
  subtype STAT_INFO_ADDR_TYPE         is std_logic_vector(C_STAT_INFO_ADDR_POS);
  subtype STAT_SUB_ADDR_TYPE          is std_logic_vector(C_STAT_SUB_ADDR_POS);
  subtype STAT_CONFIG_ADDR_TYPE       is std_logic_vector(C_STAT_CONFIG_ADDR_POS);
  subtype STAT_WORD_ADDR_TYPE         is std_logic_vector(C_STAT_WORD_ADDR_POS);
  
  constant C_STAT_CATEGORY_NUM        : natural := 2 ** (STAT_CATEGORY_ADDR_TYPE'high - STAT_CATEGORY_ADDR_TYPE'low + 1);
  constant C_STAT_NUMBER_NUM          : natural := 2 ** (STAT_NUMBER_ADDR_TYPE'high   - STAT_NUMBER_ADDR_TYPE'low + 1);
  constant C_STAT_INFO_NUM            : natural := 2 ** (STAT_INFO_ADDR_TYPE'high     - STAT_INFO_ADDR_TYPE'low + 1);
  constant C_STAT_SUB_NUM             : natural := 2 ** (STAT_SUB_ADDR_TYPE'high      - STAT_SUB_ADDR_TYPE'low + 1);
  constant C_STAT_CONFIG_NUM          : natural := 2 ** (STAT_CONFIG_ADDR_TYPE'high   - STAT_CONFIG_ADDR_TYPE'low + 1);
  constant C_STAT_WORD_NUM            : natural := 2 ** (STAT_WORD_ADDR_TYPE'high     - STAT_WORD_ADDR_TYPE'low + 1);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  type AC_TYPE is record
    Addr              : AXI_ADDR_TYPE;
  end record AC_TYPE;
  
  constant C_NULL_AC                : AC_TYPE    := (Addr=>(others=>'0'));
  
  type AC_FIFO_MEM_TYPE             is array(QUEUE_ADDR_POS)      of AC_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to    8      :=  5;
      C_LINE_LENGTH             : natural range  1 to  128      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  
  -- ----------------------------------------
  -- Initilization Handler
  
  signal ctrl_init_last             : std_logic;
  signal ctrl_init_done_i           : std_logic;
  signal ctrl_init_cnt              : ADDR_ALL_WAYS_TYPE;
  
  
  -- ----------------------------------------
  -- Automatic Clean handling
  
  signal ac_valid                   : std_logic;
  signal ac_addr                    : AXI_ADDR_TYPE;
  
  signal ac_scaler                  : std_logic_vector(9 downto 0);
  signal ac_cnt                     : ADDR_ALL_WAYS_TYPE;
  
  signal ac_push                    : std_logic;
  signal ac_pop                     : std_logic;
  signal ac_fifo_empty              : std_logic;
  signal ac_read_fifo_addr          : QUEUE_ADDR_TYPE;
  signal ac_fifo_mem                : AC_FIFO_MEM_TYPE;
  
  
  -- ----------------------------------------
  -- Transaction Handler
  
  signal new_ctrl_transaction       : boolean;
  signal new_init_transaction       : boolean;
  signal new_auto_transaction       : boolean;
  signal ctrl_access_i              : ARBITRATION_TYPE;
  
  
  -- ----------------------------------------
  -- Barrier Handling
  
  signal ctrl_barrier               : std_logic;
  signal ctrl_bar_valid             : std_logic;
  signal bar_syncro                 : std_logic;
  
  
  -- ----------------------------------------
  -- DVM Message Handling
  
  signal ctrl_dvm_valid             : std_logic;
  
  
  
  -- ----------------------------------------
  -- Write Handling
  
  signal write_ongoing              : std_logic;
  signal write_1st_cycle            : std_logic;
  signal write_2nd_cycle            : std_logic;
  signal write_3rd_cycle            : std_logic;
  signal write_secure               : std_logic;
  signal write_failed               : std_logic;
  signal write_error                : std_logic;
  signal w_data                     : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_clean_data               : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_flush_data               : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_secure_clean_data        : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_secure_flush_data        : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_dvm_1st_data             : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_dvm_2nd_data             : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_bar_data                 : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_secure_dvm_1st_data      : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_secure_dvm_2nd_data      : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal w_secure_bar_data          : std_logic_vector(C_MAX_ADDR_WIDTH-1 downto 0);
  signal S_AXI_CTRL_BVALID_I        : std_logic;
  
  
  -- ----------------------------------------
  -- Read Handling
  
  signal read_ongoing               : std_logic;
  signal read_ongoing_d1            : std_logic;
  signal read_ongoing_d2            : std_logic;
  signal read_ongoing_d3            : std_logic;
  signal read_ongoing_d4            : std_logic;
  signal read_secure                : std_logic;
  signal read_failed                : std_logic;
  signal read_error                 : std_logic;
  signal S_AXI_CTRL_RVALID_I        : std_logic;
  signal S_AXI_CTRL_RDATA_I         : std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
  
  
  -- ----------------------------------------
  -- Command registers (Read/Write)
  
  signal wr_word_idx                : natural range 0 to 2 ** STAT_WORD_ADDR_TYPE'length - 1;
  signal wr_cfg_idx                 : natural range 0 to 2 ** STAT_CONFIG_ADDR_TYPE'length - 1;
  signal wr_sub_idx                 : natural range 0 to 2 ** STAT_SUB_ADDR_TYPE'length - 1;
  signal wr_info_idx                : natural range 0 to 2 ** STAT_INFO_ADDR_TYPE'length - 1;
  signal wr_num_idx                 : natural range 0 to 2 ** STAT_NUMBER_ADDR_TYPE'length - 1;
  signal wr_cat_idx                 : natural range 0 to 2 ** STAT_CATEGORY_ADDR_TYPE'length - 1;
  
  signal stat_s_axi_rd_latency_conf_i     : STAT_CONF_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_wr_latency_conf_i     : STAT_CONF_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_gen_rd_latency_conf_i : STAT_CONF_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_wr_latency_conf_i : STAT_CONF_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_be_rd_latency_conf_i        : STAT_CONF_TYPE;
  signal stat_be_wr_latency_conf_i        : STAT_CONF_TYPE;
  signal stat_ctrl_conf_i                 : STAT_CONF_TYPE;
  signal stat_ctrl_version_register_0     : STAT_CONF_TYPE := Stat_Conf_Set_Register(C_VERSION_REGISTER(0), 32);
  signal stat_ctrl_version_register_1     : STAT_CONF_TYPE := Stat_Conf_Set_Register(C_VERSION_REGISTER(1), 32);
    
    
  -- ----------------------------------------
  -- Statistics registers (Read)
  
  signal word_idx                   : natural range 0 to 2 ** STAT_WORD_ADDR_TYPE'length - 1;
  signal cfg_idx                    : natural range 0 to 2 ** STAT_CONFIG_ADDR_TYPE'length - 1;
  signal sub_idx                    : natural range 0 to 2 ** STAT_SUB_ADDR_TYPE'length - 1;
  signal info_idx                   : natural range 0 to 2 ** STAT_INFO_ADDR_TYPE'length - 1;
  signal num_idx                    : natural range 0 to 2 ** STAT_NUMBER_ADDR_TYPE'length - 1;
  signal cat_idx                    : natural range 0 to 2 ** STAT_CATEGORY_ADDR_TYPE'length - 1;
  signal block_idx                  : natural range 0 to C_CACHE_BLOCKS - 1;
  signal master_idx                 : natural range 0 to C_NUM_MASTER_PORTS - 1;
  
  signal selected_block_idx         : natural range 0 to C_CACHE_BLOCKS - 1;
  
  signal stat_opt_rd_segments       : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
  signal stat_opt_wr_segments       : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
  signal stat_opt_rip               : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_r                 : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_bip               : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_bp                : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_wip               : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_w                 : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_rd_latency        : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_wr_latency        : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_rd_latency_conf   : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_wr_latency_conf   : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt                   : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_gen_rd_segments       : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0); -- Per transaction
  signal stat_gen_wr_segments       : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0); -- Per transaction
  signal stat_gen_rip               : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_r                 : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_bip               : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_bp                : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_wip               : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_w                 : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_rd_latency        : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_wr_latency        : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_rd_latency_conf   : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_wr_latency_conf   : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen                   : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_arb_opt_rd_blocked    : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_arb_gen_rd_blocked    : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_arbiter               : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_access                : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_opt_write_hit         : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_write_miss        : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_write_miss_dirty  : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_read_hit          : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_read_miss         : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_read_miss_dirty   : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_locked_write_hit  : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_locked_read_hit   : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_opt_first_write_hit   : STAT_VECTOR_TYPE(C_MAX_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_gen_write_hit         : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_write_miss        : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_write_miss_dirty  : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_read_hit          : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_read_miss         : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_read_miss_dirty   : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_locked_write_hit  : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_locked_read_hit   : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_gen_first_write_hit   : STAT_VECTOR_TYPE(C_MAX_GENERIC_PORTS - 1 downto 0);
  signal stat_lookup                : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_update                : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_backend               : STAT_VECTOR_TYPE(C_STAT_INFO_NUM - 1 downto 0);
  
  signal stat_ctrl                  : STAT_VECTOR_TYPE(C_STAT_CONFIG_NUM - 1 downto 0);
  
  signal stat_result                : STAT_VECTOR_TYPE(C_STAT_CATEGORY_NUM - 1 downto 0);
  
  signal stat_reset_i               : std_logic;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1             : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Initialization Handler
  -----------------------------------------------------------------------------
  
  Initialization_Handle : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        ctrl_init_last    <= '0';
        ctrl_init_done_i  <= '0';
        ctrl_init_cnt     <= (others=>'0');
        
      else
        -- Handle counting.
        if( ( ctrl_init_done_i = '0' ) and ( ctrl_ready = '1' ) ) then
          ctrl_init_cnt     <= std_logic_vector(unsigned(ctrl_init_cnt) + 1);
          ctrl_init_last    <= b2s(ctrl_init_cnt = C_INIT_CNT_MAX);
          
          -- Handle status.
          ctrl_init_done_i  <= ctrl_init_last;
          
        end if;
        
      end if;
    end if;
  end process Initialization_Handle;
  
  ctrl_arbiter_allow  <= ctrl_init_done_i and not ctrl_barrier;
  
  
  -----------------------------------------------------------------------------
  -- Transaction Handler
  -----------------------------------------------------------------------------
  
  -- Decode transaction types: Clean/Flush.
  new_ctrl_transaction  <= ( wr_cat_idx = C_STAT_ADDR_CTRL_CATEGORY  ) and 
                           ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN        ) or 
                             ( wr_cfg_idx = C_STAT_ADDR_CTRL_FLUSH        ) or
                             ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_CLEAN ) or 
                             ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_FLUSH ) ) and
                           ( ( C_S_AXI_CTRL_DATA_WIDTH > 32 ) or
                             ( wr_word_idx             =  0 ) ) and
                           ( write_2nd_cycle = '1' ) and
                           ( write_error     = '0' );
  
  -- Decode transaction types: Init.
  new_init_transaction  <= ( ( ctrl_access_i.Valid = '0' ) or ( ctrl_ready = '1' ) ) and 
                           ( ctrl_init_done_i = '0' ) and
                           ( ctrl_init_last   = '0' );
  
  -- Decode transaction types: Automatic Clean.
  new_auto_transaction  <= ( ( ctrl_access_i.Valid = '0' ) or ( ctrl_ready = '1' ) ) and 
                           ( ctrl_dvm_valid = '0' ) and
                           ( ctrl_init_done_i = '1' ) and ( ac_valid = '1' ) and 
                           ( C_ENABLE_AUTOMATIC_CLEAN > 0 );
  
  Transaction_Handle : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        ctrl_access_i                     <= C_NULL_ARBITRATION;
        
      else
        if( new_ctrl_transaction ) then
          -- Starting a transaction from Ctrl Interface.
          ctrl_access_i.Valid         <= '1';
          ctrl_access_i.Wr            <= '0';
          ctrl_access_i.Port_Num      <= (others=>'0');
          ctrl_access_i.Len           <= NULL_AXI_LENGTH;
          ctrl_access_i.Kind          <= C_KIND_WRAP;
          ctrl_access_i.Exclusive     <= '0';
          ctrl_access_i.Allocate      <= '0';
          ctrl_access_i.Bufferable    <= '0';
          ctrl_access_i.Evict         <= '1';
          if( ( C_ENABLE_NON_SECURE = 0 ) or 
              ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN ) or ( wr_cfg_idx = C_STAT_ADDR_CTRL_FLUSH ) ) ) then
            ctrl_access_i.Prot          <= NULL_AXI_PROT;               -- Normal and non-Secure Data access only
          else
            ctrl_access_i.Prot          <= (others=>'0');               -- Normal and     Secure Data access only
          end if;
          if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN ) or ( wr_cfg_idx =  C_STAT_ADDR_CTRL_SECURE_CLEAN ) ) then
            ctrl_access_i.Snoop         <= C_ARSNOOP_MakeInvalid;
            ctrl_access_i.Ignore_Data   <= '1';
            if( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN ) then
              ctrl_access_i.Addr          <= fit_vec(w_clean_data, C_MAX_ADDR_WIDTH);
            else
              ctrl_access_i.Addr          <= fit_vec(w_secure_clean_data, C_MAX_ADDR_WIDTH);
            end if;
          else
            ctrl_access_i.Snoop         <= C_ARSNOOP_CleanInvalid;
            ctrl_access_i.Ignore_Data   <= '0';
            if( wr_cfg_idx = C_STAT_ADDR_CTRL_FLUSH ) then
              ctrl_access_i.Addr          <= fit_vec(w_flush_data, C_MAX_ADDR_WIDTH);
            else
              ctrl_access_i.Addr          <= fit_vec(w_secure_flush_data, C_MAX_ADDR_WIDTH);
            end if;
          end if;
          ctrl_access_i.Force_Hit     <= '0';
          ctrl_access_i.Internal_Cmd  <= '1';
          ctrl_access_i.Barrier       <= C_BAR_NORMAL_RESPECTING;
          ctrl_access_i.Domain        <= C_DOMAIN_INNER_SHAREABLE;
          ctrl_access_i.Size          <= C_WORD_SIZE;
          
        elsif( new_init_transaction ) then 
          -- Generating Init Sequence transactions.
          ctrl_access_i.Valid         <= '1';
          ctrl_access_i.Wr            <= '0';
          ctrl_access_i.Port_Num      <= (others=>'0');
          ctrl_access_i.Addr          <= (others=>'0');
          ctrl_access_i.Addr(C_ADDR_ALL_WAYS_POS)
                                      <= ctrl_init_cnt;
          ctrl_access_i.Len           <= NULL_AXI_LENGTH;
          ctrl_access_i.Kind          <= C_KIND_WRAP;
          ctrl_access_i.Exclusive     <= '0';
          ctrl_access_i.Allocate      <= '0';
          ctrl_access_i.Bufferable    <= '0';
          ctrl_access_i.Evict         <= '1';
          ctrl_access_i.Prot          <= NULL_AXI_PROT;
          ctrl_access_i.Snoop         <= C_ARSNOOP_MakeInvalid;
          ctrl_access_i.Ignore_Data   <= '1';
          ctrl_access_i.Force_Hit     <= '1';
          ctrl_access_i.Internal_Cmd  <= '1';
          ctrl_access_i.Barrier       <= C_BAR_NORMAL_RESPECTING;
          ctrl_access_i.Domain        <= C_DOMAIN_INNER_SHAREABLE;
          ctrl_access_i.Size          <= C_WORD_SIZE;
          
        elsif( new_auto_transaction ) then 
          -- Generating Automatic Clean transactions.
          ctrl_access_i.Valid         <= '1';
          ctrl_access_i.Wr            <= '0';
          ctrl_access_i.Port_Num      <= (others=>'0');
          ctrl_access_i.Addr          <= ac_addr;
          ctrl_access_i.Len           <= NULL_AXI_LENGTH;
          ctrl_access_i.Kind          <= C_KIND_WRAP;
          ctrl_access_i.Exclusive     <= '0';
          ctrl_access_i.Allocate      <= '1';
          ctrl_access_i.Bufferable    <= '0';
          ctrl_access_i.Evict         <= '1';
          ctrl_access_i.Prot          <= NULL_AXI_PROT;
          ctrl_access_i.Snoop         <= C_ARSNOOP_CleanInvalid;
          ctrl_access_i.Ignore_Data   <= '0';
          ctrl_access_i.Force_Hit     <= '0';
          ctrl_access_i.Internal_Cmd  <= '1';
          ctrl_access_i.Barrier       <= C_BAR_NORMAL_RESPECTING;
          ctrl_access_i.Domain        <= C_DOMAIN_INNER_SHAREABLE;
          ctrl_access_i.Size          <= C_WORD_SIZE;
          
        elsif( ctrl_ready = '1' ) then
          -- End transaction.
          ctrl_access_i.Valid       <= '0';
          ctrl_access_i             <= C_NULL_ARBITRATION;
          
        end if;
        
      end if;
    end if;
  end process Transaction_Handle;
  
  ctrl_access                     <= ctrl_access_i;
  
  
  -----------------------------------------------------------------------------
  -- Automatic Clean handling
  -----------------------------------------------------------------------------
  
  Use_AC: if ( C_ENABLE_AUTOMATIC_CLEAN > 0 ) generate
  begin
  
    Use_Mode_0: if ( C_AUTOMATIC_CLEAN_MODE /= 1 ) generate
    begin
      -- Unused signals
      ac_push           <= '0';
      ac_pop            <= '0';
      ac_fifo_empty     <= '1';
      ac_read_fifo_addr <= (others=>'0');
      
      ac_scaler         <= (others=>'0');
      ac_cnt            <= (others=>'0');
      
      ac_valid          <= '0';
      ac_addr           <= (others=>'0');
      
    end generate Use_Mode_0;
    
    Use_Mode_1: if ( C_AUTOMATIC_CLEAN_MODE = 1 ) generate
      signal wma_fifo_mem               : AC_FIFO_MEM_TYPE; -- := (others=>C_NULL_AC);
    begin
      
      ac_push <= update_auto_clean_push;
      ac_pop  <= ac_valid and ctrl_ready;
      
      FIFO_AC_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => true,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => ac_push,
          queue_pop                 => ac_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => open,
          queue_almost_empty        => open,
          queue_empty               => ac_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => ac_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset_i,
          stat_enable               => stat_ctrl_conf_i(C_CTRL_CONF_ENABLE),
          
          stat_data                 => open,
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => open,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
      
      -- Handle memory for Write Miss Allocate FIFO.
      FIFO_AC_Memory : process (ACLK) is
      begin  -- process FIFO_AC_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( ac_push = '1' ) then
            -- Insert new item.
            ac_fifo_mem(0).Addr <= update_auto_clean_addr;
            
            -- Shift FIFO contents.
            ac_fifo_mem(ac_fifo_mem'left downto 1) <= ac_fifo_mem(ac_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_AC_Memory;
      
      ac_valid      <= not ac_fifo_empty;
      
      -- Extract current Write Miss information.
      ac_addr       <= ac_fifo_mem(to_integer(unsigned(ac_read_fifo_addr))).Addr;
      
      -- Unused
      ac_scaler     <= (others=>'0');
      ac_cnt        <= (others=>'0');
      
    end generate Use_Mode_1;
  
  end generate Use_AC;
  
  No_AC: if ( C_ENABLE_AUTOMATIC_CLEAN < 1 ) generate
  begin
    
    -- Unused signals
    ac_push           <= '0';
    ac_pop            <= '0';
    ac_fifo_empty     <= '1';
    ac_read_fifo_addr <= (others=>'0');
    ac_scaler         <= (others=>'0');
    ac_cnt            <= (others=>'0');
    ac_valid          <= '0';
    ac_addr           <= (others=>'0');
    
  end generate No_AC;
  
  
  -----------------------------------------------------------------------------
  -- DVM Message Handling
  -----------------------------------------------------------------------------
  
  Insert_DVM_Handle : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        ctrl_dvm_valid  <= '0';
        
      else
        if( ( is_mst_coherent(C_ENABLE_COHERENCY) > 0       ) and
            ( wr_cat_idx = C_STAT_ADDR_CTRL_CATEGORY        ) and 
            ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM0        ) or 
              ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM0 ) ) and
            ( ( C_S_AXI_CTRL_DATA_WIDTH > 32 ) or
              ( wr_word_idx             =  0 ) ) and
            ( write_1st_cycle = '1' ) and
            ( write_failed    = '0' ) ) then
          ctrl_dvm_valid  <= '1';
        
        elsif( ctrl_dvm_done(0) = '1' ) then
          ctrl_dvm_valid  <= '0';
        
        end if;
      end if;
    end if;
  end process Insert_DVM_Handle;
  
  
  -----------------------------------------------------------------------------
  -- Internal Request.
  -----------------------------------------------------------------------------
    
  -- Assemble messages
  Assemble_DVM_Message : process (ctrl_dvm_valid, w_dvm_1st_data, w_dvm_2nd_data, 
                                  w_secure_dvm_1st_data, w_secure_dvm_2nd_data, 
                                  ctrl_bar_valid, bar_syncro, w_bar_data, w_secure_bar_data, 
                                  wr_cfg_idx) is 
  begin  
    for I in 0 to C_NUM_MASTER_PORTS - 1 loop
      ctrl_dvm_req(I).Valid         <= ctrl_dvm_valid;
      if( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM0 ) then
        ctrl_dvm_req(I).Addr_1st      <= w_secure_dvm_1st_data;
        ctrl_dvm_req(I).Addr_2nd      <= w_secure_dvm_2nd_data;
      else
        ctrl_dvm_req(I).Addr_1st      <= w_dvm_1st_data;
        ctrl_dvm_req(I).Addr_2nd      <= w_dvm_2nd_data;
      end if;
      
      ctrl_bar_req(I).Valid         <= ctrl_bar_valid;
      ctrl_bar_req(I).Synchronizing <= bar_syncro;
      if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0    ) or
          ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR1    ) ) then
        ctrl_bar_req(I).Addr          <= w_secure_bar_data;
      else
        ctrl_bar_req(I).Addr          <= w_bar_data;
      end if;
    end loop;
  end process Assemble_DVM_Message;
  
  
  -----------------------------------------------------------------------------
  -- ACE Downstream Barrier Request.
  -----------------------------------------------------------------------------
    
  Insert_BAR_Handle : process (ACLK) is 
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if (ARESET_I = '1') then              -- synchronous reset (active true)
        ctrl_barrier    <= '0';
        ctrl_bar_valid  <= '0';
        bar_syncro      <= '0';
        
      else
        if( ( is_mst_coherent(C_ENABLE_COHERENCY) > 0 ) and
            ( wr_cat_idx = C_STAT_ADDR_CTRL_CATEGORY  ) and 
            ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR0           ) or
              ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR1           ) or
              ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0    ) or
              ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR1    ) ) and
            ( ( C_S_AXI_CTRL_DATA_WIDTH > 32 ) or
              ( wr_word_idx             =  0 ) ) and
            ( write_1st_cycle = '1' ) and
            ( write_failed    = '0' ) ) then
          -- Temporarily stop arbitration to empty pipeline.
          ctrl_barrier    <= '1';
          if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR0        ) or
              ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0 ) ) then
            bar_syncro      <= '0';
          else
            bar_syncro      <= '1';
          end if;
        
        elsif( ( ctrl_barrier                  = '1' ) and 
               ( reduce_and(ctrl_access_done)  = '1' ) and 
               ( reduce_and(ctrl_lookup_done)  = '1' ) and 
               ( reduce_and(ctrl_update_done)  = '1' ) and 
               ( reduce_and(ctrl_backend_done) = '1' ) ) then
          -- Issue transactions downstream.
          ctrl_barrier    <= '0';
          ctrl_bar_valid  <= '1';
        
        elsif( ctrl_bar_done(0) = '1' ) then
          -- End cycle.
          ctrl_bar_valid  <= '0';
        
        end if;
      end if;
    end if;
  end process Insert_BAR_Handle;
  
  
  -----------------------------------------------------------------------------
  -- Statistics handling
  -----------------------------------------------------------------------------
  
  Use_Ctrl: if ( C_ENABLE_CTRL > 0 ) generate
    
    signal aw_addr                    : std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    signal ar_addr                    : std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    
  begin
    
    -----------------------------------------------------------------------------
    -- Write Handling
    -----------------------------------------------------------------------------
    
    Write_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          write_ongoing         <= '0';
          write_1st_cycle       <= '0';
          write_2nd_cycle       <= '0';
          write_3rd_cycle       <= '0';
          write_secure          <= '0';
          write_error           <= '0';
          S_AXI_CTRL_BVALID_I   <= '0';
          S_AXI_CTRL_BRESP      <= C_BRESP_OKAY;
          aw_addr               <= (others=>'0');
          w_data                <= (others=>'0');
          w_clean_data          <= (others=>'0');
          w_flush_data          <= (others=>'0');
          w_dvm_1st_data        <= (others=>'0');
          w_dvm_2nd_data        <= (others=>'0');
          w_bar_data            <= (others=>'0');
          w_secure_clean_data   <= (others=>'0');
          w_secure_flush_data   <= (others=>'0');
          w_secure_dvm_1st_data <= (others=>'0');
          w_secure_dvm_2nd_data <= (others=>'0');
          w_secure_bar_data     <= (others=>'0');
          
        else
          -- Default assignment.
          write_1st_cycle     <= '0';
          write_2nd_cycle     <= write_1st_cycle;
          write_3rd_cycle     <= write_2nd_cycle;
          
          -- Control response.
          if( S_AXI_CTRL_BVALID_I = '1' and S_AXI_CTRL_BREADY = '1' ) then
            S_AXI_CTRL_BVALID_I <= '0';
            
          elsif( ( ( ctrl_access_i.Valid = '0' ) and 
                   ( ctrl_dvm_valid      = '0' ) and 
                   ( ctrl_barrier        = '0' ) and 
                   ( ctrl_bar_valid      = '0' ) and 
                   ( write_3rd_cycle     = '1' ) ) or 
                 ( ( ctrl_access_i.Valid = '1' ) and 
                   ( ctrl_ready          = '1' ) and 
                   ( ctrl_init_done_i    = '1' ) and 
                   ( write_ongoing       = '1' ) ) or
                 ( ( ctrl_dvm_valid      = '1' ) and 
                   ( ctrl_dvm_done(0)    = '1' ) and 
                   ( ctrl_init_done_i    = '1' ) and 
                   ( write_ongoing       = '1' ) ) or
                 ( ( ctrl_bar_valid      = '1' ) and 
                   ( ctrl_bar_done(0)    = '1' ) and 
                   ( ctrl_init_done_i    = '1' ) and 
                   ( write_ongoing       = '1' ) ) ) then
            S_AXI_CTRL_BVALID_I <= '1';
            
          end if;
          
          -- Control write sequence.
          if( S_AXI_CTRL_BVALID_I = '1' and S_AXI_CTRL_BREADY = '1' ) then
            write_ongoing       <= '0';
            write_1st_cycle     <= '0';
            
          elsif( S_AXI_CTRL_AWVALID = '1' and  S_AXI_CTRL_WVALID = '1' and write_ongoing = '0' and 
                 ctrl_init_done_i = '1' ) then
            write_ongoing       <= '1';
            write_1st_cycle     <= '1';
            
          end if;
          
          -- Capture data and address.
          if( S_AXI_CTRL_AWVALID = '1' and  S_AXI_CTRL_WVALID = '1' and write_ongoing = '0' ) then
            -- Store address.
            aw_addr             <=     S_AXI_CTRL_AWADDR;
            write_secure        <= not S_AXI_CTRL_AWPROT(C_PROT_SECURE_POS);
            write_error         <=     '0';
            S_AXI_CTRL_BRESP    <=     C_BRESP_OKAY;
            
          end if;
          
          if( write_failed = '1' ) then
            S_AXI_CTRL_BRESP    <= C_BRESP_SLVERR;
            write_error         <= '1';
          end if;
          
          if( write_1st_cycle  = '1' ) then
            -- Store required data parts depending on sizes.
            if( ( C_S_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) or
                ( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and 
                  ( is_mst_coherent(C_ENABLE_COHERENCY) > 0      ) ) ) then
              if( wr_word_idx = 0 ) then
                w_clean_data(31 downto 0)                         <= fit_vec(S_AXI_CTRL_WDATA, 32);
                w_flush_data(31 downto 0)                         <= fit_vec(S_AXI_CTRL_WDATA, 32);
                w_secure_clean_data(31 downto 0)                  <= fit_vec(S_AXI_CTRL_WDATA, 32);
                w_secure_flush_data(31 downto 0)                  <= fit_vec(S_AXI_CTRL_WDATA, 32);
                w_data(31 downto 0)                               <= fit_vec(S_AXI_CTRL_WDATA, 32);
              else
                if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_CLEAN ) ) ) then
                  w_clean_data(C_MAX_ADDR_WIDTH-1 downto 32)        <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
                if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_FLUSH ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_FLUSH ) ) ) then
                  w_flush_data(C_MAX_ADDR_WIDTH-1 downto 32)        <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
                if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_CLEAN ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_CLEAN ) ) ) then
                  w_secure_clean_data(C_MAX_ADDR_WIDTH-1 downto 32) <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
                if( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_FLUSH ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_FLUSH ) ) ) then
                  w_secure_flush_data(C_MAX_ADDR_WIDTH-1 downto 32) <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
                w_data(C_MAX_ADDR_WIDTH-1 downto 32)              <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
              end if;
              
            else
              w_clean_data                                      <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              w_flush_data                                      <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              w_secure_clean_data                               <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              w_secure_flush_data                               <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              w_data                                            <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              
            end if;
            
            if( is_mst_coherent(C_ENABLE_COHERENCY) > 0 ) then
              -- Store primary DVM part(s) depending on sizes (non-Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM0                                        ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM0 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_dvm_1st_data(31 downto 0)                         <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_dvm_1st_data(C_MAX_ADDR_WIDTH-1 downto 32)        <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              else
                w_dvm_1st_data                                      <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
              -- Store primary DVM part(s) depending on sizes (Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM0                          ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM0 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_secure_dvm_1st_data(31 downto 0)                  <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_secure_dvm_1st_data(C_MAX_ADDR_WIDTH-1 downto 32) <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              else
                w_secure_dvm_1st_data                               <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
              -- Store secondary DVM part(s) depending on sizes (non-Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM1                                        ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM1 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_dvm_2nd_data(31 downto 0)                         <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_dvm_2nd_data(C_MAX_ADDR_WIDTH-1 downto 32)        <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              elsif( ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM1                                        ) or
                     ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM1 ) ) ) then
                w_dvm_2nd_data                                      <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
              -- Store secondary DVM part(s) depending on sizes (Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM1                          ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM1 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_secure_dvm_2nd_data(31 downto 0)                  <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_secure_dvm_2nd_data(C_MAX_ADDR_WIDTH-1 downto 32) <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              elsif( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM1                          ) or
                     ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_DVM1 ) ) ) then
                w_secure_dvm_2nd_data                               <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
              -- Store Barrier part(s) depending on sizes (non-Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR0           ) or
                    ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR1           ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0 ) ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR1 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_bar_data(31 downto 0)                             <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_bar_data(C_MAX_ADDR_WIDTH-1 downto 32)            <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              else
                w_bar_data                                          <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
              -- Store Barrier part(s) depending on sizes (Secure).
              if( ( C_M_AXI_ADDR_WIDTH > C_S_AXI_CTRL_DATA_WIDTH ) and
                  ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0           ) or
                    ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR1           ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR0 ) ) or
                    ( ( C_ENABLE_NON_SECURE = 0 ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_BAR1 ) ) ) ) then
                if( wr_word_idx = 0 ) then
                  w_secure_bar_data(31 downto 0)                      <= fit_vec(S_AXI_CTRL_WDATA, 32);
                else
                  w_secure_bar_data(C_MAX_ADDR_WIDTH-1 downto 32)     <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH - 32);
                end if;
              else
                w_secure_bar_data                                   <= fit_vec(S_AXI_CTRL_WDATA, C_MAX_ADDR_WIDTH);
              end if;
              
            end if;
            
          end if;
        end if;
      end if;
    end process Write_Handle;
    
    -- Check register access is ok.
    write_failed        <= '1' when ( ( C_ENABLE_NON_SECURE > 0   ) and 
                                      ( write_1st_cycle = '1' ) and 
                                      ( write_secure    = '0' ) and 
                                      ( ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_CLEAN ) or
                                        ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_FLUSH ) or
                                        ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM0  ) or
                                        ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_DVM1  ) or
                                        ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR0  ) or
                                        ( wr_cfg_idx = C_STAT_ADDR_CTRL_SECURE_BAR1  ) ) ) else
                           '0';
    
    -- AW-Channel.
    S_AXI_CTRL_AWREADY  <= write_1st_cycle;
    
    -- W-Channel.
    S_AXI_CTRL_WREADY   <= write_1st_cycle;
    
    
    -----------------------------------------------------------------------------
    -- Read Handling
    -----------------------------------------------------------------------------
    
    Read_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          read_ongoing      <= '0';
          read_ongoing_d1   <= '0';
          read_ongoing_d2   <= '0';
          read_ongoing_d3   <= '0';
          read_ongoing_d4   <= '0';
          ar_addr           <= (others=>'0');
          read_secure       <= '0';
          read_error        <= '0';
          S_AXI_CTRL_RRESP  <= C_RRESP_OKAY(C_AXI_SHORT_RRESP_POS);
          
        else
          read_ongoing_d1   <= read_ongoing;
          read_ongoing_d2   <= read_ongoing_d1;
          read_ongoing_d3   <= read_ongoing_d2;
          read_ongoing_d4   <= read_ongoing_d3;
        
          if( S_AXI_CTRL_RVALID_I = '1' and S_AXI_CTRL_RREADY = '1' ) then
            read_ongoing      <= '0';
            read_ongoing_d1   <= '0';
            read_ongoing_d2   <= '0';
            read_ongoing_d3   <= '0';
            read_ongoing_d4   <= '0';
            
          elsif( S_AXI_CTRL_ARVALID = '1' and read_ongoing = '0' ) then
            read_ongoing      <=     '1';
            ar_addr           <=     S_AXI_CTRL_ARADDR;
            S_AXI_CTRL_RRESP  <=     C_RRESP_OKAY(C_AXI_SHORT_RRESP_POS);
            read_secure       <= not S_AXI_CTRL_ARPROT(C_PROT_SECURE_POS);
            read_error        <=     '0';
            
          end if;
          
          if( read_failed = '1' ) then
            S_AXI_CTRL_RRESP  <=     C_RRESP_SLVERR(C_AXI_SHORT_RRESP_POS);
            read_error        <=     '1';
          end if;
        end if;
      end if;
    end process Read_Handle;
    
    -- Check register access is ok.
    read_failed         <= '0';
    
    -- AR-Channel.
    S_AXI_CTRL_ARREADY  <= not read_ongoing;
  
    -- R-Channel.
    S_AXI_CTRL_RVALID_I <= read_ongoing_d4;
    
    
    -----------------------------------------------------------------------------
    -- Command registers (Read/Write)
    -----------------------------------------------------------------------------
    
    -- Extract index from address.
    wr_word_idx <= to_integer(unsigned(aw_addr(C_STAT_WORD_ADDR_POS)));
    wr_cfg_idx  <= to_integer(unsigned(aw_addr(C_STAT_CONFIG_ADDR_POS)));
    wr_sub_idx  <= to_integer(unsigned(aw_addr(C_STAT_SUB_ADDR_POS)));
    wr_info_idx <= to_integer(unsigned(aw_addr(C_STAT_INFO_ADDR_POS)));
    wr_num_idx  <= to_integer(unsigned(aw_addr(C_STAT_NUMBER_ADDR_POS)));
    wr_cat_idx  <= to_integer(unsigned(aw_addr(C_STAT_CATEGORY_ADDR_POS)));
    
    
    -- Register bank.
    Register_Bank : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          stat_s_axi_rd_latency_conf_i      <= (others=>Stat_Conf_Set_Register(C_STAT_DEFAULT_RD_LAT_CONF, 
                                                                               C_RD_LATENCY_WIDTH));
          stat_s_axi_wr_latency_conf_i      <= (others=>Stat_Conf_Set_Register(C_STAT_DEFAULT_WR_LAT_CONF, 
                                                                               C_WR_LATENCY_WIDTH));
          stat_s_axi_gen_rd_latency_conf_i  <= (others=>Stat_Conf_Set_Register(C_STAT_DEFAULT_RD_LAT_CONF, 
                                                                               C_RD_LATENCY_WIDTH));
          stat_s_axi_gen_wr_latency_conf_i  <= (others=>Stat_Conf_Set_Register(C_STAT_DEFAULT_WR_LAT_CONF, 
                                                                               C_WR_LATENCY_WIDTH));
          stat_be_rd_latency_conf_i         <= Stat_Conf_Set_Register(C_STAT_DEFAULT_RD_LAT_CONF, C_RD_LATENCY_WIDTH);
          stat_be_wr_latency_conf_i         <= Stat_Conf_Set_Register(C_STAT_DEFAULT_WR_LAT_CONF, C_WR_LATENCY_WIDTH);
          
          stat_ctrl_conf_i                  <= Stat_Conf_Set_Register(C_STAT_DEFAULT_CTRL_CONF, C_CTRL_CONF_WIDTH);
          
          selected_block_idx                <= 0;
          
        elsif( ( write_2nd_cycle = '1' ) and
               ( write_error     = '0' ) ) then
          -- Select Optimized type stat (Clk 1).
          for I in 0 to C_NUM_OPTIMIZED_PORTS - 1 loop
            if( I = wr_num_idx ) then
              if( ( wr_cat_idx = C_STAT_ADDR_OPT_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_OPT_RD_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_OPT_CATEGORY) = '1' ) ) then
                stat_s_axi_rd_latency_conf_i(I) <= Stat_Conf_Set_Register(w_data, C_RD_LATENCY_WIDTH);
              end if;
              if( ( wr_cat_idx = C_STAT_ADDR_OPT_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_OPT_WR_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_OPT_CATEGORY) = '1' ) ) then
                stat_s_axi_wr_latency_conf_i(I) <= Stat_Conf_Set_Register(w_data, C_WR_LATENCY_WIDTH);
              end if;
            end if;
          end loop;
      
          -- Select Generic type stat.
          for I in 0 to C_MAX_GENERIC_PORTS - 1 loop
            if( I = wr_num_idx ) then
              if( ( wr_cat_idx = C_STAT_ADDR_GEN_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_GEN_RD_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_GEN_CATEGORY) = '1' ) ) then
                stat_s_axi_gen_rd_latency_conf_i(I) <= Stat_Conf_Set_Register(w_data, C_RD_LATENCY_WIDTH);
              end if;
              if( ( wr_cat_idx = C_STAT_ADDR_GEN_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_GEN_WR_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_GEN_CATEGORY) = '1' ) ) then
                stat_s_axi_gen_wr_latency_conf_i(I) <= Stat_Conf_Set_Register(w_data, C_WR_LATENCY_WIDTH);
              end if;
            end if;
          end loop;
          
          -- M_AXI.
          if( ( wr_cat_idx = C_STAT_ADDR_BE_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_BE_RD_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_BE_CATEGORY) = '1' ) ) then
            stat_be_rd_latency_conf_i  <= Stat_Conf_Set_Register(w_data, C_RD_LATENCY_WIDTH);
          end if;
          if( ( wr_cat_idx = C_STAT_ADDR_BE_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_BE_WR_LAT_CONF ) and
                  ( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_BE_CATEGORY) = '1' ) ) then
            stat_be_wr_latency_conf_i  <= Stat_Conf_Set_Register(w_data, C_WR_LATENCY_WIDTH);
          end if;
          
          -- Ctrl.
          if( ( wr_cat_idx = C_STAT_ADDR_CTRL_CATEGORY ) and ( wr_cfg_idx = C_STAT_ADDR_CTRL_ENABLE ) and
              ( C_ENABLE_STATISTICS > 0 ) ) then
              stat_ctrl_conf_i         <= Stat_Conf_Set_Register(w_data, C_CTRL_CONF_WIDTH);
          end if;
          
        end if;
      end if;
    end process Register_Bank;
    
    -- Assign external signals.
    stat_s_axi_rd_latency_conf      <= stat_s_axi_rd_latency_conf_i(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wr_latency_conf      <= stat_s_axi_wr_latency_conf_i(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_gen_rd_latency_conf  <= stat_s_axi_gen_rd_latency_conf_i(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wr_latency_conf  <= stat_s_axi_gen_wr_latency_conf_i(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_be_rd_latency_conf         <= stat_be_rd_latency_conf_i;
    stat_be_wr_latency_conf         <= stat_be_wr_latency_conf_i;
    
    stat_enable                     <= stat_ctrl_conf_i(C_CTRL_CONF_ENABLE);
    
    
    -----------------------------------------------------------------------------
    -- Statistics reset
    -----------------------------------------------------------------------------
    
    Reset_Handler : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ( wr_cat_idx = C_STAT_ADDR_CTRL_CATEGORY ) and ( wr_info_idx = C_STAT_ADDR_CTRL_RESET ) ) then
          stat_reset_i  <= ARESET_I or 
                           ( write_2nd_cycle and not write_error ) or 
                           ( not ctrl_init_done_i );
        else
          stat_reset_i  <= ARESET_I or 
                           ( not ctrl_init_done_i );
        end if;
      end if;
    end process Reset_Handler;
    
    stat_reset  <= stat_reset_i;
    
    
    -----------------------------------------------------------------------------
    -- Statistics registers (Read)
    -----------------------------------------------------------------------------
    
    -- Extract index from address.
    word_idx  <= to_integer(unsigned(ar_addr(C_STAT_WORD_ADDR_POS)));
    cfg_idx   <= to_integer(unsigned(ar_addr(C_STAT_CONFIG_ADDR_POS)));
    sub_idx   <= to_integer(unsigned(ar_addr(C_STAT_SUB_ADDR_POS)));
    info_idx  <= to_integer(unsigned(ar_addr(C_STAT_INFO_ADDR_POS)));
    num_idx   <= to_integer(unsigned(ar_addr(C_STAT_NUMBER_ADDR_POS)));
    cat_idx   <= to_integer(unsigned(ar_addr(C_STAT_CATEGORY_ADDR_POS)));
    
    Range_Limit : process(num_idx) is 
    begin  
      -- pragma translate_off
      if ( num_idx >= C_CACHE_BLOCKS ) then
        block_idx   <= 0;
      else
      -- pragma translate_on
        block_idx   <= num_idx;
      -- pragma translate_off
      end if;
      -- pragma translate_on
      
      -- pragma translate_off
      if ( num_idx >= C_NUM_MASTER_PORTS ) then
        master_idx   <= 0;
      else
      -- pragma translate_on
        master_idx  <= num_idx;
      -- pragma translate_off
      end if;
      -- pragma translate_on
      
    end process Range_Limit;
    
    
    Read_Mux : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          for I in 0 to C_MAX_OPTIMIZED_PORTS - 1 loop
            stat_opt_rd_segments(I)       <= (others=>'0');
            stat_opt_wr_segments(I)       <= (others=>'0');
            stat_opt_rip(I)               <= (others=>'0');
            stat_opt_r(I)                 <= (others=>'0');
            stat_opt_bip(I)               <= (others=>'0');
            stat_opt_bp(I)                <= (others=>'0');
            stat_opt_wip(I)               <= (others=>'0');
            stat_opt_w(I)                 <= (others=>'0');
            stat_opt_rd_latency(I)        <= (others=>'0');
            stat_opt_wr_latency(I)        <= (others=>'0');
            stat_opt_rd_latency_conf(I)   <= (others=>'0');
            stat_opt_wr_latency_conf(I)   <= (others=>'0');
            stat_arb_opt_rd_blocked(I)    <= (others=>'0');
            stat_opt_write_hit(I)         <= (others=>'0');
            stat_opt_write_miss(I)        <= (others=>'0');
            stat_opt_write_miss_dirty(I)  <= (others=>'0');
            stat_opt_read_hit(I)          <= (others=>'0');
            stat_opt_read_miss(I)         <= (others=>'0');
            stat_opt_read_miss_dirty(I)   <= (others=>'0');
            stat_opt_locked_write_hit(I)  <= (others=>'0');
            stat_opt_locked_read_hit(I)   <= (others=>'0');
            stat_opt_first_write_hit(I)   <= (others=>'0');
          end loop;
          for I in 0 to C_MAX_GENERIC_PORTS - 1 loop
            stat_gen_rd_segments(I)       <= (others=>'0');
            stat_gen_wr_segments(I)       <= (others=>'0');
            stat_gen_rip(I)               <= (others=>'0');
            stat_gen_r(I)                 <= (others=>'0');
            stat_gen_bip(I)               <= (others=>'0');
            stat_gen_bp(I)                <= (others=>'0');
            stat_gen_wip(I)               <= (others=>'0');
            stat_gen_w(I)                 <= (others=>'0');
            stat_gen_rd_latency(I)        <= (others=>'0');
            stat_gen_wr_latency(I)        <= (others=>'0');
            stat_gen_rd_latency_conf(I)   <= (others=>'0');
            stat_gen_wr_latency_conf(I)   <= (others=>'0');
            stat_arb_gen_rd_blocked(I)    <= (others=>'0');
            stat_gen_write_hit(I)         <= (others=>'0');
            stat_gen_write_miss(I)        <= (others=>'0');
            stat_gen_write_miss_dirty(I)  <= (others=>'0');
            stat_gen_read_hit(I)          <= (others=>'0');
            stat_gen_read_miss(I)         <= (others=>'0');
            stat_gen_read_miss_dirty(I)   <= (others=>'0');
            stat_gen_locked_write_hit(I)  <= (others=>'0');
            stat_gen_locked_read_hit(I)   <= (others=>'0');
            stat_gen_first_write_hit(I)   <= (others=>'0');
          end loop;
          stat_opt                                      <= (others=>(others=>'0'));
          stat_gen                                      <= (others=>(others=>'0'));
          stat_arbiter                                  <= (others=>(others=>'0'));
          stat_access                                   <= (others=>(others=>'0'));
          stat_lookup                                   <= (others=>(others=>'0'));
          stat_update                                   <= (others=>(others=>'0'));
          stat_backend                                  <= (others=>(others=>'0'));
          stat_ctrl                                     <= (others=>(others=>'0'));
          stat_result                                   <= (others=>(others=>'0'));
        
          S_AXI_CTRL_RDATA_I                            <= (others=>'0');
        else
          -- Default assignment.
          
          -- Select Optimized type stat (Clk 1).
          for I in 0 to C_MAX_OPTIMIZED_PORTS - 1 loop
            if( I < C_NUM_OPTIMIZED_PORTS ) then
              stat_opt_rd_segments(I)       <= Stat_Point_Get_Register(stat_s_axi_rd_segments(I),       sub_idx);
              stat_opt_wr_segments(I)       <= Stat_Point_Get_Register(stat_s_axi_wr_segments(I),       sub_idx);
              stat_opt_rip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_rip(I),                sub_idx);
              stat_opt_r(I)                 <= Stat_FIFO_Get_Register(stat_s_axi_r(I),                  sub_idx);
              stat_opt_bip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_bip(I),                sub_idx);
              stat_opt_bp(I)                <= Stat_FIFO_Get_Register(stat_s_axi_bp(I),                 sub_idx);
              stat_opt_wip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_wip(I),                sub_idx);
              stat_opt_w(I)                 <= Stat_FIFO_Get_Register(stat_s_axi_w(I),                  sub_idx);
              stat_opt_rd_latency(I)        <= Stat_Point_Get_Register(stat_s_axi_rd_latency(I),        sub_idx);
              stat_opt_wr_latency(I)        <= Stat_Point_Get_Register(stat_s_axi_wr_latency(I),        sub_idx);
              stat_opt_rd_latency_conf(I)   <= Stat_Conf_Get_Register(stat_s_axi_rd_latency_conf_i(I));
              stat_opt_wr_latency_conf(I)   <= Stat_Conf_Get_Register(stat_s_axi_wr_latency_conf_i(I));
              stat_arb_opt_rd_blocked(I)    <= Stat_Point_Get_Register(stat_arb_opt_read_blocked(selected_block_idx, I),    sub_idx);
              stat_opt_write_hit(I)         <= Stat_Point_Get_Register(stat_lu_opt_write_hit(selected_block_idx, I),        sub_idx);
              stat_opt_write_miss(I)        <= Stat_Point_Get_Register(stat_lu_opt_write_miss(selected_block_idx, I),       sub_idx);
              stat_opt_write_miss_dirty(I)  <= Stat_Point_Get_Register(stat_lu_opt_write_miss_dirty(selected_block_idx, I), sub_idx);
              stat_opt_read_hit(I)          <= Stat_Point_Get_Register(stat_lu_opt_read_hit(selected_block_idx, I),         sub_idx);
              stat_opt_read_miss(I)         <= Stat_Point_Get_Register(stat_lu_opt_read_miss(selected_block_idx, I),        sub_idx);
              stat_opt_read_miss_dirty(I)   <= Stat_Point_Get_Register(stat_lu_opt_read_miss_dirty(selected_block_idx, I),  sub_idx);
              stat_opt_locked_write_hit(I)  <= Stat_Point_Get_Register(stat_lu_opt_locked_write_hit(selected_block_idx, I), sub_idx);
              stat_opt_locked_read_hit(I)   <= Stat_Point_Get_Register(stat_lu_opt_locked_read_hit(selected_block_idx, I),  sub_idx);
              stat_opt_first_write_hit(I)   <= Stat_Point_Get_Register(stat_lu_opt_first_write_hit(selected_block_idx, I),  sub_idx);
            else
              stat_opt_rd_segments(I)       <= (others=>'0');
              stat_opt_wr_segments(I)       <= (others=>'0');
              stat_opt_rip(I)               <= (others=>'0');
              stat_opt_r(I)                 <= (others=>'0');
              stat_opt_bip(I)               <= (others=>'0');
              stat_opt_bp(I)                <= (others=>'0');
              stat_opt_wip(I)               <= (others=>'0');
              stat_opt_w(I)                 <= (others=>'0');
              stat_opt_rd_latency(I)        <= (others=>'0');
              stat_opt_wr_latency(I)        <= (others=>'0');
              stat_opt_rd_latency_conf(I)   <= (others=>'0');
              stat_opt_wr_latency_conf(I)   <= (others=>'0');
              stat_arb_opt_rd_blocked(I)    <= (others=>'0');
              stat_opt_write_hit(I)         <= (others=>'0');
              stat_opt_write_miss(I)        <= (others=>'0');
              stat_opt_write_miss_dirty(I)  <= (others=>'0');
              stat_opt_read_hit(I)          <= (others=>'0');
              stat_opt_read_miss(I)         <= (others=>'0');
              stat_opt_read_miss_dirty(I)   <= (others=>'0');
              stat_opt_locked_write_hit(I)  <= (others=>'0');
              stat_opt_locked_read_hit(I)   <= (others=>'0');
              stat_opt_first_write_hit(I)   <= (others=>'0');
            end if;
          end loop;
      
          -- Select Generic type stat (Clk 1).
          for I in 0 to C_MAX_GENERIC_PORTS - 1 loop
            if( I < C_NUM_GENERIC_PORTS ) then
              stat_gen_rd_segments(I)       <= Stat_Point_Get_Register(stat_s_axi_gen_rd_segments(I),       sub_idx);
              stat_gen_wr_segments(I)       <= Stat_Point_Get_Register(stat_s_axi_gen_wr_segments(I),       sub_idx);
              stat_gen_rip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_gen_rip(I),                sub_idx);
              stat_gen_r(I)                 <= Stat_FIFO_Get_Register(stat_s_axi_gen_r(I),                  sub_idx);
              stat_gen_bip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_gen_bip(I),                sub_idx);
              stat_gen_bp(I)                <= Stat_FIFO_Get_Register(stat_s_axi_gen_bp(I),                 sub_idx);
              stat_gen_wip(I)               <= Stat_FIFO_Get_Register(stat_s_axi_gen_wip(I),                sub_idx);
              stat_gen_w(I)                 <= Stat_FIFO_Get_Register(stat_s_axi_gen_w(I),                  sub_idx);
              stat_gen_rd_latency(I)        <= Stat_Point_Get_Register(stat_s_axi_gen_rd_latency(I),        sub_idx);
              stat_gen_wr_latency(I)        <= Stat_Point_Get_Register(stat_s_axi_gen_wr_latency(I),        sub_idx);
              stat_gen_rd_latency_conf(I)   <= Stat_Conf_Get_Register(stat_s_axi_gen_rd_latency_conf_i(I));
              stat_gen_wr_latency_conf(I)   <= Stat_Conf_Get_Register(stat_s_axi_gen_wr_latency_conf_i(I));
              stat_arb_gen_rd_blocked(I)    <= Stat_Point_Get_Register(stat_arb_gen_read_blocked(selected_block_idx, I),        sub_idx);
              stat_gen_write_hit(I)         <= Stat_Point_Get_Register(stat_lu_gen_write_hit(selected_block_idx, I),            sub_idx);
              stat_gen_write_miss(I)        <= Stat_Point_Get_Register(stat_lu_gen_write_miss(selected_block_idx, I),           sub_idx);
              stat_gen_write_miss_dirty(I)  <= Stat_Point_Get_Register(stat_lu_gen_write_miss_dirty(selected_block_idx, I),     sub_idx);
              stat_gen_read_hit(I)          <= Stat_Point_Get_Register(stat_lu_gen_read_hit(selected_block_idx, I),             sub_idx);
              stat_gen_read_miss(I)         <= Stat_Point_Get_Register(stat_lu_gen_read_miss(selected_block_idx, I),            sub_idx);
              stat_gen_read_miss_dirty(I)   <= Stat_Point_Get_Register(stat_lu_gen_read_miss_dirty(selected_block_idx, I),      sub_idx);
              stat_gen_locked_write_hit(I)  <= Stat_Point_Get_Register(stat_lu_gen_locked_write_hit(selected_block_idx, I),     sub_idx);
              stat_gen_locked_read_hit(I)   <= Stat_Point_Get_Register(stat_lu_gen_locked_read_hit(selected_block_idx, I),      sub_idx);
              stat_gen_first_write_hit(I)   <= Stat_Point_Get_Register(stat_lu_gen_first_write_hit(selected_block_idx, I),      sub_idx);
            else
              stat_gen_rd_segments(I)       <= (others=>'0');
              stat_gen_wr_segments(I)       <= (others=>'0');
              stat_gen_rip(I)               <= (others=>'0');
              stat_gen_r(I)                 <= (others=>'0');
              stat_gen_bip(I)               <= (others=>'0');
              stat_gen_bp(I)                <= (others=>'0');
              stat_gen_wip(I)               <= (others=>'0');
              stat_gen_w(I)                 <= (others=>'0');
              stat_gen_rd_latency(I)        <= (others=>'0');
              stat_gen_wr_latency(I)        <= (others=>'0');
              stat_gen_rd_latency_conf(I)   <= (others=>'0');
              stat_gen_wr_latency_conf(I)   <= (others=>'0');
              stat_arb_gen_rd_blocked(I)    <= (others=>'0');
              stat_gen_write_hit(I)         <= (others=>'0');
              stat_gen_write_miss(I)        <= (others=>'0');
              stat_gen_write_miss_dirty(I)  <= (others=>'0');
              stat_gen_read_hit(I)          <= (others=>'0');
              stat_gen_read_miss(I)         <= (others=>'0');
              stat_gen_read_miss_dirty(I)   <= (others=>'0');
              stat_gen_locked_write_hit(I)  <= (others=>'0');
              stat_gen_locked_read_hit(I)   <= (others=>'0');
              stat_gen_first_write_hit(I)   <= (others=>'0');
            end if;
          end loop;
          
          -- Select Optimized type stat (Clk 2).
          stat_opt                                      <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_OPT_CATEGORY) = '1' ) then
            stat_opt(C_STAT_ADDR_OPT_RD_SEGMENTS)         <= Stat_Get_Register(stat_opt_rd_segments,      num_idx);
            stat_opt(C_STAT_ADDR_OPT_WR_SEGMENTS)         <= Stat_Get_Register(stat_opt_wr_segments,      num_idx);
            stat_opt(C_STAT_ADDR_OPT_RIP)                 <= Stat_Get_Register(stat_opt_rip,              num_idx);
            stat_opt(C_STAT_ADDR_OPT_R)                   <= Stat_Get_Register(stat_opt_r,                num_idx);
            stat_opt(C_STAT_ADDR_OPT_BIP)                 <= Stat_Get_Register(stat_opt_bip,              num_idx);
            stat_opt(C_STAT_ADDR_OPT_BP)                  <= Stat_Get_Register(stat_opt_bp,               num_idx);
            stat_opt(C_STAT_ADDR_OPT_WIP)                 <= Stat_Get_Register(stat_opt_wip,              num_idx);
            stat_opt(C_STAT_ADDR_OPT_W)                   <= Stat_Get_Register(stat_opt_w,                num_idx);
            stat_opt(C_STAT_ADDR_OPT_READ_BLOCK)          <= Stat_Get_Register(stat_arb_opt_rd_blocked,   num_idx);
            stat_opt(C_STAT_ADDR_OPT_WRITE_HIT)           <= Stat_Get_Register(stat_opt_write_hit,        num_idx);
            stat_opt(C_STAT_ADDR_OPT_WRITE_MISS)          <= Stat_Get_Register(stat_opt_write_miss,       num_idx);
            stat_opt(C_STAT_ADDR_OPT_WRITE_MISS_DIRTY)    <= Stat_Get_Register(stat_opt_write_miss_dirty, num_idx);
            stat_opt(C_STAT_ADDR_OPT_READ_HIT)            <= Stat_Get_Register(stat_opt_read_hit,         num_idx);
            stat_opt(C_STAT_ADDR_OPT_READ_MISS)           <= Stat_Get_Register(stat_opt_read_miss,        num_idx);
            stat_opt(C_STAT_ADDR_OPT_READ_MISS_DIRTY)     <= Stat_Get_Register(stat_opt_read_miss_dirty,  num_idx);
            stat_opt(C_STAT_ADDR_OPT_LOCKED_WRITE_HIT)    <= Stat_Get_Register(stat_opt_locked_write_hit, num_idx);
            stat_opt(C_STAT_ADDR_OPT_LOCKED_READ_HIT)     <= Stat_Get_Register(stat_opt_locked_read_hit,  num_idx);
            stat_opt(C_STAT_ADDR_OPT_FIRST_WRITE_HIT)     <= Stat_Get_Register(stat_opt_first_write_hit,  num_idx);
            stat_opt(C_STAT_ADDR_OPT_RD_LATENCY)          <= Stat_Get_Register(stat_opt_rd_latency,       num_idx);
            stat_opt(C_STAT_ADDR_OPT_WR_LATENCY)          <= Stat_Get_Register(stat_opt_wr_latency,       num_idx);
            stat_opt(C_STAT_ADDR_OPT_RD_LAT_CONF)         <= Stat_Get_Register(stat_opt_rd_latency_conf,  num_idx);
            stat_opt(C_STAT_ADDR_OPT_WR_LAT_CONF)         <= Stat_Get_Register(stat_opt_wr_latency_conf,  num_idx);
          end if;
          
          -- Select Generic type stat (Clk 2).
          stat_gen                                      <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_GEN_CATEGORY) = '1' ) then
            stat_gen(C_STAT_ADDR_GEN_RD_SEGMENTS)         <= Stat_Get_Register(stat_gen_rd_segments,      num_idx);
            stat_gen(C_STAT_ADDR_GEN_WR_SEGMENTS)         <= Stat_Get_Register(stat_gen_wr_segments,      num_idx);
            stat_gen(C_STAT_ADDR_GEN_RIP)                 <= Stat_Get_Register(stat_gen_rip,              num_idx);
            stat_gen(C_STAT_ADDR_GEN_R)                   <= Stat_Get_Register(stat_gen_r,                num_idx);
            stat_gen(C_STAT_ADDR_GEN_BIP)                 <= Stat_Get_Register(stat_gen_bip,              num_idx);
            stat_gen(C_STAT_ADDR_GEN_BP)                  <= Stat_Get_Register(stat_gen_bp,               num_idx);
            stat_gen(C_STAT_ADDR_GEN_WIP)                 <= Stat_Get_Register(stat_gen_wip,              num_idx);
            stat_gen(C_STAT_ADDR_GEN_W)                   <= Stat_Get_Register(stat_gen_w,                num_idx);
            stat_gen(C_STAT_ADDR_GEN_READ_BLOCK)          <= Stat_Get_Register(stat_arb_gen_rd_blocked,   num_idx);
            stat_gen(C_STAT_ADDR_GEN_WRITE_HIT)           <= Stat_Get_Register(stat_gen_write_hit,        num_idx);
            stat_gen(C_STAT_ADDR_GEN_WRITE_MISS)          <= Stat_Get_Register(stat_gen_write_miss,       num_idx);
            stat_gen(C_STAT_ADDR_GEN_WRITE_MISS_DIRTY)    <= Stat_Get_Register(stat_gen_write_miss_dirty, num_idx);
            stat_gen(C_STAT_ADDR_GEN_READ_HIT)            <= Stat_Get_Register(stat_gen_read_hit,         num_idx);
            stat_gen(C_STAT_ADDR_GEN_READ_MISS)           <= Stat_Get_Register(stat_gen_read_miss,        num_idx);
            stat_gen(C_STAT_ADDR_GEN_READ_MISS_DIRTY)     <= Stat_Get_Register(stat_gen_read_miss_dirty,  num_idx);
            stat_gen(C_STAT_ADDR_GEN_LOCKED_WRITE_HIT)    <= Stat_Get_Register(stat_gen_locked_write_hit, num_idx);
            stat_gen(C_STAT_ADDR_GEN_LOCKED_READ_HIT)     <= Stat_Get_Register(stat_gen_locked_read_hit,  num_idx);
            stat_gen(C_STAT_ADDR_GEN_FIRST_WRITE_HIT)     <= Stat_Get_Register(stat_gen_first_write_hit,  num_idx);
            stat_gen(C_STAT_ADDR_GEN_RD_LATENCY)          <= Stat_Get_Register(stat_gen_rd_latency,       num_idx);
            stat_gen(C_STAT_ADDR_GEN_WR_LATENCY)          <= Stat_Get_Register(stat_gen_wr_latency,       num_idx);
            stat_gen(C_STAT_ADDR_GEN_RD_LAT_CONF)         <= Stat_Get_Register(stat_gen_rd_latency_conf,  num_idx);
            stat_gen(C_STAT_ADDR_GEN_WR_LAT_CONF)         <= Stat_Get_Register(stat_gen_wr_latency_conf,  num_idx);
          end if;
          
          -- Arbiter (Clk 2).
          stat_arbiter                                  <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_ARB_CATEGORY) = '1' ) then
            stat_arbiter(C_STAT_ADDR_ARB_VALID)           <= Stat_Point_Get_Register(stat_arb_valid(block_idx),               sub_idx);
            stat_arbiter(C_STAT_ADDR_ARB_CON_ACCESS)      <= Stat_Point_Get_Register(stat_arb_concurrent_accesses(block_idx), sub_idx);
          end if;
          
          -- Access (Clk 2).
          stat_access                                   <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_ACS_CATEGORY) = '1' ) then
            stat_access(C_STAT_ADDR_ACS_VALID)            <= Stat_Point_Get_Register(stat_access_valid(block_idx),       sub_idx);
            stat_access(C_STAT_ADDR_ACS_STALL)            <= Stat_Point_Get_Register(stat_access_stall(block_idx),       sub_idx);
            stat_access(C_STAT_ADDR_ACS_FETCH_STALL)      <= Stat_Point_Get_Register(stat_access_fetch_stall(block_idx), sub_idx);
            stat_access(C_STAT_ADDR_ACS_REQ_STALL)        <= Stat_Point_Get_Register(stat_access_req_stall(block_idx),   sub_idx);
            stat_access(C_STAT_ADDR_ACS_ACT_STALL)        <= Stat_Point_Get_Register(stat_access_act_stall(block_idx),   sub_idx);
          end if;
          
          -- Lookup (Clk 2).
          stat_lookup                                   <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_LU_CATEGORY) = '1' ) then
            stat_lookup(C_STAT_ADDR_LU_STALL)             <= Stat_Point_Get_Register(stat_lu_stall(block_idx),             sub_idx);
            stat_lookup(C_STAT_ADDR_LU_FETCH_STALL)       <= Stat_Point_Get_Register(stat_lu_fetch_stall(block_idx),       sub_idx);
            stat_lookup(C_STAT_ADDR_LU_MEM_STALL)         <= Stat_Point_Get_Register(stat_lu_mem_stall(block_idx),         sub_idx);
            stat_lookup(C_STAT_ADDR_LU_DATA_STALL)        <= Stat_Point_Get_Register(stat_lu_data_stall(block_idx),        sub_idx);
            stat_lookup(C_STAT_ADDR_LU_DATA_HIT_STALL)    <= Stat_Point_Get_Register(stat_lu_data_hit_stall(block_idx),    sub_idx);
            stat_lookup(C_STAT_ADDR_LU_DATA_MISS_STALL)   <= Stat_Point_Get_Register(stat_lu_data_miss_stall(block_idx),   sub_idx);
          end if;
          
          -- Update (Clk 2).
          stat_update                                   <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_UD_CATEGORY) = '1' ) then
            stat_update(C_STAT_ADDR_UD_STALL)             <= Stat_Point_Get_Register(stat_ud_stall(block_idx),     sub_idx);
            stat_update(C_STAT_ADDR_UD_TAG_FREE)          <= Stat_Point_Get_Register(stat_ud_tag_free(block_idx),  sub_idx);
            stat_update(C_STAT_ADDR_UD_DATA_FREE)         <= Stat_Point_Get_Register(stat_ud_data_free(block_idx), sub_idx);
            stat_update(C_STAT_ADDR_UD_RI)                <= Stat_FIFO_Get_Register(stat_ud_ri(block_idx),         sub_idx);
            stat_update(C_STAT_ADDR_UD_R)                 <= Stat_FIFO_Get_Register(stat_ud_r(block_idx),          sub_idx);
            stat_update(C_STAT_ADDR_UD_E)                 <= Stat_FIFO_Get_Register(stat_ud_e(block_idx),          sub_idx);
            stat_update(C_STAT_ADDR_UD_BS)                <= Stat_FIFO_Get_Register(stat_ud_bs(block_idx),         sub_idx);
            stat_update(C_STAT_ADDR_UD_WM)                <= Stat_FIFO_Get_Register(stat_ud_wm(block_idx),         sub_idx);
            stat_update(C_STAT_ADDR_UD_WMA)               <= Stat_FIFO_Get_Register(stat_ud_wma(block_idx),        sub_idx);
          end if;
          
          -- Backend (Clk 2).
          stat_backend                                  <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS_MASK(C_STAT_ADDR_BE_CATEGORY) = '1' ) then
            stat_backend(C_STAT_ADDR_BE_AW)               <= Stat_FIFO_Get_Register(stat_be_aw(master_idx),                 sub_idx);
            stat_backend(C_STAT_ADDR_BE_W)                <= Stat_FIFO_Get_Register(stat_be_w(master_idx),                  sub_idx);
            stat_backend(C_STAT_ADDR_BE_AR)               <= Stat_FIFO_Get_Register(stat_be_ar(master_idx),                 sub_idx);
            stat_backend(C_STAT_ADDR_BE_AR_SEARCH_DEPTH)  <= Stat_Point_Get_Register(stat_be_ar_search_depth(master_idx),   sub_idx);
            stat_backend(C_STAT_ADDR_BE_AR_STALL)         <= Stat_Point_Get_Register(stat_be_ar_stall(master_idx),          sub_idx);
            stat_backend(C_STAT_ADDR_BE_AR_PROTECT_STALL) <= Stat_Point_Get_Register(stat_be_ar_protect_stall(master_idx),  sub_idx);
            stat_backend(C_STAT_ADDR_BE_RD_LATENCY)       <= Stat_Point_Get_Register(stat_be_rd_latency(master_idx),        sub_idx);
            stat_backend(C_STAT_ADDR_BE_WR_LATENCY)       <= Stat_Point_Get_Register(stat_be_wr_latency(master_idx),        sub_idx);
            stat_backend(C_STAT_ADDR_BE_RD_LAT_CONF)      <= Stat_Conf_Get_Register(stat_be_rd_latency_conf_i);
            stat_backend(C_STAT_ADDR_BE_WR_LAT_CONF)      <= Stat_Conf_Get_Register(stat_be_wr_latency_conf_i);
          end if;
          
          -- Control (Clk 2).
          stat_ctrl                                     <= (others=>(others=>'0'));
          if( C_ENABLE_STATISTICS > 0 ) then
            stat_ctrl(C_STAT_ADDR_CTRL_ENABLE)            <= Stat_Conf_Get_Register(stat_ctrl_conf_i);
          end if;
          if( C_ENABLE_VERSION_REGISTER > 0 ) then
            stat_ctrl(C_STAT_ADDR_CTRL0_VERSION)          <= Stat_Conf_Get_Register(stat_ctrl_version_register_0);
          end if;
          if( C_ENABLE_VERSION_REGISTER > 1 ) then
            stat_ctrl(C_STAT_ADDR_CTRL1_VERSION)          <= Stat_Conf_Get_Register(stat_ctrl_version_register_1);
          end if;
          if( is_mst_coherent(C_ENABLE_COHERENCY) > 0 ) then
            stat_ctrl(C_STAT_ADDR_CTRL_DVM0)              <= Stat_Conf_Get_Register(fit_vec(ctrl_insert_running, C_MAX_STAT_CONF_WIDTH));
            stat_ctrl(C_STAT_ADDR_CTRL_DVM1)              <= Stat_Conf_Get_Register(fit_vec(ctrl_insert_running, C_MAX_STAT_CONF_WIDTH));
            stat_ctrl(C_STAT_ADDR_CTRL_BAR0)              <= Stat_Conf_Get_Register(fit_vec(ctrl_insert_running, C_MAX_STAT_CONF_WIDTH));
            stat_ctrl(C_STAT_ADDR_CTRL_BAR1)              <= Stat_Conf_Get_Register(fit_vec(ctrl_insert_running, C_MAX_STAT_CONF_WIDTH));
          end if;
          
          
          -- Stat per source (Clk 3).
          stat_result                                   <= (others=>(others=>'0'));
          stat_result(C_STAT_ADDR_OPT_CATEGORY)         <= Stat_Get_Register(stat_opt,      info_idx);
          stat_result(C_STAT_ADDR_GEN_CATEGORY)         <= Stat_Get_Register(stat_gen,      info_idx);
          stat_result(C_STAT_ADDR_ARB_CATEGORY)         <= Stat_Get_Register(stat_arbiter,  info_idx);
          stat_result(C_STAT_ADDR_ACS_CATEGORY)         <= Stat_Get_Register(stat_access,   info_idx);
          stat_result(C_STAT_ADDR_LU_CATEGORY)          <= Stat_Get_Register(stat_lookup,   info_idx);
          stat_result(C_STAT_ADDR_UD_CATEGORY)          <= Stat_Get_Register(stat_update,   info_idx);
          stat_result(C_STAT_ADDR_BE_CATEGORY)          <= Stat_Get_Register(stat_backend,  info_idx);
          stat_result(C_STAT_ADDR_CTRL_CATEGORY)        <= Stat_Get_Register(stat_ctrl,     cfg_idx);
          
          -- Last stage (Clk 4).
          if( C_S_AXI_CTRL_DATA_WIDTH > 32 ) then
            S_AXI_CTRL_RDATA_I                            <= Stat_Get_Register_64bit(stat_result, cat_idx);
          else
            S_AXI_CTRL_RDATA_I                            <= Stat_Get_Register_32bit(stat_result, cat_idx, word_idx);
          end if;
          
        end if;
      end if;
    end process Read_Mux;
    
  end generate Use_Ctrl;
  
  No_Ctrl: if ( C_ENABLE_CTRL < 1 ) generate
  begin
    S_AXI_CTRL_AWREADY              <= '0';
    S_AXI_CTRL_WREADY               <= '0';
    S_AXI_CTRL_BRESP                <= (others=>'0');
    S_AXI_CTRL_BVALID_I             <= '0';
    S_AXI_CTRL_ARREADY              <= '0';
    S_AXI_CTRL_RDATA_I              <= (others=>'0');
    S_AXI_CTRL_RRESP                <= (others=>'0');
    S_AXI_CTRL_RVALID_I             <= '0';
    
    stat_enable                     <= '0';
    stat_reset_i                    <= '0';
    stat_reset                      <= '0';
    
    write_ongoing                   <= '0';
    write_1st_cycle                 <= '0';
    write_2nd_cycle                 <= '0';
    write_3rd_cycle                 <= '0';
    w_data                          <= (others=>'0');
    w_clean_data                    <= (others=>'0');
    w_flush_data                    <= (others=>'0');
    w_dvm_1st_data                  <= (others=>'0');
    w_dvm_2nd_data                  <= (others=>'0');
    w_bar_data                      <= (others=>'0');
    w_secure_clean_data             <= (others=>'0');
    w_secure_flush_data             <= (others=>'0');
    w_secure_dvm_1st_data           <= (others=>'0');
    w_secure_dvm_2nd_data           <= (others=>'0');
    w_secure_bar_data               <= (others=>'0');
    write_secure                    <= '0';
    write_failed                    <= '0';
    write_error                     <= '0';
    
    read_ongoing                    <= '0';
    read_ongoing_d1                 <= '0';
    read_ongoing_d2                 <= '0';
    read_ongoing_d3                 <= '0';
    read_ongoing_d4                 <= '0';
    read_secure                     <= '0';
    read_failed                     <= '0';
    read_error                      <= '0';
  
    Using_Opt: if ( C_NUM_OPTIMIZED_PORTS > 0 ) generate
    begin
    stat_s_axi_rd_latency_conf      <= (C_NUM_OPTIMIZED_PORTS - 1 downto 0=>(C_STAT_CONF_POS=>'0'));
    stat_s_axi_wr_latency_conf      <= (C_NUM_OPTIMIZED_PORTS - 1 downto 0=>(C_STAT_CONF_POS=>'0'));
    end generate Using_Opt;
    Using_Gen: if ( C_NUM_GENERIC_PORTS > 0 ) generate
    begin
    stat_s_axi_gen_rd_latency_conf  <= (C_NUM_GENERIC_PORTS - 1 downto 0=>(C_STAT_CONF_POS=>'0'));
    stat_s_axi_gen_wr_latency_conf  <= (C_NUM_GENERIC_PORTS - 1 downto 0=>(C_STAT_CONF_POS=>'0'));
    end generate Using_Gen;
    stat_be_rd_latency_conf         <= (C_STAT_CONF_POS=>'0');
    stat_be_wr_latency_conf         <= (C_STAT_CONF_POS=>'0');
    
  end generate No_Ctrl;
  
  S_AXI_CTRL_RVALID <= S_AXI_CTRL_RVALID_I;
  S_AXI_CTRL_RDATA  <= S_AXI_CTRL_RDATA_I;
  
  S_AXI_CTRL_BVALID <= S_AXI_CTRL_BVALID_I;
  
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    IF_DEBUG  <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_CNT     : natural := min_of(20, C_ADDR_ALL_WAYS_HI - C_ADDR_ALL_WAYS_LO + 1);
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          IF_DEBUG                  <= (others=>'0');
        else
          -- Default assignment.
          IF_DEBUG                  <= (others=>'0');
          
          IF_DEBUG( 31 downto   0)  <= fit_vec(S_AXI_CTRL_ARADDR,  32);
          IF_DEBUG( 63 downto  32)  <= fit_vec(S_AXI_CTRL_RDATA_I, 32);
          IF_DEBUG( 95 downto  64)  <= fit_vec(S_AXI_CTRL_AWADDR,  32);
          IF_DEBUG(127 downto  96)  <= fit_vec(S_AXI_CTRL_WDATA,   32);
          
          IF_DEBUG(159 downto 128)  <= ctrl_access_i.Addr(32 - 1 downto 0);
          IF_DEBUG(167 downto 160)  <= ctrl_access_i.Len;
          IF_DEBUG(171 downto 168)  <= ctrl_access_i.Snoop;
          IF_DEBUG(173 downto 172)  <= ctrl_access_i.Barrier;
          IF_DEBUG(175 downto 174)  <= ctrl_access_i.Domain;
          IF_DEBUG(178 downto 176)  <= ctrl_access_i.Prot;
          IF_DEBUG(181 downto 179)  <= ctrl_access_i.Size;
          IF_DEBUG(           182)  <= ctrl_access_i.Valid;
          IF_DEBUG(           183)  <= ctrl_access_i.Kind;
          IF_DEBUG(           184)  <= ctrl_access_i.Exclusive;
          IF_DEBUG(           185)  <= ctrl_access_i.Allocate;
          IF_DEBUG(           186)  <= ctrl_access_i.Bufferable;
          IF_DEBUG(           187)  <= ctrl_access_i.Evict;
          IF_DEBUG(           188)  <= ctrl_access_i.Ignore_Data;
          IF_DEBUG(           189)  <= ctrl_access_i.Force_Hit;
          
          IF_DEBUG(           190)  <= S_AXI_CTRL_AWVALID;
          IF_DEBUG(           191)  <= write_1st_cycle; -- S_AXI_CTRL_AWREADY
          IF_DEBUG(           192)  <= S_AXI_CTRL_WVALID;
          IF_DEBUG(           193)  <= write_1st_cycle; -- S_AXI_CTRL_WREADY
          IF_DEBUG(           194)  <= S_AXI_CTRL_BVALID_I;
          IF_DEBUG(           195)  <= S_AXI_CTRL_BREADY;
          IF_DEBUG(           196)  <= S_AXI_CTRL_ARVALID;
          IF_DEBUG(           197)  <= not read_ongoing; -- S_AXI_CTRL_ARREADY
          IF_DEBUG(           198)  <= S_AXI_CTRL_RVALID_I;
          IF_DEBUG(           199)  <= S_AXI_CTRL_RREADY;

          IF_DEBUG(           200)  <= ctrl_init_done_i;
          IF_DEBUG(           201)  <= ctrl_ready;
          
          IF_DEBUG(           202)  <= write_ongoing;
          IF_DEBUG(           203)  <= write_1st_cycle;
          IF_DEBUG(           204)  <= write_2nd_cycle;
          
          IF_DEBUG(           205)  <= read_ongoing;
          IF_DEBUG(           206)  <= read_ongoing_d1;
          IF_DEBUG(           207)  <= read_ongoing_d2;
          IF_DEBUG(           208)  <= read_ongoing_d3;
          IF_DEBUG(           209)  <= read_ongoing_d4;

          IF_DEBUG(           210)  <= ac_valid;
          IF_DEBUG(           211)  <= ac_push;
          IF_DEBUG(           212)  <= ac_pop;
          IF_DEBUG(           213)  <= ac_fifo_empty;
          
          IF_DEBUG(           214)  <= stat_reset_i;

          IF_DEBUG(220 + C_MY_CNT - 1 downto 220)  <= ctrl_init_cnt(C_ADDR_ALL_WAYS_LO + C_MY_CNT - 1 downto C_ADDR_ALL_WAYS_LO);
                        
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
    
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  
end architecture IMP;




-------------------------------------------------------------------------------
-- sc_access.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_access.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_access.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


entity sc_access is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- Data type and settings specific.
    C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
    C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
    
    -- Lx Cache Specific.
    C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
    
    -- IP Specific.
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    
    -- Data type and settings specific.
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write Data).
    
    wr_port_data_info         : in  DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    wr_port_data_ready        : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Snoop communication).
    
    -- Snoop Fetch Stage Signals
    snoop_fetch_piperun       : out std_logic;
    snoop_fetch_info          : out SNOOP_FETCH_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_fetch_pos_hazard    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Request Stage Signals.
    snoop_req_piperun         : out std_logic;
    snoop_req_info            : out SNOOP_REQ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Action Stage Signals.
    snoop_act_piperun         : out std_logic;
    snoop_act_info            : out SNOOP_ACT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_act_tag_info        : in  SNOOP_ACT_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_act_ack_info        : in  SNOOP_ACT_ACK_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
  
    -- Snoop Tag Information and Update Signals.
    snoop_tag_status_info     : out SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_tag_new_info        : in  SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    snoop_resp_info           : in  SNOOP_CRRESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_resp_ready          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Data Signals.
    snoop_data_info           : in  SNOOP_DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_data_ready          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    -- Complete Transaction Signals.
    read_trans_comp_info      : in  READ_COMPLETE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Arbiter signals.
    
    arb_access                : in  ARBITRATION_TYPE;
    
    arbiter_bp_push           : in  WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    wr_port_inbound           : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
     
    -- ---------------------------------------------------
    -- Lookup signals.
    
    lookup_piperun            : in  std_logic;
    
    lookup_write_data_ready   : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    update_write_data_ready   : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Access signals (for Arbiter).
    
    access_piperun            : out std_logic;
    access_write_priority     : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    access_other_write_prio   : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    access_bp_push            : out WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Access signals (to Lookup/Update).
    
    access_valid              : out std_logic;
    access_info               : out ACCESS_TYPE;
    
    access_data_info          : out DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Snoop signals (Read Data & response).
    
    snoop_read_data_info      : out READ_SNOOP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    snoop_read_data_ready     : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- ACE Downstream Barrier Request.
    
    ctrl_access_done          : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Lx Cache Configuration
    
    lx_cfg_support_dirty      : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                : in  std_logic;
    stat_enable               : in  std_logic;
    
    stat_access_valid         : out STAT_POINT_TYPE;    -- Time valid per transaction
    stat_access_stall         : out STAT_POINT_TYPE;    -- Time stalled per transaction
    stat_access_fetch_stall   : out STAT_POINT_TYPE;    -- Time stalled per transaction (fetch)
    stat_access_req_stall     : out STAT_POINT_TYPE;    -- Time stalled per transaction (req)
    stat_access_act_stall     : out STAT_POINT_TYPE;    -- Time stalled per transaction (act)
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug signals.
    
    ACCESS_DEBUG              : out MAX_DEBUG_TYPE
  );
end entity sc_access;

library IEEE;
use IEEE.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;
use system_cache_v4_0_4.system_cache_queue_pkg.all;


architecture IMP of sc_access is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Access transaction control.
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  1;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_ADDR_OFFSET_BITS             : natural := C_ADDR_OFFSET_HI - C_ADDR_OFFSET_LO + 1;
  
  subtype C_Lx_ADDR_LINE_POS          is natural range C_Lx_ADDR_LINE_HI          downto C_Lx_ADDR_LINE_LO;
  subtype Lx_ADDR_LINE_TYPE           is std_logic_vector(C_Lx_ADDR_LINE_POS);
  
  subtype C_CACHE_DATA_ADDR_POS       is natural range C_CACHE_DATA_ADDR_WIDTH - 1    downto 0;
  
  constant C_Lx_NATIVE_SIZE           : AXI_SIZE_TYPE   := int_to_std(Log2(C_Lx_CACHE_DATA_WIDTH / 8), 
                                                                           AXI_SIZE_TYPE'length);
  constant C_Lx_NATIVE_LEN            : AXI_LENGTH_TYPE := int_to_std(32*C_Lx_CACHE_LINE_LENGTH/C_Lx_CACHE_DATA_WIDTH - 1, 
                                                                      AXI_LENGTH_TYPE'length);
  
  constant C_EXTENDED_NATIVE_LEN      : std_logic_vector(8 + 15 - 1 downto 0) := "00000000" & C_Lx_NATIVE_LEN & "1111111";
  
  constant C_SUPPORT_DIRTY_DATA       : natural := is_on( C_NUM_INTERNAL_PORTS - C_NUM_PORTS );
  constant C_SUPPORT_PEER_DATA        : natural := is_on(C_ENABLE_PEER_PORT_DATA + 
                                                         ( C_NUM_INTERNAL_PORTS - C_NUM_PORTS ));
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types
  -----------------------------------------------------------------------------
  
  -- Port related.
  subtype C_PORT_POS                  is rinteger range C_NUM_PORTS - 1 downto 0;
  subtype PORT_TYPE                   is std_logic_vector(C_PORT_POS);
  
  type PORT_POS_ARRAY_TYPE            is array(C_PORT_POS) of C_PORT_POS;
  
  -- Address related.
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI downto C_ADDR_OFFSET_LO;
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  
  subtype C_BYTE_MASK_POS             is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 7 downto 7;
  subtype C_HALF_WORD_MASK_POS        is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 6 downto 6;
  subtype C_WORD_MASK_POS             is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 5 downto 5;
  subtype C_DOUBLE_WORD_MASK_POS      is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 4 downto 4;
  subtype C_QUAD_WORD_MASK_POS        is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 3 downto 3;
  subtype C_OCTA_WORD_MASK_POS        is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 2 downto 2;
  subtype C_HEXADECA_WORD_MASK_POS    is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 1 downto 1;
  subtype C_TRIACONTADI_MASK_POS      is natural range C_MAX_WORD_ADDR_WIDTH - 1 + 0 downto 0;
  
  
  -- Custom data structures.
  type SS_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
  end record SS_TYPE;
  
  type RS_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
    Resp_Mask         : PORT_TYPE;
    No_Forward        : std_logic;
    Exclusive_Ok      : std_logic;
    Exclusive_Start   : std_logic;
  end record RS_TYPE;
  
  type SM_TYPE is record
    Port_Num          : natural range 0 to C_NUM_PORTS - 1;
    Resp_Mask         : PORT_TYPE;
    No_Forward        : std_logic;
    Exclusive_Ok      : std_logic;
    Exclusive_Start   : std_logic;
    Peer              : std_logic;
    Is_Shared         : std_logic;
    Pass_Dirty        : std_logic;
    Err               : std_logic;
  end record SM_TYPE;
  
  type SDS_TYPE is record
    Dirty             : std_logic;
    Dump_Mask         : PORT_TYPE;
    Peer              : std_logic;
    ReadOnce          : std_logic;
  end record SDS_TYPE;
  
  -- Empty data structures.
  constant C_NULL_SS                  : SS_TYPE   := (Port_Num=>0);
  constant C_NULL_RS                  : RS_TYPE   := (Port_Num=>0, Resp_Mask=>(others=>'0'), No_Forward=>'0',
                                                      Exclusive_Ok=>'0', Exclusive_Start=>'0');
  constant C_NULL_SM                  : SM_TYPE   := (Port_Num=>0, Resp_Mask=>(others=>'0'), No_Forward=>'0',
                                                      Exclusive_Ok=>'0', Peer=>'0', Is_Shared=>'0', Pass_Dirty=>'0', 
                                                      Err=>'0', Exclusive_Start=>'0');
  constant C_NULL_SDS                 : SDS_TYPE  := (Dirty=>'0', Dump_Mask=>(others=>'0'), Peer=>'0', ReadOnce=>'0');
  
  -- Types for information queue storage.
  type SS_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS) of SS_TYPE;
  type RS_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS) of RS_TYPE;
  type SM_FIFO_MEM_TYPE               is array(QUEUE_ADDR_POS) of SM_TYPE;
  type SDS_FIFO_MEM_TYPE              is array(QUEUE_ADDR_POS) of SDS_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_vec_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_INPUTS  : natural;
      C_SIZE    : natural
    );
    port (
      Carry_IN  : in  std_logic;
      A_Vec     : in  std_logic_vector(C_SIZE-1 downto 0);
      Carry_OUT : out std_logic
    );
  end component carry_vec_and_n;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE
      );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and_n;
  
  component carry_or_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE
      );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_or_n;
  
  component sc_srl_fifo_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Configuration.
      C_PUSH_ON_CARRY           : boolean                       := false;
      C_POP_ON_CARRY            : boolean                       := false;
      C_ENABLE_PROTECTION       : boolean                       := false;
      C_USE_QUALIFIER           : boolean                       := false;
      C_QUALIFIER_LEVEL         : natural range  0 to    1      := 1;
      C_USE_REGISTER_OUTPUT     : boolean                       := false;
      C_QUEUE_ADDR_WIDTH        : natural range  2 to   10      :=  5;
      C_LINE_LENGTH             : natural range  1 to 1023      :=  4
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Queue Counter Interface
      
      queue_push                : in  std_logic;
      queue_pop                 : in  std_logic;
      queue_push_qualifier      : in  std_logic;
      queue_pop_qualifier       : in  std_logic;
      queue_refresh_reg         : out std_logic;
      
      queue_almost_full         : out std_logic := '0';
      queue_full                : out std_logic := '0';
      queue_almost_empty        : out std_logic := '0';
      queue_empty               : out std_logic := '1';
      queue_exist               : out std_logic := '0';
      queue_line_fit            : out std_logic := '1';
      queue_index               : out std_logic_vector(C_QUEUE_ADDR_WIDTH - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_FIFO_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      DEBUG                     : out std_logic_vector(255 downto 0)
    );
  end component sc_srl_fifo_counter;
  
  component sc_stat_event is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Probe Interface
      
      probe                     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_event;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  attribute keep                    : string;
  attribute keep                    of Reset_Inst     : label is "true";
  
  -- Guide Vivado Synthesis to handle control set as intended.
  attribute direct_reset            : string;
  attribute direct_reset            of ARESET_I       : signal is "true";
  
  
  -- ----------------------------------------
  -- Pipeline Stage: Access
  
  signal lookup_piperun_post1       : std_logic;
  signal lookup_piperun_i           : std_logic;
  signal access_piperun_i           : std_logic;
  signal extended_length            : std_logic_vector(C_ADDR_OFFSET_BITS + 15 - 1 downto 0);
  
  signal access_valid_i             : std_logic;
  signal access_info_i              : ACCESS_TYPE;
  
  signal access_evict_line          : std_logic;
  signal access_evict_1st_cycle     : std_logic;
  signal access_evict_inserted      : std_logic;
  
  signal access_insert_write        : std_logic;
  signal access_write_1st_cycle     : std_logic;
  signal access_write_inserted      : std_logic;
  
  signal access_original_cycle      : std_logic;
  signal access_stall               : std_logic;
  
  
  
  -- ----------------------------------------
  -- Snoop Read Data
  
  signal snoop_data_info_word       : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  
  signal snoop_read_data_valid      : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal snoop_read_data_last       : std_logic;
  signal snoop_read_data_resp       : AXI_RRESP_TYPE;
  signal snoop_read_data_word       : std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
    
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Pipeline Stage: Access
  -- 
  -----------------------------------------------------------------------------
  
  -- Move this stage when there is no stall or there is a bubble to fill.
--  access_piperun  <= ( lookup_piperun or not access_valid_i ) and not access_stall;
  FE_Acs_PR_Or_Inst1: carry_or_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lookup_piperun,
      A_N       => access_valid_i,
      Carry_OUT => lookup_piperun_post1
    );
  FE_Acs_PR_And_Inst1: carry_and_n 
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => lookup_piperun_post1,
      A_N       => access_stall,
      Carry_OUT => lookup_piperun_i
    );
  access_piperun  <= access_piperun_i;
  
  
  -----------------------------------------------------------------------------
  -- Non Coherent
  -----------------------------------------------------------------------------
  No_Coherency: if( not is_slv_coherent(C_ENABLE_COHERENCY) ) generate
  begin
    -- Extend the length vector.
    Ext_Len: process (arb_access) is
    begin  -- process Ext_Len
      extended_length               <= (others=>'0');
      extended_length(14 downto 7)  <= arb_access.Len;
      extended_length( 6 downto 0)  <= "1111111";
    end process Ext_Len;
    
    -- No maipulation of piperun
    access_piperun_i            <= lookup_piperun_i;
    access_valid_i              <= arb_access.Valid;
    
    -- Must evict line if there is no internal Exclusive monitor.
    access_evict_line           <= access_valid_i and arb_access.Exclusive when ( C_ENABLE_EX_MON = 0 ) else '0';
    
    -- No write to insert.
    access_insert_write         <= '0';
    
    Gen_Access: process (access_valid_i, arb_access, extended_length) is
    begin  -- process Gen_Mask
      -- Transaction (manipulation for Exclusive).
      access_info_i               <= C_NULL_ACCESS;
      access_info_i.Port_Num      <= arb_access.Port_Num;
      access_info_i.Allocate      <= arb_access.Allocate and 
                                     not arb_access.Evict;
      access_info_i.Bufferable    <= arb_access.Bufferable;
      access_info_i.Exclusive     <= arb_access.Exclusive;
      access_info_i.Evict         <= arb_access.Evict;
      access_info_i.SnoopResponse <= '0';
      access_info_i.KillHit       <= arb_access.Evict;
      access_info_i.Kind          <= arb_access.Kind;
      access_info_i.Wr            <= arb_access.Wr;
      access_info_i.Addr          <= arb_access.Addr;
      access_info_i.Len           <= arb_access.Len;
      access_info_i.Size          <= arb_access.Size;
      access_info_i.Prot          <= arb_access.Prot;
      access_info_i.IsShared      <= '0';
      access_info_i.PassDirty     <= '0';
      access_info_i.Lx_Allocate   <= '0';
      access_info_i.Ignore_Data   <= arb_access.Ignore_Data;
      access_info_i.Force_Hit     <= arb_access.Force_Hit;
      access_info_i.Internal_Cmd  <= arb_access.Internal_Cmd;
      access_info_i.Early         <= arb_access.Early;
      access_info_i.Keep          <= arb_access.Keep;
      
      -- Generate step and use.
      case arb_access.Size is
        when C_BYTE_SIZE          =>
          access_info_i.Addr_Use  <= extended_length(C_BYTE_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HALF_WORD_SIZE     =>
          access_info_i.Addr_Use  <= extended_length(C_HALF_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_WORD_SIZE          =>
          access_info_i.Addr_Use  <= extended_length(C_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_DOUBLE_WORD_SIZE   =>
          access_info_i.Addr_Use  <= extended_length(C_DOUBLE_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_QUAD_WORD_SIZE     =>
          access_info_i.Addr_Use  <= extended_length(C_QUAD_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_OCTA_WORD_SIZE     =>
          access_info_i.Addr_Use  <= extended_length(C_OCTA_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HEXADECA_WORD_SIZE =>
          access_info_i.Addr_Use  <= extended_length(C_HEXADECA_WORD_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when others               =>
          access_info_i.Addr_Use  <= extended_length(C_TRIACONTADI_MASK_POS);
          access_info_i.Addr_Stp  <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
      end case;
    
      -- ID.
      access_info_i.ID          <= arb_access.ID;
    end process Gen_Access;
    
    -- Simply pass through.
    access_bp_push            <= arbiter_bp_push;
    
    
    -----------------------------------------------------------------------------
    -- No snooping
    -----------------------------------------------------------------------------
    
    -- Internal Interface Signals (Snoop communication).
    snoop_fetch_piperun       <= '0';
    snoop_req_piperun         <= '0';
    snoop_act_piperun         <= '0';
    
    Gen_Default_Array: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      snoop_fetch_info(I)               <= C_NULL_SNOOP_FETCH;
      
      snoop_req_info(I)                 <= C_NULL_SNOOP_REQ;
      
      snoop_act_info(I)                 <= C_NULL_SNOOP_ACT;
      
      snoop_tag_status_info(I)          <= C_NULL_SNOOP_TAG;
      
      snoop_resp_ready                  <= (others=>'0');
      
      snoop_data_ready                  <= (others=>'0');
      
    end generate Gen_Default_Array;
    
    -- Snoop signals (Read Data & response).
    snoop_read_data_valid     <= (others=>'0');
    snoop_read_data_last      <= '0';
    snoop_read_data_resp      <= (others=>'0');
    snoop_read_data_word      <= (others=>'0');
    
    
    -----------------------------------------------------------------------------
    -- ACE Downstream Barrier Request.
    -----------------------------------------------------------------------------
    
    ctrl_access_done  <= not access_valid_i;
    
    
    -----------------------------------------------------------------------------
    -- Statistics
    -----------------------------------------------------------------------------
    
    stat_access_fetch_stall   <= C_NULL_STAT_POINT;
    stat_access_req_stall     <= C_NULL_STAT_POINT;
    stat_access_act_stall     <= C_NULL_STAT_POINT;
    
    -----------------------------------------------------------------------------
    -- Debug 
    -----------------------------------------------------------------------------
    
    ACCESS_DEBUG(205                  downto   0) <= (others=>'0');
    ACCESS_DEBUG(ACCESS_DEBUG'left    downto 212) <= (others=>'0');
    
  end generate No_Coherency;
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    ACCESS_DEBUG(211                  downto 206) <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          ACCESS_DEBUG(211                  downto 206) <= (others=>'0');
          
        else
          -- Default assignment.
          ACCESS_DEBUG(211                  downto 206) <= (others=>'0');
          
          ACCESS_DEBUG(                            206) <= lookup_piperun_i;
          ACCESS_DEBUG(                            207) <= access_evict_line;
          ACCESS_DEBUG(                            208) <= access_evict_1st_cycle;
          ACCESS_DEBUG(                            209) <= access_original_cycle;
          ACCESS_DEBUG(                            210) <= access_evict_inserted;
          ACCESS_DEBUG(                            211) <= access_stall;
  
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Coherent
  -----------------------------------------------------------------------------
  
  Use_Coherency: if( is_slv_coherent(C_ENABLE_COHERENCY) ) generate
    
    -- Types for information queue storage.
    type SS_FIFO_MEM_VEC_TYPE         is array(C_NUM_OPTIMIZED_PORTS-1 downto 0) of SS_FIFO_MEM_TYPE;
    type QUEUE_ADDR_VEC_TYPE          is array(C_NUM_OPTIMIZED_PORTS-1 downto 0) of QUEUE_ADDR_TYPE;

    -- ----------------------------------------
    -- Pipeline Stage: Snoop Fetch
    
    signal snoop_fetch_piperun_pre1   : std_logic;
    signal snoop_fetch_piperun_i      : std_logic;
    signal snoop_fetch_stall          : std_logic;
    signal snoop_fetch_waiting_4_pipe : std_logic;
    signal snoop_fetch_valid_i        : std_logic;
    signal access_fetch_info          : ACCESS_TYPE;
    signal snoop_fetch_addr_i         : AXI_ADDR_TYPE;
    signal snoop_fetch_myself_i       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_always         : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_any_always     : std_logic;
    signal snoop_fetch_update_filter  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_ud_filter_me   : std_logic;
    signal snoop_fetch_no_data        : std_logic;
    signal snoop_fetch_no_rs          : std_logic;
    signal snoop_fetch_dvm_complete   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_dvm_is_complete: std_logic;
    signal snoop_fetch_comp_port      : C_PORT_POS;
    signal snoop_fetch_comp_target    : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_dvm_sync       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_dvm_is_sync    : std_logic;
    signal snoop_fetch_any_want       : std_logic;
    signal snoop_fetch_want           : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_snoop          : AXI_SNOOP_VECTOR_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_prot           : AXI_PROT_TYPE;
    signal snoop_fetch_port_num       : C_PORT_POS;
    signal snoop_fetch_ex_with_mon    : std_logic;
    signal snoop_fetch_valid_cu       : std_logic;
    signal snoop_fetch_exclusive_start: std_logic;
    signal snoop_fetch_exclusive_ok   : std_logic;
    signal snoop_fetch_start_monitor  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_stop_monitor   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_fetch_is_part2       : std_logic;
    signal snoop_fetch_lx_allocate    : std_logic;
    signal snoop_fetch_peer_caches    : std_logic;
    signal snoop_fetch_ds_caches      : std_logic;
    signal snoop_fetch_is_barrier     : std_logic;
    signal snoop_fetch_valid_ds_ci    : std_logic;
    signal snoop_fetch_ignore_data    : std_logic;
    signal snoop_fetch_comp_hold      : PORT_TYPE;
    signal snoop_fetch_dvm_comp_hold  : std_logic;
    signal snoop_fetch_allow_dirty    : std_logic;
    
    
    -- ----------------------------------------
    -- Pipeline Stage: Snoop Request
    
    signal snoop_req_piperun_pre1     : std_logic;
    signal snoop_req_piperun_i        : std_logic;
    signal snoop_req_stall            : std_logic;
    signal snoop_req_conflict         : std_logic; 
    signal snoop_req_exclusive_stall  : std_logic; 
    signal snoop_req_valid_i          : std_logic;
    signal access_req_info            : ACCESS_TYPE;
    signal snoop_req_addr_i           : AXI_ADDR_TYPE;
    signal snoop_req_myself_i         : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_always_i         : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_any_always       : std_logic;
    signal snoop_req_update_filter_i  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_update_filter_me : std_logic;
    signal snoop_req_no_data          : std_logic;
    signal snoop_req_no_rs            : std_logic;
    signal snoop_req_any_want         : std_logic;
    signal snoop_req_want_i           : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_snoop_i          : AXI_SNOOP_VECTOR_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_prot             : AXI_PROT_TYPE;
    signal snoop_req_is_barrier       : std_logic;
    signal snoop_req_exclusive_start  : std_logic;
    signal snoop_req_exclusive_ok     : std_logic;
    signal snoop_req_start_monitor    : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_stop_monitor     : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_allow_exclusive  : std_logic;
    signal snoop_req_evict_line       : std_logic;
    signal snoop_req_early_resp       : std_logic;
    signal snoop_req_port_num         : C_PORT_POS;
    signal snoop_req_allow_dirty      : std_logic;
    
    
    -- ----------------------------------------
    -- Pipeline Stage: Snoop Action
    
    signal snoop_act_piperun_pre2     : std_logic;
    signal snoop_act_piperun_pre1     : std_logic;
    signal snoop_act_piperun_i        : std_logic; 
    signal snoop_act_valid_vec        : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_stall_part1      : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_stall_part2      : std_logic; 
    signal snoop_act_stall            : std_logic; 
    signal snoop_act_valid_i          : std_logic; 
    signal snoop_act_waiting_4_pipe_i : std_logic;
    signal snoop_act_conflict         : std_logic; 
    signal access_act_info            : ACCESS_TYPE;
    signal snoop_act_addr_i           : AXI_ADDR_TYPE;
    signal snoop_act_any_always       : std_logic;
    signal snoop_act_no_data          : std_logic;
    signal snoop_act_no_rs            : std_logic;
    signal snoop_act_no_forward       : std_logic;
    signal snoop_act_exclusive_start  : std_logic;
    signal snoop_act_exclusive_ok     : std_logic;
    signal snoop_act_evict_line       : std_logic;
    signal snoop_act_early_resp       : std_logic;
    signal snoop_act_port_num         : C_PORT_POS;
    signal snoop_act_allow_dirty      : std_logic;
    signal snoop_act_any_dvm          : std_logic;
    signal snoop_act_clean_or_make    : std_logic;
    signal snoop_act_is_barrier       : std_logic;
    signal snoop_act_ac_read_once     : std_logic;
    signal snoop_act_ac_read_drop     : std_logic;
    
    
    -- ----------------------------------------
    -- Pipeline Stage: Access
    
    signal access_waiting_for_pipe    : std_logic;
    signal access_snooped_ports       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal access_no_data             : std_logic;
    signal access_no_rs               : std_logic;
    signal access_no_forward          : std_logic;
    signal access_exclusive_start     : std_logic;
    signal access_exclusive_ok        : std_logic;
    
    
    -- ----------------------------------------
    -- Queue handling
    
    signal ss_push                    : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal ss_pop                     : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal ss_fifo_full               : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal ss_fifo_empty              : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal ss_port_num                : PORT_POS_ARRAY_TYPE;
    signal ss_assert                  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    signal rs_push                    : std_logic;
    signal rs_pop                     : std_logic;
    signal rs_already_pushed          : std_logic;
    signal rs_fifo_almost_full        : std_logic;
    signal rs_fifo_full               : std_logic;
    signal rs_fifo_stall              : std_logic;
    signal rs_fifo_empty              : std_logic;
    signal rs_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
    signal rs_fifo_mem                : RS_FIFO_MEM_TYPE; -- := (others=>C_NULL_RS);
    signal rs_no_forward              : std_logic;
    signal rs_port_num                : rinteger range 0 to C_NUM_PORTS - 1;
    signal rs_resp_mask               : PORT_TYPE;
    signal rs_exclusive_start         : std_logic;
    signal rs_exclusive_ok            : std_logic;
    signal rs_assert                  : std_logic;
    
    signal sm_fifo_empty              : std_logic;
    signal sm_fifo_stall              : std_logic;
    signal sm_no_forward              : std_logic;
    signal sm_port_num                : rinteger range 0 to C_NUM_PORTS - 1;
    signal sm_resp_mask               : PORT_TYPE;
    signal sm_exclusive_start         : std_logic;
    signal sm_exclusive_ok            : std_logic;
    signal sm_is_shared               : std_logic;
    signal sm_pass_dirty              : std_logic;
    signal sm_err                     : std_logic;
    signal sm_peer                    : std_logic;
    
    signal snoop_act_is_shared        : std_logic;
    signal snoop_act_found_dirty      : std_logic;
    signal snoop_act_downstream_dirty : std_logic;
    signal snoop_act_peer_copy        : std_logic;
    signal snoop_act_peer_dirty       : std_logic;
    signal snoop_act_valid_dt         : std_logic;
    signal snoop_resp_merge_ready     : std_logic;
    
    signal scd_data_push              : std_logic;
    signal sds_fifo_full              : std_logic;
    signal sds_peer                   : std_logic;
    signal sds_read_once              : std_logic;
    signal sds_port_num               : C_PORT_POS;
    
    signal ss_read_fifo_addr_vec      : QUEUE_ADDR_VEC_TYPE:= (others=>(others=>'1'));
    signal ss_fifo_mem_vec            : SS_FIFO_MEM_VEC_TYPE; -- := (others=>(others=>C_NULL_SS));
    
    -- ----------------------------------------
    -- Handle Response Merging
    
    signal snoop_merged_error         : std_logic;
    signal snoop_all_resp_available   : std_logic;
    signal access_resp_valid_vec      : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_read_data_port_num   : natural range 0 to C_NUM_PORTS - 1;
    signal snoop_read_data_any_valid  : std_logic;
    signal snoop_read_data_block      : std_logic;
    
    
    -- ----------------------------------------
    -- Exclusive Monitor
    
    signal snoop_ex_monitor_allow_new : std_logic;
    signal snoop_ex_monitor_started   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_ex_monitor_port      : natural range 0 to C_NUM_PORTS - 1;
    signal snoop_ex_trans_concluded   : std_logic;
    signal snoop_ex_enable_timer      : std_logic;
    signal snoop_ex_timer             : natural range 0 to C_NUM_PORTS;
    
    
    signal snoop_req_complete         : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_req_complete_target  : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_myself           : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_always           : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_prot             : AXI_PROT_TYPE;
    signal snoop_act_snoop            : AXI_SNOOP_VECTOR_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_done             : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_use_external     : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_write_blocking   : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_info_tag_unique      : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_info_tag_dirty       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_resp_valid           : std_logic_vector(C_NUM_PORTS - 1 downto 0);
    signal snoop_resp_crresp          : AXI_CRRESP_VECTOR_TYPE(C_NUM_PORTS - 1 downto 0);
    
    signal src_peer_ready             : std_logic;
    signal src_peer_valid             : std_logic;
    
    signal sm_peer_pop                : std_logic;
    signal sm_only_pop                : std_logic;
    signal sm_pop                     : std_logic;
    signal sm_fifo_full               : std_logic;
    
    signal sds_stall                  : std_logic;
    signal sds_fifo_empty             : std_logic;
    
    signal all_cd_last                : std_logic;
    signal snoop_peer_push            : std_logic;
    signal snoop_only_push            : std_logic;
    signal snoop_push                 : std_logic;
    signal snoop_ready                : std_logic;
    signal snoop_only_ready           : std_logic;
    
    signal scd_ready                  : std_logic;
    
    signal snoop_dump_complete        : PORT_TYPE;
    signal snoop_dump_waiting         : std_logic;
    
  begin
    
    access_piperun_i              <= snoop_fetch_piperun_i;
    
    
    -----------------------------------------------------------------------------
    -- Transform Input data
    -----------------------------------------------------------------------------
    
    Gen_Input_Array: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      snoop_act_done(I)             <= snoop_act_ack_info(I).Done;
      snoop_act_use_external(I)     <= snoop_act_ack_info(I).Use_External;
      snoop_act_write_blocking(I)   <= snoop_act_ack_info(I).Write_Blocking;
      snoop_info_tag_unique(I)      <= snoop_tag_new_info(I).Unique;
      snoop_info_tag_dirty(I)       <= snoop_tag_new_info(I).Dirty;
      snoop_resp_valid(I)           <= snoop_resp_info(I).Valid;
      snoop_resp_crresp(I)          <= snoop_resp_info(I).CRRESP;
      
    end generate Gen_Input_Array;
    
    
    -----------------------------------------------------------------------------
    -- Translate
    -- 
    -----------------------------------------------------------------------------
    
    -- Decode cache effect.
    snoop_fetch_peer_caches         <= '1' when ( arb_access.Domain = C_DOMAIN_INNER_SHAREABLE ) or
                                                ( arb_access.Domain = C_DOMAIN_OUTER_SHAREABLE ) else
                                       '0';
    snoop_fetch_ds_caches           <= '1' when ( arb_access.Domain = C_DOMAIN_NON_SHAREABLE   ) or
                                                ( arb_access.Domain = C_DOMAIN_INNER_SHAREABLE ) or
                                                ( arb_access.Domain = C_DOMAIN_OUTER_SHAREABLE ) else
                                       '0';
    snoop_fetch_is_barrier          <= '1' when ( arb_access.Barrier = C_BAR_MEMORY_BARRIER    ) or
                                                ( arb_access.Barrier = C_BAR_SYNCHRONIZATION   ) else
                                       '0';
    
    snoop_fetch_valid_i             <= arb_access.Valid;
    
    -- Extend the length vector.
    Ext_Len: process (arb_access) is
    begin  -- process Ext_Len
      extended_length               <= (others=>'0');
      extended_length(14 downto 7)  <= arb_access.Len;
      extended_length( 6 downto 0)  <= "1111111";
    end process Ext_Len;
    
    -- Generate step and use.
    Gen_Fetch: process (arb_access, extended_length, snoop_fetch_lx_allocate, snoop_fetch_ignore_data) is
    begin  -- process Gen_Mask
      -- Default assignment
      access_fetch_info               <= C_NULL_ACCESS;
      
      access_fetch_info.Port_Num      <= arb_access.Port_Num;
      access_fetch_info.Allocate      <= arb_access.Allocate and 
                                         not arb_access.Evict;
      access_fetch_info.Bufferable    <= arb_access.Bufferable;
      access_fetch_info.Exclusive     <= arb_access.Exclusive;
      access_fetch_info.Evict         <= arb_access.Evict;
      access_fetch_info.SnoopResponse <= '0';
      access_fetch_info.KillHit       <= arb_access.Evict;
      access_fetch_info.Kind          <= arb_access.Kind;
      access_fetch_info.Wr            <= arb_access.Wr;
      access_fetch_info.Addr          <= arb_access.Addr;
      access_fetch_info.Len           <= arb_access.Len;
      access_fetch_info.Size          <= arb_access.Size;
      access_fetch_info.Prot          <= arb_access.Prot;
      access_fetch_info.Domain        <= arb_access.Domain;
      access_fetch_info.Barrier       <= arb_access.Barrier;
      access_fetch_info.Snoop         <= arb_access.Snoop;
      access_fetch_info.IsShared      <= '0';
      access_fetch_info.PassDirty     <= '0';
      access_fetch_info.Lx_Allocate   <= snoop_fetch_lx_allocate;
      access_fetch_info.Ignore_Data   <= arb_access.Ignore_Data or 
                                         snoop_fetch_ignore_data;
      access_fetch_info.Force_Hit     <= arb_access.Force_Hit;
      access_fetch_info.Internal_Cmd  <= arb_access.Internal_Cmd;
      access_fetch_info.Early         <= arb_access.Early;
      access_fetch_info.Keep          <= arb_access.Keep;

      case arb_access.Size is
        when C_BYTE_SIZE          =>
          access_fetch_info.Addr_Use <= extended_length(C_BYTE_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HALF_WORD_SIZE     =>
          access_fetch_info.Addr_Use <= extended_length(C_HALF_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_WORD_SIZE          =>
          access_fetch_info.Addr_Use <= extended_length(C_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_DOUBLE_WORD_SIZE   =>
          access_fetch_info.Addr_Use <= extended_length(C_DOUBLE_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_QUAD_WORD_SIZE     =>
          access_fetch_info.Addr_Use <= extended_length(C_QUAD_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_OCTA_WORD_SIZE     =>
          access_fetch_info.Addr_Use <= extended_length(C_OCTA_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HEXADECA_WORD_SIZE =>
          access_fetch_info.Addr_Use <= extended_length(C_HEXADECA_WORD_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when others               =>
          access_fetch_info.Addr_Use <= extended_length(C_TRIACONTADI_MASK_POS);
          access_fetch_info.Addr_Stp <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
      end case;
    
      -- ID.
      access_fetch_info.ID      <= arb_access.ID;
    end process Gen_Fetch;
    
    -- Assign external signal.
    snoop_fetch_addr_i        <= arb_access.Addr;
    
    
    -----------------------------------------------------------------------------
    -- Pipeline Stage: Snoop Fetch
    -- 
    -----------------------------------------------------------------------------
    
    -- Pipeline control
--    snoop_fetch_piperun_i   <= ( snoop_req_piperun_i or not snoop_req_valid_i ) and not snoop_fetch_stall;
    FE_Acs_PR_Or_Inst4: carry_or_n 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => snoop_req_piperun_i,
        A_N       => snoop_req_valid_i,
        Carry_OUT => snoop_fetch_piperun_pre1
      );
    FE_Acs_PR_And_Inst4: carry_and_n 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => snoop_fetch_piperun_pre1,
        A_N       => snoop_fetch_stall,
        Carry_OUT => snoop_fetch_piperun_i
      );
    
    -- Stall conditions: Tag Line hazards.
    snoop_fetch_stall       <= snoop_req_conflict         or 
                               snoop_act_conflict         or 
                               snoop_req_exclusive_stall  or
                               reduce_or(snoop_fetch_pos_hazard);
    
    -- Help signal for current Port number.
    snoop_fetch_port_num    <= get_port_num(access_fetch_info.Port_Num, C_NUM_PORTS);
    
    -- Help signal to determine if a CleanUnique shall proceed.
    snoop_fetch_ex_with_mon <= snoop_fetch_valid_i and access_fetch_info.Exclusive and 
                               snoop_ex_monitor_started(snoop_fetch_port_num);
    snoop_fetch_valid_cu    <= snoop_fetch_ex_with_mon or 
                               ( snoop_fetch_valid_i and not access_fetch_info.Exclusive );
    
    -- Generate the target for a complete transaction.
    snoop_fetch_comp_port   <= ss_port_num(snoop_fetch_port_num);
    
    -- Decode transaction
    Transaction_Decode: process (arb_access, snoop_fetch_comp_port, snoop_fetch_dvm_comp_hold, snoop_fetch_comp_hold, 
                                 snoop_fetch_ex_with_mon, snoop_fetch_valid_cu, snoop_fetch_is_part2,
                                 snoop_fetch_peer_caches, snoop_fetch_ds_caches, access_fetch_info,
                                 snoop_ex_monitor_allow_new, snoop_fetch_is_barrier) is
    begin  -- process Transaction_Decode
      -- Default assignment
      snoop_fetch_myself_i          <= (others=>'0');
      snoop_fetch_always            <= (others=>'0');
      snoop_fetch_any_always        <= '0';
      snoop_fetch_update_filter     <= (others=>'0');
      snoop_fetch_ud_filter_me      <= '0';
      snoop_fetch_no_data           <= '0';
      snoop_fetch_no_rs             <= '0';
      snoop_fetch_exclusive_start   <= '0';
      snoop_fetch_exclusive_ok      <= '0';
      snoop_fetch_start_monitor     <= (others=>'0');
      snoop_fetch_stop_monitor      <= (others=>'0');
      snoop_fetch_any_want          <= '0';
      snoop_fetch_want              <= (others=>'0');
      snoop_fetch_dvm_complete      <= (others=>'0');
      snoop_fetch_comp_target       <= (others=>'0');
      snoop_fetch_dvm_is_complete   <= '0';
      snoop_fetch_dvm_sync          <= (others=>'0');
      snoop_fetch_dvm_is_sync       <= '0';
      snoop_fetch_lx_allocate       <= '0';
      snoop_fetch_valid_ds_ci       <= '0';
      snoop_fetch_ignore_data       <= '0';
      snoop_fetch_allow_dirty       <= '0';
      
      for I in 0 to C_NUM_PORTS - 1 loop
        if( get_port_num(arb_access.Port_Num, C_NUM_PORTS) = I ) then
          -- Current port only update filter.
          snoop_fetch_myself_i(I)         <= not access_fetch_info.Internal_Cmd;
          snoop_fetch_snoop(I)            <=     arb_access.Snoop;
          
          if( snoop_fetch_is_barrier = '1' ) then
            -- A Barrier transaction will not snoop any peer caches.
            -- The serialization takes care of the requirement that all later transaction can see
            -- all transactions before the Barrier.
            -- There is no distinction between Memory and Synchronizing Barrier, all are treated 
            -- as the stricter type.
            if( arb_access.Wr = '1' ) then
              snoop_fetch_ignore_data       <= '1';     -- Ignore any data available for this line  
              snoop_fetch_no_rs             <= '1';     -- Don't forward any snoop responses
            else
            end if;
            snoop_fetch_no_data           <= '1';     -- No data is interesting for this transaction
          else
            if( arb_access.Wr = '1' ) then
              -- ---------------------------------
              -- Write transaction (source port).
            
              case arb_access.Snoop(C_AXI_AWSNOOP_POS) is
                when C_AWSNOOP_WriteUnique  =>
                  -- MicroBlaze will allocate on Word WriteUnique.
                  -- The responses from peer cache snoop requests can be ignored.
                  snoop_fetch_no_rs             <= '1';
                  
                when C_AWSNOOP_WriteLineUnique    =>
                  -- All peer caches are removed.
                  -- The responses from peer cache snoop requests can be ignored.
                  snoop_fetch_no_rs             <= '1';
                  
                when C_AWSNOOP_WriteClean         =>
                  -- Data is written downstream, but line is retained in a Clean state.
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_rs             <= '1';
                  
                when C_AWSNOOP_WriteBack          =>
                  -- Data is written downstream.
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_rs             <= '1';
                  
                when C_AWSNOOP_WriteEvict         =>
                  -- Clean data is written downstream.
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_rs             <= '1';
                  
                when C_AWSNOOP_Evict              =>
                  -- Line is removed from local Lx cache, no data provided.
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_rs             <= '1';
                  
                when others                       =>
                  null;
                  
              end case;
              
            else
              -- ---------------------------------
              -- Read transaction (source port).
              
              snoop_fetch_no_rs             <= access_fetch_info.Internal_Cmd;
              
              case arb_access.Snoop is
                when C_ARSNOOP_ReadOnce  =>
                  -- Nothing needs to be done.
                  snoop_fetch_no_rs             <= not int_to_std(C_SUPPORT_PEER_DATA);
                  
                when C_ARSNOOP_ReadShared         =>
                  -- Read cache line in any state, mark my status and make the others in a shared state and 
                  -- transfer write responsibility if required.
                  snoop_fetch_lx_allocate       <= '1';
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_exclusive_start   <=     arb_access.Exclusive and snoop_ex_monitor_allow_new and
                                                       int_to_std(C_SUPPORT_PEER_DATA);
                  snoop_fetch_start_monitor(I)  <=     arb_access.Exclusive and snoop_ex_monitor_allow_new;
                  snoop_fetch_allow_dirty       <=     int_to_std(C_SUPPORT_DIRTY_DATA);
                  snoop_fetch_no_rs             <= not int_to_std(C_SUPPORT_PEER_DATA);
                  
                when C_ARSNOOP_ReadClean          =>
                  -- Read cache line only in clean state, Dirty data must be propagated downstream.
                  -- Might need to update filter.
                  snoop_fetch_lx_allocate       <= '1';
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_exclusive_start   <=     arb_access.Exclusive and snoop_ex_monitor_allow_new and
                                                       int_to_std(C_SUPPORT_PEER_DATA);
                  snoop_fetch_start_monitor(I)  <=     arb_access.Exclusive and snoop_ex_monitor_allow_new;
                  snoop_fetch_no_rs             <= not int_to_std(C_SUPPORT_PEER_DATA);
                  
                when C_ARSNOOP_ReadNotSharedDirty =>
                  -- Read cache line without write responsibility in a shared situation.
                  snoop_fetch_lx_allocate       <= '1';
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_rs             <= not int_to_std(C_SUPPORT_PEER_DATA);
                  
                when C_ARSNOOP_ReadUnique         =>
                  -- Read and make sure this is the only copy.
                  snoop_fetch_lx_allocate       <= '1';
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_allow_dirty       <=     int_to_std(C_SUPPORT_DIRTY_DATA);
                  snoop_fetch_no_rs             <= not int_to_std(C_SUPPORT_PEER_DATA);
                  
                when C_ARSNOOP_CleanUnique        =>
                  -- Make sure entry is removed from filter.
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_data           <= '1';
                  snoop_fetch_exclusive_ok      <=     snoop_fetch_ex_with_mon;
                  snoop_fetch_start_monitor(I)  <=     arb_access.Exclusive and snoop_ex_monitor_allow_new;
                  
                when C_ARSNOOP_MakeUnique         =>
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_data           <= '1';
                  snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                  
                when C_ARSNOOP_CleanShared        =>
                  snoop_fetch_update_filter(I)  <= '1';
                  snoop_fetch_ud_filter_me      <= '1';
                  snoop_fetch_no_data           <= '1';
                  snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                  
                when C_ARSNOOP_CleanInvalid       =>
                  -- Make sure entry is removed from filter.
                  if( s2b(arb_access.Internal_Cmd) ) then
                    snoop_fetch_no_data           <= '1';
                    snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                    snoop_fetch_want(I)           <=     snoop_fetch_peer_caches;
                    snoop_fetch_any_want          <=     snoop_fetch_peer_caches;
                  else
                    snoop_fetch_update_filter(I)  <= '1';
                    snoop_fetch_ud_filter_me      <= '1';
                    snoop_fetch_no_data           <= '1';
                    snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                  end if;
                  
                when C_ARSNOOP_MakeInvalid        =>
                  -- Make sure entry is removed from filter.
                  if( s2b(arb_access.Internal_Cmd) ) then
                    snoop_fetch_no_data           <= '1';
                    snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                    snoop_fetch_ignore_data       <= '1';
                    snoop_fetch_want(I)           <=     snoop_fetch_peer_caches;
                    snoop_fetch_any_want          <=     snoop_fetch_peer_caches;
                  else
                    snoop_fetch_update_filter(I)  <= '1';
                    snoop_fetch_ud_filter_me      <= '1';
                    snoop_fetch_no_data           <= '1';
                    snoop_fetch_valid_ds_ci       <=     snoop_fetch_ds_caches;
                    snoop_fetch_ignore_data       <= '1';
                  end if;
                  
                when C_ARSNOOP_DVMComplete        =>
                  -- Collect transactions.
                  if( snoop_fetch_dvm_comp_hold = '0' ) then
                    snoop_fetch_dvm_complete      <= std_logic_vector(to_unsigned(2 ** snoop_fetch_comp_port, 
                                                                                  C_NUM_PORTS));
                  else
                    snoop_fetch_dvm_complete      <= snoop_fetch_comp_hold;
                  end if;
                  snoop_fetch_comp_target(I)    <= '1';
                  snoop_fetch_dvm_is_complete   <= '1';
                  snoop_fetch_no_data           <= '1';
                  
                when C_ARSNOOP_DVMMessage         =>
                  -- Register if it is a Sync message.
                  snoop_fetch_dvm_is_sync       <= arb_access.Addr(C_DVM_NEED_COMPLETE_POS) and not snoop_fetch_is_part2;
                  snoop_fetch_dvm_sync(I)       <= arb_access.Addr(C_DVM_NEED_COMPLETE_POS) and not snoop_fetch_is_part2;
                  snoop_fetch_no_data           <= '1';
                  
                when others                       =>
                  null;
                  
              end case;
            end if;
          end if;
        else
          -- All other ports.
          
          -- Default assignment
          snoop_fetch_snoop(I)          <= C_ACSNOOP_CleanInvalid;
          
          if( snoop_fetch_is_barrier = '1' ) then
            -- Nothing for peer caches.
            
          else
            if( arb_access.Wr = '1' ) then
              -- ---------------------------------
              -- Write transaction (peer port).
            
              case arb_access.Snoop(C_AXI_AWSNOOP_POS) is
                when C_AWSNOOP_WriteUnique  => --  | C_AWSNOOP_WriteNoSnoop
                  -- Make sure any peer cache that have this line dirty is queried for data 
                  -- to be written downstream.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_CleanInvalid;
                  
                when C_AWSNOOP_WriteLineUnique    =>
                  -- Discard all data in peer caches since this write will remove any 
                  -- previously dirty data.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  
                when C_AWSNOOP_WriteClean         =>
                  -- Data write of dirty data (keep allocation), no need to query peer caches.
                  snoop_fetch_want(I)           <= '0';
                  snoop_fetch_any_want          <= '0';
                  
                when C_AWSNOOP_WriteBack          =>
                  -- Data write of dirty data, no need to query peer caches.
                  snoop_fetch_want(I)           <= '0';
                  snoop_fetch_any_want          <= '0';
                  
                when C_AWSNOOP_WriteEvict          =>
                  -- Data write of clean data to downstream caches, no need to query peer caches.
                  snoop_fetch_want(I)           <= '0';
                  snoop_fetch_any_want          <= '0';
                
                when C_AWSNOOP_Evict              =>
                  -- Snoop filter maintenance operation, no need to query peer caches.
                  snoop_fetch_want(I)           <= '0';
                  snoop_fetch_any_want          <= '0';
                  
                when others                       =>
                  null;
                  
              end case;
            else
              -- ---------------------------------
              -- Read transaction (peer port).
              
              case arb_access.Snoop is
                when C_ARSNOOP_ReadOnce  => --  | C_ARSNOOP_ReadNoSnoop
                  -- Temporary read that doesn't affect allocation.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_ReadOnce;
                  
                when C_ARSNOOP_ReadShared         =>
                  -- Read data in any state and/or update line status.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_ReadShared;
                  
                when C_ARSNOOP_ReadClean          =>
                  -- Read data in clean state and/or update line status.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_ReadClean;
                  
                when C_ARSNOOP_ReadNotSharedDirty =>
                  -- Read data without shared write responsibility and/or update line status.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_ReadNotSharedDirty;
                  
                when C_ARSNOOP_ReadUnique         =>
                  -- Read data and make sure this is the only copy.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_ReadUnique;
                  
                when C_ARSNOOP_CleanUnique        =>
                  -- Clean all other peer caches from Dirty data and remove allocation, but 
                  -- the Source is allowed keep its allocation (in preparation for Write).
                  -- Special exclusive handling as well to track the atomicity of the Exclusive operation.
                  snoop_fetch_want(I)           <= snoop_fetch_valid_cu;
                  snoop_fetch_any_want          <= snoop_fetch_valid_cu;
                  snoop_fetch_stop_monitor(I)   <= snoop_fetch_ex_with_mon;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_CleanInvalid;
                  
                when C_ARSNOOP_MakeUnique         =>
                  -- Remove any data without regard to it's current state.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  
                when C_ARSNOOP_CleanShared        =>
                  -- Make sure any Dirty data from peer caches is propagated downstream.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_CleanShared;
                  
                when C_ARSNOOP_CleanInvalid       =>
                  -- Make sure any Dirty data from peer caches is propagated downstream and no allocation remains.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_CleanInvalid;
                  
                when C_ARSNOOP_MakeInvalid        =>
                  -- Forcefully remove any allocation without regard to if it is Dirty or not.
                  snoop_fetch_want(I)           <= snoop_fetch_peer_caches;
                  snoop_fetch_any_want          <= snoop_fetch_peer_caches;
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_MakeInvalid;
                  
                when C_ARSNOOP_DVMComplete        =>
                  -- DVM Complete messages are never peer snooped. 
                  -- Only Source of the Sync is snooped once all peer caches has returned their DVM Complete.
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_DVMComplete;
                  
                when C_ARSNOOP_DVMMessage         =>
                  -- Propagate all DVM messages to all peer caches.
                  snoop_fetch_always(I)         <= '1';
                  snoop_fetch_any_always        <= '1';
                  snoop_fetch_snoop(I)          <= C_ACSNOOP_DVMMessage;
                  
                when others                       =>
                  null;
                  
              end case;
            end if;
          end if;
        end if;
      end loop;
    end process Transaction_Decode;
    
    snoop_fetch_prot  <= arb_access.Prot;
    
    Pipeline_Stage_Snoop_Fetch_Done : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Fetch_Done
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then             -- synchronous reset (active high)
          snoop_fetch_waiting_4_pipe  <= '0';
          snoop_fetch_comp_hold       <= (others=>'0');
          snoop_fetch_dvm_comp_hold   <= '0';
          
        else
          if( snoop_fetch_piperun_i = '1' ) then
            snoop_fetch_waiting_4_pipe  <= '0';
            snoop_fetch_comp_hold       <= (others=>'0');
            snoop_fetch_dvm_comp_hold   <= '0';
          elsif( snoop_fetch_valid_i = '1' ) then
            snoop_fetch_waiting_4_pipe  <= '1';
            if( snoop_fetch_waiting_4_pipe = '0' ) then
              snoop_fetch_comp_hold       <= snoop_fetch_dvm_complete;
              snoop_fetch_dvm_comp_hold   <= snoop_fetch_dvm_is_complete;
            end if;
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Fetch_Done;
    
    -- Move Snoop Request to Snoop Request (Valid).
    Pipeline_Stage_Snoop_Req_Valid : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Req_Valid
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_req_valid_i <= '0';
        else
          if( snoop_fetch_piperun_i = '1' ) then
            snoop_req_valid_i <= snoop_fetch_valid_i;
          elsif( snoop_req_piperun_i = '1' ) then
            snoop_req_valid_i <= '0';
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Req_Valid;
    
    -- Need to stall for Exclusive Store Transaction.
    Pipeline_Stage_Snoop_Req_Ex : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Req_Ex
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_req_exclusive_stall <= '0';
        else
          if( snoop_fetch_piperun_i = '1' ) then
            snoop_req_exclusive_stall <= snoop_fetch_ex_with_mon;
          else
            snoop_req_exclusive_stall <= '0';
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Req_Ex;
    
    -- Move Snoop Request to Snoop Request (Information).
    Pipeline_Stage_Snoop_Req : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Req
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          access_req_info             <= C_NULL_ACCESS;
          snoop_req_myself_i          <= (others=>'0');
          snoop_req_always_i          <= (others=>'0');
          snoop_req_any_always        <= '0';
          snoop_req_update_filter_i   <= (others=>'0');
          snoop_req_update_filter_me  <= '0';
          snoop_req_no_data           <= '0';
          snoop_req_no_rs             <= '0';
          snoop_req_any_want          <= '0';
          snoop_req_want_i            <= (others=>'0');
          snoop_req_snoop_i           <= (others=>(others=>'0'));
          snoop_req_prot              <= (others=>'0');
          snoop_req_is_barrier        <= '0';
          snoop_req_exclusive_start   <= '0';
          snoop_req_exclusive_ok      <= '0';
          snoop_req_start_monitor     <= (others=>'0');
          snoop_req_stop_monitor      <= (others=>'0');
          snoop_req_complete_target   <= (others=>'0');
          snoop_req_complete          <= (others=>'0');
          snoop_fetch_is_part2        <= '0';
          snoop_req_allow_exclusive   <= '0';
          snoop_req_evict_line        <= '0';
          snoop_req_early_resp        <= '0';
          snoop_req_port_num          <= 0;
          snoop_req_allow_dirty       <= '0';
          
        elsif( snoop_fetch_piperun_i = '1' ) then
          access_req_info             <= access_fetch_info;
          snoop_req_myself_i          <= snoop_fetch_myself_i;
          snoop_req_always_i          <= snoop_fetch_always;
          snoop_req_any_always        <= snoop_fetch_any_always;
          snoop_req_update_filter_i   <= snoop_fetch_update_filter;
          snoop_req_update_filter_me  <= snoop_fetch_ud_filter_me;
          snoop_req_no_data           <= snoop_fetch_no_data;
          snoop_req_no_rs             <= snoop_fetch_no_rs;
          snoop_req_any_want          <= snoop_fetch_any_want;
          snoop_req_want_i            <= snoop_fetch_want;
          snoop_req_snoop_i           <= snoop_fetch_snoop;
          snoop_req_prot              <= snoop_fetch_prot;
          snoop_req_is_barrier        <= snoop_fetch_is_barrier;
          snoop_req_exclusive_start   <= snoop_fetch_exclusive_start;
          snoop_req_exclusive_ok      <= snoop_fetch_exclusive_ok;
          snoop_req_start_monitor     <= snoop_fetch_start_monitor;
          snoop_req_stop_monitor      <= snoop_fetch_stop_monitor;
          snoop_req_complete_target   <= snoop_fetch_comp_target;
          snoop_req_complete          <= snoop_fetch_dvm_complete;
          snoop_req_allow_dirty       <= snoop_fetch_allow_dirty;
          if( snoop_fetch_valid_i = '1' ) then
            snoop_fetch_is_part2        <= snoop_fetch_any_always and 
                                           snoop_fetch_addr_i(C_DVM_MORE_POS);
          end if;
          if( snoop_fetch_port_num = snoop_ex_monitor_port ) then
            snoop_req_allow_exclusive   <= snoop_fetch_valid_i and access_fetch_info.Wr;
          else
            snoop_req_allow_exclusive   <= '0';
          end if;
          
          -- Remove exclusive propagation for "Exclusive Store transaction".
          if( ( arb_access.Wr = '0' ) and ( arb_access.Snoop = C_ARSNOOP_CleanUnique ) ) then
            access_req_info.Exclusive   <= '0';
          end if;
          
          -- Propagate induced evict of line.
          snoop_req_evict_line        <= snoop_fetch_valid_ds_ci;
          
          -- Determine if an early response is allowed.
          if( ( not is_mst_coherent(C_ENABLE_COHERENCY)       ) or
              (     arb_access.Exclusive                = '0' ) ) then
            snoop_req_early_resp        <= arb_access.Bufferable or 
                                           arb_access.Allocate;
          else
            snoop_req_early_resp        <= '0';
          end if;
          snoop_req_port_num          <= snoop_fetch_port_num;
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Req;
    
    
    -----------------------------------------------------------------------------
    -- Pipeline Stage: Snoop Request
    -- 
    -----------------------------------------------------------------------------
    
    -- Pipeline control
--    snoop_req_piperun_i       <= ( snoop_act_piperun_i or not snoop_act_valid_i ) and not snoop_req_stall;
    FE_Acs_PR_Or_Inst3: carry_or_n 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => snoop_act_piperun_i,
        A_N       => snoop_act_valid_i,
        Carry_OUT => snoop_req_piperun_pre1
      );
    FE_Acs_PR_And_Inst3: carry_vec_and_n 
      generic map(
        C_TARGET => C_TARGET,
        C_INPUTS => Family_To_LUT_Size(C_TARGET),
        C_SIZE   => C_NUM_PORTS
      )
      port map(
        Carry_IN  => snoop_req_piperun_pre1,
        A_Vec     => snoop_act_write_blocking,
        Carry_OUT => snoop_req_piperun_i
      );
    
    -- Stall conditions: Still waiting for AC acknowledge.
    snoop_req_stall           <= reduce_or(snoop_act_write_blocking);
    
    -- Move Snoop Request to Snoop Action (Valid).
    Pipeline_Stage_Snoop_Act_Valid : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Valid
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_act_valid_i <= '0';
        else
          if( snoop_req_piperun_i = '1' ) then
            snoop_act_valid_i <= snoop_req_valid_i;
          elsif( snoop_act_piperun_i = '1' ) then
            snoop_act_valid_i <= '0';
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Valid;
    
    Pipeline_Stage_Snoop_Act_Done : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act_Done
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then             -- synchronous reset (active high)
          snoop_act_waiting_4_pipe_i  <= '0';
          
        else
          if( snoop_req_piperun_i = '1' ) then
            snoop_act_waiting_4_pipe_i  <= '0';
          elsif( snoop_act_valid_i = '1' ) then
            snoop_act_waiting_4_pipe_i  <= '1';
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act_Done;
    
    -- Move Snoop Request to Snoop Action (Information).
    Pipeline_Stage_Snoop_Act : process (ACLK) is
    begin  -- process Pipeline_Stage_Snoop_Act
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          access_act_info             <= C_NULL_ACCESS;
          snoop_act_snoop             <= (others=>(others=>'0'));
          snoop_act_myself            <= (others=>'0');
          snoop_act_always            <= (others=>'0');
          snoop_act_any_always        <= '0';
          snoop_act_no_data           <= '0';
          snoop_act_no_rs             <= '0';
          snoop_act_exclusive_start   <= '0';
          snoop_act_exclusive_ok      <= '0';
          snoop_act_prot              <= (others=>'0');
          snoop_act_evict_line        <= '0';
          snoop_act_early_resp        <= '0';
          snoop_act_port_num          <= 0;
          snoop_act_allow_dirty       <= '0';
          snoop_act_any_dvm           <= '0';
          snoop_act_clean_or_make     <= '0';
          snoop_act_is_barrier        <= '0';
          snoop_act_ac_read_once      <= '0';
          snoop_act_ac_read_drop      <= '0';
          
        elsif( snoop_req_piperun_i = '1' ) then
          access_act_info             <= access_req_info;
          snoop_act_snoop             <= snoop_req_snoop_i;
          snoop_act_myself            <= snoop_req_myself_i;
          snoop_act_any_always        <= snoop_req_any_always;
          snoop_act_always            <= snoop_req_always_i;
          snoop_act_no_data           <= snoop_req_no_data;
          snoop_act_no_rs             <= snoop_req_no_rs;
          snoop_act_exclusive_start   <= snoop_req_exclusive_start;
          snoop_act_exclusive_ok      <= snoop_req_exclusive_ok;
          snoop_act_prot              <= snoop_req_prot;
          snoop_act_evict_line        <= snoop_req_evict_line;
          snoop_act_early_resp        <= snoop_req_early_resp;
          snoop_act_port_num          <= snoop_req_port_num;
          snoop_act_allow_dirty       <= snoop_req_allow_dirty;
          snoop_act_ac_read_once      <= '0';
          snoop_act_ac_read_drop      <= '0';
          snoop_act_is_barrier        <= '0';
          if( ( access_req_info.Snoop = C_ARSNOOP_DVMComplete ) or
              ( access_req_info.Snoop = C_ARSNOOP_DVMMessage  ) ) then
            snoop_act_any_dvm           <= '1';
          else
            snoop_act_any_dvm           <= '0';
          end if;
          if( ( access_req_info.Barrier = C_BAR_MEMORY_BARRIER    ) or
              ( access_req_info.Barrier = C_BAR_SYNCHRONIZATION   ) ) then
            -- Tag Barrier transaction.
            snoop_act_ac_read_once      <= '0';
            snoop_act_is_barrier        <= '1';
            
          else
            if( ( access_req_info.Snoop = C_ARSNOOP_ReadOnce ) and
                ( access_req_info.Wr    = '0'                ) ) then
              if( ( access_req_info.Size = C_Lx_NATIVE_SIZE ) and
                  ( access_req_info.Len  = C_Lx_NATIVE_LEN  ) and
                  ( access_req_info.Kind = C_KIND_WRAP      ) ) then
                -- Wrap ReadOnce with native size and length is allowed.
                snoop_act_ac_read_once      <= '0';
                
              elsif( to_int(access_req_info.Len) = 0 ) then
                -- ReadOnce with length Zero is also allowed and the data stream is cut short.
                snoop_act_ac_read_once      <= '1';
                
              else
                -- Remaining ReadOnce need to be dropped from Snoop Peer considerations and fetched from Core.
                snoop_act_ac_read_once      <= '0';
                snoop_act_ac_read_drop      <= '1';
                
              end if;
            else
              -- Normal transaction is unaffected.
              snoop_act_ac_read_once      <= '0';
              
            end if;
            snoop_act_is_barrier        <= '0';
          end if;
          if( ( access_req_info.Snoop = C_ARSNOOP_CleanUnique  ) or
              ( access_req_info.Snoop = C_ARSNOOP_CleanShared  ) or
              ( access_req_info.Snoop = C_ARSNOOP_CleanInvalid ) or
              ( access_req_info.Snoop = C_ARSNOOP_MakeUnique   ) or
              ( access_req_info.Snoop = C_ARSNOOP_MakeInvalid  ) ) then
            snoop_act_clean_or_make     <= '1';
          else
            snoop_act_clean_or_make     <= '0';
          end if;
          
        end if;
      end if;
    end process Pipeline_Stage_Snoop_Act;
    
    -- Rename output.
    snoop_req_addr_i        <= access_req_info.Addr;
    
    
    -----------------------------------------------------------------------------
    -- Pipeline Stage: Snoop Action
    -- 
    -----------------------------------------------------------------------------
    
    -- Pipeline control
--    snoop_act_piperun_i       <= ( lookup_piperun_i or not access_valid_i ) and not snoop_act_stall;
    FE_Acs_PR_Or_Inst2: carry_or_n 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => lookup_piperun_i,
        A_N       => access_valid_i,
        Carry_OUT => snoop_act_piperun_pre2
      );
    FE_Acs_PR_And_Inst2a: carry_vec_and_n 
      generic map(
        C_TARGET => C_TARGET,
        C_INPUTS => Family_To_LUT_Size(C_TARGET),
        C_SIZE   => C_NUM_PORTS
      )
      port map(
        Carry_IN  => snoop_act_piperun_pre2,
        A_Vec     => snoop_act_stall_part1,
        Carry_OUT => snoop_act_piperun_pre1
      );
    FE_Acs_PR_And_Inst2b: carry_and_n 
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => snoop_act_piperun_pre1,
        A_N       => snoop_act_stall_part2,
        Carry_OUT => snoop_act_piperun_i
      );
    
    -- Stall conditions: Still waiting for AC acknowledge.
--    snoop_act_stall           <= ( snoop_act_valid_i and reduce_or(not snoop_act_done) ) or 
--                                 rs_fifo_stall or sm_fifo_stall;
    snoop_act_valid_vec       <= (others => snoop_act_valid_i);
    snoop_act_stall_part1     <= snoop_act_valid_vec and not snoop_act_done;
    snoop_act_stall_part2     <= rs_fifo_stall or sm_fifo_stall or sds_stall;
    snoop_act_stall           <= reduce_or(snoop_act_stall_part1) or snoop_act_stall_part2;
    
    -- Move Snoop Action to Access (Valid).
    Pipeline_Stage_Access_Valid : process (ACLK) is
    begin  -- process Pipeline_Stage_Access_Valid
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          access_valid_i  <= '0';
        else
          if( snoop_act_piperun_i = '1' ) then
            access_valid_i  <= snoop_act_valid_i;
            
          elsif( lookup_piperun_i = '1' ) then
            access_valid_i  <= '0';
            
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Access_Valid;
    
    -- Move Snoop Action to Access (Information).
    Pipeline_Stage_Access : process (ACLK) is
    begin  -- process Pipeline_Stage_Access
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          access_info_i               <= C_NULL_ACCESS;
          access_snooped_ports        <= (others=>'0');
          access_no_data              <= '0';
          access_no_rs                <= '0';
          access_no_forward           <= '0';
          access_exclusive_start      <= '0';
          access_exclusive_ok         <= '0';
          access_evict_line           <= '0';
          access_insert_write         <= '0';
          access_bp_push              <= (others=>C_NULL_WRITE_EARLY);
          
        elsif( snoop_act_piperun_i = '1' ) then
          -- Default assignment.
          access_info_i               <= access_act_info;
          access_snooped_ports        <= snoop_act_use_external;
          access_no_data              <= snoop_act_no_data;
          access_no_rs                <= snoop_act_no_rs;
          access_no_forward           <= snoop_act_no_forward;
          access_exclusive_start      <= snoop_act_exclusive_start;
          access_exclusive_ok         <= snoop_act_exclusive_ok;
          access_bp_push              <= (others=>C_NULL_WRITE_EARLY);
          
          -- Make sure that transactions that doesn't carry data is seen by the core as length 1.
          if( snoop_act_no_data = '1' ) then
            access_info_i.Len           <= (others=>'0');
          end if;
          
          -- Update response bits.
          access_info_i.SnoopResponse <= ( snoop_act_any_always                             or 
                                           ( snoop_act_no_data and not access_act_info.Wr ) or 
                                           snoop_act_peer_copy  ) and 
                                         not access_act_info.Evict;
          access_info_i.KillHit       <= snoop_act_any_always   or 
                                         snoop_act_no_data      or 
                                         snoop_act_peer_copy    or
                                         access_act_info.Evict;
    
          -- Update extra coherency bits after all snooping is completed.
          access_info_i.IsShared      <= not snoop_info_tag_unique(snoop_act_port_num);
          access_info_i.PassDirty     <= snoop_info_tag_dirty(snoop_act_port_num);
          
          -- Stalls if preparing for Exclusive.
          access_evict_line           <= snoop_act_evict_line;
          
          -- Insert Dirty snoop data downstream into Cache Core or external memory.
          access_insert_write         <= ( snoop_act_found_dirty      and 
                                           snoop_act_downstream_dirty ) or
                                         ( snoop_act_valid_dt         and
                                           snoop_act_ac_read_drop     );
          
          -- Generate early information for write.
          access_bp_push(snoop_act_port_num).Valid  <= snoop_act_valid_i and access_act_info.Wr;
          for I in C_PORT_POS loop
            access_bp_push(I).Early                   <= snoop_act_early_resp;
            if( ( access_act_info.Barrier = C_BAR_MEMORY_BARRIER    ) or
                ( access_act_info.Barrier = C_BAR_SYNCHRONIZATION   ) ) then
              access_bp_push(I).Barrier                 <= '1';
              access_bp_push(I).Early                   <= '1';
            end if;
            
          end loop;
          
        else
          access_bp_push              <= (others=>C_NULL_WRITE_EARLY);
          
        end if;
      end if;
    end process Pipeline_Stage_Access;
    
    -- Rename output.
    snoop_act_addr_i          <= access_act_info.Addr;
    
    snoop_act_no_forward      <= snoop_act_no_rs or
                                 snoop_act_ac_read_drop;
    
    -----------------------------------------------------------------------------
    -- Pipeline Stage: Access
    -- 
    -----------------------------------------------------------------------------
    
    Pipeline_Stage_Access_Done : process (ACLK) is
    begin  -- process Pipeline_Stage_Access_Done
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if( ARESET_I = '1' ) then             -- synchronous reset (active high)
          access_waiting_for_pipe <= '0';
          
        else
          if( snoop_act_piperun_i = '1' ) then
            access_waiting_for_pipe <= '0';
          elsif( access_valid_i = '1' ) then
            access_waiting_for_pipe <= '1';
          else
          end if;
        end if;
      end if;
    end process Pipeline_Stage_Access_Done;
    
    
    -----------------------------------------------------------------------------
    -- Conflict detection
    -- 
    -----------------------------------------------------------------------------
    
    -- Detect conflicts because of updating tag (potential or actual).
    snoop_req_conflict  <= '1' when ( snoop_fetch_addr_i(C_Lx_ADDR_LINE_POS) = snoop_req_addr_i(C_Lx_ADDR_LINE_POS) and
                                    ( snoop_req_any_want = '1' or snoop_req_update_filter_me = '1' ) and
                                    ( snoop_req_valid_i = '1' ) and
                                    ( snoop_fetch_valid_i = '1' ) ) else
                           '0';
                           
    snoop_act_conflict  <= '1' when ( snoop_fetch_addr_i(C_Lx_ADDR_LINE_POS) = snoop_act_addr_i(C_Lx_ADDR_LINE_POS) and 
                                    ( snoop_act_valid_i = '1' ) and
                                    ( snoop_fetch_valid_i = '1' ) ) else
                           '0';
    
    
    -----------------------------------------------------------------------------
    -- Queue handling:
    -- 
    -- There need to be a number of queues to handle the latency/flexibility on
    -- DVM messages
    -- 
    -- * DVM Sync Souce:
    --   One queue per port that stores which port a DVM complete should be 
    --   transmitted to.
    --   (From AR)
    -- 
    -- * ACE Response Info:
    --   A queue for each port containing response information that shall be 
    --   coalesced into one response to a specific master.
    --   (Queue physically located in port)
    -- 
    -- * ACE Response Source:
    --   A single queue that determines which port the coalesced snoop responses
    --   shall be forwarded to. 
    --   DVM Complete will insert empty entries in this queue to make sure 
    --   a response is generated. Last complete will actually wait for CR from
    --   Sync Source in order to have something that terminates that response.
    --   (From CR)
    -- 
    -----------------------------------------------------------------------------
    
    Gen_Port_Queues: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      
      Not_Optimized: if( I >= C_NUM_OPTIMIZED_PORTS ) generate
      begin
        ss_push(I)        <= '0';
        ss_pop(I)         <= '0'; 
        ss_fifo_full(I)   <= '0';
        ss_fifo_empty(I)  <= '0';
        
      end generate Not_Optimized;
      
      Is_Optimized: if( I < C_NUM_OPTIMIZED_PORTS ) generate      
      begin
      
        -- Control signals for DVM Sync Source queue.
        -- Push: when Sync transaction is detected propagate to all others.
        -- Pop:  when Complete transaction is detected.
        ss_push(I)  <= snoop_fetch_valid_i and snoop_fetch_dvm_is_sync and not snoop_fetch_dvm_sync(I) and 
                       not snoop_fetch_waiting_4_pipe;
        ss_pop(I)   <= snoop_fetch_valid_i and snoop_fetch_comp_target(I) and 
                       not snoop_fetch_waiting_4_pipe;
        
        FIFO_SS_Pointer: sc_srl_fifo_counter
          generic map(
            -- General.
            C_TARGET                  => C_TARGET,
            C_USE_DEBUG               => C_USE_DEBUG,
            C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
            C_USE_STATISTICS          => C_USE_STATISTICS,
            C_STAT_BITS               => C_STAT_BITS,
            C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
            C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
            C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
            C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
            
            -- Configuration.
            C_PUSH_ON_CARRY           => false,
            C_POP_ON_CARRY            => false,
            C_ENABLE_PROTECTION       => false,
            C_USE_QUALIFIER           => false,
            C_QUALIFIER_LEVEL         => 0,
            C_USE_REGISTER_OUTPUT     => false,
            C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
            C_LINE_LENGTH             => 1
          )
          port map(
            -- ---------------------------------------------------
            -- Common signals.
            
            ACLK                      => ACLK,
            ARESET                    => ARESET_I,
        
            -- ---------------------------------------------------
            -- Queue Counter Interface
            
            queue_push                => ss_push(I),
            queue_pop                 => ss_pop(I),
            queue_push_qualifier      => '0',
            queue_pop_qualifier       => '0',
            queue_refresh_reg         => open,
            
            queue_almost_full         => open,
            queue_full                => ss_fifo_full(I),
            queue_almost_empty        => open,
            queue_empty               => ss_fifo_empty(I),
            queue_exist               => open,
            queue_line_fit            => open,
            queue_index               => ss_read_fifo_addr_vec(I),
            
            
            -- ---------------------------------------------------
            -- Statistics Signals
            
            stat_reset                => stat_reset,
            stat_enable               => stat_enable,
            
            stat_data                 => open, -- stat_acs_ss,
            
            
            -- ---------------------------------------------------
            -- Assert Signals
            
            assert_error              => ss_assert(I),
            
            
            -- ---------------------------------------------------
            -- Debug Signals
            
            DEBUG                     => open
          );
          
        -- Handle memory for SS Channel FIFO.
        FIFO_SS_Memory : process (ACLK) is
        begin  -- process FIFO_SS_Memory
          if (ACLK'event and ACLK = '1') then    -- rising clock edge
            if ( ss_push(I) = '1' ) then
              -- Insert new item.
              ss_fifo_mem_vec(I)(0).Port_Num     <= get_port_num(access_fetch_info.Port_Num, C_NUM_PORTS);
              
              -- Shift FIFO contents.
              ss_fifo_mem_vec(I)(C_QUEUE_LENGTH-1 downto 1) <= ss_fifo_mem_vec(I)(C_QUEUE_LENGTH-2 downto 0);
            end if;
          end if;
        end process FIFO_SS_Memory;
        
      end generate Is_Optimized;
      
    end generate Gen_Port_Queues;
    
    -- Extract information.
    SS_Port_Num_Assign : process(ss_read_fifo_addr_vec, ss_fifo_mem_vec) is
    begin
      ss_port_num <= (others => 0);
      for I in 0 to C_NUM_OPTIMIZED_PORTS - 1 loop
        ss_port_num(I) <= ss_fifo_mem_vec(I)( to_integer(unsigned(ss_read_fifo_addr_vec(I))) ).Port_Num;
      end loop;
    end process SS_Port_Num_Assign;
      
    
    Floating_Buffer_RS: if ( C_NUM_INTERNAL_PORTS = C_NUM_PORTS ) generate
    begin 
      -- Control signals for ACE Response Source queue.
      rs_push           <= access_valid_i and ( reduce_or(access_snooped_ports) or access_no_data ) and 
                           not rs_already_pushed;
      rs_pop            <= sm_pop;
      
      FIFO_RS_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => rs_push,
          queue_pop                 => rs_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => rs_fifo_almost_full,
          queue_full                => rs_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => rs_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => rs_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_rs,
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => rs_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for RS Channel FIFO.
      FIFO_RS_Memory : process (ACLK) is
      begin  -- process FIFO_RS_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( rs_push = '1' ) then
            -- Insert new item.
            rs_fifo_mem(0).Port_Num         <= get_port_num(access_info_i.Port_Num, C_NUM_PORTS);
            rs_fifo_mem(0).Resp_Mask        <= access_snooped_ports;
            rs_fifo_mem(0).No_Forward       <= access_no_forward;
            rs_fifo_mem(0).Exclusive_Ok     <= access_exclusive_ok;
            rs_fifo_mem(0).Exclusive_Start  <= access_exclusive_start;
            
            -- Shift FIFO contents.
            rs_fifo_mem(rs_fifo_mem'left downto 1) <= rs_fifo_mem(rs_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_RS_Memory;
      
      -- Extract information.
      rs_no_forward       <= rs_fifo_mem(to_integer(unsigned(rs_read_fifo_addr))).No_Forward;
      rs_port_num         <= rs_fifo_mem(to_integer(unsigned(rs_read_fifo_addr))).Port_Num;
      rs_resp_mask        <= rs_fifo_mem(to_integer(unsigned(rs_read_fifo_addr))).Resp_Mask;
      rs_exclusive_ok     <= rs_fifo_mem(to_integer(unsigned(rs_read_fifo_addr))).Exclusive_Ok;
      rs_exclusive_start  <= rs_fifo_mem(to_integer(unsigned(rs_read_fifo_addr))).Exclusive_Start;
      
      -- Stall when necessary.
      rs_fifo_stall   <= rs_fifo_full or rs_fifo_almost_full;
      
      -- Check if all Resps that has to be merged are available
      snoop_all_resp_available  <= ( not rs_fifo_empty ) 
                                              when ( ( snoop_resp_valid and rs_resp_mask ) = rs_resp_mask ) else 
                                   '0';
      
      -- Fake SM Queue availability.
      sm_fifo_full        <= rs_fifo_full;
      sm_fifo_empty       <= not snoop_all_resp_available;
      sm_fifo_stall       <= '0';
      sm_no_forward       <= rs_no_forward;
      sm_port_num         <= rs_port_num;
      sm_resp_mask        <= rs_resp_mask;
      sm_exclusive_ok     <= rs_exclusive_ok;
      sm_exclusive_start  <= rs_exclusive_start;
      sm_is_shared        <= '0';
      sm_pass_dirty       <= '0';
      sm_err              <= snoop_merged_error;
      sm_peer             <= '0';
      
    end generate Floating_Buffer_RS;
    
    Aligned_Buffer_RS: if ( C_NUM_INTERNAL_PORTS > C_NUM_PORTS ) generate
    
      signal rs_raw_push                : std_logic;
    
      signal sm_push                    : std_logic;
      signal sm_already_pushed          : std_logic;
      signal sm_read_fifo_addr          : QUEUE_ADDR_TYPE:= (others=>'1');
      signal sm_fifo_mem                : SM_FIFO_MEM_TYPE; -- := (others=>C_NULL_SM);
      signal sm_assert                  : std_logic;
      
    begin 
      -- Control signals for ACE Response Source queue.
      rs_raw_push       <= snoop_act_valid_i and ( reduce_or(snoop_act_use_external) or snoop_act_no_data );
      rs_push           <= rs_raw_push and rs_fifo_empty and not rs_already_pushed;
      rs_pop            <= ( not rs_fifo_empty ) and  
                           ( not sm_fifo_full  ) and
                           reduce_and(snoop_act_done);
      
      Same_Stage_Response : process (ACLK) is
      begin  -- process Same_Stage_Response
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            rs_fifo_empty       <= '1';
            rs_no_forward       <= '0';
            rs_port_num         <= 0;
            rs_resp_mask        <= (others=>'0');
            rs_exclusive_ok     <= '0';
            rs_exclusive_start  <= '0';
            
          else
            if( rs_pop = '1' ) then
              rs_fifo_empty <= '1';
              
            elsif( ( rs_push = '1' ) ) then
              rs_fifo_empty       <= '0';
              rs_no_forward       <= snoop_act_no_forward;
              rs_port_num         <= get_port_num(access_act_info.Port_Num, C_NUM_PORTS);
              rs_resp_mask        <= snoop_act_use_external;
              rs_exclusive_ok     <= snoop_act_exclusive_ok;
              rs_exclusive_start  <= snoop_act_exclusive_start;
              
            end if;
            
          end if;
        end if;
      end process Same_Stage_Response;
      
      rs_fifo_almost_full <= '0';
      rs_fifo_full        <= '0';
      rs_fifo_stall       <= ( (     rs_raw_push   ) and ( not rs_already_pushed ) ) or
                             ( ( not rs_fifo_empty ) and ( not rs_pop            ) );
      
      -- Control signals for ACE Snoop Merge queue.
      sm_push             <= rs_pop and 
                             ( snoop_act_clean_or_make or 
                               snoop_act_any_dvm       or 
                               snoop_act_is_barrier    or 
                               snoop_act_valid_dt      or 
                               rs_no_forward           ) and
                             ( not sm_already_pushed );
          
-- TODO: stall when?
      sm_fifo_stall   <= '0';
      
      Push_SM_Handler : process (ACLK) is
      begin  -- process Push_SM_Handler
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            sm_already_pushed <= '0';
            
          else
            if( snoop_act_piperun_i = '1' ) then
              sm_already_pushed <= '0';
              
            elsif( sm_push = '1' ) then
              sm_already_pushed <= '1';
              
            end if;
          end if;
        end if;
      end process Push_SM_Handler;
      
      FIFO_SM_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => sm_push,
          queue_pop                 => sm_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => sm_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => sm_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => sm_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_rs,
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => sm_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for SM Channel FIFO.
      FIFO_SM_Memory : process (ACLK) is
      begin  -- process FIFO_SM_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( sm_push = '1' ) then
            -- Insert new item.
            sm_fifo_mem(0).Port_Num         <= rs_port_num;
            sm_fifo_mem(0).Resp_Mask        <= rs_resp_mask;
            sm_fifo_mem(0).No_Forward       <= rs_no_forward;
            sm_fifo_mem(0).Exclusive_Ok     <= rs_exclusive_ok;
            sm_fifo_mem(0).Exclusive_Start  <= rs_exclusive_start;
            sm_fifo_mem(0).Peer             <= snoop_act_peer_copy;
            sm_fifo_mem(0).Is_Shared        <= snoop_act_is_shared;
            sm_fifo_mem(0).Pass_Dirty       <= snoop_act_peer_dirty;
            sm_fifo_mem(0).Err              <= snoop_merged_error;
            
            -- Shift FIFO contents.
            sm_fifo_mem(sm_fifo_mem'left downto 1) <= sm_fifo_mem(sm_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_SM_Memory;
      
      -- Extract information.
      sm_err                    <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Err;
      sm_is_shared              <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Is_Shared;
      sm_pass_dirty             <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Pass_Dirty;
      sm_peer                   <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Peer;
      sm_port_num               <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Port_Num;
      sm_resp_mask              <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Resp_Mask;
      sm_no_forward             <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).No_Forward;
      sm_exclusive_ok           <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Exclusive_Ok;
      sm_exclusive_start        <= sm_fifo_mem(to_integer(unsigned(sm_read_fifo_addr))).Exclusive_Start;
      
      -- All Resps are implicitly available since the check was before the queue.
      snoop_all_resp_available  <= ( not sm_fifo_empty );
      
    end generate Aligned_Buffer_RS;
    
    Push_RS_Handler : process (ACLK) is
    begin  -- process Push_RS_Handler
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          rs_already_pushed <= '0';
          
        else
          if( snoop_act_piperun_i = '1' ) then
            rs_already_pushed <= '0';
            
          elsif( rs_push = '1' ) then
            rs_already_pushed <= '1';
            
          end if;
        end if;
      end if;
    end process Push_RS_Handler;
    
    -- Jointly determine when SM is popped.
    sm_peer_pop         <= src_peer_ready and src_peer_valid and all_cd_last;
    sm_only_pop         <= snoop_only_ready;
    sm_pop              <= sm_peer_pop or sm_only_pop;
    
    
    -----------------------------------------------------------------------------
    -- Handle Response Merging
    -- 
    -----------------------------------------------------------------------------
    
    -- Merge all responses.
    Merge_Resp: process (rs_resp_mask, snoop_resp_crresp) is
    begin  -- process Merge_Resp
      snoop_merged_error <= '0';
      
      for I in C_PORT_POS loop
        if( rs_resp_mask(I) = '1' and snoop_resp_crresp(I)(C_CRRESP_ERROR_POS) = '1' ) then
          snoop_merged_error <= '1';
        end if;
      end loop;
    end process Merge_Resp;
    
    -- Determine if snoop register is ready to receive:
    --  * No snoop response is required, or
    --  * Currently no data in register, or
    --  * Register value is used this cycle.
    snoop_ready                   <= (     sm_no_forward and
                                       not sm_fifo_empty                                   ) or
                                     ( not snoop_read_data_any_valid                       ) or
                                     (     snoop_read_data_ready(snoop_read_data_port_num) );
    snoop_only_ready              <= ( not sm_fifo_empty ) and 
                                     (     snoop_ready   ) and 
                                     ( not sm_peer       );
    
    -- Peer alignment of data and information streams.
    src_peer_ready                <= (     snoop_all_resp_available ) and 
                                     ( not sds_fifo_empty           ) and 
                                     ( not snoop_dump_waiting       ) and
                                     (     snoop_ready              ) and 
                                     (       scd_ready              ) and 
                                     (      sm_peer                 ) and 
                                     (     sds_peer                 );
    src_peer_valid                <= (     snoop_all_resp_available            ) and 
                                     ( not sds_fifo_empty                      ) and 
                                     ( not snoop_dump_waiting                  ) and
                                     (     snoop_data_info(sds_port_num).Valid ) and 
                                     ( not snoop_dump_complete(sds_port_num)   ) and 
                                     (      sm_peer                            ) and 
                                     (     sds_peer                            );
    
    -- Snoop queue handling.
    snoop_peer_push               <= ( src_peer_ready and src_peer_valid );
    snoop_only_push               <= ( sm_only_pop and not sm_fifo_empty and not sm_no_forward );
    snoop_push                    <= snoop_peer_push or snoop_only_push;
    
    
    -- Acknowledge all relevant sources.
    access_resp_valid_vec     <= (others => sm_pop);
    snoop_resp_ready          <= access_resp_valid_vec and
                                 sm_resp_mask;
    
    
    Snoop_Response_Handle : process (ACLK) is
    begin  -- process Snoop_Response_Handle
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_read_data_port_num  <= 0;
          snoop_read_data_any_valid <= '0';
          snoop_read_data_valid     <= (others=>'0');
          snoop_read_data_last      <= '1';
          snoop_read_data_resp      <= C_RRESP_OKAY;
          snoop_read_data_word      <= (others=>'0');
          snoop_read_data_block     <= '0';
          
        else
          -- Remove message from register when acknowledged.
          if( snoop_read_data_ready(snoop_read_data_port_num) = '1' ) then
            snoop_read_data_any_valid <= '0';
            snoop_read_data_valid     <= (others=>'0');
          end if;
          
          -- Push new message to register (for queue) when there is room.
          if( snoop_push = '1' ) then
            snoop_read_data_port_num  <= sm_port_num;
            
            -- Block remaining of cacheline for ReadOnce.
            if( snoop_data_info(sds_port_num).Last = '1' ) then
              snoop_read_data_block     <= '0';
            elsif( sds_read_once = '1' ) then
              -- Only activate when more
              snoop_read_data_block     <= not snoop_data_info(sds_port_num).Last;
            end if;
            
            -- Handle valid generation for entire burst or first word for ReadOnce.
            if( ( sds_read_once = '0' ) or
                ( snoop_read_data_block  = '0' ) ) then
              snoop_read_data_any_valid <= '1';
              snoop_read_data_valid     <= std_logic_vector(to_unsigned(2 ** sm_port_num, C_NUM_PORTS));
            end if;
            
            if( sm_err = '1' ) then
              -- Snoop has returned error.
              snoop_read_data_resp                        <= C_RRESP_SLVERR;
              snoop_read_data_last                        <= '1';
              snoop_read_data_word                        <= (others=>'0');
              
            elsif( sm_exclusive_ok = '1' ) then
              -- Exclusive transaction is successful.
              snoop_read_data_resp                        <= C_RRESP_EXOKAY;
              snoop_read_data_last                        <= '1';
              snoop_read_data_word                        <= (others=>'0');
              
            else
              -- Propagate peer cache data.
              if( sm_exclusive_start = '1' ) then
                -- Exclusive transaction is successful.
                snoop_read_data_resp                        <= C_RRESP_EXOKAY;
              else
                snoop_read_data_resp                        <= C_RRESP_OKAY;
              end if;
              snoop_read_data_resp(C_RRESP_ISSHARED_POS)  <= sm_is_shared;
              snoop_read_data_resp(C_RRESP_PASSDIRTY_POS) <= sm_pass_dirty;
              if( sm_peer = '1' ) then
                snoop_read_data_last                        <= snoop_data_info(sds_port_num).Last or
                                                               sds_read_once;
                snoop_read_data_word                        <= fit_vec(snoop_data_info_word, C_CACHE_DATA_WIDTH);
              else
                snoop_read_data_last                        <= '1';
                snoop_read_data_word                        <= (others=>'0');
              end if;
            end if;
          
          end if;
        end if;
      end if;
    end process Snoop_Response_Handle;
    
    Mirror_Snoop_Data: for N in 0 to C_CACHE_DATA_WIDTH / C_Lx_CACHE_DATA_WIDTH - 1 generate
    begin
      snoop_data_info_word((N+1) * C_Lx_CACHE_DATA_WIDTH - 1 downto N * C_Lx_CACHE_DATA_WIDTH)  <= 
                                              snoop_data_info(sds_port_num).Data(C_Lx_CACHE_DATA_WIDTH - 1 downto 0);
    end generate Mirror_Snoop_Data;
    
    
    -----------------------------------------------------------------------------
    -- Exclusive Monitor
    -- 
    -----------------------------------------------------------------------------
    
    Exclusive_Monitor_Handle : process (ACLK) is
    begin  -- process Exclusive_Monitor_Handle
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_ex_monitor_allow_new  <= '1';
          snoop_ex_monitor_port       <= 0;
          snoop_ex_trans_concluded    <= '0';
          
        else
          if( ( snoop_req_valid_i = '1' ) and ( snoop_req_exclusive_ok = '1' ) ) then
            -- Always remember last port having the successful Exclusive transaction.
            snoop_ex_monitor_allow_new  <= '0';
            snoop_ex_monitor_port       <= get_port_num(access_req_info.Port_Num, C_NUM_PORTS);
            snoop_ex_trans_concluded    <= '0';
            
          elsif( read_trans_comp_info(snoop_ex_monitor_port).Ex_Rack = '1' ) then
                 
            if( lx_cfg_support_dirty(snoop_ex_monitor_port) = '1' ) then
            -- A port that support Dirty will activate New Exclusive once the RACK
            -- has been detected.
              snoop_ex_monitor_allow_new  <= '1';
              
            end if;
            if( snoop_ex_trans_concluded = '1' ) then
              -- Concluding write happened while waiting for RACK, activate Ex Sequences at once.
              snoop_ex_monitor_allow_new  <= '1';
              
            end if; 
            if( ( snoop_req_valid_i = '1' ) and 
                ( snoop_req_allow_exclusive = '1' ) ) then
              -- RACK and concluding Write at the same time, allow new Ex Sequences.
              snoop_ex_monitor_allow_new  <= '1';
              
            end if;
            
          elsif( ( snoop_req_valid_i = '1' ) and 
                 ( ( snoop_req_allow_exclusive = '1' ) or ( snoop_ex_timer = 0 ) ) ) then
            -- For WT the window for New Exclusive Sequence is increased from until RACK
            -- to until write that conclude the sequence (or time-out).
            if( snoop_ex_enable_timer = '1' ) then
              -- RACK has already been received so it is possible to activate Ex Sequences 
              -- at once.
              snoop_ex_monitor_allow_new  <= '1';
            else
              -- Must wait for RACK before enabling Ex Sequences again.
              snoop_ex_trans_concluded    <= '1';
            end if;
            
          end if;
          
        end if;
      end if;
    end process Exclusive_Monitor_Handle;
    
    Exclusive_Monitor_Handle_Timer : process (ACLK) is
    begin  -- process Exclusive_Monitor_Handle_Timer
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_ex_enable_timer <= '0';
          
        else
          if( ( snoop_req_valid_i = '1' ) and 
              ( ( snoop_req_allow_exclusive = '1' ) or ( snoop_ex_timer = 0 ) ) ) then
            -- Disable timer when Ex monitor is timed-out or grace period is terminated 
            -- by a Write for a WT port.
            snoop_ex_enable_timer <= '0';
            
          elsif( ( read_trans_comp_info(snoop_ex_monitor_port).Ex_Rack = '1' ) and
                 ( snoop_ex_trans_concluded                            = '0' ) ) then
            -- RACK for transaction has been received, enable timer for Ex release delay.
            -- If the port supports Dirty is is no point of having the time-out since
            -- the data can (and should be stored) in the Lx Cache line.
            snoop_ex_enable_timer <= not lx_cfg_support_dirty(snoop_ex_monitor_port);
            
          end if;
          
        end if;
      end if;
    end process Exclusive_Monitor_Handle_Timer;
    
    Exclusive_Monitor_Timer : process (ACLK) is
    begin  -- process Exclusive_Monitor_Timer
      if (ACLK'event and ACLK = '1') then   -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active high)
          snoop_ex_timer  <= 0;
          
        elsif( snoop_req_piperun_i = '1' ) then
          if( ( snoop_req_valid_i = '1' ) and ( snoop_req_exclusive_ok = '1' ) ) then
            -- Make sure Arbiter token has passed at least once to guarantee that a write with 
            -- the Exclusive data is detected before another Monitoring can start.
            snoop_ex_timer  <= C_NUM_PORTS;
            
          elsif( ( snoop_ex_timer /= 0 ) and ( snoop_ex_enable_timer = '1' ) and 
                 ( ( wr_port_inbound(snoop_ex_monitor_port)      = '0' ) and 
                   ( lx_cfg_support_dirty(snoop_ex_monitor_port) = '0' ) ) ) then
            -- Count if current port is doesn't support Dirty, not done counting and
            -- the current port is not issuing a write.
            snoop_ex_timer  <= snoop_ex_timer - 1;
            
          end if;
        end if;
      end if;
    end process Exclusive_Monitor_Timer;
    
    Ex_Monitor: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      
      Exclusive_Monitor_Bit : process (ACLK) is
      begin  -- process Exclusive_Monitor_Bit
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            snoop_ex_monitor_started(I) <= '0';
            
          elsif( snoop_req_valid_i = '1' ) then
            if( snoop_req_stop_monitor(I) = '1' ) then
              snoop_ex_monitor_started(I) <= '0';
              
            elsif( snoop_req_start_monitor(I) = '1' ) then
              snoop_ex_monitor_started(I) <= '1';
              
            end if;
            
          end if;
        end if;
      end process Exclusive_Monitor_Bit;
      
    end generate Ex_Monitor;
    
    
    -----------------------------------------------------------------------------
    -- Handle Internal Write Data Port
    -----------------------------------------------------------------------------
    
    Internal_Write_Port: if ( C_NUM_INTERNAL_PORTS > C_NUM_PORTS ) generate
      
      subtype DATA_TYPE                   is std_logic_vector(C_CACHE_DATA_WIDTH - 1 downto 0);
      
      type INT_W_TYPE is record
        Last              : std_logic;
        Data              : DATA_TYPE;
      end record INT_W_TYPE;
      
      type INT_W_FIFO_MEM_TYPE            is array(QUEUE_ADDR_POS) of INT_W_TYPE;
      
      constant C_NULL_INT_W               : INT_W_TYPE := (Last=>'0', Data=>(others=>'0'));
      
      -- Snoop Data Source handling.
      signal sds_push                     : std_logic;
      signal sds_peer_pop                 : std_logic;
      signal sds_only_pop                 : std_logic;
      signal sds_pop                      : std_logic;
      signal sds_already_pushed           : std_logic;
      signal sds_read_fifo_addr           : QUEUE_ADDR_TYPE:= (others=>'1');
      signal sds_fifo_mem                 : SDS_FIFO_MEM_TYPE; -- := (others=>C_NULL_SDS);
      signal sds_assert                   : std_logic;
      signal sds_dirty                    : std_logic;
      signal sds_dump_mask                : PORT_TYPE;
      
      -- Selected CD channel handling.
      signal scd_peer_push                : std_logic;
      signal scd_only_push                : std_logic;
      signal scd_push                     : std_logic;
      signal scd_pop                      : std_logic;
      signal scd_fifo_empty               : std_logic;
      signal scd_fifo_full                : std_logic;
      signal scd_read_fifo_addr           : QUEUE_ADDR_TYPE:= (others=>'1');
      signal scd_fifo_mem                 : INT_W_FIFO_MEM_TYPE; -- := (others=>C_NULL_INT_W);
      signal scd_assert                   : std_logic;
      
      signal snoop_data_dump_ready        : PORT_TYPE;
      signal snoop_data_selected_ready    : PORT_TYPE;
      signal snoop_data_ready_i           : PORT_TYPE;
      
      signal snoop_act_select_idx         : C_PORT_POS;
      signal snoop_act_found_dump         : std_logic;
      signal snoop_act_dump_mask          : PORT_TYPE;
      
      signal finalized                    : PORT_TYPE;
      signal dump_last                    : PORT_TYPE;
      signal selected_last                : PORT_TYPE;
      signal primitive_ready              : PORT_TYPE;
      
    begin
      
      -- Check if there is any Master that intends to deliver data and Write responsibility.
      Scan_Snoop_Status: process (snoop_resp_info) is
      
        variable found_one  : std_logic;
        variable found_more : std_logic;
        variable found_idx  : C_PORT_POS;
        
      
      begin  -- process Scan_Snoop_Status
        -- Default assignments.
        snoop_act_found_dirty <= '0';
        snoop_act_select_idx  <= 0;
        snoop_act_found_dump  <= '0';
        snoop_act_dump_mask   <= (others=>'0');
        snoop_act_valid_dt    <= '0';
        snoop_act_is_shared   <= '0';
        found_one             := '0';
        found_more            := '0';
        found_idx             := 0;
        
        -- Detect how many Master is providing the line.
        for I in C_PORT_POS loop
          if( ( snoop_resp_info(I).Valid = '1' )                             and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_DATATRANSFER_POS) = '1' ) ) then
            if( found_one = '1' ) then
              found_more            := '1';
            end if;
            found_one             := '1';
            found_idx             := I;
          
          end if;
          
          -- Detect if any master is providing shared.
          if( ( snoop_resp_info(I).Valid = '1' )                             and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_DATATRANSFER_POS) = '1' ) and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_ISSHARED_POS)     = '1' ) ) then
            snoop_act_is_shared   <= '1';
          
          end if;
        end loop;
          
        -- Detect if any master is providing dirty data.
        for I in C_PORT_POS loop
          if( ( snoop_resp_info(I).Valid = '1' )                             and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_DATATRANSFER_POS) = '1' ) and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_PASSDIRTY_POS)    = '1' ) ) then
            snoop_act_found_dirty <= '1';
            found_idx             := I;
          
          end if;
        end loop;
          
        for I in C_PORT_POS loop
          -- Detect if there is any data that can be dumped since there is no write ownership 
          -- transfer that take place.
          if( ( snoop_resp_info(I).Valid                             = '1' ) and 
              ( snoop_resp_info(I).CRRESP(C_CRRESP_DATATRANSFER_POS) = '1' ) ) then
--              ( found_more                                           = '1' ) and
--              ( found_idx                                           /= I   )
            snoop_act_dump_mask(I)  <= '1';
          
          end if;
        
        end loop;
        
        -- Assign signals.
        snoop_act_valid_dt    <= found_one;
        snoop_act_found_dump  <= found_more;
        snoop_act_select_idx  <= found_idx;
        
      end process Scan_Snoop_Status;
      
      -- Determine how potential data need to be propagated.
      -- Only Read can allow Dirty, i.e. Dirty data from other transactions such as CleanInvalid are
      -- automatically forwarded downstream.
      snoop_act_downstream_dirty    <= snoop_act_valid_dt and 
                                       ( (     snoop_act_found_dirty  and 
                                           not snoop_act_allow_dirty  ) or
                                         (     snoop_act_ac_read_drop ) );
      snoop_act_peer_copy           <= snoop_act_valid_dt           and 
                                       ( not snoop_act_no_data      ) and
                                       ( not access_act_info.Wr     ) and
                                       ( not snoop_act_ac_read_drop );
      snoop_act_peer_dirty          <= snoop_act_peer_copy and 
                                       snoop_act_found_dirty;
      
      -- Control signals for Snoop Data Source queue.
      -- Push: If any master intends to transfer any data.
      -- Pop : When all data requested data has been dumped and any data that needs
      --       to be transported downstream has been taken care of.
      sds_push                      <= ( snoop_act_valid_dt and not sds_fifo_full ) and
                                       ( not sds_already_pushed );
      sds_stall                     <= ( snoop_act_valid_dt and     sds_fifo_full ) and 
                                       ( not sds_already_pushed );
      sds_peer_pop                  <= sm_peer_pop;
      sds_only_pop                  <= all_cd_last and not sds_peer;
      sds_pop                       <= sds_peer_pop or sds_only_pop;
      
      Snoop_Source_Handler : process (ACLK) is
      begin  -- process Snoop_Source_Handler
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            sds_already_pushed  <= '0';
            
          else
            if( ( snoop_act_piperun_i = '1' ) ) then
              sds_already_pushed  <= '0';
              
            elsif( sds_push = '1' ) then
              sds_already_pushed  <= '1';
              
            end if;
          end if;
        end if;
      end process Snoop_Source_Handler;
      
      FIFO_SDS_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => sds_push,
          queue_pop                 => sds_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => sds_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => sds_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => sds_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_sds,
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => sds_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for SDS FIFO.
      FIFO_SDS_Memory : process (ACLK) is
      begin  -- process FIFO_SDS_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( sds_push = '1' ) then
            -- Insert new item.
            sds_fifo_mem(0).Dirty     <= snoop_act_downstream_dirty;
            sds_fifo_mem(0).Dump_Mask <= snoop_act_dump_mask;
            sds_fifo_mem(0).Peer      <= snoop_act_peer_copy;
            sds_fifo_mem(0).ReadOnce  <= snoop_act_ac_read_once;
            
            -- Shift FIFO contents.
            sds_fifo_mem(sds_fifo_mem'left downto 1) <= sds_fifo_mem(sds_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_SDS_Memory;
      
      -- Extract information.
      sds_dirty     <= sds_fifo_mem(to_integer(unsigned(sds_read_fifo_addr))).Dirty;
      sds_dump_mask <= sds_fifo_mem(to_integer(unsigned(sds_read_fifo_addr))).Dump_Mask;
      sds_peer      <= sds_fifo_mem(to_integer(unsigned(sds_read_fifo_addr))).Peer;
      sds_read_once <= sds_fifo_mem(to_integer(unsigned(sds_read_fifo_addr))).ReadOnce;
        
      Dump_Snoop_Data_Handler : process (ACLK) is
      begin  -- process Dump_Snoop_Data_Handler
        if (ACLK'event and ACLK = '1') then   -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active high)
            snoop_dump_complete <= (others=>'0');
            snoop_dump_waiting  <= '1';
            sds_port_num        <= 0;
            
          else
            -- Detect which DT stream to use.
            if( ( sds_pop = '1' ) ) then
              -- Prepare for next.
              snoop_dump_waiting  <= '1';
              
            elsif( ( snoop_dump_waiting = '1' ) ) then
              -- Prepare for selecting first available data stream.
              for I in C_PORT_POS loop
                if( ( snoop_data_info(I).Valid = '1' ) and
                    ( sds_dump_mask(I)         = '1' ) ) then
                  snoop_dump_waiting  <= '0';
                  sds_port_num        <= I;
                end if;
              end loop;
              
            end if;
            
            -- Track data stream validity.
            for I in C_PORT_POS loop
              if( ( sds_pop = '1' ) ) then
                -- Restore complete tracking when a transaction is is fully completed 
                -- and a new one can be started.
                snoop_dump_complete(I)  <= '0';
                
              elsif( ( snoop_data_info(I).Valid = '1' ) and
                     ( snoop_data_info(I).Last  = '1' ) and
                     ( snoop_data_ready_i(I)    = '1' ) ) then
                -- Mark as complete when the entire burst has been processed,
                -- this also prevent further read until all affected channels has been processed.
                snoop_dump_complete(I)  <= '1';
                
              end if;
            end loop;
          end if;
        end if;
      end process Dump_Snoop_Data_Handler;
      
      Gen_Response_Array: for I in C_PORT_POS generate
      begin
        -- Track Last.    
        finalized(I)                  <= ( (     snoop_dump_complete(I) and 
                                             not sds_fifo_empty                      ) or 
                                           (     snoop_data_info(sds_port_num).Valid and 
                                                 snoop_data_info(sds_port_num).Last  and 
                                             not sds_fifo_empty                      ) ) and
                                         ( not snoop_dump_waiting                      );
        dump_last(I)                  <= finalized(I) and sds_dump_mask(I);
        selected_last(I)              <= finalized(I) and ( sds_dirty or sds_peer )
                                                    when ( I = sds_port_num ) else 
                                         '0';
      
        -- Per port CD Handling.   
        snoop_data_dump_ready(I)      <= ( not sds_fifo_empty         and 
                                           not snoop_dump_complete(I) and 
                                               sds_dump_mask(I)       and 
                                           not snoop_dump_waiting     )
                                                    when ( I /= sds_port_num ) else 
                                         '0';
        primitive_ready(I)            <= ( not sds_fifo_empty         and 
                                           not snoop_dump_complete(I) and
                                           not snoop_dump_waiting     )
                                                    when ( I  = sds_port_num ) else 
                                         '0';
        snoop_data_selected_ready(I)  <= ( primitive_ready(I)                               ) and 
                                         ( src_peer_ready or ( scd_ready and not sds_peer ) ) and 
                                         ( not sds_fifo_empty                               );
        
        snoop_data_ready(I)           <= snoop_data_ready_i(I);
        snoop_data_ready_i(I)         <= snoop_data_selected_ready(I) or 
                                         snoop_data_dump_ready(I);
        
      end generate Gen_Response_Array;
      
      all_cd_last                   <= selected_last(sds_port_num)
                                                  when ( sds_dump_mask = dump_last ) else '0';
          
      -- Control signals for ACE Selected CD queue.
      scd_ready                     <= not scd_fifo_full;
      scd_peer_push                 <= snoop_peer_push and sds_dirty;
      scd_only_push                 <= (     primitive_ready(sds_port_num)       ) and 
                                       (     snoop_data_info(sds_port_num).Valid ) and 
                                       ( not snoop_dump_complete(sds_port_num)   ) and 
                                       ( not sds_fifo_empty                      ) and 
                                       ( not sds_peer                            );
      scd_push                      <= scd_peer_push or scd_only_push;
      scd_pop                       <= ( lookup_write_data_ready(C_NUM_PORTS) or 
                                         update_write_data_ready(C_NUM_PORTS) ) and 
                                       not scd_fifo_empty;
      
      FIFO_SCD_Pointer: sc_srl_fifo_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          C_USE_DEBUG               => C_USE_DEBUG,
          C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
          C_USE_STATISTICS          => C_USE_STATISTICS,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
          
          -- Configuration.
          C_PUSH_ON_CARRY           => false,
          C_POP_ON_CARRY            => false,
          C_ENABLE_PROTECTION       => false,
          C_USE_QUALIFIER           => false,
          C_QUALIFIER_LEVEL         => 0,
          C_USE_REGISTER_OUTPUT     => false,
          C_QUEUE_ADDR_WIDTH        => C_QUEUE_LENGTH_BITS,
          C_LINE_LENGTH             => 1
        )
        port map(
          -- ---------------------------------------------------
          -- Common signals.
          
          ACLK                      => ACLK,
          ARESET                    => ARESET_I,
      
          -- ---------------------------------------------------
          -- Queue Counter Interface
          
          queue_push                => scd_push,
          queue_pop                 => scd_pop,
          queue_push_qualifier      => '0',
          queue_pop_qualifier       => '0',
          queue_refresh_reg         => open,
          
          queue_almost_full         => open,
          queue_full                => scd_fifo_full,
          queue_almost_empty        => open,
          queue_empty               => scd_fifo_empty,
          queue_exist               => open,
          queue_line_fit            => open,
          queue_index               => scd_read_fifo_addr,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_reset                => stat_reset,
          stat_enable               => stat_enable,
          
          stat_data                 => open, -- stat_acs_scd(I),
          
          
          -- ---------------------------------------------------
          -- Assert Signals
          
          assert_error              => scd_assert,
          
          
          -- ---------------------------------------------------
          -- Debug Signals
          
          DEBUG                     => open
        );
        
      -- Handle memory for Selected CD Channel FIFO.
      FIFO_SCD_Memory : process (ACLK) is
      begin  -- process FIFO_SCD_Memory
        if (ACLK'event and ACLK = '1') then    -- rising clock edge
          if ( scd_push = '1' ) then
            -- Insert new item.
            scd_fifo_mem(0).Last   <= snoop_data_info(sds_port_num).Last;
            scd_fifo_mem(0).Data   <= fit_vec(snoop_data_info_word, C_Lx_CACHE_DATA_WIDTH);
            
            -- Shift FIFO contents.
            scd_fifo_mem(scd_fifo_mem'left downto 1) <= scd_fifo_mem(scd_fifo_mem'left-1 downto 0);
          end if;
        end if;
      end process FIFO_SCD_Memory;
      
      -- Extract data. Since this is snoop data, all bytes are valid.
      access_data_info(C_NUM_PORTS).Valid <= not scd_fifo_empty;
      access_data_info(C_NUM_PORTS).Last  <= scd_fifo_mem(to_integer(unsigned(scd_read_fifo_addr))).Last;
      access_data_info(C_NUM_PORTS).BE    <= (others=>'1');
      access_data_info(C_NUM_PORTS).Data  <= fit_vec(scd_fifo_mem(to_integer(unsigned(scd_read_fifo_addr))).Data, 
                                                     C_MAX_DATA_WIDTH);
      
    end generate Internal_Write_Port;
    
    No_Write_Port: if ( C_NUM_INTERNAL_PORTS = C_NUM_PORTS ) generate
    begin
      scd_data_push               <= '0';
      scd_ready                   <= '0';
      
      sds_stall                   <= '0';
      sds_fifo_empty              <= '1';
      sds_fifo_full               <= '0';
      sds_peer                    <= '0';
      sds_read_once               <= '0';
      sds_port_num                <= 0;
      
      snoop_act_found_dirty       <= '0';
      snoop_act_downstream_dirty  <= '0';
      snoop_act_peer_copy         <= '0';
      snoop_act_peer_dirty        <= '0';
      snoop_act_valid_dt          <= '0';
      snoop_act_is_shared         <= '0';
      snoop_resp_merge_ready      <= '0';
      
      all_cd_last                 <= '1';
      
      snoop_dump_complete         <= (others=>'0');
      snoop_dump_waiting          <= '0';
      
      snoop_data_ready            <= (others=>'0');
      
    end generate No_Write_Port;
    
    
    -----------------------------------------------------------------------------
    --  
    -----------------------------------------------------------------------------
    
    -- Assign output.
    snoop_fetch_piperun <= snoop_fetch_piperun_i;
    snoop_req_piperun   <= snoop_req_piperun_i;
    snoop_act_piperun   <= snoop_act_piperun_i;
    
    Gen_Output_Array: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      snoop_fetch_info(I).Valid         <= snoop_fetch_valid_i;
      snoop_fetch_info(I).Wr            <= access_fetch_info.Wr;
      snoop_fetch_info(I).Myself        <= snoop_fetch_myself_i(I);
      snoop_fetch_info(I).Sync          <= snoop_fetch_dvm_sync(I);
      snoop_fetch_info(I).Addr          <= snoop_fetch_addr_i;
      
      -- Assign external.
      snoop_req_info(I).Valid           <= snoop_req_valid_i;
      snoop_req_info(I).Wr              <= access_req_info.Wr;
      snoop_req_info(I).Myself          <= snoop_req_myself_i(I);
      snoop_req_info(I).Always          <= snoop_req_always_i(I);
      snoop_req_info(I).Update_Filter   <= snoop_req_update_filter_i(I);
      snoop_req_info(I).Want            <= snoop_req_want_i(I);
      snoop_req_info(I).Complete        <= snoop_req_complete(I);
      snoop_req_info(I).Barrier         <= snoop_req_is_barrier;
      snoop_req_info(I).Init_Cmd        <= access_req_info.Internal_Cmd and access_req_info.Force_Hit;
      snoop_req_info(I).Addr            <= snoop_req_addr_i;
      snoop_req_info(I).Snoop           <= snoop_req_snoop_i(I);
      snoop_req_info(I).Complete_Target <= fit_vec(snoop_req_complete_target, C_MAX_NUM_PORTS);
      
      -- Assign external.
      snoop_act_info(I).Valid           <= snoop_act_valid_i;
      snoop_act_info(I).Myself          <= snoop_act_myself(I);
      snoop_act_info(I).Waiting_4_Pipe  <= snoop_act_waiting_4_pipe_i;
      snoop_act_info(I).Wr              <= access_act_info.Wr;
      snoop_act_info(I).Always          <= snoop_act_always(I);
      snoop_act_info(I).AnyDVM          <= snoop_act_any_dvm;
      snoop_act_info(I).Addr            <= snoop_act_addr_i 
                                                    when ( snoop_act_any_dvm = '1' ) else
                                           snoop_act_addr_i and
                                           not std_logic_vector(to_unsigned(2 ** C_CACHE_DATA_ADDR_WIDTH - 1,
                                                                            C_MAX_ADDR_WIDTH));
      snoop_act_info(I).Prot            <= snoop_act_prot;
      snoop_act_info(I).Snoop           <= snoop_act_snoop(I);
      
      -- No need to modify
      snoop_tag_status_info(I).Valid    <= snoop_act_tag_info(I).Valid;
      snoop_tag_status_info(I).Unique   <= snoop_act_tag_info(I).Unique;
      snoop_tag_status_info(I).Dirty    <= snoop_act_tag_info(I).Dirty;
      snoop_tag_status_info(I).Secure   <= snoop_act_tag_info(I).Secure;
      
    end generate Gen_Output_Array;
    
    
    -----------------------------------------------------------------------------
    -- ACE Downstream Barrier Request.
    -----------------------------------------------------------------------------
    
    ctrl_access_done  <= ( not snoop_fetch_valid_i ) and  
                         ( not snoop_req_valid_i   ) and
                         ( not snoop_act_valid_i   );
    
    
    -----------------------------------------------------------------------------
    -- Statistics
    -----------------------------------------------------------------------------
    
    No_Stat: if( not C_USE_STATISTICS ) generate
    begin
      stat_access_fetch_stall <= C_NULL_STAT_POINT;
      stat_access_req_stall   <= C_NULL_STAT_POINT;
      stat_access_act_stall   <= C_NULL_STAT_POINT;
      
    end generate No_Stat;
    
    Use_Stat: if( C_USE_STATISTICS ) generate
      
      signal det_acs_fetch_stall    : std_logic;
      signal det_acs_req_stall      : std_logic;
      signal det_acs_act_stall      : std_logic;
      
    begin
      Stat_Handle : process (ACLK) is
      begin  -- process Stat_Handle
        if ACLK'event and ACLK = '1' then           -- rising clock edge
          if stat_reset = '1' then                  -- synchronous reset (active high)
            det_acs_fetch_stall <= '0';
            det_acs_req_stall   <= '0';
            det_acs_act_stall   <= '0';
            
          else
            det_acs_fetch_stall <= snoop_fetch_valid_i and snoop_fetch_stall;
            det_acs_req_stall   <= snoop_req_valid_i   and snoop_req_stall;
            det_acs_act_stall   <= snoop_act_valid_i   and snoop_act_stall;
            
          end if;
        end if;
      end process Stat_Handle;
      
      Stall_Fetch_Inst: sc_stat_event
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Probe Interface
          
          probe                     => det_acs_fetch_stall,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_access_fetch_stall
        );
        
      Stall_Req_Inst: sc_stat_event
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Probe Interface
          
          probe                     => det_acs_req_stall,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_access_req_stall
        );
        
      Stall_Act_Inst: sc_stat_event
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Probe Interface
          
          probe                     => det_acs_act_stall,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_access_act_stall
        );
        
    end generate Use_Stat;
    
    
    -----------------------------------------------------------------------------
    -- Debug 
    -----------------------------------------------------------------------------
    
    No_Debug: if( not C_USE_DEBUG ) generate
    begin
      ACCESS_DEBUG(205                  downto   0) <= (others=>'0');
      ACCESS_DEBUG(ACCESS_DEBUG'left    downto 212) <= (others=>'0');
    end generate No_Debug;
    
    Use_Debug: if( C_USE_DEBUG ) generate
      constant C_MY_PORT    : natural := min_of( 4, C_NUM_PORTS);
      constant C_MY_QCNT    : natural := min_of( 4, C_QUEUE_LENGTH_BITS);
      constant C_MY_NUM     : natural := min_of( 2, Log2(C_NUM_PORTS));
      constant C_MY_TIMER   : natural := min_of( 4, Log2(C_NUM_PORTS));
    begin
      Debug_Handle : process (ACLK) is 
      begin  
        if ACLK'event and ACLK = '1' then     -- rising clock edge
          if (ARESET_I = '1') then              -- synchronous reset (active true)
            ACCESS_DEBUG(205                  downto   0) <= (others=>'0');
            ACCESS_DEBUG(ACCESS_DEBUG'left    downto 212) <= (others=>'0');
            
          else
            -- Default assignment.
            ACCESS_DEBUG(205                  downto   0) <= (others=>'0');
            ACCESS_DEBUG(ACCESS_DEBUG'left    downto 212) <= (others=>'0');
            
            ACCESS_DEBUG(  0 + C_MY_PORT  - 1 downto   0) <= snoop_fetch_myself_i(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(  4 + C_MY_PORT  - 1 downto   4) <= snoop_fetch_always(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(  8 + C_MY_PORT  - 1 downto   8) <= snoop_fetch_update_filter(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 12 + C_MY_PORT  - 1 downto  12) <= snoop_fetch_comp_target(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 16 + C_MY_PORT  - 1 downto  16) <= snoop_fetch_dvm_sync(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 20 + C_MY_PORT  - 1 downto  20) <= snoop_fetch_want(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 24 + C_MY_PORT  - 1 downto  24) <= snoop_fetch_start_monitor(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 28 + C_MY_PORT  - 1 downto  28) <= snoop_fetch_stop_monitor(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 32 + C_MY_PORT  - 1 downto  32) <= snoop_req_myself_i(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 36 + C_MY_PORT  - 1 downto  36) <= snoop_req_always_i(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 40 + C_MY_PORT  - 1 downto  40) <= snoop_req_update_filter_i(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 44 + C_MY_PORT  - 1 downto  44) <= snoop_req_want_i(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 48 + C_MY_PORT  - 1 downto  48) <= snoop_req_start_monitor(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 52 + C_MY_PORT  - 1 downto  52) <= snoop_req_stop_monitor(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 56 + C_MY_PORT  - 1 downto  56) <= access_snooped_ports(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 60 + C_MY_PORT  - 1 downto  60) <= ss_push(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 64 + C_MY_PORT  - 1 downto  64) <= ss_pop(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 68 + C_MY_PORT  - 1 downto  68) <= ss_fifo_empty(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 72 + C_MY_PORT  - 1 downto  72) <= snoop_fetch_dvm_complete(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 76 + C_MY_PORT  - 1 downto  76) <= snoop_fetch_comp_hold(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 80 + C_MY_PORT  - 1 downto  80) <= snoop_ex_monitor_started(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG( 84 + C_MY_PORT  - 1 downto  84) <= rs_resp_mask(C_MY_PORT - 1 downto 0);
            for I in 0 to C_MY_PORT - 1 loop
              ACCESS_DEBUG(                         I + 88) <= snoop_act_tag_info(I).Valid;
              ACCESS_DEBUG(                         I + 92) <= snoop_act_tag_info(I).Unique;
              ACCESS_DEBUG(                         I + 96) <= snoop_act_tag_info(I).Dirty;
            end loop;
            ACCESS_DEBUG(100 + C_MY_PORT  - 1 downto 100) <= snoop_act_done(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(104 + C_MY_PORT  - 1 downto 104) <= snoop_act_use_external(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(108 + C_MY_PORT  - 1 downto 108) <= snoop_info_tag_unique(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(112 + C_MY_PORT  - 1 downto 112) <= snoop_info_tag_dirty(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(116 + C_MY_PORT  - 1 downto 116) <= snoop_resp_valid(C_MY_PORT - 1 downto 0);
            
            ACCESS_DEBUG(120 + C_MY_NUM   - 1 downto 120) <= std_logic_vector(to_unsigned(snoop_fetch_port_num, C_MY_NUM));
            ACCESS_DEBUG(122 + C_MY_NUM   - 1 downto 122) <= std_logic_vector(to_unsigned(snoop_fetch_comp_port, C_MY_NUM));
            ACCESS_DEBUG(124 + C_MY_NUM   - 1 downto 124) <= std_logic_vector(to_unsigned(rs_port_num, C_MY_NUM));
            
            ACCESS_DEBUG(126 + C_MY_PORT  - 1 downto 126) <= ss_assert(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(130 + C_MY_QCNT  - 1 downto 130) <= rs_read_fifo_addr;
            
            ACCESS_DEBUG(                            134) <= snoop_fetch_piperun_i;
            ACCESS_DEBUG(                            135) <= snoop_fetch_stall;
            ACCESS_DEBUG(                            136) <= snoop_fetch_waiting_4_pipe;
            ACCESS_DEBUG(                            137) <= snoop_fetch_valid_i;
            ACCESS_DEBUG(                            138) <= snoop_fetch_any_always;
            ACCESS_DEBUG(                            139) <= snoop_fetch_ud_filter_me;
            ACCESS_DEBUG(                            140) <= snoop_fetch_no_data;
            ACCESS_DEBUG(                            141) <= snoop_fetch_no_rs;
            ACCESS_DEBUG(                            142) <= snoop_fetch_dvm_is_complete;
            ACCESS_DEBUG(                            143) <= snoop_fetch_dvm_is_sync;
            ACCESS_DEBUG(                            144) <= snoop_fetch_any_want;
            ACCESS_DEBUG(                            145) <= snoop_fetch_ex_with_mon;
            ACCESS_DEBUG(                            146) <= snoop_fetch_valid_cu;
            ACCESS_DEBUG(                            147) <= snoop_fetch_exclusive_ok;
            
            ACCESS_DEBUG(                            148) <= snoop_req_piperun_i;
            ACCESS_DEBUG(                            149) <= snoop_req_stall;
            ACCESS_DEBUG(                            150) <= snoop_req_conflict; 
            ACCESS_DEBUG(                            151) <= snoop_req_exclusive_stall;
            ACCESS_DEBUG(                            152) <= snoop_req_valid_i;
            ACCESS_DEBUG(                            153) <= snoop_req_any_always;
            ACCESS_DEBUG(                            154) <= snoop_req_update_filter_me;
            ACCESS_DEBUG(                            155) <= snoop_req_no_data;
            ACCESS_DEBUG(                            156) <= snoop_req_no_rs;
            ACCESS_DEBUG(                            157) <= snoop_req_any_want;
            ACCESS_DEBUG(                            158) <= snoop_act_any_dvm;
            ACCESS_DEBUG(                            159) <= '0';
            ACCESS_DEBUG(                            160) <= snoop_req_exclusive_ok;
            ACCESS_DEBUG(                            161) <= access_req_info.Wr;          -- snoop_req_info(x).Wr
            
            ACCESS_DEBUG(                            162) <= snoop_act_piperun_i; 
            ACCESS_DEBUG(                            163) <= snoop_act_stall; 
            ACCESS_DEBUG(                            164) <= snoop_act_valid_i; 
            ACCESS_DEBUG(                            165) <= snoop_act_conflict;
            ACCESS_DEBUG(                            166) <= snoop_act_any_always;
            ACCESS_DEBUG(                            167) <= snoop_act_no_data;
            ACCESS_DEBUG(                            168) <= snoop_act_no_rs;
            ACCESS_DEBUG(                            169) <= snoop_act_waiting_4_pipe_i;
            ACCESS_DEBUG(                            170) <= access_act_info.Wr;          -- snoop_act_info(x).Wr
            ACCESS_DEBUG(                            171) <= snoop_act_exclusive_ok;
            
            ACCESS_DEBUG(                            172) <= access_waiting_for_pipe;
            ACCESS_DEBUG(                            173) <= '0';
            ACCESS_DEBUG(                            174) <= '0';
            ACCESS_DEBUG(                            175) <= access_no_data;
            ACCESS_DEBUG(                            176) <= access_no_rs;
            ACCESS_DEBUG(                            177) <= access_exclusive_ok;
            
            ACCESS_DEBUG(                            178) <= snoop_read_data_any_valid;
            ACCESS_DEBUG(                            179) <= reduce_or(ss_assert);
            ACCESS_DEBUG(                            180) <= arb_access.Exclusive;        -- snoop_fetch_exclusive
            ACCESS_DEBUG(                            181) <= snoop_ex_monitor_allow_new;  
            ACCESS_DEBUG(                            182) <= rs_fifo_almost_full;
            
            ACCESS_DEBUG(                            183) <= rs_push;
            ACCESS_DEBUG(                            184) <= rs_pop;
            ACCESS_DEBUG(                            185) <= rs_fifo_full;
            ACCESS_DEBUG(                            186) <= rs_fifo_empty;
            ACCESS_DEBUG(                            187) <= rs_no_forward;
            ACCESS_DEBUG(                            188) <= rs_exclusive_ok;
            ACCESS_DEBUG(                            189) <= rs_assert;
            
            ACCESS_DEBUG(                            190) <= snoop_fetch_dvm_comp_hold;
            
            ACCESS_DEBUG(                            191) <= snoop_merged_error;
            ACCESS_DEBUG(                            192) <= snoop_all_resp_available;
            ACCESS_DEBUG(                            193) <= sm_pop;
            
            ACCESS_DEBUG(                            194) <= snoop_fetch_is_part2;
            
            ACCESS_DEBUG(195 + C_MY_PORT  - 1 downto 195) <= snoop_fetch_pos_hazard(C_MY_PORT - 1 downto 0);
            ACCESS_DEBUG(                            199) <= snoop_fetch_lx_allocate;
            
            ACCESS_DEBUG(200 + C_MY_NUM   - 1 downto 200) <= std_logic_vector(to_unsigned(snoop_ex_monitor_port, 
                                                                                          C_MY_NUM));
            
            ACCESS_DEBUG(202 + C_MY_TIMER - 1 downto 202) <= std_logic_vector(to_unsigned(snoop_ex_timer, 
                                                                                          C_MY_TIMER));
            
            -- ACCESS_DEBUG(211 downto 206) is shared debug signals.
            ACCESS_DEBUG(                            212) <= snoop_act_evict_line;
            ACCESS_DEBUG(                            213) <= snoop_req_evict_line;
            ACCESS_DEBUG(                            214) <= snoop_fetch_peer_caches;
            ACCESS_DEBUG(                            215) <= snoop_fetch_ds_caches;
            ACCESS_DEBUG(                            216) <= snoop_fetch_valid_ds_ci;
            ACCESS_DEBUG(                            217) <= snoop_fetch_ignore_data;
            ACCESS_DEBUG(                            218) <= snoop_ex_enable_timer;
            ACCESS_DEBUG(                            219) <= access_insert_write;
            ACCESS_DEBUG(                            220) <= access_write_1st_cycle;
            ACCESS_DEBUG(                            221) <= access_write_inserted;
            
          end if;
        end if;
      end process Debug_Handle;
    end generate Use_Debug;
    
  end generate Use_Coherency;
  
  
  -----------------------------------------------------------------------------
  -- Common code
  -----------------------------------------------------------------------------
  
  -- Inset transaction handling:
  --  * Exclusive transaction management.
  --  * Dirty Snoop Data management.
  access_write_1st_cycle      <= access_insert_write and 
                                 ( not access_write_inserted  );
  access_evict_1st_cycle      <= access_evict_line              and 
                                 ( not access_write_1st_cycle ) and 
                                 ( not access_evict_inserted  );
  access_original_cycle       <= ( (     access_insert_write and access_write_inserted ) or
                                   ( not access_insert_write ) ) and
                                 ( (     access_evict_line  and access_evict_inserted ) or
                                   ( not access_evict_line   ) );
  
  -- Handle sequence for Exclusive.
  Pipeline_Exclusive_Handle : process (ACLK) is
  begin  -- process Pipeline_Exclusive_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      if( ARESET_I = '1' ) then             -- synchronous reset (active high)
        access_write_inserted <= '0';
        access_evict_inserted <= '0';
        
      else
        if( lookup_piperun_i = '1' ) then
          access_write_inserted <= '0';
          access_evict_inserted <= '0';
          
        elsif( lookup_piperun = '1' ) then
          access_write_inserted <= access_valid_i and access_write_1st_cycle;
          access_evict_inserted <= access_valid_i and access_evict_line;
          
        end if;
      end if;
    end if;
  end process Pipeline_Exclusive_Handle;
  
  -- Stalls if preparing for Exclusive.
  access_stall                <= access_valid_i and 
                                 ( access_write_1st_cycle or access_evict_1st_cycle );
  
  -- Assign output directly.
  access_valid                <= access_valid_i;
  
  -- Assign and manipulate Access transaction when evict must be inserted.
  Post_Process_Access: process (access_info_i, access_evict_1st_cycle, access_write_1st_cycle) is
  begin  -- process Post_Process_Access
    -- Default assignment.
    access_info                             <= access_info_i;
    
    -- Update as necessary.
    if( access_write_1st_cycle = '1' ) then
      -- Insert a fake write transaction to handle the Dirty downstream data.
      access_info.Port_Num                    <= int_to_std(C_NUM_PORTS, C_MAX_NUM_PORT_WIDTH);
      access_info.Internal_Cmd                <= '1';
      access_info.Allocate                    <= '0';
      access_info.Bufferable                  <= '1';
      access_info.Exclusive                   <= '0';
      access_info.Evict                       <= '0';
      access_info.SnoopResponse               <= '0';
      access_info.KillHit                     <= '0';
      access_info.Wr                          <= '1';
      access_info.Len                         <= C_Lx_NATIVE_LEN;
      access_info.Size                        <= C_Lx_NATIVE_SIZE;
      access_info.Kind                        <= C_KIND_WRAP;
      access_info.Addr(C_CACHE_DATA_ADDR_POS) <= (others=>'0');
      
      case C_Lx_NATIVE_SIZE is
        when C_BYTE_SIZE          =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_BYTE_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_BYTE_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HALF_WORD_SIZE     =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_HALF_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_HALF_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_WORD_SIZE          =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_DOUBLE_WORD_SIZE   =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_DOUBLE_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_DOUBLE_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_QUAD_WORD_SIZE     =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_QUAD_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_QUAD_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_OCTA_WORD_SIZE     =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_OCTA_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_OCTA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when C_HEXADECA_WORD_SIZE =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_HEXADECA_WORD_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_HEXADECA_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
        when others               =>
          access_info.Addr_Use  <= C_EXTENDED_NATIVE_LEN(C_TRIACONTADI_MASK_POS);
          access_info.Addr_Stp  <= std_logic_vector(to_unsigned(C_TRIACONTADI_WORD_STEP_SIZE, C_MAX_WORD_ADDR_WIDTH));
          
      end case;
      
    elsif( access_evict_1st_cycle = '1' ) then
      -- Remove any allocation to make sure the exclusive sequence reach memory.
      access_info.Allocate                    <= '0';
      access_info.Exclusive                   <= '0';
      access_info.Evict                       <= '1';
      access_info.SnoopResponse               <= '0';
      access_info.KillHit                     <= '1';
      access_info.Wr                          <= '0';
      
    end if;
    
    -- Unused.
    access_info.ID               <= (others=>'0');
  end process Post_Process_Access;
  
  -- Write Data propagation.
  Gen_Port_Write_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    access_data_info(I)         <= wr_port_data_info(I);
    wr_port_data_ready(I)       <= lookup_write_data_ready(I) or update_write_data_ready(I);
    
  end generate Gen_Port_Write_Array;
  
  -- Unused.
  access_write_priority       <= (others=>'0');
  access_other_write_prio     <= (others=>'0');
  
  Gen_Port_RRESP_Array: for I in 0 to C_NUM_PORTS - 1 generate
  begin
    snoop_read_data_info(I).Valid <= snoop_read_data_valid(I);
    snoop_read_data_info(I).Last  <= snoop_read_data_last;
    snoop_read_data_info(I).Data  <= fit_vec(snoop_read_data_word, C_MAX_DATA_WIDTH);
    snoop_read_data_info(I).RRESP <= snoop_read_data_resp;
    
  end generate Gen_Port_RRESP_Array;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_access_valid       <= C_NULL_STAT_POINT;
    stat_access_stall       <= C_NULL_STAT_POINT;
    
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
    
    signal new_access             : std_logic;
    signal count_time             : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal time_valid             : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    
    signal det_acs_stall          : std_logic;
    
  begin
    Stat_Handle : process (ACLK) is
    begin  -- process Stat_Handle
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if stat_reset = '1' then                  -- synchronous reset (active high)
          new_access          <= '0';
          count_time          <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
          time_valid          <= (others=>'0');
          det_acs_stall       <= '0';
          
        else
          new_access          <= '0';
          det_acs_stall       <= access_valid_i      and access_stall;
          
          if( access_valid_i = '1' ) then
            count_time  <= std_logic_vector(unsigned(count_time) + 1);
          end if;
          if( lookup_piperun = '1' ) then
            new_access  <= access_valid_i;
            count_time  <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
            time_valid  <= count_time;
            
          end if;
        end if;
      end if;
    end process Stat_Handle;
    
    Valid_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_access,
        counter                   => time_valid,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_access_valid
      );
      
    Stall_Inst: sc_stat_event
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Probe Interface
        
        probe                     => det_acs_stall,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_access_stall
      );
    
  end generate Use_Stat;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- Detect condition
  assert_err  <= (others=>'0');
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_arbiter.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_arbiter.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_arbiter.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


entity sc_arbiter is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- IP Specific.
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
    C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
    C_IGNORE_MODIFIABLE       : natural range  0 to    1      :=  0;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_FAST_PORTS          : natural range  0 to   32      :=  0;
    C_NUM_PORTS               : natural range  1 to   32      :=  1
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (All request).
    
    opt_port_piperun          : in  std_logic;
    arbiter_piperun           : out std_logic;
    arbiter_allowed           : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Write request).
    
    wr_port_access            : in  WRITE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    wr_port_ready             : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    rd_port_access            : in  READ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    rd_port_ready             : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Arbiter signals (to Access).
    
    arb_access                : out ARBITRATION_TYPE;
    
    
    -- ---------------------------------------------------
    -- Control If Transactions.
    
    ctrl_arbiter_allow        : in  std_logic;
    ctrl_access               : in  ARBITRATION_TYPE;
    ctrl_ready                : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Port signals.
    
    arbiter_bp_push           : out WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    wr_port_inbound           : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Access signals.
    
    access_piperun            : in  std_logic;
    access_write_priority     : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    access_other_write_prio   : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Port signals (to Arbiter).
    
    read_data_status          : in  STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (to Arbiter).
    
    lookup_read_done          : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                      : in  std_logic;
    stat_enable                     : in  std_logic;
    
    stat_arb_valid                  : out STAT_POINT_TYPE;    -- Time valid transactions exist
    stat_arb_concurrent_accesses    : out STAT_POINT_TYPE;    -- Transactions available each time command is arbitrated
    stat_arb_opt_read_blocked       : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
    stat_arb_gen_read_blocked       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                              -- Time valid read is blocked by prohibit
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug signals.
    
    ARBITER_DEBUG             : out MAX_DEBUG_TYPE
  );
end entity sc_arbiter;

library IEEE;
use IEEE.numeric_std.all;

architecture IMP of sc_arbiter is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- Arbitrate between available input transactions, with a Round-Robin 
  -- scheme.
  -- Write can be prioritized when needed. 
  -- Read a prohibited on the same port until data is returned, because of the
  -- Hit/Miss delay difference issue.
  -- 
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  1;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  subtype C_PORT_POS                  is natural range C_NUM_PORTS - 1 downto 0;
  subtype PORT_TYPE                   is std_logic_vector(C_PORT_POS);
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  function arbitrate(token : PORT_TYPE; rp : READ_PORTS_TYPE; wp : WRITE_PORTS_TYPE; rack, wack, rprohib, wprio : PORT_TYPE) return ARBITRATION_TYPE is
    variable arb    : ARBITRATION_TYPE := C_NULL_ARBITRATION;
    variable found  : boolean          := false;
  begin
    for i in 0 to C_NUM_PORTS - 1 loop
      if ( wprio(i) = '1' and wp(i).Valid = '1' and wack(i) = '0' ) then
        found       := true;
        arb.Valid   := '1';
        arb.Wr      := '1';
        arb.Port_Num:= std_logic_vector(to_unsigned(i, C_MAX_NUM_PORT_WIDTH));
        
      elsif( rp(i).Valid = '1' and rprohib(i) = '0' and ( arb.Valid = '0' or ( token(I) = '1' and not found ) ) ) then
        arb.Valid   := '1';
        arb.Wr      := '0';
        arb.Port_Num:= std_logic_vector(to_unsigned(i, C_MAX_NUM_PORT_WIDTH));
        
      elsif( wp(i).Valid = '1' and wack(i) = '0' and ( arb.Valid = '0' or ( token(I) = '1' and not found ) ) ) then
        arb.Valid   := '1';
        arb.Wr      := '1';
        arb.Port_Num:= std_logic_vector(to_unsigned(i, C_MAX_NUM_PORT_WIDTH));
        
      end if;
    end loop;
    
    return arb;
  end function arbitrate;
  
  function set_fast_port return PORT_TYPE is
    variable tmp    : PORT_TYPE := (others=>'0');
  begin
    if( C_NUM_FAST_PORTS > 0 ) then
      tmp(C_NUM_PORTS - 1 downto C_NUM_PORTS - C_NUM_FAST_PORTS)  := (others=>'1');
    end if;
    
    return tmp;
  end function set_fast_port;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_WRITE_ENABLED            : PORT_TYPE := (others=>'1');  
  constant C_READ_ENABLED             : PORT_TYPE := (others=>'1');  
  constant C_FAST_PORT                : PORT_TYPE := set_fast_port;  
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component carry_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE
      );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and;
  
  component carry_and_n is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE
      );
    port (
      Carry_IN  : in  std_logic;
      A_N       : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_and_n;
  
  component carry_or is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET : TARGET_FAMILY_TYPE
      );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      Carry_OUT : out std_logic);
  end component carry_or;
  
  component carry_latch_and is
    generic (
      C_KEEP    : boolean:= false;
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_and;
  
  component sc_stat_counter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      
      -- Configuration.
      C_STAT_SIMPLE_COUNTER     : natural range  0 to    1      :=  0;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common Signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Counter Interface
      
      update                    : in  std_logic;
      counter                   : in  std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_enable               : in  std_logic;
      
      stat_data                 : out STAT_POINT_TYPE
    );
  end component sc_stat_counter;
  
  component bit_reg_ce is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_IS_SET  : std_logic;
      C_CE_LOW  : std_logic_vector;
      C_NUM_CE  : natural
    );
    port (
      CLK       : in  std_logic;
      SR        : in  std_logic;
      CE        : in  std_logic_vector(C_NUM_CE - 1 downto 0);
      D         : in  std_logic;
      Q         : out std_logic
    );
  end component bit_reg_ce;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  
  -- ----------------------------------------
  -- Local Reset
  
  signal ARESET_I                   : std_logic;
  signal prohibit_rst               : boolean;
  attribute dont_touch              : string;
  attribute dont_touch              of Reset_Inst     : label is "true";
  
  -- Guide Vivado Synthesis to handle control set as intended.
  attribute direct_reset            : string;
  attribute direct_reset            of prohibit_rst   : signal is "true";
  
  -- ----------------------------------------
  -- Piperun 
  
  signal arbiter_piperun_i          : std_logic;
  
  
  -- ----------------------------------------
  -- Detect Transactions
  
  signal wr_port_blocked            : PORT_TYPE;
  signal wr_port_exist              : PORT_TYPE;
  signal rd_port_exist              : PORT_TYPE;
  signal trans_port_exist           : PORT_TYPE;
  signal port_idle                  : PORT_TYPE;
  signal port_prio_taken            : PORT_TYPE;
  signal port_token_taken           : PORT_TYPE;
  signal port_arbiter_taken         : PORT_TYPE;
  signal port_other_idle            : PORT_TYPE;
  signal port_allow_ready_pre       : PORT_TYPE;
  signal port_allow_ready           : PORT_TYPE;
  signal port_ready_blocked_by_init : PORT_TYPE;
  signal port_ready_no_init         : PORT_TYPE;
  signal port_ready                 : PORT_TYPE;
  signal port_ready_i               : PORT_TYPE;
  signal wr_port_ready_cmb          : PORT_TYPE;
  signal wr_port_ready_cmb2         : PORT_TYPE;
  signal wr_port_ready_q            : PORT_TYPE;
  signal wr_port_ready_block        : PORT_TYPE;
  signal rd_port_ready_cmb          : PORT_TYPE;
  signal rd_port_ready_cmb2         : PORT_TYPE;
  signal rd_port_ready_q            : PORT_TYPE;
  signal rd_port_ready_block        : PORT_TYPE;
  signal wr_port_bufferable         : PORT_TYPE;
  signal wr_port_modifiable         : PORT_TYPE;
  signal wr_port_any_alloc          : PORT_TYPE;
  signal wr_port_keep               : PORT_TYPE;
  signal wr_port_early              : PORT_TYPE;
  signal wr_port_barrier            : PORT_TYPE;
  
  
  -- ----------------------------------------
  -- Arbitration
  
  signal arb_token_new              : PORT_TYPE;
  signal arb_token                  : PORT_TYPE;
  signal arb_token_cnt              : C_PORT_POS;
  signal port_ready_num             : C_PORT_POS;
  signal all_ready                  : std_logic;
  signal arbiter_piperun_and_valid  : std_logic;
  signal arb_access_cmb             : ARBITRATION_TYPE;
  signal arb_access_i               : ARBITRATION_TYPE;
  signal wr_port_ready_i            : PORT_TYPE;
  signal rd_port_ready_i            : PORT_TYPE;
  signal arb_want_multi_part        : PORT_TYPE;
  signal rd_port_multi_part         : PORT_TYPE;
  signal any_port_forbid            : PORT_TYPE;
  signal dvm_2nd_part               : std_logic;
  signal ctrl_ready_i               : std_logic;
  
  signal arbiter_bp_push_i          : WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
  
  -- ----------------------------------------
  -- Prohibit Handle
  
  signal arb_prohibit_read          : PORT_TYPE;
  signal arb_prohibit_quick         : PORT_TYPE;
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP
  
  
  -----------------------------------------------------------------------------
  -- Internal Reset Fan-Out
  -----------------------------------------------------------------------------
  
  Reset_Inst: bit_reg_ce
    generic map(
      C_TARGET  => C_TARGET,
      C_IS_SET  => '0',
      C_CE_LOW  => (0 downto 0=>'0'),
      C_NUM_CE  => 1
    )
    port map(
      CLK       => ACLK,
      SR        => '0',
      CE        => "1",
      D         => ARESET,
      Q         => ARESET_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Piperun 
  -----------------------------------------------------------------------------
  
  -- The Piperun signal takes a detour through the Front End in order to branch out
  -- the Generic Piperun signals, but the status of the piperun is not altered.
  -- It returns as "opt_port_piperun" and the carry chain can continue with the
  -- ready termination to generate "arbiter_piperun_and_valid".
-- TODO: Could it be safe to propagate "arbiter_piperun_and_valid" to the Front End?
  arbiter_piperun   <= arbiter_piperun_i;
  arbiter_piperun_i <= access_piperun;
  
  -- Any ready.
-- TODO: It should be ok to use Valid instead of Ready (if prohibit are taken into account),
--       could be better timing?
  all_ready         <= reduce_or(port_ready);
  
  -- Generate valid for token.
  FE_Arb_PR_Valid_Inst1: carry_and
    generic map(
      C_TARGET => C_TARGET
    )
    port map(
      Carry_IN  => opt_port_piperun,
      A         => all_ready,
      Carry_OUT => arbiter_piperun_and_valid
    );
  
  -- Calculate if there are of will be room for new transaction in Arb Slot.
  arbiter_allowed <= arbiter_piperun_i or not arb_access_i.Valid;
  
  
  -----------------------------------------------------------------------------
  -- Detect Transactions
  -----------------------------------------------------------------------------
  
  Gen_Port_Ready: for I in 0 to C_NUM_PORTS - 1 generate
    signal idle_carry : std_logic_vector(C_NUM_PORTS*2 downto 0);
  begin
    wr_port_barrier(I)    <= '1' when ( wr_port_access(I).Barrier = C_BAR_MEMORY_BARRIER  ) or
                                      ( wr_port_access(I).Barrier = C_BAR_SYNCHRONIZATION ) else
                             '0';
    
    wr_port_modifiable(I) <= wr_port_access(I).Modifiable;
    
    wr_port_bufferable(I) <= wr_port_access(I).Bufferable and 
                             ( not ( wr_port_access(I).Exclusive and int_to_std(C_ENABLE_EX_MON) ) or 
                               not   wr_port_access(I).Exclusive );
    
    wr_port_any_alloc(I)  <= wr_port_access(I).Allocate or 
                             wr_port_access(I).Other_Allocate;
    
    wr_port_keep(I)       <= ( wr_port_any_alloc(I) or
                               ( wr_port_bufferable(I) and i2s(C_KEEP_BUFFERABLE) ) ) and
                             ( wr_port_bufferable(I) ) and
                             ( wr_port_modifiable(I) or i2s(C_IGNORE_MODIFIABLE) );
    
    -- Early Write response can be given for Barriers or Cacheable/Bufferable,
    -- unless an Exclusive is tagged with internal Allocation in order
    -- to be able to track the line completely.
    -- (A normal AXI Exclusive transaction is not allowed to be Cacheable).
--          if( ( not is_mst_coherent(C_ENABLE_COHERENCY)       ) or
--              ( (     wr_port_access(I).Exclusive         = '0' ) and
--                ( C_ENABLE_EARLY_BRESP = 1                      ) ) ) then
--            arbiter_bp_push_i(I).Early    <= ( wr_port_bufferable(I) or 
--                                               wr_port_any_alloc(I)  );
--          end if;
--          if( wr_port_barrier(I) = '1' ) then
--            arbiter_bp_push_i(I).Early    <= '1';
--          end if;
    wr_port_early(I)      <= '1'                         when s2b(wr_port_barrier(I)) else
                             ( wr_port_bufferable(I) or 
                               wr_port_any_alloc(I)  )   when ( not is_mst_coherent(C_ENABLE_COHERENCY)       ) or
                                                              ( (     wr_port_access(I).Exclusive         = '0' ) and
                                                                ( C_ENABLE_EARLY_BRESP = 1                      ) ) else
                             '0';
    
    -- Forward that write is coming.
    wr_port_inbound(I)    <= wr_port_access(I).Valid;
    
    -- Detect if read is blocking write.
    wr_port_blocked(I)    <= ( rd_port_access(I).Valid and not access_write_priority(I) ) or
                             rd_port_multi_part(I) or any_port_forbid(I);
    
    -- Detect active write transaction.
    wr_port_exist(I)      <= wr_port_access(I).Valid and not wr_port_blocked(I) and not wr_port_ready_block(I) 
                                when C_WRITE_ENABLED(I) = '1' else
                             '0';
    
    -- Detect active read transaction.
    rd_port_exist(I)      <= rd_port_access(I).Valid and ( rd_port_multi_part(I) or not access_write_priority(I) ) and 
                             not rd_port_ready_block(I) and not any_port_forbid(I)
                                when C_READ_ENABLED(I) = '1' else
                             '0';
    
    -- Detect any active transaction.
    trans_port_exist(I)   <= wr_port_exist(I) or rd_port_exist(I);
    
    -- Detect if port is idle.
    port_idle(I)          <= ( not wr_port_exist(I) ) and ( not rd_port_exist(I) );
    
    -- Detect priority taken.
    port_prio_taken(I)    <= ( wr_port_access(I).Valid and access_write_priority(I) ) or
                             ( rd_port_access(I).Valid and rd_port_multi_part(I) );
    
    -- Detect token taken.
    port_token_taken(I)   <= ( wr_port_access(I).Valid or rd_port_access(I).Valid ) and arb_token(I) and 
                             not any_port_forbid(I);
    
    -- Detect arbiter taken.
    port_arbiter_taken(I) <= port_prio_taken(I) or port_token_taken(I);
    
    
    -- Search if lower priority transactions are idle
    idle_carry(idle_carry'right) <= '1';
    Detect_Idle: for J in 0 to C_NUM_PORTS - 1 generate
    begin
      Lower_Prio: if J < I generate
      begin
        LP_Rd_Inst: carry_and_n
          generic map(
            C_TARGET => C_TARGET
          )
          port map(
            Carry_IN  => idle_carry(J*2),
            A_N       => rd_port_exist(J),
            Carry_OUT => idle_carry(J*2+1)
          );
        LP_Wr_Inst: carry_and_n
          generic map(
            C_TARGET => C_TARGET
          )
          port map(
            Carry_IN  => idle_carry(J*2+1),
            A_N       => wr_port_exist(J),
            Carry_OUT => idle_carry(J*2+2)
          );
      end generate Lower_Prio;
      
      Current_Port: if J = I generate
      begin
        idle_carry(J*2+1) <= idle_carry(J*2);
        idle_carry(J*2+2) <= idle_carry(J*2+1);
      end generate Current_Port;
      
      Taken_Block: if J > I generate
      begin
        TB_Inst: carry_and_n
          generic map(
            C_TARGET => C_TARGET
          )
          port map(
            Carry_IN  => idle_carry(J*2),
            A_N       => port_arbiter_taken(J),
            Carry_OUT => idle_carry(J*2+1)
          );
        idle_carry(J*2+2) <= idle_carry(J*2+1);
      end generate Taken_Block;
    end generate Detect_Idle;
    
    -- No one else want or are being arbitrated.
    port_other_idle(I)  <= idle_carry(idle_carry'left);
    
    -- Add if current has the token.
    Token_Inst: carry_or
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_other_idle(I),
        A         => arb_token(I),
        Carry_OUT => port_allow_ready_pre(I)
      );
    Prio_Inst: carry_or
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_allow_ready_pre(I),
        A         => access_write_priority(I),
        Carry_OUT => port_allow_ready(I)
      );
    
    -- Detect if port is used.
    Use_Inst: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_allow_ready(I),
        A         => trans_port_exist(I),
        Carry_OUT => port_ready_no_init(I)
      );
    
    -- Detect if initialization has completed.
    port_ready_blocked_by_init(I) <= ctrl_arbiter_allow and not ARESET and not ARESET_I;
    Init_Inst: carry_and
      generic map(
        C_TARGET => C_TARGET
      )
      port map(
        Carry_IN  => port_ready_no_init(I),
        A         => port_ready_blocked_by_init(I),
        Carry_OUT => port_ready(I)
      );
    
    -- Set port type dependent ready forwading and blocking.
    Use_Fast_Port: if( C_FAST_PORT(I) = '1' ) generate
    begin
      -- Transaction type dependent ready.
      Wr_Inst: carry_latch_and
        generic map(
          C_TARGET  => C_TARGET,
          C_NUM_PAD => 0,
          C_INV_C   => false
        )
        port map(
          Carry_IN  => port_ready(I),
          A         => wr_port_exist(I),
          O         => wr_port_ready_cmb(I),
          Carry_OUT => port_ready_i(I)
        );
        
      Rd_Inst: carry_and
        generic map(
          C_TARGET => C_TARGET
        )
        port map(
          Carry_IN  => port_ready_i(I),
          A         => rd_port_exist(I),
          Carry_OUT => rd_port_ready_cmb(I)
        );
        
      
      -- Assign output.
      rd_port_ready_i(I)      <= rd_port_ready_cmb(I);
      wr_port_ready_i(I)      <= wr_port_ready_cmb(I);
      
      -- Unused signals.
      rd_port_ready_q(I)      <= '0';
      wr_port_ready_q(I)      <= '0';
      
      -- Generate blocking.
      rd_port_ready_block(I)  <= arb_prohibit_read(I);
      wr_port_ready_block(I)  <= '0';
      
      -- Unused bit for Fast.
      wr_port_ready_cmb2(I) <= '0';
      rd_port_ready_cmb2(I) <= '0';
    end generate Use_Fast_Port;
    
    Use_Slow_Port: if( C_FAST_PORT(I) /= '1' ) generate
    begin
      -- Transaction type dependent ready.
      Rd_Inst: carry_latch_and
        generic map(
          C_TARGET  => C_TARGET,
          C_NUM_PAD => 0,
          C_INV_C   => false
        )
        port map(
          Carry_IN  => port_ready(I),
          A         => rd_port_exist(I),
          O         => rd_port_ready_cmb(I),
          Carry_OUT => port_ready_i(I)
        );
        
      Wr_Inst: carry_and
        generic map(
          C_TARGET => C_TARGET
        )
        port map(
          Carry_IN  => port_ready_i(I),
          A         => wr_port_exist(I),
          Carry_OUT => wr_port_ready_cmb(I)
        );
      
      -- Generate the combinatorial input for the FFs.
      Ready_Gen: process (rd_port_ready_cmb, wr_port_ready_cmb, arbiter_piperun_i) is
      begin  -- process Ready_Gen
        wr_port_ready_cmb2(I) <= '0';
        rd_port_ready_cmb2(I) <= '0';
        if( ( wr_port_ready_cmb(I) = '1' ) and ( arbiter_piperun_i = '1' ) ) then
          wr_port_ready_cmb2(I) <= '1';
        end if;
        if( ( rd_port_ready_cmb(I) = '1' ) and ( arbiter_piperun_i = '1' ) ) then
          rd_port_ready_cmb2(I) <= '1';
        end if;
      end process Ready_Gen;
      
      
      -- Clock port ready.
      Rd_FF_Inst : FDR
        port map (
          Q  => rd_port_ready_q(I),           -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => rd_port_ready_cmb2(I),        -- [in  std_logic]
          R  => ARESET_I                      -- [in  std_logic]
        );
      Wr_FF_Inst : FDR
        port map (
          Q  => wr_port_ready_q(I),           -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => wr_port_ready_cmb2(I),        -- [in  std_logic]
          R  => ARESET_I                      -- [in  std_logic]
        );
      
      -- Assign output.
      rd_port_ready_i(I)  <= rd_port_ready_q(I);
      wr_port_ready_i(I)  <= wr_port_ready_q(I);
      
      -- Generate blocking.
      rd_port_ready_block(I)  <= arb_prohibit_read(I);
      wr_port_ready_block(I)  <= wr_port_ready_q(I);
    end generate Use_Slow_Port;
  end generate Gen_Port_Ready;
  
  
  -----------------------------------------------------------------------------
  -- Predecode
  -----------------------------------------------------------------------------
  
  Pre_Decode: process (rd_port_access, rd_port_ready_cmb, rd_port_multi_part, dvm_2nd_part) is
  begin  -- process Pre_Decode
    arb_want_multi_part <= (others=>'0');
    
    for I in 0 to C_NUM_PORTS - 1 loop
      if( ( I < C_NUM_OPTIMIZED_PORTS ) and 
          ( rd_port_access(I).Snoop = C_ARSNOOP_DVMMessage ) ) then
        arb_want_multi_part(I)  <= rd_port_access(I).Addr(C_DVM_MORE_POS) and not dvm_2nd_part;
      end if;
    end loop;
  end process Pre_Decode;
  
  
  -----------------------------------------------------------------------------
  -- Arbitration
  -----------------------------------------------------------------------------
  
  Port_Gen: process (port_ready) is
  begin  -- process Port_Gen
    port_ready_num  <= 0;
    for I in 0 to C_NUM_PORTS - 1 loop
      if( port_ready(I) = '1' ) then
        port_ready_num <= I;
      end if;
    end loop; 
  end process Port_Gen;
  
  Arbitration_Handle : process (ACLK) is
  begin  -- process Arbitration_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        arb_access_i            <= C_NULL_ARBITRATION;
        
      else
        if( arbiter_piperun_i = '1' ) then
          -- Common arbitration part.
          arb_access_i.Valid      <= reduce_or(port_ready);
          arb_access_i.Wr         <= reduce_or(wr_port_ready_cmb);
          arb_access_i.Port_Num   <= std_logic_vector(to_unsigned(port_ready_num, C_MAX_NUM_PORT_WIDTH));
          
          -- Type dependent.
          if( reduce_or(wr_port_ready_cmb) = '1' ) then
            -- Write transaction.
            arb_access_i.ID           <=     wr_port_access(port_ready_num).ID;
            arb_access_i.Addr         <=     wr_port_access(port_ready_num).Addr;
            arb_access_i.Len          <=     wr_port_access(port_ready_num).Len;
            arb_access_i.Kind         <=     wr_port_access(port_ready_num).Kind;
            arb_access_i.Exclusive    <=     wr_port_access(port_ready_num).Exclusive;
            arb_access_i.Allocate     <=     wr_port_access(port_ready_num).Allocate and
                                             wr_port_keep(port_ready_num);
            arb_access_i.Bufferable   <=     wr_port_bufferable(port_ready_num);
            arb_access_i.Evict        <=     '0';
            arb_access_i.Ignore_Data  <=     '0';
            arb_access_i.Force_Hit    <=     '0';
            arb_access_i.Internal_Cmd <=     '0';
            arb_access_i.Early        <=     wr_port_early(port_ready_num);
            arb_access_i.Keep         <=     wr_port_keep(port_ready_num);
            arb_access_i.Prot         <=     wr_port_access(port_ready_num).Prot;
            arb_access_i.Snoop        <= (others=>'0');
            arb_access_i.Snoop(C_AXI_AWSNOOP_POS)
                                      <=     wr_port_access(port_ready_num).Snoop;
            arb_access_i.Barrier      <=     wr_port_access(port_ready_num).Barrier;
            arb_access_i.Domain       <=     wr_port_access(port_ready_num).Domain;
            arb_access_i.Size         <=     wr_port_access(port_ready_num).Size;
            
          elsif( reduce_or(rd_port_ready_cmb) = '1' ) then
            -- Read transaction.
            arb_access_i.ID           <=     rd_port_access(port_ready_num).ID;
            arb_access_i.Addr         <=     rd_port_access(port_ready_num).Addr;
            arb_access_i.Len          <=     rd_port_access(port_ready_num).Len;
            arb_access_i.Kind         <=     rd_port_access(port_ready_num).Kind;
            arb_access_i.Exclusive    <=     rd_port_access(port_ready_num).Exclusive;
            arb_access_i.Allocate     <=     rd_port_access(port_ready_num).Allocate;
            arb_access_i.Bufferable   <=     rd_port_access(port_ready_num).Bufferable;
            arb_access_i.Evict        <=     '0';
            arb_access_i.Ignore_Data  <=     '0';
            arb_access_i.Force_Hit    <=     '0';
            arb_access_i.Internal_Cmd <=     '0';
            arb_access_i.Early        <=     '1';
            arb_access_i.Keep         <=     '1';
            arb_access_i.Prot         <=     rd_port_access(port_ready_num).Prot;
            arb_access_i.Snoop        <=     rd_port_access(port_ready_num).Snoop;
            arb_access_i.Barrier      <=     rd_port_access(port_ready_num).Barrier;
            arb_access_i.Domain       <=     rd_port_access(port_ready_num).Domain;
            arb_access_i.Size         <=     rd_port_access(port_ready_num).Size;
            
          else
            -- Ctrl port transaction.
            arb_access_i              <= ctrl_access;
            arb_access_i.Valid        <= ctrl_access.Valid and not ctrl_ready_i;
            
            ctrl_ready_i              <= ctrl_access.Valid and not ctrl_ready_i;
            
          end if;
          
        else
          ctrl_ready_i              <= '0';
          
        end if;
      end if;
    end if;
  end process Arbitration_Handle;
  
  Token_Handle : process (ACLK) is
  begin  -- process Token_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        dvm_2nd_part    <= '0';
        arb_token_cnt   <= 0;
        
      elsif( arbiter_piperun_and_valid = '1' ) then
        -- Track message that needs to be kept together.
        dvm_2nd_part    <= rd_port_ready_cmb(port_ready_num) and arb_want_multi_part(port_ready_num);
        
        -- Only move token once per message.
        if( dvm_2nd_part = '0' ) then
          if( arb_token_cnt = C_NUM_PORTS - 1 ) then
            arb_token_cnt   <= 0;
          else
            arb_token_cnt   <= arb_token_cnt + 1;
          end if;
        end if;
        
      end if;
    end if;
  end process Token_Handle;
  
  Single_Port: if( C_NUM_PORTS = 1 ) generate
  begin
    arb_token           <= (others=>'1');
    rd_port_multi_part  <= (others=>'0');
    any_port_forbid     <= (others=>'0');
    
  end generate Single_Port;
  
  Multi_Port: if( C_NUM_PORTS > 1 ) generate
    signal rd_port_multi_part_cmb     : PORT_TYPE;
    signal any_port_forbid_cmb        : PORT_TYPE;
  begin
    Multi_Part_Handle : process (rd_port_ready_cmb, arb_want_multi_part, port_ready_num) is
    begin  -- process Multi_Part_Handle
      if( reduce_or(rd_port_ready_cmb) = '1' ) then
        any_port_forbid_cmb                     <= (others=>arb_want_multi_part(port_ready_num));
        any_port_forbid_cmb(port_ready_num)     <= '0';
        rd_port_multi_part_cmb                  <= (others=>'0');
        rd_port_multi_part_cmb(port_ready_num)  <= arb_want_multi_part(port_ready_num);
        
      else
        rd_port_multi_part_cmb                  <= (others=>'0');
        any_port_forbid_cmb                     <= (others=>'0');
        
      end if;
    end process Multi_Part_Handle;
    
    Token_Handle : process (dvm_2nd_part, arb_token) is
    begin  -- process Token_Handle
      if( dvm_2nd_part = '0' ) then
        arb_token_new <= arb_token(arb_token'left - 1 downto arb_token'right) & arb_token(arb_token'left);
      else
        arb_token_new <= arb_token;
      end if;
      
    end process Token_Handle;
    
    Gen_Token: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      First_Inst: if( I = 0 ) generate
      begin
        FF_Inst : FDSE
          port map (
            Q  => arb_token(I),                 -- [out std_logic]
            C  => ACLK,                         -- [in  std_logic]
            D  => arb_token_new(I),             -- [in  std_logic]
            CE => arbiter_piperun_and_valid,    -- [in  std_logic]
            S  => ARESET_I                      -- [in  std_logic]
          );
      end generate First_Inst;
      Other_Inst: if( I /= 0 ) generate
      begin
        FF_Inst : FDRE
          port map (
            Q  => arb_token(I),                 -- [out std_logic]
            C  => ACLK,                         -- [in  std_logic]
            D  => arb_token_new(I),             -- [in  std_logic]
            CE => arbiter_piperun_and_valid,    -- [in  std_logic]
            R  => ARESET_I                      -- [in  std_logic]
          );
      end generate Other_Inst;
      
      Multi_FF_Inst : FDRE
        port map (
          Q  => rd_port_multi_part(I),        -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => rd_port_multi_part_cmb(I),    -- [in  std_logic]
          CE => arbiter_piperun_and_valid,    -- [in  std_logic]
          R  => ARESET_I                      -- [in  std_logic]
        );
      Forbid_FF_Inst : FDRE
        port map (
          Q  => any_port_forbid(I),           -- [out std_logic]
          C  => ACLK,                         -- [in  std_logic]
          D  => any_port_forbid_cmb(I),       -- [in  std_logic]
          CE => arbiter_piperun_and_valid,    -- [in  std_logic]
          R  => ARESET_I                      -- [in  std_logic]
        );
    end generate Gen_Token;
  end generate Multi_Port;
  
  -- Assign external.
  arb_access    <= arb_access_i;
  wr_port_ready <= wr_port_ready_i;
  rd_port_ready <= rd_port_ready_i;
  ctrl_ready    <= ctrl_ready_i;
  
  Arbitration_Early_Handle : process (ACLK) is
  begin  -- process Arbitration_Early_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      if ARESET_I = '1' then                      -- synchronous reset (active high)
        arbiter_bp_push_i   <= (others=>C_NULL_WRITE_EARLY);
        
      else
        -- Default assignment.
        arbiter_bp_push_i   <= (others=>C_NULL_WRITE_EARLY);
        
        for I in 0 to C_NUM_PORTS - 1 loop
          if( arbiter_piperun_i = '1' ) then
            arbiter_bp_push_i(I).Valid    <= wr_port_ready_cmb(I);
          end if;
          arbiter_bp_push_i(I).Early    <= wr_port_early(I);
          arbiter_bp_push_i(I).Barrier  <= wr_port_barrier(I);
          
        end loop; 
      end if;
    end if;
  end process Arbitration_Early_Handle;
  
  arbiter_bp_push <= arbiter_bp_push_i;
  
  
  -----------------------------------------------------------------------------
  -- Prohibit Handle
  -----------------------------------------------------------------------------
  
  prohibit_rst  <= ARESET_I = '1';
  
  Prohibit_Handle : process (ACLK) is
  begin  -- process Prohibit_Handle
    if ACLK'event and ACLK = '1' then           -- rising clock edge
      for I in 0 to C_NUM_PORTS - 1 loop
        if prohibit_rst then                      -- synchronous reset (active high)
          arb_prohibit_read     <= (others=>'0');
          arb_prohibit_quick    <= (others=>'0');
        
        else
          if( ( rd_port_ready_cmb(I) = '1' ) and ( arbiter_piperun_i = '1' ) and 
              ( read_data_status(I).Hit_Fit = '0' or C_FAST_PORT(I) = '0' ) ) then
            arb_prohibit_read(I)  <= '1';
            arb_prohibit_quick(I) <= read_data_status(I).Hit_Fit and not C_FAST_PORT(I);
            
          elsif( ( lookup_read_done(I) = '1' ) or ( arb_prohibit_quick(I) = '1' ) )then
            arb_prohibit_read(I)  <= '0';
            arb_prohibit_quick(I) <= '0';
            
          end if;
        end if;
      end loop;
    end if;
  end process Prohibit_Handle;
  
  
  -----------------------------------------------------------------------------
  -- Statistics
  -----------------------------------------------------------------------------
  
  No_Stat: if( not C_USE_STATISTICS ) generate
  begin
    stat_arb_valid                <= C_NULL_STAT_POINT;
    stat_arb_concurrent_accesses  <= C_NULL_STAT_POINT;
    stat_arb_opt_read_blocked     <= (others=>C_NULL_STAT_POINT);
    stat_arb_gen_read_blocked     <= (others=>C_NULL_STAT_POINT);
  end generate No_Stat;
  
  Use_Stat: if( C_USE_STATISTICS ) generate
  
    signal valid_count                : natural range 0 to 2 * C_NUM_PORTS;
    signal new_arbitation             : std_logic;
    signal concurrent_valid           : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal count_time                 : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    signal time_valid                 : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
    
  begin
    Count_Active_Ports: process (wr_port_access, rd_port_access) is
      variable tmp  : natural range 0 to 2 * C_NUM_PORTS;
    begin  -- process Count_Active_Ports
      tmp := 0;
      for i in 0 to C_NUM_PORTS - 1 loop
        if( wr_port_access(i).Valid = '1' ) then
          tmp := tmp + 1;
        end if;
        if( rd_port_access(i).Valid = '1' ) then
          tmp := tmp + 1;
        end if;
      end loop; 
      valid_count <= tmp;
    end process Count_Active_Ports;
    
    Stat_Handle : process (ACLK) is
    begin  -- process Stat_Handle
      if ACLK'event and ACLK = '1' then           -- rising clock edge
        if stat_reset = '1' then                  -- synchronous reset (active high)
          new_arbitation    <= '0';
          concurrent_valid  <= (others=>'0');
          count_time        <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
          time_valid        <= (others=>'0');
          
        else
          new_arbitation    <= '0';
          
          if( arb_access_i.Valid = '1' ) then
            count_time        <= std_logic_vector(unsigned(count_time) + 1);
          end if;
          if( arbiter_piperun_i = '1' ) then
            new_arbitation    <= reduce_or(port_ready);
            concurrent_valid  <= std_logic_vector(to_unsigned(valid_count, C_STAT_COUNTER_BITS));
            count_time        <= std_logic_vector(to_unsigned(1, C_STAT_COUNTER_BITS));
            time_valid        <= count_time;
            
          end if;
        end if;
      end if;
    end process Stat_Handle;
    
    Trans_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_arbitation,
        counter                   => time_valid,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_arb_valid
      );
      
    Segment_Inst: sc_stat_counter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        
        -- Configuration.
        C_STAT_SIMPLE_COUNTER     => 0,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
      )
      port map(
        -- ---------------------------------------------------
        -- Common Signals
        
        ACLK                      => ACLK,
        ARESET                    => stat_reset,
        
        
        -- ---------------------------------------------------
        -- Counter Interface
        
        update                    => new_arbitation,
        counter                   => concurrent_valid,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_enable               => stat_enable,
        
        stat_data                 => stat_arb_concurrent_accesses
      );
      
    Gen_Prohibit: for I in 0 to C_NUM_PORTS - 1 generate
      signal port_tick            : std_logic;
      signal port_done            : std_logic;
      signal port_arbitation      : std_logic;
      signal read_block_valid     : std_logic;
      signal prohibit_cnt         : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      signal prohibit_stat        : std_logic_vector(C_STAT_COUNTER_BITS - 1 downto 0);
      signal stat_read_block      : STAT_POINT_TYPE;
    begin
      -- Detector.
      Stat_Handle : process (ACLK) is
      begin  -- process Stat_Handle
        if ACLK'event and ACLK = '1' then           -- rising clock edge
          if stat_reset = '1' then                  -- synchronous reset (active high)
            port_tick         <= '0';
            port_done         <= '0';
            port_arbitation   <= '0';
            read_block_valid  <= '0';
            prohibit_cnt      <= (others=>'0');
            prohibit_stat     <= (others=>'0');
            
          else
            port_tick         <= arbiter_piperun_i and rd_port_access(I).Valid and arb_prohibit_read(I);
            port_done         <= arbiter_piperun_i and rd_port_access(I).Valid and rd_port_ready_cmb(I);
            port_arbitation   <= port_done and read_block_valid;
            
            if( port_tick = '1' ) then
              read_block_valid  <= '1';
              prohibit_cnt      <= std_logic_vector(unsigned(prohibit_cnt) + 1);
            end if;
            if( port_done = '1' ) then
              read_block_valid  <= '0';
              prohibit_cnt      <= (others=>'0');
              prohibit_stat     <= prohibit_cnt;
            end if;
          end if;
        end if;
      end process Stat_Handle;
      
      -- Stat counter.
      Segment_Inst: sc_stat_counter
        generic map(
          -- General.
          C_TARGET                  => C_TARGET,
          
          -- Configuration.
          C_STAT_SIMPLE_COUNTER     => 0,
          C_STAT_BITS               => C_STAT_BITS,
          C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
          C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
          C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
          C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV
        )
        port map(
          -- ---------------------------------------------------
          -- Common Signals
          
          ACLK                      => ACLK,
          ARESET                    => stat_reset,
          
          
          -- ---------------------------------------------------
          -- Counter Interface
          
          update                    => port_arbitation,
          counter                   => prohibit_stat,
          
          
          -- ---------------------------------------------------
          -- Statistics Signals
          
          stat_enable               => stat_enable,
          
          stat_data                 => stat_read_block
        );
      
      -- Assign depending on category.
      Use_Opt: if( I < C_NUM_OPTIMIZED_PORTS ) generate
      begin
        stat_arb_opt_read_blocked(I)                          <= stat_read_block;
      end generate Use_Opt;
      Use_Gen: if( I >= C_NUM_OPTIMIZED_PORTS ) generate
      begin
        stat_arb_gen_read_blocked(I - C_NUM_OPTIMIZED_PORTS)  <= stat_read_block;
      end generate Use_Gen;
    end generate Gen_Prohibit;
    
  end generate Use_Stat;
  
  -----------------------------------------------------------------------------
  -- Debug 
  -----------------------------------------------------------------------------
  No_Debug: if( not C_USE_DEBUG ) generate
  begin
    ARBITER_DEBUG <= (others=>'0');
  end generate No_Debug;
  
  Use_Debug: if( C_USE_DEBUG ) generate
    constant C_MY_PORTS       : natural := 9;
    constant C_MY_PORTS_WIDTH : natural := 4;
    constant C_PART1_LEN      : natural:= 4 * C_MY_PORTS_WIDTH + 7 * C_MY_PORTS + 7;
  begin
    Debug_Handle : process (ACLK) is 
    begin  
      if ACLK'event and ACLK = '1' then     -- rising clock edge
        if (ARESET_I = '1') then              -- synchronous reset (active true)
          ARBITER_DEBUG <= (others=>'0');
        else
          -- Default assignment.
          ARBITER_DEBUG                 <= (others=>'0');
          
          -- Per port information.
          ARBITER_DEBUG( 31 downto   0) <= fit_vec(wr_port_ready_i, 32);
          ARBITER_DEBUG( 63 downto  32) <= fit_vec(rd_port_ready_i, 32);
          ARBITER_DEBUG( 95 downto  64) <= fit_vec(arb_prohibit_read, 32);
          ARBITER_DEBUG(127 downto  96) <= fit_vec(access_write_priority, 32);
          for I in 0 to C_NUM_PORTS - 1 loop
            ARBITER_DEBUG(       128 + I) <= wr_port_access(I).Valid;
            ARBITER_DEBUG(       160 + I) <= rd_port_access(I).Valid;
            ARBITER_DEBUG(       192 + I) <= read_data_status(I).Hit_Fit;
            ARBITER_DEBUG(       224 + I) <= arbiter_bp_push_i(I).Valid;
          end loop;
          ARBITER_DEBUG(287 downto 256) <= fit_vec(arb_token, 32);
          ARBITER_DEBUG(319 downto 288) <= fit_vec(lookup_read_done, 32);
          ARBITER_DEBUG(351 downto 320) <= fit_vec(any_port_forbid, 32);
          ARBITER_DEBUG(383 downto 352) <= fit_vec(arb_want_multi_part, 32);
          ARBITER_DEBUG(415 downto 384) <= fit_vec(rd_port_multi_part, 32);
          ARBITER_DEBUG(447 downto 416) <= fit_vec(arb_prohibit_quick, 32);
          ARBITER_DEBUG(479 downto 448) <= fit_vec(access_other_write_prio, 32);
          
          -- Binary representation of token.
          ARBITER_DEBUG(485 downto 480) <= std_logic_vector(to_unsigned(arb_token_cnt, 6));
          
          -- Piperun information.
          ARBITER_DEBUG(           486) <= access_piperun;
          ARBITER_DEBUG(           487) <= arbiter_piperun_and_valid;
          ARBITER_DEBUG(           488) <= opt_port_piperun;
          ARBITER_DEBUG(           489) <= all_ready;
          
          -- Ctrl information.
          ARBITER_DEBUG(           490) <= ctrl_arbiter_allow;
          ARBITER_DEBUG(           491) <= ctrl_access.Valid;
          ARBITER_DEBUG(           492) <= ctrl_ready_i;
          ARBITER_DEBUG(           493) <= dvm_2nd_part;
          
          -- Selected transaction.
          ARBITER_DEBUG(499 downto 494) <= fit_vec(arb_access_i.Port_Num, 6);
          ARBITER_DEBUG(547 downto 500) <= fit_vec(arb_access_i.Addr, 48);
          ARBITER_DEBUG(551 downto 548) <= arb_access_i.Snoop;
          ARBITER_DEBUG(553 downto 552) <= arb_access_i.Barrier;
          ARBITER_DEBUG(555 downto 554) <= arb_access_i.Domain;
          ARBITER_DEBUG(571 downto 556) <= fit_vec(arb_access_i.ID, 16);
          ARBITER_DEBUG(574 downto 572) <= arb_access_i.Prot;
          ARBITER_DEBUG(577 downto 575) <= arb_access_i.Size;
          ARBITER_DEBUG(585 downto 578) <= arb_access_i.Len;
          
          ARBITER_DEBUG(           586) <= arb_access_i.Valid;
          ARBITER_DEBUG(           587) <= arb_access_i.Wr;
          ARBITER_DEBUG(           588) <= arb_access_i.Kind;
          ARBITER_DEBUG(           589) <= arb_access_i.Exclusive;
          ARBITER_DEBUG(           590) <= arb_access_i.Allocate;
          ARBITER_DEBUG(           591) <= arb_access_i.Bufferable;
          ARBITER_DEBUG(           592) <= arb_access_i.Evict;
          ARBITER_DEBUG(           593) <= arb_access_i.Ignore_Data;
          ARBITER_DEBUG(           594) <= arb_access_i.Force_Hit;
          ARBITER_DEBUG(           595) <= arb_access_i.Internal_Cmd;
                        
          for I in 0 to C_NUM_PORTS - 1 loop
            ARBITER_DEBUG(       596 + I) <= arbiter_bp_push_i(I).Early;
          end loop;
          
        end if;
      end if;
    end process Debug_Handle;
  end generate Use_Debug;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- Detect condition
  assert_err  <= (others=>'0');
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- sc_front_end.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        sc_front_end.vhd
--
-- Description:     
--
-- VHDL-Standard:   VHDL'93/02
-------------------------------------------------------------------------------
-- Structure:   
--              sc_front_end.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

-- pragma xilinx_rtl_off
library unisim;
use unisim.vcomponents.all;
-- pragma xilinx_rtl_on

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


entity sc_front_end is
  generic (
    -- General.
    C_TARGET                  : TARGET_FAMILY_TYPE;
    C_USE_DEBUG               : boolean                       := false;
    C_USE_ASSERTIONS          : boolean                       := false;
    C_USE_STATISTICS          : boolean                       := false;
    C_STAT_OPT_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_OPT_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_GEN_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
    C_STAT_GEN_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
    C_STAT_BITS               : natural range  1 to   64      := 32;
    C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
    C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
    C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
    C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
    
    -- Common for all ports.
    C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
    
    -- Optimized AXI4 Slave Interface #0 specific.
    C_S0_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S0_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S0_AXI_ID_WIDTH         : natural                       := 1;
    C_S0_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S0_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S0_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S0_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S0_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S0_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S0_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S0_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S0_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S0_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S0_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #1 specific.
    C_S1_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S1_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S1_AXI_ID_WIDTH         : natural                       := 1;
    C_S1_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S1_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S1_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S1_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S1_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S1_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S1_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S1_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S1_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S1_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S1_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #2 specific.
    C_S2_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S2_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S2_AXI_ID_WIDTH         : natural                       := 1;
    C_S2_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S2_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S2_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S2_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S2_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S2_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S2_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S2_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S2_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S2_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S2_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #3 specific.
    C_S3_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S3_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S3_AXI_ID_WIDTH         : natural                       := 1;
    C_S3_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S3_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S3_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S3_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S3_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S3_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S3_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S3_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S3_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S3_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S3_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #4 specific.
    C_S4_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S4_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S4_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S4_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S4_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S4_AXI_ID_WIDTH         : natural                       := 1;
    C_S4_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S4_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S4_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S4_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S4_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S4_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S4_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S4_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S4_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S4_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S4_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #5 specific.
    C_S5_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S5_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S5_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S5_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S5_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S5_AXI_ID_WIDTH         : natural                       := 1;
    C_S5_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S5_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S5_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S5_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S5_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S5_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S5_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S5_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S5_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S5_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S5_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #6 specific.
    C_S6_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S6_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S6_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S6_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S6_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S6_AXI_ID_WIDTH         : natural                       := 1;
    C_S6_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S6_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S6_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S6_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S6_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S6_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S6_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S6_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S6_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S6_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S6_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #7 specific.
    C_S7_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S7_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S7_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S7_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S7_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S7_AXI_ID_WIDTH         : natural                       := 1;
    C_S7_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S7_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S7_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S7_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S7_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S7_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S7_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S7_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S7_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S7_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S7_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #8 specific.
    C_S8_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S8_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S8_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S8_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S8_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S8_AXI_ID_WIDTH         : natural                       := 1;
    C_S8_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S8_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S8_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S8_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S8_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S8_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S8_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S8_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S8_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S8_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S8_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #9 specific.
    C_S9_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S9_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S9_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S9_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S9_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S9_AXI_ID_WIDTH         : natural                       := 1;
    C_S9_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S9_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S9_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S9_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S9_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S9_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S9_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S9_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S9_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S9_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S9_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #10 specific.
    C_S10_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S10_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S10_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S10_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S10_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S10_AXI_ID_WIDTH         : natural                       := 1;
    C_S10_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S10_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S10_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S10_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S10_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S10_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S10_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S10_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S10_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S10_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S10_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #1 specific.
    C_S11_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S11_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S11_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S11_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S11_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S11_AXI_ID_WIDTH         : natural                       := 1;
    C_S11_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S11_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S11_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S11_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S11_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S11_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S11_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S11_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S11_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S11_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S11_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #12 specific.
    C_S12_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S12_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S12_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S12_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S12_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S12_AXI_ID_WIDTH         : natural                       := 1;
    C_S12_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S12_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S12_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S12_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S12_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S12_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S12_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S12_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S12_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S12_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S12_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #13 specific.
    C_S13_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S13_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S13_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S13_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S13_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S13_AXI_ID_WIDTH         : natural                       := 1;
    C_S13_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S13_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S13_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S13_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S13_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S13_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S13_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S13_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S13_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S13_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S13_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #14 specific.
    C_S14_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S14_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S14_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S14_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S14_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S14_AXI_ID_WIDTH         : natural                       := 1;
    C_S14_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S14_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S14_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S14_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S14_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S14_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S14_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S14_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S14_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S14_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S14_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #15 specific.
    C_S15_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S15_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S15_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S15_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S15_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S15_AXI_ID_WIDTH         : natural                       := 1;
    C_S15_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
    C_S15_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
    C_S15_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S15_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S15_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
    C_S15_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
    C_S15_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
    C_S15_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
    C_S15_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
    C_S15_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
    C_S15_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #0 specific.
    C_S0_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S0_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S0_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S0_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S0_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S0_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #1 specific.
    C_S1_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S1_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S1_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S1_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S1_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S1_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #2 specific.
    C_S2_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S2_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S2_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S2_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S2_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S2_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #3 specific.
    C_S3_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S3_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S3_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S3_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S3_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S3_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #4 specific.
    C_S4_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S4_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S4_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S4_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S4_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S4_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #5 specific.
    C_S5_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S5_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S5_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S5_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S5_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S5_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #6 specific.
    C_S6_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S6_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S6_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S6_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S6_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S6_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #7 specific.
    C_S7_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S7_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S7_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S7_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S7_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S7_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #8 specific.
    C_S8_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S8_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S8_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S8_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S8_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S8_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #9 specific.
    C_S9_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S9_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S9_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S9_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S9_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S9_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #10 specific.
    C_S10_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S10_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S10_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S10_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S10_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S10_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #11 specific.
    C_S11_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S11_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S11_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S11_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S11_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S11_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #12 specific.
    C_S12_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S12_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S12_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S12_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S12_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S12_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #13 specific.
    C_S13_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S13_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S13_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S13_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S13_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S13_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #14 specific.
    C_S14_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S14_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S14_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S14_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S14_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S14_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Generic AXI4 Slave Interface #15 specific.
    C_S15_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_S15_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_S15_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S15_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S15_AXI_GEN_ID_WIDTH     : natural                       := 1;
    C_S15_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
    C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
    
    -- Data type and settings specific.
    C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
    C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
    C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
    C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
    C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
    C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
    C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
    C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
    C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
    C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
    C_Lx_ADDR_REQ_HI          : natural range  2 to   63      := 27;
    C_Lx_ADDR_REQ_LO          : natural range  2 to   63      :=  7;
    C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
    C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
    C_Lx_ADDR_DATA_HI         : natural range  2 to   63      := 14;
    C_Lx_ADDR_DATA_LO         : natural range  2 to   63      :=  2;
    C_Lx_ADDR_TAG_HI          : natural range  4 to   63      := 27;
    C_Lx_ADDR_TAG_LO          : natural range  4 to   63      := 14;
    C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
    C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
    C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
    C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
    C_Lx_ADDR_WORD_HI         : natural range  2 to   63      :=  6;
    C_Lx_ADDR_WORD_LO         : natural range  2 to   63      :=  2;
    C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
    C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
    
    -- Lx Cache Specific.
    C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
    C_Lx_CACHE_SIZE           : natural                       := 1024;
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
    C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
    C_Lx_NUM_ADDR_TAG_BITS    : natural range  1 to   63      :=  8;
    
    -- System Cache Specific.
    C_PIPELINE_LU_READ_DATA   : boolean                       := false;
    C_ID_WIDTH                : natural range  1 to   32      :=  1;
    C_NUM_WAYS                : natural range  1 to    8      :=  1;
    C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_PORTS               : natural range  1 to   32      :=  1;
    C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
    C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
    C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
    C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
    C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
    C_IGNORE_MODIFIABLE       : natural range  0 to    1      :=  0;
    C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    ACLK                      : in  std_logic;
    ARESET                    : in  std_logic;

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #0 Slave Signals.
    
    S0_AXI_AWID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_AWADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
    S0_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S0_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S0_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S0_AXI_AWLOCK             : in  std_logic;
    S0_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S0_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S0_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S0_AXI_AWVALID            : in  std_logic;
    S0_AXI_AWREADY            : out std_logic;
    S0_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S0_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S0_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S0_AXI_WDATA              : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
    S0_AXI_WSTRB              : in  std_logic_vector((C_S0_AXI_DATA_WIDTH/8)-1 downto 0);
    S0_AXI_WLAST              : in  std_logic;
    S0_AXI_WVALID             : in  std_logic;
    S0_AXI_WREADY             : out std_logic;
    
    S0_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S0_AXI_BID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_BVALID             : out std_logic;
    S0_AXI_BREADY             : in  std_logic;
    S0_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S0_AXI_ARID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_ARADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
    S0_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S0_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S0_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S0_AXI_ARLOCK             : in  std_logic;
    S0_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S0_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S0_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S0_AXI_ARVALID            : in  std_logic;
    S0_AXI_ARREADY            : out std_logic;
    S0_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S0_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S0_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S0_AXI_RID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_RDATA              : out std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
    S0_AXI_RRESP              : out std_logic_vector(C_S0_AXI_RRESP_WIDTH-1 downto 0);
    S0_AXI_RLAST              : out std_logic;
    S0_AXI_RVALID             : out std_logic;
    S0_AXI_RREADY             : in  std_logic;
    S0_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S0_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S0_AXI_ACADDR             : out std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S0_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S0_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S0_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S0_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S0_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S0_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S0_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S0_AXI_CDDATA             : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S0_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S0_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #1 Slave Signals.
    
    S1_AXI_AWID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_AWADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
    S1_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S1_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S1_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S1_AXI_AWLOCK             : in  std_logic;
    S1_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S1_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S1_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S1_AXI_AWVALID            : in  std_logic;
    S1_AXI_AWREADY            : out std_logic;
    S1_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S1_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S1_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S1_AXI_WDATA              : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
    S1_AXI_WSTRB              : in  std_logic_vector((C_S1_AXI_DATA_WIDTH/8)-1 downto 0);
    S1_AXI_WLAST              : in  std_logic;
    S1_AXI_WVALID             : in  std_logic;
    S1_AXI_WREADY             : out std_logic;
    
    S1_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S1_AXI_BID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_BVALID             : out std_logic;
    S1_AXI_BREADY             : in  std_logic;
    S1_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S1_AXI_ARID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_ARADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
    S1_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S1_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S1_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S1_AXI_ARLOCK             : in  std_logic;
    S1_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S1_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S1_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S1_AXI_ARVALID            : in  std_logic;
    S1_AXI_ARREADY            : out std_logic;
    S1_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S1_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S1_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S1_AXI_RID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_RDATA              : out std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
    S1_AXI_RRESP              : out std_logic_vector(C_S1_AXI_RRESP_WIDTH-1 downto 0);
    S1_AXI_RLAST              : out std_logic;
    S1_AXI_RVALID             : out std_logic;
    S1_AXI_RREADY             : in  std_logic;
    S1_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S1_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S1_AXI_ACADDR             : out std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S1_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S1_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S1_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S1_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S1_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S1_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S1_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S1_AXI_CDDATA             : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S1_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S1_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #2 Slave Signals.
    
    S2_AXI_AWID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_AWADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
    S2_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S2_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S2_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S2_AXI_AWLOCK             : in  std_logic;
    S2_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S2_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S2_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S2_AXI_AWVALID            : in  std_logic;
    S2_AXI_AWREADY            : out std_logic;
    S2_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S2_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S2_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S2_AXI_WDATA              : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
    S2_AXI_WSTRB              : in  std_logic_vector((C_S2_AXI_DATA_WIDTH/8)-1 downto 0);
    S2_AXI_WLAST              : in  std_logic;
    S2_AXI_WVALID             : in  std_logic;
    S2_AXI_WREADY             : out std_logic;
    
    S2_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S2_AXI_BID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_BVALID             : out std_logic;
    S2_AXI_BREADY             : in  std_logic;
    S2_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S2_AXI_ARID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_ARADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
    S2_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S2_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S2_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S2_AXI_ARLOCK             : in  std_logic;
    S2_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S2_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S2_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S2_AXI_ARVALID            : in  std_logic;
    S2_AXI_ARREADY            : out std_logic;
    S2_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S2_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S2_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S2_AXI_RID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_RDATA              : out std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
    S2_AXI_RRESP              : out std_logic_vector(C_S2_AXI_RRESP_WIDTH-1 downto 0);
    S2_AXI_RLAST              : out std_logic;
    S2_AXI_RVALID             : out std_logic;
    S2_AXI_RREADY             : in  std_logic;
    S2_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S2_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S2_AXI_ACADDR             : out std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S2_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S2_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S2_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S2_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S2_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S2_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S2_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S2_AXI_CDDATA             : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S2_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S2_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #3 Slave Signals.
    
    S3_AXI_AWID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_AWADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
    S3_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S3_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S3_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S3_AXI_AWLOCK             : in  std_logic;
    S3_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S3_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S3_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S3_AXI_AWVALID            : in  std_logic;
    S3_AXI_AWREADY            : out std_logic;
    S3_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S3_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S3_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S3_AXI_WDATA              : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
    S3_AXI_WSTRB              : in  std_logic_vector((C_S3_AXI_DATA_WIDTH/8)-1 downto 0);
    S3_AXI_WLAST              : in  std_logic;
    S3_AXI_WVALID             : in  std_logic;
    S3_AXI_WREADY             : out std_logic;
    
    S3_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S3_AXI_BID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_BVALID             : out std_logic;
    S3_AXI_BREADY             : in  std_logic;
    S3_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S3_AXI_ARID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_ARADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
    S3_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S3_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S3_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S3_AXI_ARLOCK             : in  std_logic;
    S3_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S3_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S3_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S3_AXI_ARVALID            : in  std_logic;
    S3_AXI_ARREADY            : out std_logic;
    S3_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S3_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S3_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S3_AXI_RID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_RDATA              : out std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
    S3_AXI_RRESP              : out std_logic_vector(C_S3_AXI_RRESP_WIDTH-1 downto 0);
    S3_AXI_RLAST              : out std_logic;
    S3_AXI_RVALID             : out std_logic;
    S3_AXI_RREADY             : in  std_logic;
    S3_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S3_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S3_AXI_ACADDR             : out std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S3_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S3_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S3_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S3_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S3_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S3_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S3_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S3_AXI_CDDATA             : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S3_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S3_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #4 Slave Signals.
    
    S4_AXI_AWID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_AWADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
    S4_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S4_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S4_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S4_AXI_AWLOCK             : in  std_logic;
    S4_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S4_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S4_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S4_AXI_AWVALID            : in  std_logic;
    S4_AXI_AWREADY            : out std_logic;
    S4_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S4_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S4_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S4_AXI_WDATA              : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
    S4_AXI_WSTRB              : in  std_logic_vector((C_S4_AXI_DATA_WIDTH/8)-1 downto 0);
    S4_AXI_WLAST              : in  std_logic;
    S4_AXI_WVALID             : in  std_logic;
    S4_AXI_WREADY             : out std_logic;
    
    S4_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S4_AXI_BID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_BVALID             : out std_logic;
    S4_AXI_BREADY             : in  std_logic;
    S4_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S4_AXI_ARID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_ARADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
    S4_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S4_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S4_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S4_AXI_ARLOCK             : in  std_logic;
    S4_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S4_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S4_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S4_AXI_ARVALID            : in  std_logic;
    S4_AXI_ARREADY            : out std_logic;
    S4_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S4_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S4_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S4_AXI_RID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_RDATA              : out std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
    S4_AXI_RRESP              : out std_logic_vector(C_S4_AXI_RRESP_WIDTH-1 downto 0);
    S4_AXI_RLAST              : out std_logic;
    S4_AXI_RVALID             : out std_logic;
    S4_AXI_RREADY             : in  std_logic;
    S4_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S4_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S4_AXI_ACADDR             : out std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S4_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S4_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S4_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S4_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S4_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S4_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S4_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S4_AXI_CDDATA             : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S4_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S4_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #5 Slave Signals.
    
    S5_AXI_AWID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_AWADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
    S5_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S5_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S5_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S5_AXI_AWLOCK             : in  std_logic;
    S5_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S5_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S5_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S5_AXI_AWVALID            : in  std_logic;
    S5_AXI_AWREADY            : out std_logic;
    S5_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S5_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S5_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S5_AXI_WDATA              : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
    S5_AXI_WSTRB              : in  std_logic_vector((C_S5_AXI_DATA_WIDTH/8)-1 downto 0);
    S5_AXI_WLAST              : in  std_logic;
    S5_AXI_WVALID             : in  std_logic;
    S5_AXI_WREADY             : out std_logic;
    
    S5_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S5_AXI_BID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_BVALID             : out std_logic;
    S5_AXI_BREADY             : in  std_logic;
    S5_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S5_AXI_ARID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_ARADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
    S5_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S5_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S5_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S5_AXI_ARLOCK             : in  std_logic;
    S5_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S5_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S5_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S5_AXI_ARVALID            : in  std_logic;
    S5_AXI_ARREADY            : out std_logic;
    S5_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S5_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S5_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S5_AXI_RID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_RDATA              : out std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
    S5_AXI_RRESP              : out std_logic_vector(C_S5_AXI_RRESP_WIDTH-1 downto 0);
    S5_AXI_RLAST              : out std_logic;
    S5_AXI_RVALID             : out std_logic;
    S5_AXI_RREADY             : in  std_logic;
    S5_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S5_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S5_AXI_ACADDR             : out std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S5_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S5_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S5_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S5_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S5_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S5_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S5_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S5_AXI_CDDATA             : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S5_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S5_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #6 Slave Signals.
    
    S6_AXI_AWID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_AWADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
    S6_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S6_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S6_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S6_AXI_AWLOCK             : in  std_logic;
    S6_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S6_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S6_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S6_AXI_AWVALID            : in  std_logic;
    S6_AXI_AWREADY            : out std_logic;
    S6_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S6_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S6_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S6_AXI_WDATA              : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
    S6_AXI_WSTRB              : in  std_logic_vector((C_S6_AXI_DATA_WIDTH/8)-1 downto 0);
    S6_AXI_WLAST              : in  std_logic;
    S6_AXI_WVALID             : in  std_logic;
    S6_AXI_WREADY             : out std_logic;
    
    S6_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S6_AXI_BID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_BVALID             : out std_logic;
    S6_AXI_BREADY             : in  std_logic;
    S6_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S6_AXI_ARID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_ARADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
    S6_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S6_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S6_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S6_AXI_ARLOCK             : in  std_logic;
    S6_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S6_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S6_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S6_AXI_ARVALID            : in  std_logic;
    S6_AXI_ARREADY            : out std_logic;
    S6_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S6_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S6_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S6_AXI_RID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_RDATA              : out std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
    S6_AXI_RRESP              : out std_logic_vector(C_S6_AXI_RRESP_WIDTH-1 downto 0);
    S6_AXI_RLAST              : out std_logic;
    S6_AXI_RVALID             : out std_logic;
    S6_AXI_RREADY             : in  std_logic;
    S6_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S6_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S6_AXI_ACADDR             : out std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S6_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S6_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S6_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S6_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S6_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S6_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S6_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S6_AXI_CDDATA             : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S6_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S6_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #7 Slave Signals.
    
    S7_AXI_AWID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_AWADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
    S7_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S7_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S7_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S7_AXI_AWLOCK             : in  std_logic;
    S7_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S7_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S7_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S7_AXI_AWVALID            : in  std_logic;
    S7_AXI_AWREADY            : out std_logic;
    S7_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S7_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S7_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S7_AXI_WDATA              : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
    S7_AXI_WSTRB              : in  std_logic_vector((C_S7_AXI_DATA_WIDTH/8)-1 downto 0);
    S7_AXI_WLAST              : in  std_logic;
    S7_AXI_WVALID             : in  std_logic;
    S7_AXI_WREADY             : out std_logic;
    
    S7_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S7_AXI_BID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_BVALID             : out std_logic;
    S7_AXI_BREADY             : in  std_logic;
    S7_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S7_AXI_ARID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_ARADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
    S7_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S7_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S7_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S7_AXI_ARLOCK             : in  std_logic;
    S7_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S7_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S7_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S7_AXI_ARVALID            : in  std_logic;
    S7_AXI_ARREADY            : out std_logic;
    S7_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S7_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S7_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S7_AXI_RID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_RDATA              : out std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
    S7_AXI_RRESP              : out std_logic_vector(C_S7_AXI_RRESP_WIDTH-1 downto 0);
    S7_AXI_RLAST              : out std_logic;
    S7_AXI_RVALID             : out std_logic;
    S7_AXI_RREADY             : in  std_logic;
    S7_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S7_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S7_AXI_ACADDR             : out std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S7_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S7_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S7_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S7_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S7_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S7_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S7_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S7_AXI_CDDATA             : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S7_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S7_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #8 Slave Signals.
    
    S8_AXI_AWID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_AWADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
    S8_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S8_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S8_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S8_AXI_AWLOCK             : in  std_logic;
    S8_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S8_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S8_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S8_AXI_AWVALID            : in  std_logic;
    S8_AXI_AWREADY            : out std_logic;
    S8_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S8_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S8_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S8_AXI_WDATA              : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
    S8_AXI_WSTRB              : in  std_logic_vector((C_S8_AXI_DATA_WIDTH/8)-1 downto 0);
    S8_AXI_WLAST              : in  std_logic;
    S8_AXI_WVALID             : in  std_logic;
    S8_AXI_WREADY             : out std_logic;
    
    S8_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S8_AXI_BID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_BVALID             : out std_logic;
    S8_AXI_BREADY             : in  std_logic;
    S8_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S8_AXI_ARID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_ARADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
    S8_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S8_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S8_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S8_AXI_ARLOCK             : in  std_logic;
    S8_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S8_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S8_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S8_AXI_ARVALID            : in  std_logic;
    S8_AXI_ARREADY            : out std_logic;
    S8_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S8_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S8_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S8_AXI_RID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_RDATA              : out std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
    S8_AXI_RRESP              : out std_logic_vector(C_S8_AXI_RRESP_WIDTH-1 downto 0);
    S8_AXI_RLAST              : out std_logic;
    S8_AXI_RVALID             : out std_logic;
    S8_AXI_RREADY             : in  std_logic;
    S8_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S8_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S8_AXI_ACADDR             : out std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S8_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S8_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S8_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S8_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S8_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S8_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S8_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S8_AXI_CDDATA             : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S8_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S8_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #9 Slave Signals.
    
    S9_AXI_AWID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_AWADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
    S9_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S9_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S9_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S9_AXI_AWLOCK             : in  std_logic;
    S9_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S9_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S9_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S9_AXI_AWVALID            : in  std_logic;
    S9_AXI_AWREADY            : out std_logic;
    S9_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S9_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S9_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S9_AXI_WDATA              : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
    S9_AXI_WSTRB              : in  std_logic_vector((C_S9_AXI_DATA_WIDTH/8)-1 downto 0);
    S9_AXI_WLAST              : in  std_logic;
    S9_AXI_WVALID             : in  std_logic;
    S9_AXI_WREADY             : out std_logic;
    
    S9_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S9_AXI_BID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_BVALID             : out std_logic;
    S9_AXI_BREADY             : in  std_logic;
    S9_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S9_AXI_ARID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_ARADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
    S9_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S9_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S9_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S9_AXI_ARLOCK             : in  std_logic;
    S9_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S9_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S9_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S9_AXI_ARVALID            : in  std_logic;
    S9_AXI_ARREADY            : out std_logic;
    S9_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S9_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S9_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S9_AXI_RID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_RDATA              : out std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
    S9_AXI_RRESP              : out std_logic_vector(C_S9_AXI_RRESP_WIDTH-1 downto 0);
    S9_AXI_RLAST              : out std_logic;
    S9_AXI_RVALID             : out std_logic;
    S9_AXI_RREADY             : in  std_logic;
    S9_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S9_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S9_AXI_ACADDR             : out std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S9_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S9_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S9_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S9_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S9_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S9_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S9_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S9_AXI_CDDATA             : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S9_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S9_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #10 Slave Signals.
    
    S10_AXI_AWID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_AWADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
    S10_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S10_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S10_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S10_AXI_AWLOCK             : in  std_logic;
    S10_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S10_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S10_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S10_AXI_AWVALID            : in  std_logic;
    S10_AXI_AWREADY            : out std_logic;
    S10_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S10_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S10_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S10_AXI_WDATA              : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
    S10_AXI_WSTRB              : in  std_logic_vector((C_S10_AXI_DATA_WIDTH/8)-1 downto 0);
    S10_AXI_WLAST              : in  std_logic;
    S10_AXI_WVALID             : in  std_logic;
    S10_AXI_WREADY             : out std_logic;
    
    S10_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S10_AXI_BID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_BVALID             : out std_logic;
    S10_AXI_BREADY             : in  std_logic;
    S10_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S10_AXI_ARID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_ARADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
    S10_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S10_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S10_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S10_AXI_ARLOCK             : in  std_logic;
    S10_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S10_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S10_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S10_AXI_ARVALID            : in  std_logic;
    S10_AXI_ARREADY            : out std_logic;
    S10_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S10_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S10_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S10_AXI_RID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_RDATA              : out std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
    S10_AXI_RRESP              : out std_logic_vector(C_S10_AXI_RRESP_WIDTH-1 downto 0);
    S10_AXI_RLAST              : out std_logic;
    S10_AXI_RVALID             : out std_logic;
    S10_AXI_RREADY             : in  std_logic;
    S10_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S10_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S10_AXI_ACADDR             : out std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S10_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S10_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S10_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S10_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S10_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S10_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S10_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S10_AXI_CDDATA             : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S10_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S10_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #11 Slave Signals.
    
    S11_AXI_AWID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_AWADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
    S11_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S11_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S11_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S11_AXI_AWLOCK             : in  std_logic;
    S11_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S11_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S11_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S11_AXI_AWVALID            : in  std_logic;
    S11_AXI_AWREADY            : out std_logic;
    S11_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S11_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S11_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S11_AXI_WDATA              : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
    S11_AXI_WSTRB              : in  std_logic_vector((C_S11_AXI_DATA_WIDTH/8)-1 downto 0);
    S11_AXI_WLAST              : in  std_logic;
    S11_AXI_WVALID             : in  std_logic;
    S11_AXI_WREADY             : out std_logic;
    
    S11_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S11_AXI_BID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_BVALID             : out std_logic;
    S11_AXI_BREADY             : in  std_logic;
    S11_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S11_AXI_ARID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_ARADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
    S11_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S11_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S11_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S11_AXI_ARLOCK             : in  std_logic;
    S11_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S11_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S11_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S11_AXI_ARVALID            : in  std_logic;
    S11_AXI_ARREADY            : out std_logic;
    S11_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S11_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S11_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S11_AXI_RID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_RDATA              : out std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
    S11_AXI_RRESP              : out std_logic_vector(C_S11_AXI_RRESP_WIDTH-1 downto 0);
    S11_AXI_RLAST              : out std_logic;
    S11_AXI_RVALID             : out std_logic;
    S11_AXI_RREADY             : in  std_logic;
    S11_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S11_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S11_AXI_ACADDR             : out std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S11_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S11_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S11_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S11_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S11_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S11_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S11_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S11_AXI_CDDATA             : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S11_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S11_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #12 Slave Signals.
    
    S12_AXI_AWID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_AWADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
    S12_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S12_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S12_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S12_AXI_AWLOCK             : in  std_logic;
    S12_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S12_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S12_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S12_AXI_AWVALID            : in  std_logic;
    S12_AXI_AWREADY            : out std_logic;
    S12_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S12_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S12_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S12_AXI_WDATA              : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
    S12_AXI_WSTRB              : in  std_logic_vector((C_S12_AXI_DATA_WIDTH/8)-1 downto 0);
    S12_AXI_WLAST              : in  std_logic;
    S12_AXI_WVALID             : in  std_logic;
    S12_AXI_WREADY             : out std_logic;
    
    S12_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S12_AXI_BID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_BVALID             : out std_logic;
    S12_AXI_BREADY             : in  std_logic;
    S12_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S12_AXI_ARID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_ARADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
    S12_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S12_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S12_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S12_AXI_ARLOCK             : in  std_logic;
    S12_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S12_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S12_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S12_AXI_ARVALID            : in  std_logic;
    S12_AXI_ARREADY            : out std_logic;
    S12_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S12_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S12_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S12_AXI_RID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_RDATA              : out std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
    S12_AXI_RRESP              : out std_logic_vector(C_S12_AXI_RRESP_WIDTH-1 downto 0);
    S12_AXI_RLAST              : out std_logic;
    S12_AXI_RVALID             : out std_logic;
    S12_AXI_RREADY             : in  std_logic;
    S12_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S12_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S12_AXI_ACADDR             : out std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S12_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S12_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S12_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S12_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S12_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S12_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S12_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S12_AXI_CDDATA             : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S12_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S12_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #13 Slave Signals.
    
    S13_AXI_AWID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_AWADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
    S13_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S13_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S13_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S13_AXI_AWLOCK             : in  std_logic;
    S13_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S13_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S13_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S13_AXI_AWVALID            : in  std_logic;
    S13_AXI_AWREADY            : out std_logic;
    S13_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S13_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S13_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S13_AXI_WDATA              : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
    S13_AXI_WSTRB              : in  std_logic_vector((C_S13_AXI_DATA_WIDTH/8)-1 downto 0);
    S13_AXI_WLAST              : in  std_logic;
    S13_AXI_WVALID             : in  std_logic;
    S13_AXI_WREADY             : out std_logic;
    
    S13_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S13_AXI_BID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_BVALID             : out std_logic;
    S13_AXI_BREADY             : in  std_logic;
    S13_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S13_AXI_ARID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_ARADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
    S13_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S13_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S13_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S13_AXI_ARLOCK             : in  std_logic;
    S13_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S13_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S13_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S13_AXI_ARVALID            : in  std_logic;
    S13_AXI_ARREADY            : out std_logic;
    S13_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S13_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S13_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S13_AXI_RID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_RDATA              : out std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
    S13_AXI_RRESP              : out std_logic_vector(C_S13_AXI_RRESP_WIDTH-1 downto 0);
    S13_AXI_RLAST              : out std_logic;
    S13_AXI_RVALID             : out std_logic;
    S13_AXI_RREADY             : in  std_logic;
    S13_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S13_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S13_AXI_ACADDR             : out std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S13_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S13_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S13_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S13_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S13_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S13_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S13_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S13_AXI_CDDATA             : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S13_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S13_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #14 Slave Signals.
    
    S14_AXI_AWID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_AWADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
    S14_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S14_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S14_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S14_AXI_AWLOCK             : in  std_logic;
    S14_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S14_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S14_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S14_AXI_AWVALID            : in  std_logic;
    S14_AXI_AWREADY            : out std_logic;
    S14_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S14_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S14_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S14_AXI_WDATA              : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
    S14_AXI_WSTRB              : in  std_logic_vector((C_S14_AXI_DATA_WIDTH/8)-1 downto 0);
    S14_AXI_WLAST              : in  std_logic;
    S14_AXI_WVALID             : in  std_logic;
    S14_AXI_WREADY             : out std_logic;
    
    S14_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S14_AXI_BID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_BVALID             : out std_logic;
    S14_AXI_BREADY             : in  std_logic;
    S14_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S14_AXI_ARID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_ARADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
    S14_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S14_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S14_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S14_AXI_ARLOCK             : in  std_logic;
    S14_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S14_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S14_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S14_AXI_ARVALID            : in  std_logic;
    S14_AXI_ARREADY            : out std_logic;
    S14_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S14_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S14_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S14_AXI_RID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_RDATA              : out std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
    S14_AXI_RRESP              : out std_logic_vector(C_S14_AXI_RRESP_WIDTH-1 downto 0);
    S14_AXI_RLAST              : out std_logic;
    S14_AXI_RVALID             : out std_logic;
    S14_AXI_RREADY             : in  std_logic;
    S14_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S14_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S14_AXI_ACADDR             : out std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S14_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S14_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S14_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S14_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S14_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S14_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S14_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S14_AXI_CDDATA             : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S14_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S14_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #15 Slave Signals.
    
    S15_AXI_AWID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_AWADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
    S15_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S15_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S15_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S15_AXI_AWLOCK             : in  std_logic;
    S15_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S15_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S15_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S15_AXI_AWVALID            : in  std_logic;
    S15_AXI_AWREADY            : out std_logic;
    S15_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S15_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S15_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S15_AXI_WDATA              : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
    S15_AXI_WSTRB              : in  std_logic_vector((C_S15_AXI_DATA_WIDTH/8)-1 downto 0);
    S15_AXI_WLAST              : in  std_logic;
    S15_AXI_WVALID             : in  std_logic;
    S15_AXI_WREADY             : out std_logic;
    
    S15_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S15_AXI_BID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_BVALID             : out std_logic;
    S15_AXI_BREADY             : in  std_logic;
    S15_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S15_AXI_ARID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_ARADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
    S15_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S15_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S15_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S15_AXI_ARLOCK             : in  std_logic;
    S15_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S15_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S15_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S15_AXI_ARVALID            : in  std_logic;
    S15_AXI_ARREADY            : out std_logic;
    S15_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S15_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S15_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S15_AXI_RID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_RDATA              : out std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
    S15_AXI_RRESP              : out std_logic_vector(C_S15_AXI_RRESP_WIDTH-1 downto 0);
    S15_AXI_RLAST              : out std_logic;
    S15_AXI_RVALID             : out std_logic;
    S15_AXI_RREADY             : in  std_logic;
    S15_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S15_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S15_AXI_ACADDR             : out std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S15_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S15_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S15_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S15_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S15_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S15_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S15_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S15_AXI_CDDATA             : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S15_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S15_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #0 Slave Signals.
    
    S0_AXI_GEN_AWID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_AWADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S0_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S0_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S0_AXI_GEN_AWLOCK         : in  std_logic;
    S0_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_AWVALID        : in  std_logic;
    S0_AXI_GEN_AWREADY        : out std_logic;
    
    S0_AXI_GEN_WDATA          : in  std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
    S0_AXI_GEN_WSTRB          : in  std_logic_vector((C_S0_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S0_AXI_GEN_WLAST          : in  std_logic;
    S0_AXI_GEN_WVALID         : in  std_logic;
    S0_AXI_GEN_WREADY         : out std_logic;
    
    S0_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S0_AXI_GEN_BID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_BVALID         : out std_logic;
    S0_AXI_GEN_BREADY         : in  std_logic;
    
    S0_AXI_GEN_ARID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_ARADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S0_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S0_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S0_AXI_GEN_ARLOCK         : in  std_logic;
    S0_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_ARVALID        : in  std_logic;
    S0_AXI_GEN_ARREADY        : out std_logic;
    
    S0_AXI_GEN_RID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_RDATA          : out std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
    S0_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S0_AXI_GEN_RLAST          : out std_logic;
    S0_AXI_GEN_RVALID         : out std_logic;
    S0_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #1 Slave Signals.
    
    S1_AXI_GEN_AWID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_AWADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S1_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S1_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S1_AXI_GEN_AWLOCK         : in  std_logic;
    S1_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_AWVALID        : in  std_logic;
    S1_AXI_GEN_AWREADY        : out std_logic;
    
    S1_AXI_GEN_WDATA          : in  std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
    S1_AXI_GEN_WSTRB          : in  std_logic_vector((C_S1_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S1_AXI_GEN_WLAST          : in  std_logic;
    S1_AXI_GEN_WVALID         : in  std_logic;
    S1_AXI_GEN_WREADY         : out std_logic;
    
    S1_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S1_AXI_GEN_BID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_BVALID         : out std_logic;
    S1_AXI_GEN_BREADY         : in  std_logic;
    
    S1_AXI_GEN_ARID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_ARADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S1_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S1_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S1_AXI_GEN_ARLOCK         : in  std_logic;
    S1_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_ARVALID        : in  std_logic;
    S1_AXI_GEN_ARREADY        : out std_logic;
    
    S1_AXI_GEN_RID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_RDATA          : out std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
    S1_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S1_AXI_GEN_RLAST          : out std_logic;
    S1_AXI_GEN_RVALID         : out std_logic;
    S1_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #2 Slave Signals.
    
    S2_AXI_GEN_AWID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_AWADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S2_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S2_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S2_AXI_GEN_AWLOCK         : in  std_logic;
    S2_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_AWVALID        : in  std_logic;
    S2_AXI_GEN_AWREADY        : out std_logic;
    
    S2_AXI_GEN_WDATA          : in  std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
    S2_AXI_GEN_WSTRB          : in  std_logic_vector((C_S2_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S2_AXI_GEN_WLAST          : in  std_logic;
    S2_AXI_GEN_WVALID         : in  std_logic;
    S2_AXI_GEN_WREADY         : out std_logic;
    
    S2_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S2_AXI_GEN_BID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_BVALID         : out std_logic;
    S2_AXI_GEN_BREADY         : in  std_logic;
    
    S2_AXI_GEN_ARID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_ARADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S2_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S2_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S2_AXI_GEN_ARLOCK         : in  std_logic;
    S2_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_ARVALID        : in  std_logic;
    S2_AXI_GEN_ARREADY        : out std_logic;
    
    S2_AXI_GEN_RID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_RDATA          : out std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
    S2_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S2_AXI_GEN_RLAST          : out std_logic;
    S2_AXI_GEN_RVALID         : out std_logic;
    S2_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #3 Slave Signals.
    
    S3_AXI_GEN_AWID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_AWADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S3_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S3_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S3_AXI_GEN_AWLOCK         : in  std_logic;
    S3_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_AWVALID        : in  std_logic;
    S3_AXI_GEN_AWREADY        : out std_logic;
    
    S3_AXI_GEN_WDATA          : in  std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
    S3_AXI_GEN_WSTRB          : in  std_logic_vector((C_S3_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S3_AXI_GEN_WLAST          : in  std_logic;
    S3_AXI_GEN_WVALID         : in  std_logic;
    S3_AXI_GEN_WREADY         : out std_logic;
    
    S3_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S3_AXI_GEN_BID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_BVALID         : out std_logic;
    S3_AXI_GEN_BREADY         : in  std_logic;
    
    S3_AXI_GEN_ARID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_ARADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S3_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S3_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S3_AXI_GEN_ARLOCK         : in  std_logic;
    S3_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_ARVALID        : in  std_logic;
    S3_AXI_GEN_ARREADY        : out std_logic;
    
    S3_AXI_GEN_RID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_RDATA          : out std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
    S3_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S3_AXI_GEN_RLAST          : out std_logic;
    S3_AXI_GEN_RVALID         : out std_logic;
    S3_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #4 Slave Signals.
    
    S4_AXI_GEN_AWID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_AWADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S4_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S4_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S4_AXI_GEN_AWLOCK         : in  std_logic;
    S4_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_AWVALID        : in  std_logic;
    S4_AXI_GEN_AWREADY        : out std_logic;
    
    S4_AXI_GEN_WDATA          : in  std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
    S4_AXI_GEN_WSTRB          : in  std_logic_vector((C_S4_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S4_AXI_GEN_WLAST          : in  std_logic;
    S4_AXI_GEN_WVALID         : in  std_logic;
    S4_AXI_GEN_WREADY         : out std_logic;
    
    S4_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S4_AXI_GEN_BID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_BVALID         : out std_logic;
    S4_AXI_GEN_BREADY         : in  std_logic;
    
    S4_AXI_GEN_ARID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_ARADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S4_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S4_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S4_AXI_GEN_ARLOCK         : in  std_logic;
    S4_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_ARVALID        : in  std_logic;
    S4_AXI_GEN_ARREADY        : out std_logic;
    
    S4_AXI_GEN_RID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_RDATA          : out std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
    S4_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S4_AXI_GEN_RLAST          : out std_logic;
    S4_AXI_GEN_RVALID         : out std_logic;
    S4_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #5 Slave Signals.
    
    S5_AXI_GEN_AWID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_AWADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S5_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S5_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S5_AXI_GEN_AWLOCK         : in  std_logic;
    S5_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_AWVALID        : in  std_logic;
    S5_AXI_GEN_AWREADY        : out std_logic;
    
    S5_AXI_GEN_WDATA          : in  std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
    S5_AXI_GEN_WSTRB          : in  std_logic_vector((C_S5_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S5_AXI_GEN_WLAST          : in  std_logic;
    S5_AXI_GEN_WVALID         : in  std_logic;
    S5_AXI_GEN_WREADY         : out std_logic;
    
    S5_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S5_AXI_GEN_BID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_BVALID         : out std_logic;
    S5_AXI_GEN_BREADY         : in  std_logic;
    
    S5_AXI_GEN_ARID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_ARADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S5_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S5_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S5_AXI_GEN_ARLOCK         : in  std_logic;
    S5_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_ARVALID        : in  std_logic;
    S5_AXI_GEN_ARREADY        : out std_logic;
    
    S5_AXI_GEN_RID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_RDATA          : out std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
    S5_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S5_AXI_GEN_RLAST          : out std_logic;
    S5_AXI_GEN_RVALID         : out std_logic;
    S5_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #6 Slave Signals.
    
    S6_AXI_GEN_AWID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_AWADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S6_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S6_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S6_AXI_GEN_AWLOCK         : in  std_logic;
    S6_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_AWVALID        : in  std_logic;
    S6_AXI_GEN_AWREADY        : out std_logic;
    
    S6_AXI_GEN_WDATA          : in  std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
    S6_AXI_GEN_WSTRB          : in  std_logic_vector((C_S6_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S6_AXI_GEN_WLAST          : in  std_logic;
    S6_AXI_GEN_WVALID         : in  std_logic;
    S6_AXI_GEN_WREADY         : out std_logic;
    
    S6_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S6_AXI_GEN_BID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_BVALID         : out std_logic;
    S6_AXI_GEN_BREADY         : in  std_logic;
    
    S6_AXI_GEN_ARID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_ARADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S6_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S6_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S6_AXI_GEN_ARLOCK         : in  std_logic;
    S6_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_ARVALID        : in  std_logic;
    S6_AXI_GEN_ARREADY        : out std_logic;
    
    S6_AXI_GEN_RID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_RDATA          : out std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
    S6_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S6_AXI_GEN_RLAST          : out std_logic;
    S6_AXI_GEN_RVALID         : out std_logic;
    S6_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #7 Slave Signals.
    
    S7_AXI_GEN_AWID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_AWADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S7_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S7_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S7_AXI_GEN_AWLOCK         : in  std_logic;
    S7_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_AWVALID        : in  std_logic;
    S7_AXI_GEN_AWREADY        : out std_logic;
    
    S7_AXI_GEN_WDATA          : in  std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
    S7_AXI_GEN_WSTRB          : in  std_logic_vector((C_S7_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S7_AXI_GEN_WLAST          : in  std_logic;
    S7_AXI_GEN_WVALID         : in  std_logic;
    S7_AXI_GEN_WREADY         : out std_logic;
    
    S7_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S7_AXI_GEN_BID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_BVALID         : out std_logic;
    S7_AXI_GEN_BREADY         : in  std_logic;
    
    S7_AXI_GEN_ARID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_ARADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S7_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S7_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S7_AXI_GEN_ARLOCK         : in  std_logic;
    S7_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_ARVALID        : in  std_logic;
    S7_AXI_GEN_ARREADY        : out std_logic;
    
    S7_AXI_GEN_RID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_RDATA          : out std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
    S7_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S7_AXI_GEN_RLAST          : out std_logic;
    S7_AXI_GEN_RVALID         : out std_logic;
    S7_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #8 Slave Signals.
    
    S8_AXI_GEN_AWID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_AWADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S8_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S8_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S8_AXI_GEN_AWLOCK         : in  std_logic;
    S8_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_AWVALID        : in  std_logic;
    S8_AXI_GEN_AWREADY        : out std_logic;
    
    S8_AXI_GEN_WDATA          : in  std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
    S8_AXI_GEN_WSTRB          : in  std_logic_vector((C_S8_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S8_AXI_GEN_WLAST          : in  std_logic;
    S8_AXI_GEN_WVALID         : in  std_logic;
    S8_AXI_GEN_WREADY         : out std_logic;
    
    S8_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S8_AXI_GEN_BID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_BVALID         : out std_logic;
    S8_AXI_GEN_BREADY         : in  std_logic;
    
    S8_AXI_GEN_ARID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_ARADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S8_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S8_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S8_AXI_GEN_ARLOCK         : in  std_logic;
    S8_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_ARVALID        : in  std_logic;
    S8_AXI_GEN_ARREADY        : out std_logic;
    
    S8_AXI_GEN_RID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_RDATA          : out std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
    S8_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S8_AXI_GEN_RLAST          : out std_logic;
    S8_AXI_GEN_RVALID         : out std_logic;
    S8_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #9 Slave Signals.
    
    S9_AXI_GEN_AWID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_AWADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S9_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S9_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S9_AXI_GEN_AWLOCK         : in  std_logic;
    S9_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_AWVALID        : in  std_logic;
    S9_AXI_GEN_AWREADY        : out std_logic;
    
    S9_AXI_GEN_WDATA          : in  std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
    S9_AXI_GEN_WSTRB          : in  std_logic_vector((C_S9_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S9_AXI_GEN_WLAST          : in  std_logic;
    S9_AXI_GEN_WVALID         : in  std_logic;
    S9_AXI_GEN_WREADY         : out std_logic;
    
    S9_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S9_AXI_GEN_BID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_BVALID         : out std_logic;
    S9_AXI_GEN_BREADY         : in  std_logic;
    
    S9_AXI_GEN_ARID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_ARADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S9_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S9_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S9_AXI_GEN_ARLOCK         : in  std_logic;
    S9_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_ARVALID        : in  std_logic;
    S9_AXI_GEN_ARREADY        : out std_logic;
    
    S9_AXI_GEN_RID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_RDATA          : out std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
    S9_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S9_AXI_GEN_RLAST          : out std_logic;
    S9_AXI_GEN_RVALID         : out std_logic;
    S9_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #10 Slave Signals.
    
    S10_AXI_GEN_AWID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_AWADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S10_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S10_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S10_AXI_GEN_AWLOCK         : in  std_logic;
    S10_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_AWVALID        : in  std_logic;
    S10_AXI_GEN_AWREADY        : out std_logic;
    
    S10_AXI_GEN_WDATA          : in  std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
    S10_AXI_GEN_WSTRB          : in  std_logic_vector((C_S10_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S10_AXI_GEN_WLAST          : in  std_logic;
    S10_AXI_GEN_WVALID         : in  std_logic;
    S10_AXI_GEN_WREADY         : out std_logic;
    
    S10_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S10_AXI_GEN_BID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_BVALID         : out std_logic;
    S10_AXI_GEN_BREADY         : in  std_logic;
    
    S10_AXI_GEN_ARID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_ARADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S10_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S10_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S10_AXI_GEN_ARLOCK         : in  std_logic;
    S10_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_ARVALID        : in  std_logic;
    S10_AXI_GEN_ARREADY        : out std_logic;
    
    S10_AXI_GEN_RID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_RDATA          : out std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
    S10_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S10_AXI_GEN_RLAST          : out std_logic;
    S10_AXI_GEN_RVALID         : out std_logic;
    S10_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #11 Slave Signals.
    
    S11_AXI_GEN_AWID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_AWADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S11_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S11_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S11_AXI_GEN_AWLOCK         : in  std_logic;
    S11_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_AWVALID        : in  std_logic;
    S11_AXI_GEN_AWREADY        : out std_logic;
    
    S11_AXI_GEN_WDATA          : in  std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
    S11_AXI_GEN_WSTRB          : in  std_logic_vector((C_S11_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S11_AXI_GEN_WLAST          : in  std_logic;
    S11_AXI_GEN_WVALID         : in  std_logic;
    S11_AXI_GEN_WREADY         : out std_logic;
    
    S11_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S11_AXI_GEN_BID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_BVALID         : out std_logic;
    S11_AXI_GEN_BREADY         : in  std_logic;
    
    S11_AXI_GEN_ARID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_ARADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S11_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S11_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S11_AXI_GEN_ARLOCK         : in  std_logic;
    S11_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_ARVALID        : in  std_logic;
    S11_AXI_GEN_ARREADY        : out std_logic;
    
    S11_AXI_GEN_RID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_RDATA          : out std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
    S11_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S11_AXI_GEN_RLAST          : out std_logic;
    S11_AXI_GEN_RVALID         : out std_logic;
    S11_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #12 Slave Signals.
    
    S12_AXI_GEN_AWID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_AWADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S12_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S12_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S12_AXI_GEN_AWLOCK         : in  std_logic;
    S12_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_AWVALID        : in  std_logic;
    S12_AXI_GEN_AWREADY        : out std_logic;
    
    S12_AXI_GEN_WDATA          : in  std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
    S12_AXI_GEN_WSTRB          : in  std_logic_vector((C_S12_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S12_AXI_GEN_WLAST          : in  std_logic;
    S12_AXI_GEN_WVALID         : in  std_logic;
    S12_AXI_GEN_WREADY         : out std_logic;
    
    S12_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S12_AXI_GEN_BID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_BVALID         : out std_logic;
    S12_AXI_GEN_BREADY         : in  std_logic;
    
    S12_AXI_GEN_ARID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_ARADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S12_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S12_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S12_AXI_GEN_ARLOCK         : in  std_logic;
    S12_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_ARVALID        : in  std_logic;
    S12_AXI_GEN_ARREADY        : out std_logic;
    
    S12_AXI_GEN_RID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_RDATA          : out std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
    S12_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S12_AXI_GEN_RLAST          : out std_logic;
    S12_AXI_GEN_RVALID         : out std_logic;
    S12_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #13 Slave Signals.
    
    S13_AXI_GEN_AWID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_AWADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S13_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S13_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S13_AXI_GEN_AWLOCK         : in  std_logic;
    S13_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_AWVALID        : in  std_logic;
    S13_AXI_GEN_AWREADY        : out std_logic;
    
    S13_AXI_GEN_WDATA          : in  std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
    S13_AXI_GEN_WSTRB          : in  std_logic_vector((C_S13_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S13_AXI_GEN_WLAST          : in  std_logic;
    S13_AXI_GEN_WVALID         : in  std_logic;
    S13_AXI_GEN_WREADY         : out std_logic;
    
    S13_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S13_AXI_GEN_BID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_BVALID         : out std_logic;
    S13_AXI_GEN_BREADY         : in  std_logic;
    
    S13_AXI_GEN_ARID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_ARADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S13_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S13_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S13_AXI_GEN_ARLOCK         : in  std_logic;
    S13_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_ARVALID        : in  std_logic;
    S13_AXI_GEN_ARREADY        : out std_logic;
    
    S13_AXI_GEN_RID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_RDATA          : out std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
    S13_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S13_AXI_GEN_RLAST          : out std_logic;
    S13_AXI_GEN_RVALID         : out std_logic;
    S13_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #14 Slave Signals.
    
    S14_AXI_GEN_AWID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_AWADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S14_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S14_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S14_AXI_GEN_AWLOCK         : in  std_logic;
    S14_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_AWVALID        : in  std_logic;
    S14_AXI_GEN_AWREADY        : out std_logic;
    
    S14_AXI_GEN_WDATA          : in  std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
    S14_AXI_GEN_WSTRB          : in  std_logic_vector((C_S14_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S14_AXI_GEN_WLAST          : in  std_logic;
    S14_AXI_GEN_WVALID         : in  std_logic;
    S14_AXI_GEN_WREADY         : out std_logic;
    
    S14_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S14_AXI_GEN_BID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_BVALID         : out std_logic;
    S14_AXI_GEN_BREADY         : in  std_logic;
    
    S14_AXI_GEN_ARID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_ARADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S14_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S14_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S14_AXI_GEN_ARLOCK         : in  std_logic;
    S14_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_ARVALID        : in  std_logic;
    S14_AXI_GEN_ARREADY        : out std_logic;
    
    S14_AXI_GEN_RID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_RDATA          : out std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
    S14_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S14_AXI_GEN_RLAST          : out std_logic;
    S14_AXI_GEN_RVALID         : out std_logic;
    S14_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #15 Slave Signals.
    
    S15_AXI_GEN_AWID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_AWADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S15_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S15_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S15_AXI_GEN_AWLOCK         : in  std_logic;
    S15_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_AWVALID        : in  std_logic;
    S15_AXI_GEN_AWREADY        : out std_logic;
    
    S15_AXI_GEN_WDATA          : in  std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
    S15_AXI_GEN_WSTRB          : in  std_logic_vector((C_S15_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S15_AXI_GEN_WLAST          : in  std_logic;
    S15_AXI_GEN_WVALID         : in  std_logic;
    S15_AXI_GEN_WREADY         : out std_logic;
    
    S15_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S15_AXI_GEN_BID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_BVALID         : out std_logic;
    S15_AXI_GEN_BREADY         : in  std_logic;
    
    S15_AXI_GEN_ARID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_ARADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S15_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S15_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S15_AXI_GEN_ARLOCK         : in  std_logic;
    S15_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_ARVALID        : in  std_logic;
    S15_AXI_GEN_ARREADY        : out std_logic;
    
    S15_AXI_GEN_RID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_RDATA          : out std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
    S15_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S15_AXI_GEN_RLAST          : out std_logic;
    S15_AXI_GEN_RVALID         : out std_logic;
    S15_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Control If Transactions.
    
    ctrl_arbiter_allow        : in  std_logic;
    ctrl_access               : in  ARBITRATION_TYPE;
    ctrl_ready                : out std_logic;
    
    
     -- ---------------------------------------------------
     -- ACE Downstream Barrier Request.
    
    ctrl_access_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
   -- ---------------------------------------------------
    -- Lookup signals.
    
    lookup_piperun            : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    lookup_write_data_ready   : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    lookup_read_done          : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals.
    
    update_write_data_ready   : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (to Port).
    
    -- Write miss response
    update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Lookup signals (Read Data).
    
    lookup_read_data_info     : in  READ_HIT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Update signals (Read Data).
    
    update_read_data_info     : in  READ_MISS_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Access signals (to Lookup/Update).
    
    access_valid              : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    access_info               : out ACCESS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    access_data_info          : out DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_INTERNAL_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read request).
    
    lookup_read_data_new      : in  READ_SOURCE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Internal Interface Signals (Read Data).
    
    read_info_status          : out STAT_RI_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    read_data_status          : out STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
    
    -- ---------------------------------------------------
    -- Statistics Signals
    
    stat_reset                      : in  std_logic;
    stat_enable                     : in  std_logic;
    
    -- Optimized ports.
    stat_s_axi_rd_segments          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_wr_segments          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_rip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_r                    : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_bip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_bp                   : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_w                    : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_rd_latency           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wr_latency           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_rd_latency_conf      : in  STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_s_axi_wr_latency_conf      : in  STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);

    -- Generic ports.
    stat_s_axi_gen_rd_segments      : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_gen_wr_segments      : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
    stat_s_axi_gen_rip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_r                : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_bip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_bp               : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_w                : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_rd_latency       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wr_latency       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_rd_latency_conf  : in  STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    stat_s_axi_gen_wr_latency_conf  : in  STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    
    -- Arbiter
    stat_arb_valid                  : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid transactions exist
    stat_arb_concurrent_accesses    : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Transactions available each time command is arbitrated
    stat_arb_opt_read_blocked       : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    stat_arb_gen_read_blocked       : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
                                                              -- Time valid read is blocked by prohibit
    
    -- Access
    stat_access_valid               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid per transaction
    stat_access_stall               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction
    stat_access_fetch_stall         : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (fetch)
    stat_access_req_stall           : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (req)
    stat_access_act_stall           : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (act)
    
    
    -- ---------------------------------------------------
    -- Assert Signals
    
    assert_error              : out std_logic;
    
    
    -- ---------------------------------------------------
    -- Debug signals.
    
    OPT_IF0_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF1_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF2_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF3_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF4_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF5_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF6_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF7_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF8_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF9_DEBUG             : out std_logic_vector(255 downto 0);
    OPT_IF10_DEBUG            : out std_logic_vector(255 downto 0);
    OPT_IF11_DEBUG            : out std_logic_vector(255 downto 0);
    OPT_IF12_DEBUG            : out std_logic_vector(255 downto 0);
    OPT_IF13_DEBUG            : out std_logic_vector(255 downto 0);
    OPT_IF14_DEBUG            : out std_logic_vector(255 downto 0);
    OPT_IF15_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF0_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF1_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF2_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF3_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF4_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF5_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF6_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF7_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF8_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF9_DEBUG             : out std_logic_vector(255 downto 0);
    GEN_IF10_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF11_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF12_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF13_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF14_DEBUG            : out std_logic_vector(255 downto 0);
    GEN_IF15_DEBUG            : out std_logic_vector(255 downto 0);
    ARBITER_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    ACCESS_DEBUG              : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0)
  );
end entity sc_front_end;

library IEEE;
use IEEE.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;


architecture IMP of sc_front_end is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  -- 
  -- This module instantiates all AXI/ACE slave connections, both for the
  -- Optimized and Generiric ports.
  -- All slave port signals are vecotized and feed to the Arbiter where the 
  -- next transaction is selected.
  -- After that are the selected transaction forward to the Access module,
  -- where preprocessing takes place before anything is forwarded to the Cache
  -- Core.
  -- 
  --  ______________ 
  -- | Optimized  0 |
  -- |______________|\
  --  ______________  \        _____________    ______________
  -- | Optimized  1 |--++--+->| Arbiter     |->| Access       |->
  -- |______________|  /  /   |_____________|  |______________|
  --  ______________  /  /
  -- | Optimized  . |/  /
  -- |______________|  /
  --  ______________  /
  -- | Generic    0 |/
  -- |______________|
  -- 
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_PORT_0_ERROR              : natural :=  0;
  constant C_ASSERT_PORT_1_ERROR              : natural :=  1;
  constant C_ASSERT_PORT_2_ERROR              : natural :=  2;
  constant C_ASSERT_PORT_3_ERROR              : natural :=  3;
  constant C_ASSERT_PORT_4_ERROR              : natural :=  4;
  constant C_ASSERT_PORT_5_ERROR              : natural :=  5;
  constant C_ASSERT_PORT_6_ERROR              : natural :=  6;
  constant C_ASSERT_PORT_7_ERROR              : natural :=  7;
  constant C_ASSERT_PORT_8_ERROR              : natural :=  8;
  constant C_ASSERT_PORT_9_ERROR              : natural :=  9;
  constant C_ASSERT_PORT_10_ERROR             : natural := 10;
  constant C_ASSERT_PORT_11_ERROR             : natural := 11;
  constant C_ASSERT_PORT_12_ERROR             : natural := 12;
  constant C_ASSERT_PORT_13_ERROR             : natural := 13;
  constant C_ASSERT_PORT_14_ERROR             : natural := 14;
  constant C_ASSERT_PORT_15_ERROR             : natural := 15;
  constant C_ASSERT_PORT_16_ERROR             : natural := 16;
  constant C_ASSERT_PORT_17_ERROR             : natural := 17;
  constant C_ASSERT_PORT_18_ERROR             : natural := 18;
  constant C_ASSERT_PORT_19_ERROR             : natural := 19;
  constant C_ASSERT_PORT_20_ERROR             : natural := 20;
  constant C_ASSERT_PORT_21_ERROR             : natural := 21;
  constant C_ASSERT_PORT_22_ERROR             : natural := 22;
  constant C_ASSERT_PORT_23_ERROR             : natural := 23;
  constant C_ASSERT_PORT_24_ERROR             : natural := 24;
  constant C_ASSERT_PORT_25_ERROR             : natural := 25;
  constant C_ASSERT_PORT_26_ERROR             : natural := 26;
  constant C_ASSERT_PORT_27_ERROR             : natural := 27;
  constant C_ASSERT_PORT_28_ERROR             : natural := 28;
  constant C_ASSERT_PORT_29_ERROR             : natural := 29;
  constant C_ASSERT_PORT_30_ERROR             : natural := 30;
  constant C_ASSERT_PORT_31_ERROR             : natural := 31;
  constant C_ASSERT_ARBITER_ERROR             : natural := 32;
  constant C_ASSERT_ACCESS_ERROR              : natural := 33;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural := 34;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  constant C_NUM_FAST_PORTS           : natural range 0 to 16 := C_NUM_GENERIC_PORTS;
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Custom types 
  -----------------------------------------------------------------------------
  
  -- Address related.
  subtype C_ADDR_INTERNAL_POS         is natural range C_ADDR_INTERNAL_HI   downto C_ADDR_INTERNAL_LO;
  subtype C_ADDR_DIRECT_POS           is natural range C_ADDR_DIRECT_HI     downto C_ADDR_DIRECT_LO;
  subtype C_ADDR_LINE_POS             is natural range C_ADDR_LINE_HI       downto C_ADDR_LINE_LO;
  subtype C_ADDR_OFFSET_POS           is natural range C_ADDR_OFFSET_HI     downto C_ADDR_OFFSET_LO;
  subtype C_ADDR_BYTE_POS             is natural range C_ADDR_BYTE_HI       downto C_ADDR_BYTE_LO;
  
  -- Subtypes for address parts.
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  -- Subtype for ID.
  subtype ID_TYPE                     is std_logic_vector(C_ID_WIDTH - 1 downto 0);
  type ID_PORTS_TYPE                  is array(natural range <>) of ID_TYPE;
  
  
  -----------------------------------------------------------------------------
  -- Component declaration
  -----------------------------------------------------------------------------
  
  component sc_s_axi_opt_interface is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_OPT_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_OPT_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
      C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_S_AXI_ADDR_WIDTH        : natural                       := 32;
      C_S_AXI_RRESP_WIDTH       : natural range  2 to    4      :=  2;
      C_S_AXI_ID_WIDTH          : natural                       :=  1;
      C_S_AXI_SUPPORT_UNIQUE    : natural range  0 to    1      :=  1;
      C_S_AXI_SUPPORT_DIRTY     : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Data type and settings specific.
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      C_Lx_ADDR_REQ_HI          : natural range  2 to   63      := 27;
      C_Lx_ADDR_REQ_LO          : natural range  2 to   63      :=  7;
      C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
      C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
      C_Lx_ADDR_DATA_HI         : natural range  2 to   63      := 14;
      C_Lx_ADDR_DATA_LO         : natural range  2 to   63      :=  2;
      C_Lx_ADDR_TAG_HI          : natural range  4 to   63      := 27;
      C_Lx_ADDR_TAG_LO          : natural range  4 to   63      := 14;
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
      C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
      C_Lx_ADDR_WORD_HI         : natural range  2 to   63      :=  6;
      C_Lx_ADDR_WORD_LO         : natural range  2 to   63      :=  2;
      C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
      C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_SIZE           : natural                       := 1024;
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
      C_Lx_NUM_ADDR_TAG_BITS    : natural range  1 to   63      :=  8;
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_NUM_WAYS                : natural range  1 to    8      :=  1;
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_PORT_NUM                : natural range  0 to   31      :=  0;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- AW-Channel
      S_AXI_AWID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_AWADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      S_AXI_AWLEN               : in  std_logic_vector(7 downto 0);
      S_AXI_AWSIZE              : in  std_logic_vector(2 downto 0);
      S_AXI_AWBURST             : in  std_logic_vector(1 downto 0);
      S_AXI_AWLOCK              : in  std_logic;
      S_AXI_AWCACHE             : in  std_logic_vector(3 downto 0);
      S_AXI_AWPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_AWQOS               : in  std_logic_vector(3 downto 0);
      S_AXI_AWVALID             : in  std_logic;
      S_AXI_AWREADY             : out std_logic;
      S_AXI_AWDOMAIN            : in  std_logic_vector(1 downto 0);                      -- For ACE
      S_AXI_AWSNOOP             : in  std_logic_vector(2 downto 0);                      -- For ACE
      S_AXI_AWBAR               : in  std_logic_vector(1 downto 0);                      -- For ACE
  
      -- W-Channel
      S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
      S_AXI_WLAST               : in  std_logic;
      S_AXI_WVALID              : in  std_logic;
      S_AXI_WREADY              : out std_logic;
  
      -- B-Channel
      S_AXI_BRESP               : out std_logic_vector(1 downto 0);
      S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_BVALID              : out std_logic;
      S_AXI_BREADY              : in  std_logic;
      S_AXI_WACK                : in  std_logic;                                         -- For ACE
  
      -- AR-Channel
      S_AXI_ARID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_ARADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      S_AXI_ARLEN               : in  std_logic_vector(7 downto 0);
      S_AXI_ARSIZE              : in  std_logic_vector(2 downto 0);
      S_AXI_ARBURST             : in  std_logic_vector(1 downto 0);
      S_AXI_ARLOCK              : in  std_logic;
      S_AXI_ARCACHE             : in  std_logic_vector(3 downto 0);
      S_AXI_ARPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_ARQOS               : in  std_logic_vector(3 downto 0);
      S_AXI_ARVALID             : in  std_logic;
      S_AXI_ARREADY             : out std_logic;
      S_AXI_ARDOMAIN            : in  std_logic_vector(1 downto 0);                      -- For ACE
      S_AXI_ARSNOOP             : in  std_logic_vector(3 downto 0);                      -- For ACE
      S_AXI_ARBAR               : in  std_logic_vector(1 downto 0);                      -- For ACE
  
      -- R-Channel
      S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_RRESP               : out std_logic_vector(C_S_AXI_RRESP_WIDTH-1 downto 0);
      S_AXI_RLAST               : out std_logic;
      S_AXI_RVALID              : out std_logic;
      S_AXI_RREADY              : in  std_logic;
      S_AXI_RACK                : in  std_logic;                                         -- For ACE
  
      -- AC-Channel (coherency only)
      S_AXI_ACVALID             : out std_logic;                                         -- For ACE
      S_AXI_ACADDR              : out std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);   -- For ACE
      S_AXI_ACSNOOP             : out std_logic_vector(3 downto 0);                      -- For ACE
      S_AXI_ACPROT              : out std_logic_vector(2 downto 0);                      -- For ACE
      S_AXI_ACREADY             : in  std_logic;                                         -- For ACE
  
      -- CR-Channel (coherency only)
      S_AXI_CRVALID             : in  std_logic;                                         -- For ACE
      S_AXI_CRRESP              : in  std_logic_vector(4 downto 0);                      -- For ACE
      S_AXI_CRREADY             : out std_logic;                                         -- For ACE
  
      -- CD-Channel (coherency only)
      S_AXI_CDVALID             : in  std_logic;                                         -- For ACE
      S_AXI_CDDATA              : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);   -- For ACE
      S_AXI_CDLAST              : in  std_logic;                                         -- For ACE
      S_AXI_CDREADY             : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      arbiter_piperun           : in  std_logic;
      arbiter_allowed           : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            : out WRITE_PORT_TYPE;
      wr_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            : out READ_PORT_TYPE;
      rd_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Snoop communication).
      
      -- Snoop Fetch Stage Signals
      snoop_fetch_piperun       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_fetch_info          : in  SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_fetch_pos_hazard    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Request Stage Signals.
      snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_req_info            : in  SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Action Stage Signals.
      snoop_act_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_info            : in  SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_tag_info        : out SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_ack_info        : out SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Tag Information and Update Signals.
      snoop_tag_status_info     : in  SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      snoop_tag_new_info        : out SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Response Information Signals.
      snoop_resp_info           : out SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_resp_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Data Signals.
      snoop_data_info           : out SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Complete Transaction Signals.
      read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write Data).
      
      wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write response).
      
      access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      stat_s_axi_rd_segments          : out STAT_POINT_TYPE;
      stat_s_axi_wr_segments          : out STAT_POINT_TYPE;
      stat_s_axi_rip                  : out STAT_FIFO_TYPE;
      stat_s_axi_r                    : out STAT_FIFO_TYPE;
      stat_s_axi_bip                  : out STAT_FIFO_TYPE;
      stat_s_axi_bp                   : out STAT_FIFO_TYPE;
      stat_s_axi_wip                  : out STAT_FIFO_TYPE;
      stat_s_axi_w                    : out STAT_FIFO_TYPE;
      stat_s_axi_rd_latency           : out STAT_POINT_TYPE;
      stat_s_axi_wr_latency           : out STAT_POINT_TYPE;
      stat_s_axi_rd_latency_conf      : in  STAT_CONF_TYPE;
      stat_s_axi_wr_latency_conf      : in  STAT_CONF_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_opt_interface;
  
  component sc_s_axi_gen_interface is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_GEN_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_GEN_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- AXI4 Interface Specific.
      C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
      C_S_AXI_BASEADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_S_AXI_HIGHADDR          : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_S_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_S_AXI_ADDR_WIDTH        : natural                       := 32;
      C_S_AXI_ID_WIDTH          : natural                       :=  1;
      C_S_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Data type and settings specific.
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
      C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
      C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
      C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
      C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
      C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_Lx_CACHE_SIZE           : natural                       := 1024;
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
      
      -- IP Specific.
      C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
      C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0;
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_NUM_WAYS                : natural range  1 to    8      :=  1;
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_PORT_NUM                : natural range  0 to   31      :=  0;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- AXI4/ACE Slave Interface Signals.
      
      -- AW-Channel
      S_AXI_AWID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_AWADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      S_AXI_AWLEN               : in  std_logic_vector(7 downto 0);
      S_AXI_AWSIZE              : in  std_logic_vector(2 downto 0);
      S_AXI_AWBURST             : in  std_logic_vector(1 downto 0);
      S_AXI_AWLOCK              : in  std_logic;
      S_AXI_AWCACHE             : in  std_logic_vector(3 downto 0);
      S_AXI_AWPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_AWQOS               : in  std_logic_vector(3 downto 0);
      S_AXI_AWVALID             : in  std_logic;
      S_AXI_AWREADY             : out std_logic;
  
      -- W-Channel
      S_AXI_WDATA               : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_WSTRB               : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
      S_AXI_WLAST               : in  std_logic;
      S_AXI_WVALID              : in  std_logic;
      S_AXI_WREADY              : out std_logic;
  
      -- B-Channel
      S_AXI_BRESP               : out std_logic_vector(1 downto 0);
      S_AXI_BID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_BVALID              : out std_logic;
      S_AXI_BREADY              : in  std_logic;
  
      -- AR-Channel
      S_AXI_ARID                : in  std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_ARADDR              : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
      S_AXI_ARLEN               : in  std_logic_vector(7 downto 0);
      S_AXI_ARSIZE              : in  std_logic_vector(2 downto 0);
      S_AXI_ARBURST             : in  std_logic_vector(1 downto 0);
      S_AXI_ARLOCK              : in  std_logic;
      S_AXI_ARCACHE             : in  std_logic_vector(3 downto 0);
      S_AXI_ARPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_ARQOS               : in  std_logic_vector(3 downto 0);
      S_AXI_ARVALID             : in  std_logic;
      S_AXI_ARREADY             : out std_logic;
  
      -- R-Channel
      S_AXI_RID                 : out std_logic_vector(C_S_AXI_ID_WIDTH-1 downto 0);
      S_AXI_RDATA               : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
      S_AXI_RRESP               : out std_logic_vector(1 downto 0);
      S_AXI_RLAST               : out std_logic;
      S_AXI_RVALID              : out std_logic;
      S_AXI_RREADY              : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      arbiter_piperun           : in  std_logic;
      arbiter_allowed           : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            : out WRITE_PORT_TYPE;
      wr_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            : out READ_PORT_TYPE;
      rd_port_ready             : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Snoop communication).
      
      -- Snoop Fetch Stage Signals
      snoop_fetch_piperun       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_fetch_info          : in  SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_fetch_pos_hazard    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Request Stage Signals.
      snoop_req_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_req_info            : in  SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Action Stage Signals.
      snoop_act_piperun         : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_info            : in  SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_tag_info        : out SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_act_ack_info        : out SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Tag Information and Update Signals.
      snoop_tag_status_info     : in  SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      snoop_tag_new_info        : out SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Response Information Signals.
      snoop_resp_info           : out SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_resp_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Snoop Data Signals.
      snoop_data_info           : out SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      -- Complete Transaction Signals.
      read_trans_comp_info      : out READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write Data).
      
      wr_port_data_info         : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      wr_port_data_ready        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write response).
      
      access_bp_push            : in  WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : in  READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : out STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_data_status          : out STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      : in  READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      snoop_read_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     : in  READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     : in  READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      stat_s_axi_gen_rd_segments      : out STAT_POINT_TYPE; -- Per transaction
      stat_s_axi_gen_wr_segments      : out STAT_POINT_TYPE; -- Per transaction
      stat_s_axi_gen_rip              : out STAT_FIFO_TYPE;
      stat_s_axi_gen_r                : out STAT_FIFO_TYPE;
      stat_s_axi_gen_bip              : out STAT_FIFO_TYPE;
      stat_s_axi_gen_bp               : out STAT_FIFO_TYPE;
      stat_s_axi_gen_wip              : out STAT_FIFO_TYPE;
      stat_s_axi_gen_w                : out STAT_FIFO_TYPE;
      stat_s_axi_gen_rd_latency       : out STAT_POINT_TYPE;
      stat_s_axi_gen_wr_latency       : out STAT_POINT_TYPE;
      stat_s_axi_gen_rd_latency_conf  : in  STAT_CONF_TYPE;
      stat_s_axi_gen_wr_latency_conf  : in  STAT_CONF_TYPE;
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_gen_interface;
  
  component sc_arbiter is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
      C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
      C_IGNORE_MODIFIABLE       : natural range  0 to    1      :=  0;
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
      C_NUM_FAST_PORTS          : natural range  0 to   32      :=  0;
      C_NUM_PORTS               : natural range  1 to   32      :=  1
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Internal Interface Signals (All request).
      
      opt_port_piperun          : in  std_logic;
      arbiter_piperun           : out std_logic;
      arbiter_allowed           : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write request).
      
      wr_port_access            : in  WRITE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      wr_port_ready             : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      rd_port_access            : in  READ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      rd_port_ready             : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Arbiter signals (to Access).
      
      arb_access                : out ARBITRATION_TYPE;
       
       
      -- ---------------------------------------------------
      -- Control If Transactions.
      
      ctrl_arbiter_allow        : in  std_logic;
      ctrl_access               : in  ARBITRATION_TYPE;
      ctrl_ready                : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Port signals.
      
      arbiter_bp_push           : out WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      wr_port_inbound           : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Access signals.
      
      access_piperun            : in  std_logic;
      access_write_priority     : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      access_other_write_prio   : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Port signals (to Arbiter).
      
      read_data_status          : in  STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Arbiter).
      
      lookup_read_done          : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      stat_arb_valid                  : out STAT_POINT_TYPE;    -- Time valid transactions exist
      stat_arb_concurrent_accesses    : out STAT_POINT_TYPE;    -- Transactions available each time command is arbitrated
      stat_arb_opt_read_blocked       : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
      stat_arb_gen_read_blocked       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                                -- Time valid read is blocked by prohibit
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error                    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug signals.
      
      ARBITER_DEBUG                   : out MAX_DEBUG_TYPE
    );
  end component sc_arbiter;
  
  component sc_access is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
      
      -- IP Specific.
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      
      -- Data type and settings specific.
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Write Data).
      
      wr_port_data_info         : in  DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      wr_port_data_ready        : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Snoop communication).
      
      -- Snoop Fetch Stage Signals
      snoop_fetch_piperun       : out std_logic;
      snoop_fetch_info          : out SNOOP_FETCH_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_fetch_pos_hazard    : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      -- Snoop Request Stage Signals.
      snoop_req_piperun         : out std_logic;
      snoop_req_info            : out SNOOP_REQ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      -- Snoop Action Stage Signals.
      snoop_act_piperun         : out std_logic;
      snoop_act_info            : out SNOOP_ACT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_act_tag_info        : in  SNOOP_ACT_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_act_ack_info        : in  SNOOP_ACT_ACK_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
      -- Snoop Tag Information and Update Signals.
      snoop_tag_status_info     : out SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_tag_new_info        : in  SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      -- Snoop Response Information Signals.
      snoop_resp_info           : in  SNOOP_CRRESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_resp_ready          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      -- Snoop Data Signals.
      snoop_data_info           : in  SNOOP_DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_data_ready          : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      -- Complete Transaction Signals.
      read_trans_comp_info      : in  READ_COMPLETE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Arbiter signals.
      
      arb_access                : in  ARBITRATION_TYPE;
       
      arbiter_bp_push           : in  WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      wr_port_inbound           : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
       
      -- ---------------------------------------------------
      -- Lookup signals.
      
      lookup_piperun            : in  std_logic;
      
      lookup_write_data_ready   : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      update_write_data_ready   : in  std_logic_vector(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Access signals (for Arbiter).
      
      access_piperun            : out std_logic;
      access_write_priority     : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      access_other_write_prio   : out std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      access_bp_push            : out WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Access signals (to Lookup/Update).
      
      access_valid              : out std_logic;
      access_info               : out ACCESS_TYPE;
      
      access_data_info          : out DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Snoop signals (Read Data & response).
      
      snoop_read_data_info      : out READ_SNOOP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      snoop_read_data_ready     : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_access_done          : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Lx Cache Configuration
      
      lx_cfg_support_dirty      : in  std_logic_vector(C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      stat_access_valid         : out STAT_POINT_TYPE;    -- Time valid per transaction
      stat_access_stall         : out STAT_POINT_TYPE;    -- Time stalled per transaction
      stat_access_fetch_stall   : out STAT_POINT_TYPE;    -- Time stalled per transaction (fetch)
      stat_access_req_stall     : out STAT_POINT_TYPE;    -- Time stalled per transaction (req)
      stat_access_act_stall     : out STAT_POINT_TYPE;    -- Time stalled per transaction (act)
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug signals.
      
      ACCESS_DEBUG              : out MAX_DEBUG_TYPE
    );
  end component sc_access;
  
  component carry_latch_or is
    generic (
      C_TARGET  : TARGET_FAMILY_TYPE;
      C_NUM_PAD : natural;
      C_INV_C   : boolean
    );
    port (
      Carry_IN  : in  std_logic;
      A         : in  std_logic;
      O         : out std_logic;
      Carry_OUT : out std_logic
    );
  end component carry_latch_or;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Signals between Interface and Core
  
  -- Internal Interface Signals (Write response).
  signal update_ext_bresp_ready_blk    : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
  -- Lookup signals (Read Data).
  signal lookup_read_data_ready_blk    : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  signal read_data_status_i            : STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
  -- Update signals (Read Data).
  signal update_read_data_ready_blk    : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
    
  -- ----------------------------------------
  -- Signals between Interface and Arbiter
  
  -- Internal Interface Signals (All request).
  signal arbiter_piperun            : std_logic;
  signal arbiter_allowed            : std_logic;
  
  
  -- Piperun Manipulation
  signal gen_port_is_idle           : std_logic;
  signal opt_port_piperun           : std_logic;
  signal gen_port_piperun           : std_logic_vector(max_of(C_NUM_PORTS - 1, 0) downto 0);
  
  
  -- Internal Interface Signals (Write request).
  signal wr_port_access             : WRITE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
  signal wr_port_ready              : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  
  -- Internal Interface Signals (Read request).
  signal rd_port_access             : READ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
  signal rd_port_ready              : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  
  -- Internal Interface Signals (Write Data).
  signal wr_port_data_info_all      : DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal wr_port_data_ready_blk     : std_logic_vector(C_NUM_PORTS * C_CACHE_BLOCKS - 1 downto 0);
  signal wr_port_data_ready_prt     : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  
  -- Port signals (to Arbiter).
  
  
  -- ---------------------------------------------------
  -- Internal Interface Signals (Snoop communication).
  
  -- Snoop Fetch Stage Signals
  signal snoop_fetch_piperun       : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal snoop_fetch_info          : SNOOP_FETCH_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_fetch_pos_hazard_blk: std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  signal snoop_fetch_pos_hazard_prt: std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  -- Snoop Request Stage Signals.
  signal snoop_req_piperun         : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal snoop_req_info            : SNOOP_REQ_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  
  -- Snoop Action Stage Signals.
  signal snoop_act_piperun         : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal snoop_act_info            : SNOOP_ACT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_act_tag_info        : SNOOP_ACT_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_act_ack_info        : SNOOP_ACT_ACK_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  
  -- Snoop Tag Information and Update Signals.
  signal snoop_tag_status_info     : SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_tag_new_info        : SNOOP_TAG_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  
  -- Snoop Response Information Signals.
  signal snoop_resp_info           : SNOOP_CRRESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_resp_ready_blk      : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  signal snoop_resp_ready_prt      : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
    
  -- Snoop Data Signals.
  signal snoop_data_info           : SNOOP_DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_data_ready_blk      : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  signal snoop_data_ready_prt      : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
  -- Complete Transaction Signals.
  signal read_trans_comp_info      : READ_COMPLETE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
  
  -- Arbiter signals (to Access).
  signal arb_access                 : ARBITRATION_TYPE;
   
  -- Port signals.
  signal arbiter_bp_push            : WRITE_EARLY_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal wr_port_inbound            : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal access_bp_push             : WRITE_EARLY_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
    
  -- Access signals.
  signal access_piperun             : std_logic;
  signal access_write_priority      : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal access_other_write_prio    : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  signal lx_cfg_support_dirty       : std_logic_vector(C_NUM_PORTS - 1 downto 0);
  
  -- Snoop signals (Read Data & response).
  
  signal snoop_read_data_info      : READ_SNOOP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal snoop_read_data_ready_blk : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  signal snoop_read_data_ready_prt : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal port_assert_error          : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal arb_assert                 : std_logic;
  signal acs_assert                 : std_logic;
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0) := (others=>'0');
  
  
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Piperun Manipulation
  -----------------------------------------------------------------------------
  
  -- Move Generic Pipeline if it is idle
  Use_Gen_Port: if (C_NUM_GENERIC_PORTS > 0) generate
    signal pad_arbiter_piperun    : std_logic_vector(C_NUM_PORTS downto 0);
  begin
    -- Generate a dedicated Piperun for each Generic interface.
    -- It has to be a "or" of the regular Arbiter Piperun in order to pull
    -- data through the pipeline registers.
    -- I.e. the Piperun signal branches to each interface in order to bring transaction to
    -- the arbiter point even when there is no pipeline movement.
    
    -- Starting point.
    pad_arbiter_piperun(0) <= arbiter_piperun;
    
    -- The branch.
    Gen_Port: for I in 0 to C_NUM_GENERIC_PORTS - 1 generate
      signal gen_port_is_idle : std_logic;
    begin
      gen_port_is_idle  <= ( not wr_port_access(C_NUM_OPTIMIZED_PORTS + I).Valid and 
                             not rd_port_access(C_NUM_OPTIMIZED_PORTS + I).Valid );
    
      FE_PR_Latch_Inst1: carry_latch_or
        generic map(
          C_TARGET  => C_TARGET,
          C_NUM_PAD => min_of(4, I * 4),
          C_INV_C   => false
        )
        port map(
          Carry_IN  => pad_arbiter_piperun(I),
          A         => gen_port_is_idle,
          O         => gen_port_piperun(I),
          Carry_OUT => pad_arbiter_piperun(I+1)
        );
    end generate Gen_Port;
    
    -- Propagate arbiter pipeline run directly to the Optimized interfaces.
    opt_port_piperun <= pad_arbiter_piperun(C_NUM_GENERIC_PORTS);
    
  end generate Use_Gen_Port;

  No_Gen_Port: if (C_NUM_GENERIC_PORTS = 0) generate
  begin
    gen_port_piperun(0) <= arbiter_piperun;
    opt_port_piperun    <= arbiter_piperun;
  end generate No_Gen_Port;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #0
  -----------------------------------------------------------------------------
  
  Use_Port_0: if ( C_NUM_OPTIMIZED_PORTS > 0 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_0: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S0_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S0_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S0_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S0_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S0_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S0_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S0_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S0_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S0_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S0_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S0_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S0_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S0_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S0_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S0_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S0_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S0_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 0,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S0_AXI_AWID,
        S_AXI_AWADDR              => S0_AXI_AWADDR,
        S_AXI_AWLEN               => S0_AXI_AWLEN,
        S_AXI_AWSIZE              => S0_AXI_AWSIZE,
        S_AXI_AWBURST             => S0_AXI_AWBURST,
        S_AXI_AWLOCK              => S0_AXI_AWLOCK,
        S_AXI_AWCACHE             => S0_AXI_AWCACHE,
        S_AXI_AWPROT              => S0_AXI_AWPROT,
        S_AXI_AWQOS               => S0_AXI_AWQOS,
        S_AXI_AWVALID             => S0_AXI_AWVALID,
        S_AXI_AWREADY             => S0_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S0_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S0_AXI_AWSNOOP,
        S_AXI_AWBAR               => S0_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S0_AXI_WDATA,
        S_AXI_WSTRB               => S0_AXI_WSTRB,
        S_AXI_WLAST               => S0_AXI_WLAST,
        S_AXI_WVALID              => S0_AXI_WVALID,
        S_AXI_WREADY              => S0_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S0_AXI_BRESP,
        S_AXI_BID                 => S0_AXI_BID,
        S_AXI_BVALID              => S0_AXI_BVALID,
        S_AXI_BREADY              => S0_AXI_BREADY,
        S_AXI_WACK                => S0_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S0_AXI_ARID,
        S_AXI_ARADDR              => S0_AXI_ARADDR,
        S_AXI_ARLEN               => S0_AXI_ARLEN,
        S_AXI_ARSIZE              => S0_AXI_ARSIZE,
        S_AXI_ARBURST             => S0_AXI_ARBURST,
        S_AXI_ARLOCK              => S0_AXI_ARLOCK,
        S_AXI_ARCACHE             => S0_AXI_ARCACHE,
        S_AXI_ARPROT              => S0_AXI_ARPROT,
        S_AXI_ARQOS               => S0_AXI_ARQOS,
        S_AXI_ARVALID             => S0_AXI_ARVALID,
        S_AXI_ARREADY             => S0_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S0_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S0_AXI_ARSNOOP,
        S_AXI_ARBAR               => S0_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S0_AXI_RID,
        S_AXI_RDATA               => S0_AXI_RDATA,
        S_AXI_RRESP               => S0_AXI_RRESP,
        S_AXI_RLAST               => S0_AXI_RLAST,
        S_AXI_RVALID              => S0_AXI_RVALID,
        S_AXI_RREADY              => S0_AXI_RREADY,
        S_AXI_RACK                => S0_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S0_AXI_ACVALID,
        S_AXI_ACADDR              => S0_AXI_ACADDR,
        S_AXI_ACSNOOP             => S0_AXI_ACSNOOP,
        S_AXI_ACPROT              => S0_AXI_ACPROT,
        S_AXI_ACREADY             => S0_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S0_AXI_CRVALID,
        S_AXI_CRRESP              => S0_AXI_CRRESP,
        S_AXI_CRREADY             => S0_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S0_AXI_CDVALID,
        S_AXI_CDDATA              => S0_AXI_CDDATA,
        S_AXI_CDLAST              => S0_AXI_CDLAST,
        S_AXI_CDREADY             => S0_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(0),
        wr_port_ready             => wr_port_ready(0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(0),
        rd_port_ready             => rd_port_ready(0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (0 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (0 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (0 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(0),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(0),
        stat_s_axi_rip              => stat_s_axi_rip(0),
        stat_s_axi_r                => stat_s_axi_r(0),
        stat_s_axi_bip              => stat_s_axi_bip(0),
        stat_s_axi_bp               => stat_s_axi_bp(0),
        stat_s_axi_wip              => stat_s_axi_wip(0),
        stat_s_axi_w                => stat_s_axi_w(0),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(0),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(0),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(0),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(0),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(0),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF0_DEBUG 
      );
    
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 0)   <= wr_port_data_info_blk(J);
      read_info_status(J, 0)        <= read_info_status_blk(J);
      read_data_status_i(J, 0)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 0);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 0);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 0);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 0);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 0);
      access_bp_push_blk(J)         <= access_bp_push(J, 0);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 0);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 0);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 0);
      
      snoop_act_tag_info(J, 0)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 0)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 0)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 0)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 0)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 0)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(0)  <= int_to_std(C_S0_AXI_SUPPORT_DIRTY);
  end generate Use_Port_0;
  
  No_Port_0: if ( C_NUM_OPTIMIZED_PORTS < 1 ) generate
  begin
    S0_AXI_AWREADY        <= '0';
    S0_AXI_WREADY         <= '0';
    S0_AXI_BRESP          <= (others=>'0');
    S0_AXI_BID            <= (others=>'0');
    S0_AXI_BVALID         <= '0';
    S0_AXI_ARREADY        <= '0';
    S0_AXI_RID            <= (others=>'0');
    S0_AXI_RDATA          <= (others=>'0');
    S0_AXI_RRESP          <= (others=>'0');
    S0_AXI_RLAST          <= '0';
    S0_AXI_RVALID         <= '0';
    S0_AXI_ACVALID        <= '0';
    S0_AXI_ACADDR         <= (others=>'0');
    S0_AXI_ACSNOOP        <= (others=>'0');
    S0_AXI_ACPROT         <= (others=>'0');
    S0_AXI_CRREADY        <= '0';
    S0_AXI_CDREADY        <= '0';
    port_assert_error(0)  <= '0';
    OPT_IF0_DEBUG         <= (others=>'0');
  end generate No_Port_0;
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #1
  -----------------------------------------------------------------------------
  
  Use_Port_1: if ( C_NUM_OPTIMIZED_PORTS > 1 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_1: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S1_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S1_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S1_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S1_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S1_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S1_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S1_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S1_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S1_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S1_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S1_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S1_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S1_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S1_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S1_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S1_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S1_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 1,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S1_AXI_AWID,
        S_AXI_AWADDR              => S1_AXI_AWADDR,
        S_AXI_AWLEN               => S1_AXI_AWLEN,
        S_AXI_AWSIZE              => S1_AXI_AWSIZE,
        S_AXI_AWBURST             => S1_AXI_AWBURST,
        S_AXI_AWLOCK              => S1_AXI_AWLOCK,
        S_AXI_AWCACHE             => S1_AXI_AWCACHE,
        S_AXI_AWPROT              => S1_AXI_AWPROT,
        S_AXI_AWQOS               => S1_AXI_AWQOS,
        S_AXI_AWVALID             => S1_AXI_AWVALID,
        S_AXI_AWREADY             => S1_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S1_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S1_AXI_AWSNOOP,
        S_AXI_AWBAR               => S1_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S1_AXI_WDATA,
        S_AXI_WSTRB               => S1_AXI_WSTRB,
        S_AXI_WLAST               => S1_AXI_WLAST,
        S_AXI_WVALID              => S1_AXI_WVALID,
        S_AXI_WREADY              => S1_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S1_AXI_BRESP,
        S_AXI_BID                 => S1_AXI_BID,
        S_AXI_BVALID              => S1_AXI_BVALID,
        S_AXI_BREADY              => S1_AXI_BREADY,
        S_AXI_WACK                => S1_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S1_AXI_ARID,
        S_AXI_ARADDR              => S1_AXI_ARADDR,
        S_AXI_ARLEN               => S1_AXI_ARLEN,
        S_AXI_ARSIZE              => S1_AXI_ARSIZE,
        S_AXI_ARBURST             => S1_AXI_ARBURST,
        S_AXI_ARLOCK              => S1_AXI_ARLOCK,
        S_AXI_ARCACHE             => S1_AXI_ARCACHE,
        S_AXI_ARPROT              => S1_AXI_ARPROT,
        S_AXI_ARQOS               => S1_AXI_ARQOS,
        S_AXI_ARVALID             => S1_AXI_ARVALID,
        S_AXI_ARREADY             => S1_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S1_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S1_AXI_ARSNOOP,
        S_AXI_ARBAR               => S1_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S1_AXI_RID,
        S_AXI_RDATA               => S1_AXI_RDATA,
        S_AXI_RRESP               => S1_AXI_RRESP,
        S_AXI_RLAST               => S1_AXI_RLAST,
        S_AXI_RVALID              => S1_AXI_RVALID,
        S_AXI_RREADY              => S1_AXI_RREADY,
        S_AXI_RACK                => S1_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S1_AXI_ACVALID,
        S_AXI_ACADDR              => S1_AXI_ACADDR,
        S_AXI_ACSNOOP             => S1_AXI_ACSNOOP,
        S_AXI_ACPROT              => S1_AXI_ACPROT,
        S_AXI_ACREADY             => S1_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S1_AXI_CRVALID,
        S_AXI_CRRESP              => S1_AXI_CRRESP,
        S_AXI_CRREADY             => S1_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S1_AXI_CDVALID,
        S_AXI_CDDATA              => S1_AXI_CDDATA,
        S_AXI_CDLAST              => S1_AXI_CDLAST,
        S_AXI_CDREADY             => S1_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(1),
        wr_port_ready             => wr_port_ready(1),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(1),
        rd_port_ready             => rd_port_ready(1),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (1 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (1 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (1 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(1),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(1),
        stat_s_axi_rip              => stat_s_axi_rip(1),
        stat_s_axi_r                => stat_s_axi_r(1),
        stat_s_axi_bip              => stat_s_axi_bip(1),
        stat_s_axi_bp               => stat_s_axi_bp(1),
        stat_s_axi_wip              => stat_s_axi_wip(1),
        stat_s_axi_w                => stat_s_axi_w(1),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(1),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(1),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(1),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(1),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(1),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF1_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 1)   <= wr_port_data_info_blk(J);
      read_info_status(J, 1)        <= read_info_status_blk(J);
      read_data_status_i(J, 1)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 1);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 1);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 1);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 1);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 1);
      access_bp_push_blk(J)         <= access_bp_push(J, 1);

      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 1);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 1);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 1);
      
      snoop_act_tag_info(J, 1)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 1)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 1)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 1)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 1)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 1)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(1)  <= int_to_std(C_S1_AXI_SUPPORT_DIRTY);
  end generate Use_Port_1;
  
  No_Port_1: if ( C_NUM_OPTIMIZED_PORTS < 2 ) generate
  begin
    S1_AXI_AWREADY        <= '0';
    S1_AXI_WREADY         <= '0';
    S1_AXI_BRESP          <= (others=>'0');
    S1_AXI_BID            <= (others=>'0');
    S1_AXI_BVALID         <= '0';
    S1_AXI_ARREADY        <= '0';
    S1_AXI_RID            <= (others=>'0');
    S1_AXI_RDATA          <= (others=>'0');
    S1_AXI_RRESP          <= (others=>'0');
    S1_AXI_RLAST          <= '0';
    S1_AXI_RVALID         <= '0';
    S1_AXI_ACVALID        <= '0';
    S1_AXI_ACADDR         <= (others=>'0');
    S1_AXI_ACSNOOP        <= (others=>'0');
    S1_AXI_ACPROT         <= (others=>'0');
    S1_AXI_CRREADY        <= '0';
    S1_AXI_CDREADY        <= '0';
    port_assert_error(1)  <= '0';
    OPT_IF1_DEBUG         <= (others=>'0');
  end generate No_Port_1;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #2
  -----------------------------------------------------------------------------
  
  Use_Port_2: if ( C_NUM_OPTIMIZED_PORTS > 2 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_2: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S2_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S2_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S2_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S2_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S2_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S2_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S2_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S2_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S2_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S2_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S2_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S2_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S2_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S2_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S2_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S2_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S2_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 2,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S2_AXI_AWID,
        S_AXI_AWADDR              => S2_AXI_AWADDR,
        S_AXI_AWLEN               => S2_AXI_AWLEN,
        S_AXI_AWSIZE              => S2_AXI_AWSIZE,
        S_AXI_AWBURST             => S2_AXI_AWBURST,
        S_AXI_AWLOCK              => S2_AXI_AWLOCK,
        S_AXI_AWCACHE             => S2_AXI_AWCACHE,
        S_AXI_AWPROT              => S2_AXI_AWPROT,
        S_AXI_AWQOS               => S2_AXI_AWQOS,
        S_AXI_AWVALID             => S2_AXI_AWVALID,
        S_AXI_AWREADY             => S2_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S2_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S2_AXI_AWSNOOP,
        S_AXI_AWBAR               => S2_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S2_AXI_WDATA,
        S_AXI_WSTRB               => S2_AXI_WSTRB,
        S_AXI_WLAST               => S2_AXI_WLAST,
        S_AXI_WVALID              => S2_AXI_WVALID,
        S_AXI_WREADY              => S2_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S2_AXI_BRESP,
        S_AXI_BID                 => S2_AXI_BID,
        S_AXI_BVALID              => S2_AXI_BVALID,
        S_AXI_BREADY              => S2_AXI_BREADY,
        S_AXI_WACK                => S2_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S2_AXI_ARID,
        S_AXI_ARADDR              => S2_AXI_ARADDR,
        S_AXI_ARLEN               => S2_AXI_ARLEN,
        S_AXI_ARSIZE              => S2_AXI_ARSIZE,
        S_AXI_ARBURST             => S2_AXI_ARBURST,
        S_AXI_ARLOCK              => S2_AXI_ARLOCK,
        S_AXI_ARCACHE             => S2_AXI_ARCACHE,
        S_AXI_ARPROT              => S2_AXI_ARPROT,
        S_AXI_ARQOS               => S2_AXI_ARQOS,
        S_AXI_ARVALID             => S2_AXI_ARVALID,
        S_AXI_ARREADY             => S2_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S2_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S2_AXI_ARSNOOP,
        S_AXI_ARBAR               => S2_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S2_AXI_RID,
        S_AXI_RDATA               => S2_AXI_RDATA,
        S_AXI_RRESP               => S2_AXI_RRESP,
        S_AXI_RLAST               => S2_AXI_RLAST,
        S_AXI_RVALID              => S2_AXI_RVALID,
        S_AXI_RREADY              => S2_AXI_RREADY,
        S_AXI_RACK                => S2_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S2_AXI_ACVALID,
        S_AXI_ACADDR              => S2_AXI_ACADDR,
        S_AXI_ACSNOOP             => S2_AXI_ACSNOOP,
        S_AXI_ACPROT              => S2_AXI_ACPROT,
        S_AXI_ACREADY             => S2_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S2_AXI_CRVALID,
        S_AXI_CRRESP              => S2_AXI_CRRESP,
        S_AXI_CRREADY             => S2_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S2_AXI_CDVALID,
        S_AXI_CDDATA              => S2_AXI_CDDATA,
        S_AXI_CDLAST              => S2_AXI_CDLAST,
        S_AXI_CDREADY             => S2_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(2),
        wr_port_ready             => wr_port_ready(2),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(2),
        rd_port_ready             => rd_port_ready(2),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (2 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (2 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (2 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(2),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(2),
        stat_s_axi_rip              => stat_s_axi_rip(2),
        stat_s_axi_r                => stat_s_axi_r(2),
        stat_s_axi_bip              => stat_s_axi_bip(2),
        stat_s_axi_bp               => stat_s_axi_bp(2),
        stat_s_axi_wip              => stat_s_axi_wip(2),
        stat_s_axi_w                => stat_s_axi_w(2),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(2),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(2),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(2),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(2),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(2),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF2_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 2)   <= wr_port_data_info_blk(J);
      read_info_status(J, 2)        <= read_info_status_blk(J);
      read_data_status_i(J, 2)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 2);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 2);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 2);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 2);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 2);
      access_bp_push_blk(J)         <= access_bp_push(J, 2);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 2);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 2);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 2);
      
      snoop_act_tag_info(J, 2)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 2)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 2)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 2)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 2)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 2)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(2)  <= int_to_std(C_S2_AXI_SUPPORT_DIRTY);
  end generate Use_Port_2;
  
  No_Port_2: if ( C_NUM_OPTIMIZED_PORTS < 3 ) generate
  begin
    S2_AXI_AWREADY        <= '0';
    S2_AXI_WREADY         <= '0';
    S2_AXI_BRESP          <= (others=>'0');
    S2_AXI_BID            <= (others=>'0');
    S2_AXI_BVALID         <= '0';
    S2_AXI_ARREADY        <= '0';
    S2_AXI_RID            <= (others=>'0');
    S2_AXI_RDATA          <= (others=>'0');
    S2_AXI_RRESP          <= (others=>'0');
    S2_AXI_RLAST          <= '0';
    S2_AXI_RVALID         <= '0';
    S2_AXI_ACVALID        <= '0';
    S2_AXI_ACADDR         <= (others=>'0');
    S2_AXI_ACSNOOP        <= (others=>'0');
    S2_AXI_ACPROT         <= (others=>'0');
    S2_AXI_CRREADY        <= '0';
    S2_AXI_CDREADY        <= '0';
    port_assert_error(2)  <= '0';
    OPT_IF2_DEBUG         <= (others=>'0');
  end generate No_Port_2;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #3
  -----------------------------------------------------------------------------
  
  Use_Port_3: if ( C_NUM_OPTIMIZED_PORTS > 3 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_3: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S3_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S3_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S3_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S3_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S3_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S3_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S3_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S3_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S3_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S3_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S3_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S3_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S3_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S3_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S3_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S3_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S3_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 3,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S3_AXI_AWID,
        S_AXI_AWADDR              => S3_AXI_AWADDR,
        S_AXI_AWLEN               => S3_AXI_AWLEN,
        S_AXI_AWSIZE              => S3_AXI_AWSIZE,
        S_AXI_AWBURST             => S3_AXI_AWBURST,
        S_AXI_AWLOCK              => S3_AXI_AWLOCK,
        S_AXI_AWCACHE             => S3_AXI_AWCACHE,
        S_AXI_AWPROT              => S3_AXI_AWPROT,
        S_AXI_AWQOS               => S3_AXI_AWQOS,
        S_AXI_AWVALID             => S3_AXI_AWVALID,
        S_AXI_AWREADY             => S3_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S3_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S3_AXI_AWSNOOP,
        S_AXI_AWBAR               => S3_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S3_AXI_WDATA,
        S_AXI_WSTRB               => S3_AXI_WSTRB,
        S_AXI_WLAST               => S3_AXI_WLAST,
        S_AXI_WVALID              => S3_AXI_WVALID,
        S_AXI_WREADY              => S3_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S3_AXI_BRESP,
        S_AXI_BID                 => S3_AXI_BID,
        S_AXI_BVALID              => S3_AXI_BVALID,
        S_AXI_BREADY              => S3_AXI_BREADY,
        S_AXI_WACK                => S3_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S3_AXI_ARID,
        S_AXI_ARADDR              => S3_AXI_ARADDR,
        S_AXI_ARLEN               => S3_AXI_ARLEN,
        S_AXI_ARSIZE              => S3_AXI_ARSIZE,
        S_AXI_ARBURST             => S3_AXI_ARBURST,
        S_AXI_ARLOCK              => S3_AXI_ARLOCK,
        S_AXI_ARCACHE             => S3_AXI_ARCACHE,
        S_AXI_ARPROT              => S3_AXI_ARPROT,
        S_AXI_ARQOS               => S3_AXI_ARQOS,
        S_AXI_ARVALID             => S3_AXI_ARVALID,
        S_AXI_ARREADY             => S3_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S3_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S3_AXI_ARSNOOP,
        S_AXI_ARBAR               => S3_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S3_AXI_RID,
        S_AXI_RDATA               => S3_AXI_RDATA,
        S_AXI_RRESP               => S3_AXI_RRESP,
        S_AXI_RLAST               => S3_AXI_RLAST,
        S_AXI_RVALID              => S3_AXI_RVALID,
        S_AXI_RREADY              => S3_AXI_RREADY,
        S_AXI_RACK                => S3_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S3_AXI_ACVALID,
        S_AXI_ACADDR              => S3_AXI_ACADDR,
        S_AXI_ACSNOOP             => S3_AXI_ACSNOOP,
        S_AXI_ACPROT              => S3_AXI_ACPROT,
        S_AXI_ACREADY             => S3_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S3_AXI_CRVALID,
        S_AXI_CRRESP              => S3_AXI_CRRESP,
        S_AXI_CRREADY             => S3_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S3_AXI_CDVALID,
        S_AXI_CDDATA              => S3_AXI_CDDATA,
        S_AXI_CDLAST              => S3_AXI_CDLAST,
        S_AXI_CDREADY             => S3_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(3),
        wr_port_ready             => wr_port_ready(3),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(3),
        rd_port_ready             => rd_port_ready(3),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (3 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (3 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (3 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(3),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(3),
        stat_s_axi_rip              => stat_s_axi_rip(3),
        stat_s_axi_r                => stat_s_axi_r(3),
        stat_s_axi_bip              => stat_s_axi_bip(3),
        stat_s_axi_bp               => stat_s_axi_bp(3),
        stat_s_axi_wip              => stat_s_axi_wip(3),
        stat_s_axi_w                => stat_s_axi_w(3),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(3),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(3),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(3),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(3),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(3),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF3_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 3)   <= wr_port_data_info_blk(J);
      read_info_status(J, 3)        <= read_info_status_blk(J);
      read_data_status_i(J, 3)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 3);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 3);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 3);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 3);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 3);
      access_bp_push_blk(J)         <= access_bp_push(J, 3);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 3);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 3);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 3);
      
      snoop_act_tag_info(J, 3)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 3)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 3)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 3)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 3)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 3)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(3)  <= int_to_std(C_S3_AXI_SUPPORT_DIRTY);
  end generate Use_Port_3;
  
  No_Port_3: if ( C_NUM_OPTIMIZED_PORTS < 4 ) generate
  begin
    S3_AXI_AWREADY        <= '0';
    S3_AXI_WREADY         <= '0';
    S3_AXI_BRESP          <= (others=>'0');
    S3_AXI_BID            <= (others=>'0');
    S3_AXI_BVALID         <= '0';
    S3_AXI_ARREADY        <= '0';
    S3_AXI_RID            <= (others=>'0');
    S3_AXI_RDATA          <= (others=>'0');
    S3_AXI_RRESP          <= (others=>'0');
    S3_AXI_RLAST          <= '0';
    S3_AXI_RVALID         <= '0';
    S3_AXI_ACVALID        <= '0';
    S3_AXI_ACADDR         <= (others=>'0');
    S3_AXI_ACSNOOP        <= (others=>'0');
    S3_AXI_ACPROT         <= (others=>'0');
    S3_AXI_CRREADY        <= '0';
    S3_AXI_CDREADY        <= '0';
    port_assert_error(3)  <= '0';
    OPT_IF3_DEBUG         <= (others=>'0');
  end generate No_Port_3;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #4
  -----------------------------------------------------------------------------
  
  Use_Port_4: if ( C_NUM_OPTIMIZED_PORTS > 4 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_4: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S4_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S4_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S4_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S4_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S4_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S4_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S4_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S4_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S4_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S4_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S4_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S4_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S4_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S4_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S4_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S4_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S4_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 4,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S4_AXI_AWID,
        S_AXI_AWADDR              => S4_AXI_AWADDR,
        S_AXI_AWLEN               => S4_AXI_AWLEN,
        S_AXI_AWSIZE              => S4_AXI_AWSIZE,
        S_AXI_AWBURST             => S4_AXI_AWBURST,
        S_AXI_AWLOCK              => S4_AXI_AWLOCK,
        S_AXI_AWCACHE             => S4_AXI_AWCACHE,
        S_AXI_AWPROT              => S4_AXI_AWPROT,
        S_AXI_AWQOS               => S4_AXI_AWQOS,
        S_AXI_AWVALID             => S4_AXI_AWVALID,
        S_AXI_AWREADY             => S4_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S4_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S4_AXI_AWSNOOP,
        S_AXI_AWBAR               => S4_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S4_AXI_WDATA,
        S_AXI_WSTRB               => S4_AXI_WSTRB,
        S_AXI_WLAST               => S4_AXI_WLAST,
        S_AXI_WVALID              => S4_AXI_WVALID,
        S_AXI_WREADY              => S4_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S4_AXI_BRESP,
        S_AXI_BID                 => S4_AXI_BID,
        S_AXI_BVALID              => S4_AXI_BVALID,
        S_AXI_BREADY              => S4_AXI_BREADY,
        S_AXI_WACK                => S4_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S4_AXI_ARID,
        S_AXI_ARADDR              => S4_AXI_ARADDR,
        S_AXI_ARLEN               => S4_AXI_ARLEN,
        S_AXI_ARSIZE              => S4_AXI_ARSIZE,
        S_AXI_ARBURST             => S4_AXI_ARBURST,
        S_AXI_ARLOCK              => S4_AXI_ARLOCK,
        S_AXI_ARCACHE             => S4_AXI_ARCACHE,
        S_AXI_ARPROT              => S4_AXI_ARPROT,
        S_AXI_ARQOS               => S4_AXI_ARQOS,
        S_AXI_ARVALID             => S4_AXI_ARVALID,
        S_AXI_ARREADY             => S4_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S4_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S4_AXI_ARSNOOP,
        S_AXI_ARBAR               => S4_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S4_AXI_RID,
        S_AXI_RDATA               => S4_AXI_RDATA,
        S_AXI_RRESP               => S4_AXI_RRESP,
        S_AXI_RLAST               => S4_AXI_RLAST,
        S_AXI_RVALID              => S4_AXI_RVALID,
        S_AXI_RREADY              => S4_AXI_RREADY,
        S_AXI_RACK                => S4_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S4_AXI_ACVALID,
        S_AXI_ACADDR              => S4_AXI_ACADDR,
        S_AXI_ACSNOOP             => S4_AXI_ACSNOOP,
        S_AXI_ACPROT              => S4_AXI_ACPROT,
        S_AXI_ACREADY             => S4_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S4_AXI_CRVALID,
        S_AXI_CRRESP              => S4_AXI_CRRESP,
        S_AXI_CRREADY             => S4_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S4_AXI_CDVALID,
        S_AXI_CDDATA              => S4_AXI_CDDATA,
        S_AXI_CDLAST              => S4_AXI_CDLAST,
        S_AXI_CDREADY             => S4_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(4),
        wr_port_ready             => wr_port_ready(4),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(4),
        rd_port_ready             => rd_port_ready(4),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (4 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (4 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (4 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(4),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(4),
        stat_s_axi_rip              => stat_s_axi_rip(4),
        stat_s_axi_r                => stat_s_axi_r(4),
        stat_s_axi_bip              => stat_s_axi_bip(4),
        stat_s_axi_bp               => stat_s_axi_bp(4),
        stat_s_axi_wip              => stat_s_axi_wip(4),
        stat_s_axi_w                => stat_s_axi_w(4),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(4),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(4),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(4),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(4),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(4),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF4_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 4)   <= wr_port_data_info_blk(J);
      read_info_status(J, 4)        <= read_info_status_blk(J);
      read_data_status_i(J, 4)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 4);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 4);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 4);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 4);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 4);
      access_bp_push_blk(J)         <= access_bp_push(J, 4);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 4);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 4);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 4);
      
      snoop_act_tag_info(J, 4)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 4)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 4)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 4)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 4)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 4)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(4)  <= int_to_std(C_S4_AXI_SUPPORT_DIRTY);
  end generate Use_Port_4;
  
  No_Port_4: if ( C_NUM_OPTIMIZED_PORTS < 5 ) generate
  begin
    S4_AXI_AWREADY        <= '0';
    S4_AXI_WREADY         <= '0';
    S4_AXI_BRESP          <= (others=>'0');
    S4_AXI_BID            <= (others=>'0');
    S4_AXI_BVALID         <= '0';
    S4_AXI_ARREADY        <= '0';
    S4_AXI_RID            <= (others=>'0');
    S4_AXI_RDATA          <= (others=>'0');
    S4_AXI_RRESP          <= (others=>'0');
    S4_AXI_RLAST          <= '0';
    S4_AXI_RVALID         <= '0';
    S4_AXI_ACVALID        <= '0';
    S4_AXI_ACADDR         <= (others=>'0');
    S4_AXI_ACSNOOP        <= (others=>'0');
    S4_AXI_ACPROT         <= (others=>'0');
    S4_AXI_CRREADY        <= '0';
    S4_AXI_CDREADY        <= '0';
    port_assert_error(4)  <= '0';
    OPT_IF4_DEBUG         <= (others=>'0');
  end generate No_Port_4;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #5
  -----------------------------------------------------------------------------
  
  Use_Port_5: if ( C_NUM_OPTIMIZED_PORTS > 5 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_5: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S5_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S5_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S5_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S5_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S5_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S5_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S5_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S5_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S5_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S5_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S5_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S5_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S5_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S5_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S5_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S5_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S5_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 5,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S5_AXI_AWID,
        S_AXI_AWADDR              => S5_AXI_AWADDR,
        S_AXI_AWLEN               => S5_AXI_AWLEN,
        S_AXI_AWSIZE              => S5_AXI_AWSIZE,
        S_AXI_AWBURST             => S5_AXI_AWBURST,
        S_AXI_AWLOCK              => S5_AXI_AWLOCK,
        S_AXI_AWCACHE             => S5_AXI_AWCACHE,
        S_AXI_AWPROT              => S5_AXI_AWPROT,
        S_AXI_AWQOS               => S5_AXI_AWQOS,
        S_AXI_AWVALID             => S5_AXI_AWVALID,
        S_AXI_AWREADY             => S5_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S5_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S5_AXI_AWSNOOP,
        S_AXI_AWBAR               => S5_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S5_AXI_WDATA,
        S_AXI_WSTRB               => S5_AXI_WSTRB,
        S_AXI_WLAST               => S5_AXI_WLAST,
        S_AXI_WVALID              => S5_AXI_WVALID,
        S_AXI_WREADY              => S5_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S5_AXI_BRESP,
        S_AXI_BID                 => S5_AXI_BID,
        S_AXI_BVALID              => S5_AXI_BVALID,
        S_AXI_BREADY              => S5_AXI_BREADY,
        S_AXI_WACK                => S5_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S5_AXI_ARID,
        S_AXI_ARADDR              => S5_AXI_ARADDR,
        S_AXI_ARLEN               => S5_AXI_ARLEN,
        S_AXI_ARSIZE              => S5_AXI_ARSIZE,
        S_AXI_ARBURST             => S5_AXI_ARBURST,
        S_AXI_ARLOCK              => S5_AXI_ARLOCK,
        S_AXI_ARCACHE             => S5_AXI_ARCACHE,
        S_AXI_ARPROT              => S5_AXI_ARPROT,
        S_AXI_ARQOS               => S5_AXI_ARQOS,
        S_AXI_ARVALID             => S5_AXI_ARVALID,
        S_AXI_ARREADY             => S5_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S5_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S5_AXI_ARSNOOP,
        S_AXI_ARBAR               => S5_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S5_AXI_RID,
        S_AXI_RDATA               => S5_AXI_RDATA,
        S_AXI_RRESP               => S5_AXI_RRESP,
        S_AXI_RLAST               => S5_AXI_RLAST,
        S_AXI_RVALID              => S5_AXI_RVALID,
        S_AXI_RREADY              => S5_AXI_RREADY,
        S_AXI_RACK                => S5_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S5_AXI_ACVALID,
        S_AXI_ACADDR              => S5_AXI_ACADDR,
        S_AXI_ACSNOOP             => S5_AXI_ACSNOOP,
        S_AXI_ACPROT              => S5_AXI_ACPROT,
        S_AXI_ACREADY             => S5_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S5_AXI_CRVALID,
        S_AXI_CRRESP              => S5_AXI_CRRESP,
        S_AXI_CRREADY             => S5_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S5_AXI_CDVALID,
        S_AXI_CDDATA              => S5_AXI_CDDATA,
        S_AXI_CDLAST              => S5_AXI_CDLAST,
        S_AXI_CDREADY             => S5_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(5),
        wr_port_ready             => wr_port_ready(5),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(5),
        rd_port_ready             => rd_port_ready(5),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (5 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (5 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (5 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(5),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(5),
        stat_s_axi_rip              => stat_s_axi_rip(5),
        stat_s_axi_r                => stat_s_axi_r(5),
        stat_s_axi_bip              => stat_s_axi_bip(5),
        stat_s_axi_bp               => stat_s_axi_bp(5),
        stat_s_axi_wip              => stat_s_axi_wip(5),
        stat_s_axi_w                => stat_s_axi_w(5),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(5),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(5),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(5),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(5),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(5),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF5_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 5)   <= wr_port_data_info_blk(J);
      read_info_status(J, 5)        <= read_info_status_blk(J);
      read_data_status_i(J, 5)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 5);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 5);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 5);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 5);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 5);
      access_bp_push_blk(J)         <= access_bp_push(J, 5);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 5);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 5);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 5);
      
      snoop_act_tag_info(J, 5)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 5)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 5)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 5)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 5)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 5)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(5)  <= int_to_std(C_S5_AXI_SUPPORT_DIRTY);
  end generate Use_Port_5;
  
  No_Port_5: if ( C_NUM_OPTIMIZED_PORTS < 6 ) generate
  begin
    S5_AXI_AWREADY        <= '0';
    S5_AXI_WREADY         <= '0';
    S5_AXI_BRESP          <= (others=>'0');
    S5_AXI_BID            <= (others=>'0');
    S5_AXI_BVALID         <= '0';
    S5_AXI_ARREADY        <= '0';
    S5_AXI_RID            <= (others=>'0');
    S5_AXI_RDATA          <= (others=>'0');
    S5_AXI_RRESP          <= (others=>'0');
    S5_AXI_RLAST          <= '0';
    S5_AXI_RVALID         <= '0';
    S5_AXI_ACVALID        <= '0';
    S5_AXI_ACADDR         <= (others=>'0');
    S5_AXI_ACSNOOP        <= (others=>'0');
    S5_AXI_ACPROT         <= (others=>'0');
    S5_AXI_CRREADY        <= '0';
    S5_AXI_CDREADY        <= '0';
    port_assert_error(5)  <= '0';
    OPT_IF5_DEBUG         <= (others=>'0');
  end generate No_Port_5;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #6
  -----------------------------------------------------------------------------
  
  Use_Port_6: if ( C_NUM_OPTIMIZED_PORTS > 6 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_6: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S6_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S6_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S6_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S6_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S6_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S6_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S6_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S6_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S6_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S6_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S6_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S6_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S6_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S6_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S6_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S6_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S6_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 6,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S6_AXI_AWID,
        S_AXI_AWADDR              => S6_AXI_AWADDR,
        S_AXI_AWLEN               => S6_AXI_AWLEN,
        S_AXI_AWSIZE              => S6_AXI_AWSIZE,
        S_AXI_AWBURST             => S6_AXI_AWBURST,
        S_AXI_AWLOCK              => S6_AXI_AWLOCK,
        S_AXI_AWCACHE             => S6_AXI_AWCACHE,
        S_AXI_AWPROT              => S6_AXI_AWPROT,
        S_AXI_AWQOS               => S6_AXI_AWQOS,
        S_AXI_AWVALID             => S6_AXI_AWVALID,
        S_AXI_AWREADY             => S6_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S6_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S6_AXI_AWSNOOP,
        S_AXI_AWBAR               => S6_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S6_AXI_WDATA,
        S_AXI_WSTRB               => S6_AXI_WSTRB,
        S_AXI_WLAST               => S6_AXI_WLAST,
        S_AXI_WVALID              => S6_AXI_WVALID,
        S_AXI_WREADY              => S6_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S6_AXI_BRESP,
        S_AXI_BID                 => S6_AXI_BID,
        S_AXI_BVALID              => S6_AXI_BVALID,
        S_AXI_BREADY              => S6_AXI_BREADY,
        S_AXI_WACK                => S6_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S6_AXI_ARID,
        S_AXI_ARADDR              => S6_AXI_ARADDR,
        S_AXI_ARLEN               => S6_AXI_ARLEN,
        S_AXI_ARSIZE              => S6_AXI_ARSIZE,
        S_AXI_ARBURST             => S6_AXI_ARBURST,
        S_AXI_ARLOCK              => S6_AXI_ARLOCK,
        S_AXI_ARCACHE             => S6_AXI_ARCACHE,
        S_AXI_ARPROT              => S6_AXI_ARPROT,
        S_AXI_ARQOS               => S6_AXI_ARQOS,
        S_AXI_ARVALID             => S6_AXI_ARVALID,
        S_AXI_ARREADY             => S6_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S6_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S6_AXI_ARSNOOP,
        S_AXI_ARBAR               => S6_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S6_AXI_RID,
        S_AXI_RDATA               => S6_AXI_RDATA,
        S_AXI_RRESP               => S6_AXI_RRESP,
        S_AXI_RLAST               => S6_AXI_RLAST,
        S_AXI_RVALID              => S6_AXI_RVALID,
        S_AXI_RREADY              => S6_AXI_RREADY,
        S_AXI_RACK                => S6_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S6_AXI_ACVALID,
        S_AXI_ACADDR              => S6_AXI_ACADDR,
        S_AXI_ACSNOOP             => S6_AXI_ACSNOOP,
        S_AXI_ACPROT              => S6_AXI_ACPROT,
        S_AXI_ACREADY             => S6_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S6_AXI_CRVALID,
        S_AXI_CRRESP              => S6_AXI_CRRESP,
        S_AXI_CRREADY             => S6_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S6_AXI_CDVALID,
        S_AXI_CDDATA              => S6_AXI_CDDATA,
        S_AXI_CDLAST              => S6_AXI_CDLAST,
        S_AXI_CDREADY             => S6_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(6),
        wr_port_ready             => wr_port_ready(6),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(6),
        rd_port_ready             => rd_port_ready(6),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (6 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (6 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (6 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(6),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(6),
        stat_s_axi_rip              => stat_s_axi_rip(6),
        stat_s_axi_r                => stat_s_axi_r(6),
        stat_s_axi_bip              => stat_s_axi_bip(6),
        stat_s_axi_bp               => stat_s_axi_bp(6),
        stat_s_axi_wip              => stat_s_axi_wip(6),
        stat_s_axi_w                => stat_s_axi_w(6),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(6),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(6),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(6),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(6),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(6),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF6_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 6)   <= wr_port_data_info_blk(J);
      read_info_status(J, 6)        <= read_info_status_blk(J);
      read_data_status_i(J, 6)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 6);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 6);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 6);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 6);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 6);
      access_bp_push_blk(J)         <= access_bp_push(J, 6);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 6);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 6);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 6);
      
      snoop_act_tag_info(J, 6)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 6)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 6)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 6)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 6)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 6)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(6)  <= int_to_std(C_S6_AXI_SUPPORT_DIRTY);
  end generate Use_Port_6;
  
  No_Port_6: if ( C_NUM_OPTIMIZED_PORTS < 7 ) generate
  begin
    S6_AXI_AWREADY        <= '0';
    S6_AXI_WREADY         <= '0';
    S6_AXI_BRESP          <= (others=>'0');
    S6_AXI_BID            <= (others=>'0');
    S6_AXI_BVALID         <= '0';
    S6_AXI_ARREADY        <= '0';
    S6_AXI_RID            <= (others=>'0');
    S6_AXI_RDATA          <= (others=>'0');
    S6_AXI_RRESP          <= (others=>'0');
    S6_AXI_RLAST          <= '0';
    S6_AXI_RVALID         <= '0';
    S6_AXI_ACVALID        <= '0';
    S6_AXI_ACADDR         <= (others=>'0');
    S6_AXI_ACSNOOP        <= (others=>'0');
    S6_AXI_ACPROT         <= (others=>'0');
    S6_AXI_CRREADY        <= '0';
    S6_AXI_CDREADY        <= '0';
    port_assert_error(6)  <= '0';
    OPT_IF6_DEBUG         <= (others=>'0');
  end generate No_Port_6;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #7
  -----------------------------------------------------------------------------
  
  Use_Port_7: if ( C_NUM_OPTIMIZED_PORTS > 7 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_7: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S7_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S7_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S7_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S7_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S7_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S7_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S7_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S7_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S7_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S7_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S7_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S7_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S7_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S7_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S7_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S7_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S7_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 7,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S7_AXI_AWID,
        S_AXI_AWADDR              => S7_AXI_AWADDR,
        S_AXI_AWLEN               => S7_AXI_AWLEN,
        S_AXI_AWSIZE              => S7_AXI_AWSIZE,
        S_AXI_AWBURST             => S7_AXI_AWBURST,
        S_AXI_AWLOCK              => S7_AXI_AWLOCK,
        S_AXI_AWCACHE             => S7_AXI_AWCACHE,
        S_AXI_AWPROT              => S7_AXI_AWPROT,
        S_AXI_AWQOS               => S7_AXI_AWQOS,
        S_AXI_AWVALID             => S7_AXI_AWVALID,
        S_AXI_AWREADY             => S7_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S7_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S7_AXI_AWSNOOP,
        S_AXI_AWBAR               => S7_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S7_AXI_WDATA,
        S_AXI_WSTRB               => S7_AXI_WSTRB,
        S_AXI_WLAST               => S7_AXI_WLAST,
        S_AXI_WVALID              => S7_AXI_WVALID,
        S_AXI_WREADY              => S7_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S7_AXI_BRESP,
        S_AXI_BID                 => S7_AXI_BID,
        S_AXI_BVALID              => S7_AXI_BVALID,
        S_AXI_BREADY              => S7_AXI_BREADY,
        S_AXI_WACK                => S7_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S7_AXI_ARID,
        S_AXI_ARADDR              => S7_AXI_ARADDR,
        S_AXI_ARLEN               => S7_AXI_ARLEN,
        S_AXI_ARSIZE              => S7_AXI_ARSIZE,
        S_AXI_ARBURST             => S7_AXI_ARBURST,
        S_AXI_ARLOCK              => S7_AXI_ARLOCK,
        S_AXI_ARCACHE             => S7_AXI_ARCACHE,
        S_AXI_ARPROT              => S7_AXI_ARPROT,
        S_AXI_ARQOS               => S7_AXI_ARQOS,
        S_AXI_ARVALID             => S7_AXI_ARVALID,
        S_AXI_ARREADY             => S7_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S7_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S7_AXI_ARSNOOP,
        S_AXI_ARBAR               => S7_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S7_AXI_RID,
        S_AXI_RDATA               => S7_AXI_RDATA,
        S_AXI_RRESP               => S7_AXI_RRESP,
        S_AXI_RLAST               => S7_AXI_RLAST,
        S_AXI_RVALID              => S7_AXI_RVALID,
        S_AXI_RREADY              => S7_AXI_RREADY,
        S_AXI_RACK                => S7_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S7_AXI_ACVALID,
        S_AXI_ACADDR              => S7_AXI_ACADDR,
        S_AXI_ACSNOOP             => S7_AXI_ACSNOOP,
        S_AXI_ACPROT              => S7_AXI_ACPROT,
        S_AXI_ACREADY             => S7_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S7_AXI_CRVALID,
        S_AXI_CRRESP              => S7_AXI_CRRESP,
        S_AXI_CRREADY             => S7_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S7_AXI_CDVALID,
        S_AXI_CDDATA              => S7_AXI_CDDATA,
        S_AXI_CDLAST              => S7_AXI_CDLAST,
        S_AXI_CDREADY             => S7_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(7),
        wr_port_ready             => wr_port_ready(7),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(7),
        rd_port_ready             => rd_port_ready(7),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (7 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (7 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (7 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(7),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(7),
        stat_s_axi_rip              => stat_s_axi_rip(7),
        stat_s_axi_r                => stat_s_axi_r(7),
        stat_s_axi_bip              => stat_s_axi_bip(7),
        stat_s_axi_bp               => stat_s_axi_bp(7),
        stat_s_axi_wip              => stat_s_axi_wip(7),
        stat_s_axi_w                => stat_s_axi_w(7),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(7),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(7),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(7),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(7),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(7),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF7_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 7)   <= wr_port_data_info_blk(J);
      read_info_status(J, 7)        <= read_info_status_blk(J);
      read_data_status_i(J, 7)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 7);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 7);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 7);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 7);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 7);
      access_bp_push_blk(J)         <= access_bp_push(J, 7);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 7);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 7);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 7);
      
      snoop_act_tag_info(J, 7)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 7)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 7)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 7)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 7)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 7)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(7)  <= int_to_std(C_S7_AXI_SUPPORT_DIRTY);
  end generate Use_Port_7;
  
  No_Port_7: if ( C_NUM_OPTIMIZED_PORTS < 8 ) generate
  begin
    S7_AXI_AWREADY        <= '0';
    S7_AXI_WREADY         <= '0';
    S7_AXI_BRESP          <= (others=>'0');
    S7_AXI_BID            <= (others=>'0');
    S7_AXI_BVALID         <= '0';
    S7_AXI_ARREADY        <= '0';
    S7_AXI_RID            <= (others=>'0');
    S7_AXI_RDATA          <= (others=>'0');
    S7_AXI_RRESP          <= (others=>'0');
    S7_AXI_RLAST          <= '0';
    S7_AXI_RVALID         <= '0';
    S7_AXI_ACVALID        <= '0';
    S7_AXI_ACADDR         <= (others=>'0');
    S7_AXI_ACSNOOP        <= (others=>'0');
    S7_AXI_ACPROT         <= (others=>'0');
    S7_AXI_CRREADY        <= '0';
    S7_AXI_CDREADY        <= '0';
    port_assert_error(7)  <= '0';
    OPT_IF7_DEBUG         <= (others=>'0');
  end generate No_Port_7;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #8
  -----------------------------------------------------------------------------
  
  Use_Port_8: if ( C_NUM_OPTIMIZED_PORTS > 8 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_8: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S8_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S8_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S8_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S8_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S8_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S8_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S8_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S8_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S8_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S8_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S8_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S8_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S8_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S8_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S8_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S8_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S8_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 8,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S8_AXI_AWID,
        S_AXI_AWADDR              => S8_AXI_AWADDR,
        S_AXI_AWLEN               => S8_AXI_AWLEN,
        S_AXI_AWSIZE              => S8_AXI_AWSIZE,
        S_AXI_AWBURST             => S8_AXI_AWBURST,
        S_AXI_AWLOCK              => S8_AXI_AWLOCK,
        S_AXI_AWCACHE             => S8_AXI_AWCACHE,
        S_AXI_AWPROT              => S8_AXI_AWPROT,
        S_AXI_AWQOS               => S8_AXI_AWQOS,
        S_AXI_AWVALID             => S8_AXI_AWVALID,
        S_AXI_AWREADY             => S8_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S8_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S8_AXI_AWSNOOP,
        S_AXI_AWBAR               => S8_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S8_AXI_WDATA,
        S_AXI_WSTRB               => S8_AXI_WSTRB,
        S_AXI_WLAST               => S8_AXI_WLAST,
        S_AXI_WVALID              => S8_AXI_WVALID,
        S_AXI_WREADY              => S8_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S8_AXI_BRESP,
        S_AXI_BID                 => S8_AXI_BID,
        S_AXI_BVALID              => S8_AXI_BVALID,
        S_AXI_BREADY              => S8_AXI_BREADY,
        S_AXI_WACK                => S8_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S8_AXI_ARID,
        S_AXI_ARADDR              => S8_AXI_ARADDR,
        S_AXI_ARLEN               => S8_AXI_ARLEN,
        S_AXI_ARSIZE              => S8_AXI_ARSIZE,
        S_AXI_ARBURST             => S8_AXI_ARBURST,
        S_AXI_ARLOCK              => S8_AXI_ARLOCK,
        S_AXI_ARCACHE             => S8_AXI_ARCACHE,
        S_AXI_ARPROT              => S8_AXI_ARPROT,
        S_AXI_ARQOS               => S8_AXI_ARQOS,
        S_AXI_ARVALID             => S8_AXI_ARVALID,
        S_AXI_ARREADY             => S8_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S8_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S8_AXI_ARSNOOP,
        S_AXI_ARBAR               => S8_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S8_AXI_RID,
        S_AXI_RDATA               => S8_AXI_RDATA,
        S_AXI_RRESP               => S8_AXI_RRESP,
        S_AXI_RLAST               => S8_AXI_RLAST,
        S_AXI_RVALID              => S8_AXI_RVALID,
        S_AXI_RREADY              => S8_AXI_RREADY,
        S_AXI_RACK                => S8_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S8_AXI_ACVALID,
        S_AXI_ACADDR              => S8_AXI_ACADDR,
        S_AXI_ACSNOOP             => S8_AXI_ACSNOOP,
        S_AXI_ACPROT              => S8_AXI_ACPROT,
        S_AXI_ACREADY             => S8_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S8_AXI_CRVALID,
        S_AXI_CRRESP              => S8_AXI_CRRESP,
        S_AXI_CRREADY             => S8_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S8_AXI_CDVALID,
        S_AXI_CDDATA              => S8_AXI_CDDATA,
        S_AXI_CDLAST              => S8_AXI_CDLAST,
        S_AXI_CDREADY             => S8_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(8),
        wr_port_ready             => wr_port_ready(8),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(8),
        rd_port_ready             => rd_port_ready(8),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (8 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (8 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (8 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(8),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(8),
        stat_s_axi_rip              => stat_s_axi_rip(8),
        stat_s_axi_r                => stat_s_axi_r(8),
        stat_s_axi_bip              => stat_s_axi_bip(8),
        stat_s_axi_bp               => stat_s_axi_bp(8),
        stat_s_axi_wip              => stat_s_axi_wip(8),
        stat_s_axi_w                => stat_s_axi_w(8),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(8),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(8),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(8),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(8),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(8),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF8_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 8)   <= wr_port_data_info_blk(J);
      read_info_status(J, 8)        <= read_info_status_blk(J);
      read_data_status_i(J, 8)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 8);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 8);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 8);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 8);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 8);
      access_bp_push_blk(J)         <= access_bp_push(J, 8);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 8);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 8);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 8);
      
      snoop_act_tag_info(J, 8)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 8)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 8)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 8)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 8)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 8)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(8)  <= int_to_std(C_S8_AXI_SUPPORT_DIRTY);
  end generate Use_Port_8;
  
  No_Port_8: if ( C_NUM_OPTIMIZED_PORTS < 9 ) generate
  begin
    S8_AXI_AWREADY        <= '0';
    S8_AXI_WREADY         <= '0';
    S8_AXI_BRESP          <= (others=>'0');
    S8_AXI_BID            <= (others=>'0');
    S8_AXI_BVALID         <= '0';
    S8_AXI_ARREADY        <= '0';
    S8_AXI_RID            <= (others=>'0');
    S8_AXI_RDATA          <= (others=>'0');
    S8_AXI_RRESP          <= (others=>'0');
    S8_AXI_RLAST          <= '0';
    S8_AXI_RVALID         <= '0';
    S8_AXI_ACVALID        <= '0';
    S8_AXI_ACADDR         <= (others=>'0');
    S8_AXI_ACSNOOP        <= (others=>'0');
    S8_AXI_ACPROT         <= (others=>'0');
    S8_AXI_CRREADY        <= '0';
    S8_AXI_CDREADY        <= '0';
    port_assert_error(8)  <= '0';
    OPT_IF8_DEBUG         <= (others=>'0');
  end generate No_Port_8;
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #9
  -----------------------------------------------------------------------------
  
  Use_Port_9: if ( C_NUM_OPTIMIZED_PORTS > 9 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_9: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S9_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S9_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S9_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S9_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S9_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S9_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S9_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S9_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S9_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S9_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S9_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S9_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S9_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S9_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S9_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S9_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S9_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 9,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S9_AXI_AWID,
        S_AXI_AWADDR              => S9_AXI_AWADDR,
        S_AXI_AWLEN               => S9_AXI_AWLEN,
        S_AXI_AWSIZE              => S9_AXI_AWSIZE,
        S_AXI_AWBURST             => S9_AXI_AWBURST,
        S_AXI_AWLOCK              => S9_AXI_AWLOCK,
        S_AXI_AWCACHE             => S9_AXI_AWCACHE,
        S_AXI_AWPROT              => S9_AXI_AWPROT,
        S_AXI_AWQOS               => S9_AXI_AWQOS,
        S_AXI_AWVALID             => S9_AXI_AWVALID,
        S_AXI_AWREADY             => S9_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S9_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S9_AXI_AWSNOOP,
        S_AXI_AWBAR               => S9_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S9_AXI_WDATA,
        S_AXI_WSTRB               => S9_AXI_WSTRB,
        S_AXI_WLAST               => S9_AXI_WLAST,
        S_AXI_WVALID              => S9_AXI_WVALID,
        S_AXI_WREADY              => S9_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S9_AXI_BRESP,
        S_AXI_BID                 => S9_AXI_BID,
        S_AXI_BVALID              => S9_AXI_BVALID,
        S_AXI_BREADY              => S9_AXI_BREADY,
        S_AXI_WACK                => S9_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S9_AXI_ARID,
        S_AXI_ARADDR              => S9_AXI_ARADDR,
        S_AXI_ARLEN               => S9_AXI_ARLEN,
        S_AXI_ARSIZE              => S9_AXI_ARSIZE,
        S_AXI_ARBURST             => S9_AXI_ARBURST,
        S_AXI_ARLOCK              => S9_AXI_ARLOCK,
        S_AXI_ARCACHE             => S9_AXI_ARCACHE,
        S_AXI_ARPROT              => S9_AXI_ARPROT,
        S_AXI_ARQOS               => S9_AXI_ARQOS,
        S_AXI_ARVALID             => S9_AXI_ARVALID,
        S_AXI_ARREADY             => S9_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S9_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S9_AXI_ARSNOOP,
        S_AXI_ARBAR               => S9_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S9_AXI_RID,
        S_AXI_RDATA               => S9_AXI_RDATA,
        S_AXI_RRESP               => S9_AXI_RRESP,
        S_AXI_RLAST               => S9_AXI_RLAST,
        S_AXI_RVALID              => S9_AXI_RVALID,
        S_AXI_RREADY              => S9_AXI_RREADY,
        S_AXI_RACK                => S9_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S9_AXI_ACVALID,
        S_AXI_ACADDR              => S9_AXI_ACADDR,
        S_AXI_ACSNOOP             => S9_AXI_ACSNOOP,
        S_AXI_ACPROT              => S9_AXI_ACPROT,
        S_AXI_ACREADY             => S9_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S9_AXI_CRVALID,
        S_AXI_CRRESP              => S9_AXI_CRRESP,
        S_AXI_CRREADY             => S9_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S9_AXI_CDVALID,
        S_AXI_CDDATA              => S9_AXI_CDDATA,
        S_AXI_CDLAST              => S9_AXI_CDLAST,
        S_AXI_CDREADY             => S9_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(9),
        wr_port_ready             => wr_port_ready(9),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(9),
        rd_port_ready             => rd_port_ready(9),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (9 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (9 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (9 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(9),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(9),
        stat_s_axi_rip              => stat_s_axi_rip(9),
        stat_s_axi_r                => stat_s_axi_r(9),
        stat_s_axi_bip              => stat_s_axi_bip(9),
        stat_s_axi_bp               => stat_s_axi_bp(9),
        stat_s_axi_wip              => stat_s_axi_wip(9),
        stat_s_axi_w                => stat_s_axi_w(9),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(9),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(9),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(9),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(9),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(9),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF9_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 9)   <= wr_port_data_info_blk(J);
      read_info_status(J, 9)        <= read_info_status_blk(J);
      read_data_status_i(J, 9)      <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 9);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 9);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 9);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 9);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 9);
      access_bp_push_blk(J)         <= access_bp_push(J, 9);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 9);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 9);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 9);
      
      snoop_act_tag_info(J, 9)      <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 9)      <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 9)      <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 9)         <= snoop_resp_info_blk(J);
      snoop_data_info(J, 9)         <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 9)    <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(9)  <= int_to_std(C_S9_AXI_SUPPORT_DIRTY);
  end generate Use_Port_9;
  
  No_Port_9: if ( C_NUM_OPTIMIZED_PORTS < 10 ) generate
  begin
    S9_AXI_AWREADY        <= '0';
    S9_AXI_WREADY         <= '0';
    S9_AXI_BRESP          <= (others=>'0');
    S9_AXI_BID            <= (others=>'0');
    S9_AXI_BVALID         <= '0';
    S9_AXI_ARREADY        <= '0';
    S9_AXI_RID            <= (others=>'0');
    S9_AXI_RDATA          <= (others=>'0');
    S9_AXI_RRESP          <= (others=>'0');
    S9_AXI_RLAST          <= '0';
    S9_AXI_RVALID         <= '0';
    S9_AXI_ACVALID        <= '0';
    S9_AXI_ACADDR         <= (others=>'0');
    S9_AXI_ACSNOOP        <= (others=>'0');
    S9_AXI_ACPROT         <= (others=>'0');
    S9_AXI_CRREADY        <= '0';
    S9_AXI_CDREADY        <= '0';
    port_assert_error(9)  <= '0';
    OPT_IF9_DEBUG         <= (others=>'0');
  end generate No_Port_9;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #10
  -----------------------------------------------------------------------------
  
  Use_Port_10: if ( C_NUM_OPTIMIZED_PORTS > 10 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_10: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S10_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S10_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S10_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S10_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S10_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S10_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S10_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S10_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S10_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S10_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S10_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S10_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S10_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S10_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S10_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S10_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S10_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 10,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S10_AXI_AWID,
        S_AXI_AWADDR              => S10_AXI_AWADDR,
        S_AXI_AWLEN               => S10_AXI_AWLEN,
        S_AXI_AWSIZE              => S10_AXI_AWSIZE,
        S_AXI_AWBURST             => S10_AXI_AWBURST,
        S_AXI_AWLOCK              => S10_AXI_AWLOCK,
        S_AXI_AWCACHE             => S10_AXI_AWCACHE,
        S_AXI_AWPROT              => S10_AXI_AWPROT,
        S_AXI_AWQOS               => S10_AXI_AWQOS,
        S_AXI_AWVALID             => S10_AXI_AWVALID,
        S_AXI_AWREADY             => S10_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S10_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S10_AXI_AWSNOOP,
        S_AXI_AWBAR               => S10_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S10_AXI_WDATA,
        S_AXI_WSTRB               => S10_AXI_WSTRB,
        S_AXI_WLAST               => S10_AXI_WLAST,
        S_AXI_WVALID              => S10_AXI_WVALID,
        S_AXI_WREADY              => S10_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S10_AXI_BRESP,
        S_AXI_BID                 => S10_AXI_BID,
        S_AXI_BVALID              => S10_AXI_BVALID,
        S_AXI_BREADY              => S10_AXI_BREADY,
        S_AXI_WACK                => S10_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S10_AXI_ARID,
        S_AXI_ARADDR              => S10_AXI_ARADDR,
        S_AXI_ARLEN               => S10_AXI_ARLEN,
        S_AXI_ARSIZE              => S10_AXI_ARSIZE,
        S_AXI_ARBURST             => S10_AXI_ARBURST,
        S_AXI_ARLOCK              => S10_AXI_ARLOCK,
        S_AXI_ARCACHE             => S10_AXI_ARCACHE,
        S_AXI_ARPROT              => S10_AXI_ARPROT,
        S_AXI_ARQOS               => S10_AXI_ARQOS,
        S_AXI_ARVALID             => S10_AXI_ARVALID,
        S_AXI_ARREADY             => S10_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S10_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S10_AXI_ARSNOOP,
        S_AXI_ARBAR               => S10_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S10_AXI_RID,
        S_AXI_RDATA               => S10_AXI_RDATA,
        S_AXI_RRESP               => S10_AXI_RRESP,
        S_AXI_RLAST               => S10_AXI_RLAST,
        S_AXI_RVALID              => S10_AXI_RVALID,
        S_AXI_RREADY              => S10_AXI_RREADY,
        S_AXI_RACK                => S10_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S10_AXI_ACVALID,
        S_AXI_ACADDR              => S10_AXI_ACADDR,
        S_AXI_ACSNOOP             => S10_AXI_ACSNOOP,
        S_AXI_ACPROT              => S10_AXI_ACPROT,
        S_AXI_ACREADY             => S10_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S10_AXI_CRVALID,
        S_AXI_CRRESP              => S10_AXI_CRRESP,
        S_AXI_CRREADY             => S10_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S10_AXI_CDVALID,
        S_AXI_CDDATA              => S10_AXI_CDDATA,
        S_AXI_CDLAST              => S10_AXI_CDLAST,
        S_AXI_CDREADY             => S10_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(10),
        wr_port_ready             => wr_port_ready(10),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(10),
        rd_port_ready             => rd_port_ready(10),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (10 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (10 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (10 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(10),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(10),
        stat_s_axi_rip              => stat_s_axi_rip(10),
        stat_s_axi_r                => stat_s_axi_r(10),
        stat_s_axi_bip              => stat_s_axi_bip(10),
        stat_s_axi_bp               => stat_s_axi_bp(10),
        stat_s_axi_wip              => stat_s_axi_wip(10),
        stat_s_axi_w                => stat_s_axi_w(10),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(10),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(10),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(10),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(10),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(10),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF10_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 10)  <= wr_port_data_info_blk(J);
      read_info_status(J, 10)       <= read_info_status_blk(J);
      read_data_status_i(J, 10)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 10);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 10);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 10);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 10);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 10);
      access_bp_push_blk(J)         <= access_bp_push(J, 10);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 10);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 10);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 10);
      
      snoop_act_tag_info(J, 10)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 10)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 10)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 10)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 10)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 10)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(10) <= int_to_std(C_S10_AXI_SUPPORT_DIRTY);
  end generate Use_Port_10;
  
  No_Port_10: if ( C_NUM_OPTIMIZED_PORTS < 11 ) generate
  begin
    S10_AXI_AWREADY        <= '0';
    S10_AXI_WREADY         <= '0';
    S10_AXI_BRESP          <= (others=>'0');
    S10_AXI_BID            <= (others=>'0');
    S10_AXI_BVALID         <= '0';
    S10_AXI_ARREADY        <= '0';
    S10_AXI_RID            <= (others=>'0');
    S10_AXI_RDATA          <= (others=>'0');
    S10_AXI_RRESP          <= (others=>'0');
    S10_AXI_RLAST          <= '0';
    S10_AXI_RVALID         <= '0';
    S10_AXI_ACVALID        <= '0';
    S10_AXI_ACADDR         <= (others=>'0');
    S10_AXI_ACSNOOP        <= (others=>'0');
    S10_AXI_ACPROT         <= (others=>'0');
    S10_AXI_CRREADY        <= '0';
    S10_AXI_CDREADY        <= '0';
    port_assert_error(10)  <= '0';
    OPT_IF10_DEBUG         <= (others=>'0');
  end generate No_Port_10;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #11
  -----------------------------------------------------------------------------
  
  Use_Port_11: if ( C_NUM_OPTIMIZED_PORTS > 11 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_11: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S11_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S11_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S11_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S11_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S11_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S11_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S11_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S11_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S11_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S11_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S11_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S11_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S11_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S11_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S11_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S11_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S11_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 11,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S11_AXI_AWID,
        S_AXI_AWADDR              => S11_AXI_AWADDR,
        S_AXI_AWLEN               => S11_AXI_AWLEN,
        S_AXI_AWSIZE              => S11_AXI_AWSIZE,
        S_AXI_AWBURST             => S11_AXI_AWBURST,
        S_AXI_AWLOCK              => S11_AXI_AWLOCK,
        S_AXI_AWCACHE             => S11_AXI_AWCACHE,
        S_AXI_AWPROT              => S11_AXI_AWPROT,
        S_AXI_AWQOS               => S11_AXI_AWQOS,
        S_AXI_AWVALID             => S11_AXI_AWVALID,
        S_AXI_AWREADY             => S11_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S11_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S11_AXI_AWSNOOP,
        S_AXI_AWBAR               => S11_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S11_AXI_WDATA,
        S_AXI_WSTRB               => S11_AXI_WSTRB,
        S_AXI_WLAST               => S11_AXI_WLAST,
        S_AXI_WVALID              => S11_AXI_WVALID,
        S_AXI_WREADY              => S11_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S11_AXI_BRESP,
        S_AXI_BID                 => S11_AXI_BID,
        S_AXI_BVALID              => S11_AXI_BVALID,
        S_AXI_BREADY              => S11_AXI_BREADY,
        S_AXI_WACK                => S11_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S11_AXI_ARID,
        S_AXI_ARADDR              => S11_AXI_ARADDR,
        S_AXI_ARLEN               => S11_AXI_ARLEN,
        S_AXI_ARSIZE              => S11_AXI_ARSIZE,
        S_AXI_ARBURST             => S11_AXI_ARBURST,
        S_AXI_ARLOCK              => S11_AXI_ARLOCK,
        S_AXI_ARCACHE             => S11_AXI_ARCACHE,
        S_AXI_ARPROT              => S11_AXI_ARPROT,
        S_AXI_ARQOS               => S11_AXI_ARQOS,
        S_AXI_ARVALID             => S11_AXI_ARVALID,
        S_AXI_ARREADY             => S11_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S11_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S11_AXI_ARSNOOP,
        S_AXI_ARBAR               => S11_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S11_AXI_RID,
        S_AXI_RDATA               => S11_AXI_RDATA,
        S_AXI_RRESP               => S11_AXI_RRESP,
        S_AXI_RLAST               => S11_AXI_RLAST,
        S_AXI_RVALID              => S11_AXI_RVALID,
        S_AXI_RREADY              => S11_AXI_RREADY,
        S_AXI_RACK                => S11_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S11_AXI_ACVALID,
        S_AXI_ACADDR              => S11_AXI_ACADDR,
        S_AXI_ACSNOOP             => S11_AXI_ACSNOOP,
        S_AXI_ACPROT              => S11_AXI_ACPROT,
        S_AXI_ACREADY             => S11_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S11_AXI_CRVALID,
        S_AXI_CRRESP              => S11_AXI_CRRESP,
        S_AXI_CRREADY             => S11_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S11_AXI_CDVALID,
        S_AXI_CDDATA              => S11_AXI_CDDATA,
        S_AXI_CDLAST              => S11_AXI_CDLAST,
        S_AXI_CDREADY             => S11_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(11),
        wr_port_ready             => wr_port_ready(11),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(11),
        rd_port_ready             => rd_port_ready(11),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (11 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (11 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (11 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(11),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(11),
        stat_s_axi_rip              => stat_s_axi_rip(11),
        stat_s_axi_r                => stat_s_axi_r(11),
        stat_s_axi_bip              => stat_s_axi_bip(11),
        stat_s_axi_bp               => stat_s_axi_bp(11),
        stat_s_axi_wip              => stat_s_axi_wip(11),
        stat_s_axi_w                => stat_s_axi_w(11),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(11),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(11),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(11),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(11),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(11),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF11_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 11)  <= wr_port_data_info_blk(J);
      read_info_status(J, 11)       <= read_info_status_blk(J);
      read_data_status_i(J, 11)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 11);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 11);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 11);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 11);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 11);
      access_bp_push_blk(J)         <= access_bp_push(J, 11);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 11);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 11);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 11);
      
      snoop_act_tag_info(J, 11)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 11)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 11)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 11)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 11)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 11)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(11) <= int_to_std(C_S11_AXI_SUPPORT_DIRTY);
  end generate Use_Port_11;
  
  No_Port_11: if ( C_NUM_OPTIMIZED_PORTS < 12 ) generate
  begin
    S11_AXI_AWREADY        <= '0';
    S11_AXI_WREADY         <= '0';
    S11_AXI_BRESP          <= (others=>'0');
    S11_AXI_BID            <= (others=>'0');
    S11_AXI_BVALID         <= '0';
    S11_AXI_ARREADY        <= '0';
    S11_AXI_RID            <= (others=>'0');
    S11_AXI_RDATA          <= (others=>'0');
    S11_AXI_RRESP          <= (others=>'0');
    S11_AXI_RLAST          <= '0';
    S11_AXI_RVALID         <= '0';
    S11_AXI_ACVALID        <= '0';
    S11_AXI_ACADDR         <= (others=>'0');
    S11_AXI_ACSNOOP        <= (others=>'0');
    S11_AXI_ACPROT         <= (others=>'0');
    S11_AXI_CRREADY        <= '0';
    S11_AXI_CDREADY        <= '0';
    port_assert_error(11)  <= '0';
    OPT_IF11_DEBUG         <= (others=>'0');
  end generate No_Port_11;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #12
  -----------------------------------------------------------------------------
  
  Use_Port_12: if ( C_NUM_OPTIMIZED_PORTS > 12 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_12: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S12_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S12_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S12_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S12_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S12_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S12_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S12_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S12_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S12_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S12_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S12_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S12_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S12_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S12_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S12_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S12_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S12_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 12,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S12_AXI_AWID,
        S_AXI_AWADDR              => S12_AXI_AWADDR,
        S_AXI_AWLEN               => S12_AXI_AWLEN,
        S_AXI_AWSIZE              => S12_AXI_AWSIZE,
        S_AXI_AWBURST             => S12_AXI_AWBURST,
        S_AXI_AWLOCK              => S12_AXI_AWLOCK,
        S_AXI_AWCACHE             => S12_AXI_AWCACHE,
        S_AXI_AWPROT              => S12_AXI_AWPROT,
        S_AXI_AWQOS               => S12_AXI_AWQOS,
        S_AXI_AWVALID             => S12_AXI_AWVALID,
        S_AXI_AWREADY             => S12_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S12_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S12_AXI_AWSNOOP,
        S_AXI_AWBAR               => S12_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S12_AXI_WDATA,
        S_AXI_WSTRB               => S12_AXI_WSTRB,
        S_AXI_WLAST               => S12_AXI_WLAST,
        S_AXI_WVALID              => S12_AXI_WVALID,
        S_AXI_WREADY              => S12_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S12_AXI_BRESP,
        S_AXI_BID                 => S12_AXI_BID,
        S_AXI_BVALID              => S12_AXI_BVALID,
        S_AXI_BREADY              => S12_AXI_BREADY,
        S_AXI_WACK                => S12_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S12_AXI_ARID,
        S_AXI_ARADDR              => S12_AXI_ARADDR,
        S_AXI_ARLEN               => S12_AXI_ARLEN,
        S_AXI_ARSIZE              => S12_AXI_ARSIZE,
        S_AXI_ARBURST             => S12_AXI_ARBURST,
        S_AXI_ARLOCK              => S12_AXI_ARLOCK,
        S_AXI_ARCACHE             => S12_AXI_ARCACHE,
        S_AXI_ARPROT              => S12_AXI_ARPROT,
        S_AXI_ARQOS               => S12_AXI_ARQOS,
        S_AXI_ARVALID             => S12_AXI_ARVALID,
        S_AXI_ARREADY             => S12_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S12_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S12_AXI_ARSNOOP,
        S_AXI_ARBAR               => S12_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S12_AXI_RID,
        S_AXI_RDATA               => S12_AXI_RDATA,
        S_AXI_RRESP               => S12_AXI_RRESP,
        S_AXI_RLAST               => S12_AXI_RLAST,
        S_AXI_RVALID              => S12_AXI_RVALID,
        S_AXI_RREADY              => S12_AXI_RREADY,
        S_AXI_RACK                => S12_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S12_AXI_ACVALID,
        S_AXI_ACADDR              => S12_AXI_ACADDR,
        S_AXI_ACSNOOP             => S12_AXI_ACSNOOP,
        S_AXI_ACPROT              => S12_AXI_ACPROT,
        S_AXI_ACREADY             => S12_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S12_AXI_CRVALID,
        S_AXI_CRRESP              => S12_AXI_CRRESP,
        S_AXI_CRREADY             => S12_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S12_AXI_CDVALID,
        S_AXI_CDDATA              => S12_AXI_CDDATA,
        S_AXI_CDLAST              => S12_AXI_CDLAST,
        S_AXI_CDREADY             => S12_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(12),
        wr_port_ready             => wr_port_ready(12),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(12),
        rd_port_ready             => rd_port_ready(12),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (12 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (12 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (12 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(12),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(12),
        stat_s_axi_rip              => stat_s_axi_rip(12),
        stat_s_axi_r                => stat_s_axi_r(12),
        stat_s_axi_bip              => stat_s_axi_bip(12),
        stat_s_axi_bp               => stat_s_axi_bp(12),
        stat_s_axi_wip              => stat_s_axi_wip(12),
        stat_s_axi_w                => stat_s_axi_w(12),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(12),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(12),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(12),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(12),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(12),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF12_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 12)  <= wr_port_data_info_blk(J);
      read_info_status(J, 12)       <= read_info_status_blk(J);
      read_data_status_i(J, 12)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 12);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 12);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 12);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 12);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 12);
      access_bp_push_blk(J)         <= access_bp_push(J, 12);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 12);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 12);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 12);
      
      snoop_act_tag_info(J, 12)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 12)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 12)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 12)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 12)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 12)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(12) <= int_to_std(C_S12_AXI_SUPPORT_DIRTY);
  end generate Use_Port_12;
  
  No_Port_12: if ( C_NUM_OPTIMIZED_PORTS < 13 ) generate
  begin
    S12_AXI_AWREADY        <= '0';
    S12_AXI_WREADY         <= '0';
    S12_AXI_BRESP          <= (others=>'0');
    S12_AXI_BID            <= (others=>'0');
    S12_AXI_BVALID         <= '0';
    S12_AXI_ARREADY        <= '0';
    S12_AXI_RID            <= (others=>'0');
    S12_AXI_RDATA          <= (others=>'0');
    S12_AXI_RRESP          <= (others=>'0');
    S12_AXI_RLAST          <= '0';
    S12_AXI_RVALID         <= '0';
    S12_AXI_ACVALID        <= '0';
    S12_AXI_ACADDR         <= (others=>'0');
    S12_AXI_ACSNOOP        <= (others=>'0');
    S12_AXI_ACPROT         <= (others=>'0');
    S12_AXI_CRREADY        <= '0';
    S12_AXI_CDREADY        <= '0';
    port_assert_error(12)  <= '0';
    OPT_IF12_DEBUG         <= (others=>'0');
  end generate No_Port_12;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #13
  -----------------------------------------------------------------------------
  
  Use_Port_13: if ( C_NUM_OPTIMIZED_PORTS > 13 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_13: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S13_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S13_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S13_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S13_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S13_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S13_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S13_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S13_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S13_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S13_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S13_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S13_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S13_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S13_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S13_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S13_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S13_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 13,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S13_AXI_AWID,
        S_AXI_AWADDR              => S13_AXI_AWADDR,
        S_AXI_AWLEN               => S13_AXI_AWLEN,
        S_AXI_AWSIZE              => S13_AXI_AWSIZE,
        S_AXI_AWBURST             => S13_AXI_AWBURST,
        S_AXI_AWLOCK              => S13_AXI_AWLOCK,
        S_AXI_AWCACHE             => S13_AXI_AWCACHE,
        S_AXI_AWPROT              => S13_AXI_AWPROT,
        S_AXI_AWQOS               => S13_AXI_AWQOS,
        S_AXI_AWVALID             => S13_AXI_AWVALID,
        S_AXI_AWREADY             => S13_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S13_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S13_AXI_AWSNOOP,
        S_AXI_AWBAR               => S13_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S13_AXI_WDATA,
        S_AXI_WSTRB               => S13_AXI_WSTRB,
        S_AXI_WLAST               => S13_AXI_WLAST,
        S_AXI_WVALID              => S13_AXI_WVALID,
        S_AXI_WREADY              => S13_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S13_AXI_BRESP,
        S_AXI_BID                 => S13_AXI_BID,
        S_AXI_BVALID              => S13_AXI_BVALID,
        S_AXI_BREADY              => S13_AXI_BREADY,
        S_AXI_WACK                => S13_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S13_AXI_ARID,
        S_AXI_ARADDR              => S13_AXI_ARADDR,
        S_AXI_ARLEN               => S13_AXI_ARLEN,
        S_AXI_ARSIZE              => S13_AXI_ARSIZE,
        S_AXI_ARBURST             => S13_AXI_ARBURST,
        S_AXI_ARLOCK              => S13_AXI_ARLOCK,
        S_AXI_ARCACHE             => S13_AXI_ARCACHE,
        S_AXI_ARPROT              => S13_AXI_ARPROT,
        S_AXI_ARQOS               => S13_AXI_ARQOS,
        S_AXI_ARVALID             => S13_AXI_ARVALID,
        S_AXI_ARREADY             => S13_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S13_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S13_AXI_ARSNOOP,
        S_AXI_ARBAR               => S13_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S13_AXI_RID,
        S_AXI_RDATA               => S13_AXI_RDATA,
        S_AXI_RRESP               => S13_AXI_RRESP,
        S_AXI_RLAST               => S13_AXI_RLAST,
        S_AXI_RVALID              => S13_AXI_RVALID,
        S_AXI_RREADY              => S13_AXI_RREADY,
        S_AXI_RACK                => S13_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S13_AXI_ACVALID,
        S_AXI_ACADDR              => S13_AXI_ACADDR,
        S_AXI_ACSNOOP             => S13_AXI_ACSNOOP,
        S_AXI_ACPROT              => S13_AXI_ACPROT,
        S_AXI_ACREADY             => S13_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S13_AXI_CRVALID,
        S_AXI_CRRESP              => S13_AXI_CRRESP,
        S_AXI_CRREADY             => S13_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S13_AXI_CDVALID,
        S_AXI_CDDATA              => S13_AXI_CDDATA,
        S_AXI_CDLAST              => S13_AXI_CDLAST,
        S_AXI_CDREADY             => S13_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(13),
        wr_port_ready             => wr_port_ready(13),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(13),
        rd_port_ready             => rd_port_ready(13),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (13 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (13 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (13 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(13),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(13),
        stat_s_axi_rip              => stat_s_axi_rip(13),
        stat_s_axi_r                => stat_s_axi_r(13),
        stat_s_axi_bip              => stat_s_axi_bip(13),
        stat_s_axi_bp               => stat_s_axi_bp(13),
        stat_s_axi_wip              => stat_s_axi_wip(13),
        stat_s_axi_w                => stat_s_axi_w(13),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(13),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(13),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(13),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(13),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(13),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF13_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 13)  <= wr_port_data_info_blk(J);
      read_info_status(J, 13)       <= read_info_status_blk(J);
      read_data_status_i(J, 13)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 13);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 13);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 13);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 13);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 13);
      access_bp_push_blk(J)         <= access_bp_push(J, 13);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 13);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 13);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 13);
      
      snoop_act_tag_info(J, 13)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 13)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 13)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 13)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 13)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 13)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(13) <= int_to_std(C_S13_AXI_SUPPORT_DIRTY);
  end generate Use_Port_13;
  
  No_Port_13: if ( C_NUM_OPTIMIZED_PORTS < 14 ) generate
  begin
    S13_AXI_AWREADY        <= '0';
    S13_AXI_WREADY         <= '0';
    S13_AXI_BRESP          <= (others=>'0');
    S13_AXI_BID            <= (others=>'0');
    S13_AXI_BVALID         <= '0';
    S13_AXI_ARREADY        <= '0';
    S13_AXI_RID            <= (others=>'0');
    S13_AXI_RDATA          <= (others=>'0');
    S13_AXI_RRESP          <= (others=>'0');
    S13_AXI_RLAST          <= '0';
    S13_AXI_RVALID         <= '0';
    S13_AXI_ACVALID        <= '0';
    S13_AXI_ACADDR         <= (others=>'0');
    S13_AXI_ACSNOOP        <= (others=>'0');
    S13_AXI_ACPROT         <= (others=>'0');
    S13_AXI_CRREADY        <= '0';
    S13_AXI_CDREADY        <= '0';
    port_assert_error(13)  <= '0';
    OPT_IF13_DEBUG         <= (others=>'0');
  end generate No_Port_13;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #14
  -----------------------------------------------------------------------------
  
  Use_Port_14: if ( C_NUM_OPTIMIZED_PORTS > 14 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_14: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S14_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S14_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S14_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S14_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S14_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S14_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S14_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S14_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S14_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S14_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S14_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S14_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S14_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S14_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S14_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S14_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S14_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 14,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S14_AXI_AWID,
        S_AXI_AWADDR              => S14_AXI_AWADDR,
        S_AXI_AWLEN               => S14_AXI_AWLEN,
        S_AXI_AWSIZE              => S14_AXI_AWSIZE,
        S_AXI_AWBURST             => S14_AXI_AWBURST,
        S_AXI_AWLOCK              => S14_AXI_AWLOCK,
        S_AXI_AWCACHE             => S14_AXI_AWCACHE,
        S_AXI_AWPROT              => S14_AXI_AWPROT,
        S_AXI_AWQOS               => S14_AXI_AWQOS,
        S_AXI_AWVALID             => S14_AXI_AWVALID,
        S_AXI_AWREADY             => S14_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S14_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S14_AXI_AWSNOOP,
        S_AXI_AWBAR               => S14_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S14_AXI_WDATA,
        S_AXI_WSTRB               => S14_AXI_WSTRB,
        S_AXI_WLAST               => S14_AXI_WLAST,
        S_AXI_WVALID              => S14_AXI_WVALID,
        S_AXI_WREADY              => S14_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S14_AXI_BRESP,
        S_AXI_BID                 => S14_AXI_BID,
        S_AXI_BVALID              => S14_AXI_BVALID,
        S_AXI_BREADY              => S14_AXI_BREADY,
        S_AXI_WACK                => S14_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S14_AXI_ARID,
        S_AXI_ARADDR              => S14_AXI_ARADDR,
        S_AXI_ARLEN               => S14_AXI_ARLEN,
        S_AXI_ARSIZE              => S14_AXI_ARSIZE,
        S_AXI_ARBURST             => S14_AXI_ARBURST,
        S_AXI_ARLOCK              => S14_AXI_ARLOCK,
        S_AXI_ARCACHE             => S14_AXI_ARCACHE,
        S_AXI_ARPROT              => S14_AXI_ARPROT,
        S_AXI_ARQOS               => S14_AXI_ARQOS,
        S_AXI_ARVALID             => S14_AXI_ARVALID,
        S_AXI_ARREADY             => S14_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S14_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S14_AXI_ARSNOOP,
        S_AXI_ARBAR               => S14_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S14_AXI_RID,
        S_AXI_RDATA               => S14_AXI_RDATA,
        S_AXI_RRESP               => S14_AXI_RRESP,
        S_AXI_RLAST               => S14_AXI_RLAST,
        S_AXI_RVALID              => S14_AXI_RVALID,
        S_AXI_RREADY              => S14_AXI_RREADY,
        S_AXI_RACK                => S14_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S14_AXI_ACVALID,
        S_AXI_ACADDR              => S14_AXI_ACADDR,
        S_AXI_ACSNOOP             => S14_AXI_ACSNOOP,
        S_AXI_ACPROT              => S14_AXI_ACPROT,
        S_AXI_ACREADY             => S14_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S14_AXI_CRVALID,
        S_AXI_CRRESP              => S14_AXI_CRRESP,
        S_AXI_CRREADY             => S14_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S14_AXI_CDVALID,
        S_AXI_CDDATA              => S14_AXI_CDDATA,
        S_AXI_CDLAST              => S14_AXI_CDLAST,
        S_AXI_CDREADY             => S14_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(14),
        wr_port_ready             => wr_port_ready(14),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(14),
        rd_port_ready             => rd_port_ready(14),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (14 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (14 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (14 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(14),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(14),
        stat_s_axi_rip              => stat_s_axi_rip(14),
        stat_s_axi_r                => stat_s_axi_r(14),
        stat_s_axi_bip              => stat_s_axi_bip(14),
        stat_s_axi_bp               => stat_s_axi_bp(14),
        stat_s_axi_wip              => stat_s_axi_wip(14),
        stat_s_axi_w                => stat_s_axi_w(14),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(14),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(14),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(14),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(14),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(14),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF14_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 14)  <= wr_port_data_info_blk(J);
      read_info_status(J, 14)       <= read_info_status_blk(J);
      read_data_status_i(J, 14)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 14);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 14);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 14);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 14);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 14);
      access_bp_push_blk(J)         <= access_bp_push(J, 14);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 14);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 14);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 14);
      
      snoop_act_tag_info(J, 14)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 14)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 14)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 14)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 14)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 14)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(14) <= int_to_std(C_S14_AXI_SUPPORT_DIRTY);
  end generate Use_Port_14;
  
  No_Port_14: if ( C_NUM_OPTIMIZED_PORTS < 15 ) generate
  begin
    S14_AXI_AWREADY        <= '0';
    S14_AXI_WREADY         <= '0';
    S14_AXI_BRESP          <= (others=>'0');
    S14_AXI_BID            <= (others=>'0');
    S14_AXI_BVALID         <= '0';
    S14_AXI_ARREADY        <= '0';
    S14_AXI_RID            <= (others=>'0');
    S14_AXI_RDATA          <= (others=>'0');
    S14_AXI_RRESP          <= (others=>'0');
    S14_AXI_RLAST          <= '0';
    S14_AXI_RVALID         <= '0';
    S14_AXI_ACVALID        <= '0';
    S14_AXI_ACADDR         <= (others=>'0');
    S14_AXI_ACSNOOP        <= (others=>'0');
    S14_AXI_ACPROT         <= (others=>'0');
    S14_AXI_CRREADY        <= '0';
    S14_AXI_CDREADY        <= '0';
    port_assert_error(14)  <= '0';
    OPT_IF14_DEBUG         <= (others=>'0');
  end generate No_Port_14;
  
  
  -----------------------------------------------------------------------------
  -- Optimized AXI Slave Interface #15
  -----------------------------------------------------------------------------
  
  Use_Port_15: if ( C_NUM_OPTIMIZED_PORTS > 15 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_15: sc_s_axi_opt_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
        C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S15_AXI_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S15_AXI_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S15_AXI_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S15_AXI_ADDR_WIDTH,
        C_S_AXI_RRESP_WIDTH       => C_S15_AXI_RRESP_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S15_AXI_ID_WIDTH,
        C_S_AXI_SUPPORT_UNIQUE    => C_S15_AXI_SUPPORT_UNIQUE,
        C_S_AXI_SUPPORT_DIRTY     => C_S15_AXI_SUPPORT_DIRTY,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S15_AXI_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S15_AXI_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S15_AXI_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S15_AXI_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S15_AXI_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S15_AXI_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S15_AXI_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S15_AXI_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S15_AXI_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
        C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_HI,
        C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_LO,
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_HI,
        C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_LO,
        C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_HI,
        C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_HI,
        C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => 15,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S15_AXI_AWID,
        S_AXI_AWADDR              => S15_AXI_AWADDR,
        S_AXI_AWLEN               => S15_AXI_AWLEN,
        S_AXI_AWSIZE              => S15_AXI_AWSIZE,
        S_AXI_AWBURST             => S15_AXI_AWBURST,
        S_AXI_AWLOCK              => S15_AXI_AWLOCK,
        S_AXI_AWCACHE             => S15_AXI_AWCACHE,
        S_AXI_AWPROT              => S15_AXI_AWPROT,
        S_AXI_AWQOS               => S15_AXI_AWQOS,
        S_AXI_AWVALID             => S15_AXI_AWVALID,
        S_AXI_AWREADY             => S15_AXI_AWREADY,
        S_AXI_AWDOMAIN            => S15_AXI_AWDOMAIN,
        S_AXI_AWSNOOP             => S15_AXI_AWSNOOP,
        S_AXI_AWBAR               => S15_AXI_AWBAR,
    
        -- W-Channel
        S_AXI_WDATA               => S15_AXI_WDATA,
        S_AXI_WSTRB               => S15_AXI_WSTRB,
        S_AXI_WLAST               => S15_AXI_WLAST,
        S_AXI_WVALID              => S15_AXI_WVALID,
        S_AXI_WREADY              => S15_AXI_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S15_AXI_BRESP,
        S_AXI_BID                 => S15_AXI_BID,
        S_AXI_BVALID              => S15_AXI_BVALID,
        S_AXI_BREADY              => S15_AXI_BREADY,
        S_AXI_WACK                => S15_AXI_WACK,
    
        -- AR-Channel
        S_AXI_ARID                => S15_AXI_ARID,
        S_AXI_ARADDR              => S15_AXI_ARADDR,
        S_AXI_ARLEN               => S15_AXI_ARLEN,
        S_AXI_ARSIZE              => S15_AXI_ARSIZE,
        S_AXI_ARBURST             => S15_AXI_ARBURST,
        S_AXI_ARLOCK              => S15_AXI_ARLOCK,
        S_AXI_ARCACHE             => S15_AXI_ARCACHE,
        S_AXI_ARPROT              => S15_AXI_ARPROT,
        S_AXI_ARQOS               => S15_AXI_ARQOS,
        S_AXI_ARVALID             => S15_AXI_ARVALID,
        S_AXI_ARREADY             => S15_AXI_ARREADY,
        S_AXI_ARDOMAIN            => S15_AXI_ARDOMAIN,
        S_AXI_ARSNOOP             => S15_AXI_ARSNOOP,
        S_AXI_ARBAR               => S15_AXI_ARBAR,
    
        -- R-Channel
        S_AXI_RID                 => S15_AXI_RID,
        S_AXI_RDATA               => S15_AXI_RDATA,
        S_AXI_RRESP               => S15_AXI_RRESP,
        S_AXI_RLAST               => S15_AXI_RLAST,
        S_AXI_RVALID              => S15_AXI_RVALID,
        S_AXI_RREADY              => S15_AXI_RREADY,
        S_AXI_RACK                => S15_AXI_RACK,
    
        -- AC-Channel (coherency only)
        S_AXI_ACVALID             => S15_AXI_ACVALID,
        S_AXI_ACADDR              => S15_AXI_ACADDR,
        S_AXI_ACSNOOP             => S15_AXI_ACSNOOP,
        S_AXI_ACPROT              => S15_AXI_ACPROT,
        S_AXI_ACREADY             => S15_AXI_ACREADY,
    
        -- CR-Channel (coherency only)
        S_AXI_CRVALID             => S15_AXI_CRVALID,
        S_AXI_CRRESP              => S15_AXI_CRRESP,
        S_AXI_CRREADY             => S15_AXI_CRREADY,
    
        -- CD-Channel (coherency only)
        S_AXI_CDVALID             => S15_AXI_CDVALID,
        S_AXI_CDDATA              => S15_AXI_CDDATA,
        S_AXI_CDLAST              => S15_AXI_CDLAST,
        S_AXI_CDREADY             => S15_AXI_CDREADY,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => opt_port_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(15),
        wr_port_ready             => wr_port_ready(15),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(15),
        rd_port_ready             => rd_port_ready(15),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (15 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (15 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (15 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                  => stat_reset,
        stat_enable                 => stat_enable,
        
        stat_s_axi_rd_segments      => stat_s_axi_rd_segments(15),
        stat_s_axi_wr_segments      => stat_s_axi_wr_segments(15),
        stat_s_axi_rip              => stat_s_axi_rip(15),
        stat_s_axi_r                => stat_s_axi_r(15),
        stat_s_axi_bip              => stat_s_axi_bip(15),
        stat_s_axi_bp               => stat_s_axi_bp(15),
        stat_s_axi_wip              => stat_s_axi_wip(15),
        stat_s_axi_w                => stat_s_axi_w(15),
        stat_s_axi_rd_latency       => stat_s_axi_rd_latency(15),
        stat_s_axi_wr_latency       => stat_s_axi_wr_latency(15),
        stat_s_axi_rd_latency_conf  => stat_s_axi_rd_latency_conf(15),
        stat_s_axi_wr_latency_conf  => stat_s_axi_wr_latency_conf(15),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(15),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => OPT_IF15_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, 15)  <= wr_port_data_info_blk(J);
      read_info_status(J, 15)       <= read_info_status_blk(J);
      read_data_status_i(J, 15)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)  <= update_ext_bresp_info(J, 15);
      lookup_read_data_new_blk(J)   <= lookup_read_data_new(J, 15);
      lookup_read_data_info_blk(J)  <= lookup_read_data_info(J, 15);
      snoop_read_data_info_blk(J)   <= snoop_read_data_info(J, 15);
      update_read_data_info_blk(J)  <= update_read_data_info(J, 15);
      access_bp_push_blk(J)         <= access_bp_push(J, 15);
      
      snoop_fetch_info_blk(J)       <= snoop_fetch_info(J, 15);
      snoop_req_info_blk(J)         <= snoop_req_info(J, 15);
      snoop_act_info_blk(J)         <= snoop_act_info(J, 15);
      
      snoop_act_tag_info(J, 15)     <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, 15)     <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, 15)     <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, 15)        <= snoop_resp_info_blk(J);
      snoop_data_info(J, 15)        <= snoop_data_info_blk(J);
      read_trans_comp_info(J, 15)   <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(15) <= int_to_std(C_S15_AXI_SUPPORT_DIRTY);
  end generate Use_Port_15;
  
  No_Port_15: if ( C_NUM_OPTIMIZED_PORTS < 16 ) generate
  begin
    S15_AXI_AWREADY        <= '0';
    S15_AXI_WREADY         <= '0';
    S15_AXI_BRESP          <= (others=>'0');
    S15_AXI_BID            <= (others=>'0');
    S15_AXI_BVALID         <= '0';
    S15_AXI_ARREADY        <= '0';
    S15_AXI_RID            <= (others=>'0');
    S15_AXI_RDATA          <= (others=>'0');
    S15_AXI_RRESP          <= (others=>'0');
    S15_AXI_RLAST          <= '0';
    S15_AXI_RVALID         <= '0';
    S15_AXI_ACVALID        <= '0';
    S15_AXI_ACADDR         <= (others=>'0');
    S15_AXI_ACSNOOP        <= (others=>'0');
    S15_AXI_ACPROT         <= (others=>'0');
    S15_AXI_CRREADY        <= '0';
    S15_AXI_CDREADY        <= '0';
    port_assert_error(15)  <= '0';
    OPT_IF15_DEBUG         <= (others=>'0');
  end generate No_Port_15;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #0
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+0
  
  Use_Generic_Port_0: if ( C_NUM_GENERIC_PORTS > 0 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_0: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S0_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S0_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S0_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S0_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S0_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S0_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S0_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S0_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S0_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 0,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S0_AXI_GEN_AWID,
        S_AXI_AWADDR              => S0_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S0_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S0_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S0_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S0_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S0_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S0_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S0_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S0_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S0_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S0_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S0_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S0_AXI_GEN_WLAST,
        S_AXI_WVALID              => S0_AXI_GEN_WVALID,
        S_AXI_WREADY              => S0_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S0_AXI_GEN_BRESP,
        S_AXI_BID                 => S0_AXI_GEN_BID,
        S_AXI_BVALID              => S0_AXI_GEN_BVALID,
        S_AXI_BREADY              => S0_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S0_AXI_GEN_ARID,
        S_AXI_ARADDR              => S0_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S0_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S0_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S0_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S0_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S0_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S0_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S0_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S0_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S0_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S0_AXI_GEN_RID,
        S_AXI_RDATA               => S0_AXI_GEN_RDATA,
        S_AXI_RRESP               => S0_AXI_GEN_RRESP,
        S_AXI_RLAST               => S0_AXI_GEN_RLAST,
        S_AXI_RVALID              => S0_AXI_GEN_RVALID,
        S_AXI_RREADY              => S0_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(0),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 0),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 0),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 0),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 0 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 0 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(0),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(0),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(0),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(0),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(0),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(0),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(0),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(0),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(0),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(0),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(0),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(0),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(16),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF0_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 0) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 0)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 0)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 0);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 0);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 0);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 0)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 0)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 0)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 0)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 0)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 0)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 0)  <= '0';
  end generate Use_Generic_Port_0;
  
  No_Generic_Port_0: if ( C_NUM_GENERIC_PORTS < 1 ) generate
  begin
    S0_AXI_GEN_AWREADY    <= '0';
    S0_AXI_GEN_WREADY     <= '0';
    S0_AXI_GEN_BRESP      <= (others=>'0');
    S0_AXI_GEN_BID        <= (others=>'0');
    S0_AXI_GEN_BVALID     <= '0';
    S0_AXI_GEN_ARREADY    <= '0';
    S0_AXI_GEN_RID        <= (others=>'0');
    S0_AXI_GEN_RDATA      <= (others=>'0');
    S0_AXI_GEN_RRESP      <= (others=>'0');
    S0_AXI_GEN_RLAST      <= '0';
    S0_AXI_GEN_RVALID     <= '0';
    port_assert_error(16)  <= '0';
    GEN_IF0_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_0;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #1
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+1
  
  Use_Generic_Port_1: if ( C_NUM_GENERIC_PORTS > 1 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_1: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S1_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S1_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S1_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S1_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S1_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S1_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S1_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S1_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S1_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 1,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S1_AXI_GEN_AWID,
        S_AXI_AWADDR              => S1_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S1_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S1_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S1_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S1_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S1_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S1_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S1_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S1_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S1_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S1_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S1_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S1_AXI_GEN_WLAST,
        S_AXI_WVALID              => S1_AXI_GEN_WVALID,
        S_AXI_WREADY              => S1_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S1_AXI_GEN_BRESP,
        S_AXI_BID                 => S1_AXI_GEN_BID,
        S_AXI_BVALID              => S1_AXI_GEN_BVALID,
        S_AXI_BREADY              => S1_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S1_AXI_GEN_ARID,
        S_AXI_ARADDR              => S1_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S1_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S1_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S1_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S1_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S1_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S1_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S1_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S1_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S1_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S1_AXI_GEN_RID,
        S_AXI_RDATA               => S1_AXI_GEN_RDATA,
        S_AXI_RRESP               => S1_AXI_GEN_RRESP,
        S_AXI_RLAST               => S1_AXI_GEN_RLAST,
        S_AXI_RVALID              => S1_AXI_GEN_RVALID,
        S_AXI_RREADY              => S1_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(1),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 1),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 1),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 1),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 1),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 1 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 1 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(1),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(1),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(1),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(1),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(1),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(1),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(1),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(1),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(1),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(1),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(1),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(1),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(17),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF1_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 1) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 1)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 1)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 1);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 1);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 1);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 1)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 1)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 1)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 1)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 1)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 1)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 1)  <= '0';
  end generate Use_Generic_Port_1;
  
  No_Generic_Port_1: if ( C_NUM_GENERIC_PORTS < 2 ) generate
  begin
    S1_AXI_GEN_AWREADY    <= '0';
    S1_AXI_GEN_WREADY     <= '0';
    S1_AXI_GEN_BRESP      <= (others=>'0');
    S1_AXI_GEN_BID        <= (others=>'0');
    S1_AXI_GEN_BVALID     <= '0';
    S1_AXI_GEN_ARREADY    <= '0';
    S1_AXI_GEN_RID        <= (others=>'0');
    S1_AXI_GEN_RDATA      <= (others=>'0');
    S1_AXI_GEN_RRESP      <= (others=>'0');
    S1_AXI_GEN_RLAST      <= '0';
    S1_AXI_GEN_RVALID     <= '0';
    port_assert_error(17) <= '0';
    GEN_IF1_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_1;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #2
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+2
  
  Use_Generic_Port_2: if ( C_NUM_GENERIC_PORTS > 2 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_2: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S2_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S2_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S2_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S2_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S2_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S2_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S2_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S2_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S2_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 2,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S2_AXI_GEN_AWID,
        S_AXI_AWADDR              => S2_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S2_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S2_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S2_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S2_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S2_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S2_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S2_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S2_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S2_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S2_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S2_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S2_AXI_GEN_WLAST,
        S_AXI_WVALID              => S2_AXI_GEN_WVALID,
        S_AXI_WREADY              => S2_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S2_AXI_GEN_BRESP,
        S_AXI_BID                 => S2_AXI_GEN_BID,
        S_AXI_BVALID              => S2_AXI_GEN_BVALID,
        S_AXI_BREADY              => S2_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S2_AXI_GEN_ARID,
        S_AXI_ARADDR              => S2_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S2_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S2_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S2_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S2_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S2_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S2_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S2_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S2_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S2_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S2_AXI_GEN_RID,
        S_AXI_RDATA               => S2_AXI_GEN_RDATA,
        S_AXI_RRESP               => S2_AXI_GEN_RRESP,
        S_AXI_RLAST               => S2_AXI_GEN_RLAST,
        S_AXI_RVALID              => S2_AXI_GEN_RVALID,
        S_AXI_RREADY              => S2_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(2),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 2),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 2),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 2),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 2),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 2 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 2 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(2),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(2),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(2),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(2),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(2),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(2),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(2),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(2),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(2),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(2),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(2),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(2),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(18),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF2_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 2) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 2)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 2)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 2);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 2);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 2);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 2)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 2)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 2)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 2)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 2)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 2)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 2)  <= '0';
  end generate Use_Generic_Port_2;
  
  No_Generic_Port_2: if ( C_NUM_GENERIC_PORTS < 3 ) generate
  begin
    S2_AXI_GEN_AWREADY    <= '0';
    S2_AXI_GEN_WREADY     <= '0';
    S2_AXI_GEN_BRESP      <= (others=>'0');
    S2_AXI_GEN_BID        <= (others=>'0');
    S2_AXI_GEN_BVALID     <= '0';
    S2_AXI_GEN_ARREADY    <= '0';
    S2_AXI_GEN_RID        <= (others=>'0');
    S2_AXI_GEN_RDATA      <= (others=>'0');
    S2_AXI_GEN_RRESP      <= (others=>'0');
    S2_AXI_GEN_RLAST      <= '0';
    S2_AXI_GEN_RVALID     <= '0';
    port_assert_error(18) <= '0';
    GEN_IF2_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_2;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #3
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+3
  
  Use_Generic_Port_3: if ( C_NUM_GENERIC_PORTS > 3 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_3: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S3_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S3_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S3_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S3_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S3_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S3_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S3_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S3_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S3_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 3,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S3_AXI_GEN_AWID,
        S_AXI_AWADDR              => S3_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S3_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S3_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S3_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S3_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S3_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S3_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S3_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S3_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S3_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S3_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S3_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S3_AXI_GEN_WLAST,
        S_AXI_WVALID              => S3_AXI_GEN_WVALID,
        S_AXI_WREADY              => S3_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S3_AXI_GEN_BRESP,
        S_AXI_BID                 => S3_AXI_GEN_BID,
        S_AXI_BVALID              => S3_AXI_GEN_BVALID,
        S_AXI_BREADY              => S3_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S3_AXI_GEN_ARID,
        S_AXI_ARADDR              => S3_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S3_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S3_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S3_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S3_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S3_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S3_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S3_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S3_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S3_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S3_AXI_GEN_RID,
        S_AXI_RDATA               => S3_AXI_GEN_RDATA,
        S_AXI_RRESP               => S3_AXI_GEN_RRESP,
        S_AXI_RLAST               => S3_AXI_GEN_RLAST,
        S_AXI_RVALID              => S3_AXI_GEN_RVALID,
        S_AXI_RREADY              => S3_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(3),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 3),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 3),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 3),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 3),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 3 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 3 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(3),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(3),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(3),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(3),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(3),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(3),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(3),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(3),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(3),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(3),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(3),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(3),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(19),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF3_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 3) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 3)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 3)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 3);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 3);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 3);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 3)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 3)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 3)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 3)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 3)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 3)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 3)  <= '0';
  end generate Use_Generic_Port_3;
  
  No_Generic_Port_3: if ( C_NUM_GENERIC_PORTS < 4 ) generate
  begin
    S3_AXI_GEN_AWREADY    <= '0';
    S3_AXI_GEN_WREADY     <= '0';
    S3_AXI_GEN_BRESP      <= (others=>'0');
    S3_AXI_GEN_BID        <= (others=>'0');
    S3_AXI_GEN_BVALID     <= '0';
    S3_AXI_GEN_ARREADY    <= '0';
    S3_AXI_GEN_RID        <= (others=>'0');
    S3_AXI_GEN_RDATA      <= (others=>'0');
    S3_AXI_GEN_RRESP      <= (others=>'0');
    S3_AXI_GEN_RLAST      <= '0';
    S3_AXI_GEN_RVALID     <= '0';
    port_assert_error(19) <= '0';
    GEN_IF3_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_3;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #4
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+4
  
  Use_Generic_Port_4: if ( C_NUM_GENERIC_PORTS > 4 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_4: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S4_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S4_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S4_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S4_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S4_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S4_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S4_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S4_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S4_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 4,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S4_AXI_GEN_AWID,
        S_AXI_AWADDR              => S4_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S4_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S4_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S4_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S4_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S4_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S4_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S4_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S4_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S4_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S4_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S4_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S4_AXI_GEN_WLAST,
        S_AXI_WVALID              => S4_AXI_GEN_WVALID,
        S_AXI_WREADY              => S4_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S4_AXI_GEN_BRESP,
        S_AXI_BID                 => S4_AXI_GEN_BID,
        S_AXI_BVALID              => S4_AXI_GEN_BVALID,
        S_AXI_BREADY              => S4_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S4_AXI_GEN_ARID,
        S_AXI_ARADDR              => S4_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S4_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S4_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S4_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S4_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S4_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S4_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S4_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S4_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S4_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S4_AXI_GEN_RID,
        S_AXI_RDATA               => S4_AXI_GEN_RDATA,
        S_AXI_RRESP               => S4_AXI_GEN_RRESP,
        S_AXI_RLAST               => S4_AXI_GEN_RLAST,
        S_AXI_RVALID              => S4_AXI_GEN_RVALID,
        S_AXI_RREADY              => S4_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(4),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 4),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 4),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 4),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 4),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 4 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 4 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(4),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(4),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(4),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(4),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(4),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(4),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(4),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(4),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(4),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(4),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(4),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(4),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(20),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF4_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 4) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 4)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 4)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 4);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 4);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 4);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 4)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 4)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 4)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 4)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 4)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 4)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 4)  <= '0';
  end generate Use_Generic_Port_4;
  
  No_Generic_Port_4: if ( C_NUM_GENERIC_PORTS < 5 ) generate
  begin
    S4_AXI_GEN_AWREADY    <= '0';
    S4_AXI_GEN_WREADY     <= '0';
    S4_AXI_GEN_BRESP      <= (others=>'0');
    S4_AXI_GEN_BID        <= (others=>'0');
    S4_AXI_GEN_BVALID     <= '0';
    S4_AXI_GEN_ARREADY    <= '0';
    S4_AXI_GEN_RID        <= (others=>'0');
    S4_AXI_GEN_RDATA      <= (others=>'0');
    S4_AXI_GEN_RRESP      <= (others=>'0');
    S4_AXI_GEN_RLAST      <= '0';
    S4_AXI_GEN_RVALID     <= '0';
    port_assert_error(20) <= '0';
    GEN_IF4_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_4;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #5
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+5
  
  Use_Generic_Port_5: if ( C_NUM_GENERIC_PORTS > 5 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_5: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S5_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S5_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S5_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S5_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S5_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S5_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S5_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S5_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S5_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 5,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S5_AXI_GEN_AWID,
        S_AXI_AWADDR              => S5_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S5_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S5_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S5_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S5_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S5_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S5_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S5_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S5_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S5_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S5_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S5_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S5_AXI_GEN_WLAST,
        S_AXI_WVALID              => S5_AXI_GEN_WVALID,
        S_AXI_WREADY              => S5_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S5_AXI_GEN_BRESP,
        S_AXI_BID                 => S5_AXI_GEN_BID,
        S_AXI_BVALID              => S5_AXI_GEN_BVALID,
        S_AXI_BREADY              => S5_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S5_AXI_GEN_ARID,
        S_AXI_ARADDR              => S5_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S5_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S5_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S5_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S5_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S5_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S5_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S5_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S5_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S5_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S5_AXI_GEN_RID,
        S_AXI_RDATA               => S5_AXI_GEN_RDATA,
        S_AXI_RRESP               => S5_AXI_GEN_RRESP,
        S_AXI_RLAST               => S5_AXI_GEN_RLAST,
        S_AXI_RVALID              => S5_AXI_GEN_RVALID,
        S_AXI_RREADY              => S5_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(5),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 5),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 5),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 5),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 5),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 5 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 5 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(5),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(5),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(5),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(5),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(5),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(5),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(5),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(5),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(5),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(5),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(5),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(5),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(21),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF5_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 5) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 5)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 5)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 5);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 5);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 5);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 5)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 5)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 5)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 5)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 5)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 5)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 5)  <= '0';
  end generate Use_Generic_Port_5;
  
  No_Generic_Port_5: if ( C_NUM_GENERIC_PORTS < 6 ) generate
  begin
    S5_AXI_GEN_AWREADY    <= '0';
    S5_AXI_GEN_WREADY     <= '0';
    S5_AXI_GEN_BRESP      <= (others=>'0');
    S5_AXI_GEN_BID        <= (others=>'0');
    S5_AXI_GEN_BVALID     <= '0';
    S5_AXI_GEN_ARREADY    <= '0';
    S5_AXI_GEN_RID        <= (others=>'0');
    S5_AXI_GEN_RDATA      <= (others=>'0');
    S5_AXI_GEN_RRESP      <= (others=>'0');
    S5_AXI_GEN_RLAST      <= '0';
    S5_AXI_GEN_RVALID     <= '0';
    port_assert_error(21) <= '0';
    GEN_IF5_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_5;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #6
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+6
  
  Use_Generic_Port_6: if ( C_NUM_GENERIC_PORTS > 6 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_6: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S6_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S6_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S6_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S6_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S6_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S6_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S6_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S6_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S6_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 6,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S6_AXI_GEN_AWID,
        S_AXI_AWADDR              => S6_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S6_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S6_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S6_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S6_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S6_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S6_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S6_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S6_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S6_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S6_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S6_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S6_AXI_GEN_WLAST,
        S_AXI_WVALID              => S6_AXI_GEN_WVALID,
        S_AXI_WREADY              => S6_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S6_AXI_GEN_BRESP,
        S_AXI_BID                 => S6_AXI_GEN_BID,
        S_AXI_BVALID              => S6_AXI_GEN_BVALID,
        S_AXI_BREADY              => S6_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S6_AXI_GEN_ARID,
        S_AXI_ARADDR              => S6_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S6_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S6_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S6_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S6_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S6_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S6_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S6_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S6_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S6_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S6_AXI_GEN_RID,
        S_AXI_RDATA               => S6_AXI_GEN_RDATA,
        S_AXI_RRESP               => S6_AXI_GEN_RRESP,
        S_AXI_RLAST               => S6_AXI_GEN_RLAST,
        S_AXI_RVALID              => S6_AXI_GEN_RVALID,
        S_AXI_RREADY              => S6_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(6),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 6),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 6),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 6),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 6),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 6 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 6 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(6),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(6),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(6),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(6),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(6),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(6),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(6),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(6),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(6),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(6),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(6),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(6),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(22),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF6_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 6) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 6)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 6)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 6);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 6);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 6);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 6)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 6)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 6)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 6)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 6)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 6)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 6)  <= '0';
  end generate Use_Generic_Port_6;
  
  No_Generic_Port_6: if ( C_NUM_GENERIC_PORTS < 7 ) generate
  begin
    S6_AXI_GEN_AWREADY    <= '0';
    S6_AXI_GEN_WREADY     <= '0';
    S6_AXI_GEN_BRESP      <= (others=>'0');
    S6_AXI_GEN_BID        <= (others=>'0');
    S6_AXI_GEN_BVALID     <= '0';
    S6_AXI_GEN_ARREADY    <= '0';
    S6_AXI_GEN_RID        <= (others=>'0');
    S6_AXI_GEN_RDATA      <= (others=>'0');
    S6_AXI_GEN_RRESP      <= (others=>'0');
    S6_AXI_GEN_RLAST      <= '0';
    S6_AXI_GEN_RVALID     <= '0';
    port_assert_error(22) <= '0';
    GEN_IF6_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_6;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #7
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+7
  
  Use_Generic_Port_7: if ( C_NUM_GENERIC_PORTS > 7 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_7: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S7_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S7_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S7_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S7_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S7_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S7_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S7_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S7_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S7_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 7,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S7_AXI_GEN_AWID,
        S_AXI_AWADDR              => S7_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S7_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S7_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S7_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S7_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S7_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S7_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S7_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S7_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S7_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S7_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S7_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S7_AXI_GEN_WLAST,
        S_AXI_WVALID              => S7_AXI_GEN_WVALID,
        S_AXI_WREADY              => S7_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S7_AXI_GEN_BRESP,
        S_AXI_BID                 => S7_AXI_GEN_BID,
        S_AXI_BVALID              => S7_AXI_GEN_BVALID,
        S_AXI_BREADY              => S7_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S7_AXI_GEN_ARID,
        S_AXI_ARADDR              => S7_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S7_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S7_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S7_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S7_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S7_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S7_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S7_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S7_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S7_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S7_AXI_GEN_RID,
        S_AXI_RDATA               => S7_AXI_GEN_RDATA,
        S_AXI_RRESP               => S7_AXI_GEN_RRESP,
        S_AXI_RLAST               => S7_AXI_GEN_RLAST,
        S_AXI_RVALID              => S7_AXI_GEN_RVALID,
        S_AXI_RREADY              => S7_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(7),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 7),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 7),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 7),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 7),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 7 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 7 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(7),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(7),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(7),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(7),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(7),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(7),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(7),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(7),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(7),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(7),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(7),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(7),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(23),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF7_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 7) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 7)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 7)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 7);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 7);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 7);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 7)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 7)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 7)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 7)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 7)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 7)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 7)  <= '0';
  end generate Use_Generic_Port_7;
  
  No_Generic_Port_7: if ( C_NUM_GENERIC_PORTS < 8 ) generate
  begin
    S7_AXI_GEN_AWREADY    <= '0';
    S7_AXI_GEN_WREADY     <= '0';
    S7_AXI_GEN_BRESP      <= (others=>'0');
    S7_AXI_GEN_BID        <= (others=>'0');
    S7_AXI_GEN_BVALID     <= '0';
    S7_AXI_GEN_ARREADY    <= '0';
    S7_AXI_GEN_RID        <= (others=>'0');
    S7_AXI_GEN_RDATA      <= (others=>'0');
    S7_AXI_GEN_RRESP      <= (others=>'0');
    S7_AXI_GEN_RLAST      <= '0';
    S7_AXI_GEN_RVALID     <= '0';
    port_assert_error(23) <= '0';
    GEN_IF7_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_7;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #8
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+8
  
  Use_Generic_Port_8: if ( C_NUM_GENERIC_PORTS > 8 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_8: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S8_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S8_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S8_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S8_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S8_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S8_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S8_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S8_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S8_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 8,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S8_AXI_GEN_AWID,
        S_AXI_AWADDR              => S8_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S8_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S8_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S8_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S8_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S8_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S8_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S8_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S8_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S8_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S8_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S8_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S8_AXI_GEN_WLAST,
        S_AXI_WVALID              => S8_AXI_GEN_WVALID,
        S_AXI_WREADY              => S8_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S8_AXI_GEN_BRESP,
        S_AXI_BID                 => S8_AXI_GEN_BID,
        S_AXI_BVALID              => S8_AXI_GEN_BVALID,
        S_AXI_BREADY              => S8_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S8_AXI_GEN_ARID,
        S_AXI_ARADDR              => S8_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S8_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S8_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S8_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S8_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S8_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S8_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S8_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S8_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S8_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S8_AXI_GEN_RID,
        S_AXI_RDATA               => S8_AXI_GEN_RDATA,
        S_AXI_RRESP               => S8_AXI_GEN_RRESP,
        S_AXI_RLAST               => S8_AXI_GEN_RLAST,
        S_AXI_RVALID              => S8_AXI_GEN_RVALID,
        S_AXI_RREADY              => S8_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(8),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 8),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 8),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 8),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 8),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 8 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 8 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(8),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(8),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(8),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(8),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(8),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(8),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(8),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(8),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(8),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(8),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(8),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(8),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(24),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF8_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 8) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 8)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 8)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 8);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 8);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 8);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 8)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 8)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 8)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 8)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 8)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 8)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 8)  <= '0';
  end generate Use_Generic_Port_8;
  
  No_Generic_Port_8: if ( C_NUM_GENERIC_PORTS < 9 ) generate
  begin
    S8_AXI_GEN_AWREADY    <= '0';
    S8_AXI_GEN_WREADY     <= '0';
    S8_AXI_GEN_BRESP      <= (others=>'0');
    S8_AXI_GEN_BID        <= (others=>'0');
    S8_AXI_GEN_BVALID     <= '0';
    S8_AXI_GEN_ARREADY    <= '0';
    S8_AXI_GEN_RID        <= (others=>'0');
    S8_AXI_GEN_RDATA      <= (others=>'0');
    S8_AXI_GEN_RRESP      <= (others=>'0');
    S8_AXI_GEN_RLAST      <= '0';
    S8_AXI_GEN_RVALID     <= '0';
    port_assert_error(24) <= '0';
    GEN_IF8_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_8;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #9
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+9
  
  Use_Generic_Port_9: if ( C_NUM_GENERIC_PORTS > 9 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_9: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S9_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S9_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S9_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S9_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S9_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S9_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S9_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S9_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S9_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 9,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S9_AXI_GEN_AWID,
        S_AXI_AWADDR              => S9_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S9_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S9_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S9_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S9_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S9_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S9_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S9_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S9_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S9_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S9_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S9_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S9_AXI_GEN_WLAST,
        S_AXI_WVALID              => S9_AXI_GEN_WVALID,
        S_AXI_WREADY              => S9_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S9_AXI_GEN_BRESP,
        S_AXI_BID                 => S9_AXI_GEN_BID,
        S_AXI_BVALID              => S9_AXI_GEN_BVALID,
        S_AXI_BREADY              => S9_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S9_AXI_GEN_ARID,
        S_AXI_ARADDR              => S9_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S9_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S9_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S9_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S9_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S9_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S9_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S9_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S9_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S9_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S9_AXI_GEN_RID,
        S_AXI_RDATA               => S9_AXI_GEN_RDATA,
        S_AXI_RRESP               => S9_AXI_GEN_RRESP,
        S_AXI_RLAST               => S9_AXI_GEN_RLAST,
        S_AXI_RVALID              => S9_AXI_GEN_RVALID,
        S_AXI_RREADY              => S9_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(9),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 9),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 9),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 9),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 9),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 9 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 9 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(9),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(9),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(9),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(9),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(9),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(9),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(9),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(9),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(9),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(9),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(9),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(9),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(25),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF9_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 9) <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 9)      <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 9)    <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                        <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      lookup_read_data_new_blk(J)                         <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 9);
      lookup_read_data_info_blk(J)                        <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      snoop_read_data_info_blk(J)                         <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      update_read_data_info_blk(J)                        <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 9);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 9);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 9)    <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 9)    <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 9)    <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 9)       <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 9)       <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 9)  <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 9)  <= '0';
  end generate Use_Generic_Port_9;
  
  No_Generic_Port_9: if ( C_NUM_GENERIC_PORTS < 10 ) generate
  begin
    S9_AXI_GEN_AWREADY    <= '0';
    S9_AXI_GEN_WREADY     <= '0';
    S9_AXI_GEN_BRESP      <= (others=>'0');
    S9_AXI_GEN_BID        <= (others=>'0');
    S9_AXI_GEN_BVALID     <= '0';
    S9_AXI_GEN_ARREADY    <= '0';
    S9_AXI_GEN_RID        <= (others=>'0');
    S9_AXI_GEN_RDATA      <= (others=>'0');
    S9_AXI_GEN_RRESP      <= (others=>'0');
    S9_AXI_GEN_RLAST      <= '0';
    S9_AXI_GEN_RVALID     <= '0';
    port_assert_error(25) <= '0';
    GEN_IF9_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_9;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #10
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+10
  
  Use_Generic_Port_10: if ( C_NUM_GENERIC_PORTS > 10 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_10: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S10_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S10_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S10_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S10_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S10_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S10_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S10_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S10_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S10_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 10,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S10_AXI_GEN_AWID,
        S_AXI_AWADDR              => S10_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S10_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S10_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S10_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S10_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S10_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S10_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S10_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S10_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S10_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S10_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S10_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S10_AXI_GEN_WLAST,
        S_AXI_WVALID              => S10_AXI_GEN_WVALID,
        S_AXI_WREADY              => S10_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S10_AXI_GEN_BRESP,
        S_AXI_BID                 => S10_AXI_GEN_BID,
        S_AXI_BVALID              => S10_AXI_GEN_BVALID,
        S_AXI_BREADY              => S10_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S10_AXI_GEN_ARID,
        S_AXI_ARADDR              => S10_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S10_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S10_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S10_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S10_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S10_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S10_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S10_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S10_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S10_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S10_AXI_GEN_RID,
        S_AXI_RDATA               => S10_AXI_GEN_RDATA,
        S_AXI_RRESP               => S10_AXI_GEN_RRESP,
        S_AXI_RLAST               => S10_AXI_GEN_RLAST,
        S_AXI_RVALID              => S10_AXI_GEN_RVALID,
        S_AXI_RREADY              => S10_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(10),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 10),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 10),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 10),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 10),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 10 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 10 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(10),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(10),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(10),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(10),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(10),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(10),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(10),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(10),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(10),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(10),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(10),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(10),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(26),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF10_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 10)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 10)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 10)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 10);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 10);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 10);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 10)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 10)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 10)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 10)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 10)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 10) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 10)  <= '0';
  end generate Use_Generic_Port_10;
  
  No_Generic_Port_10: if ( C_NUM_GENERIC_PORTS < 11 ) generate
  begin
    S10_AXI_GEN_AWREADY    <= '0';
    S10_AXI_GEN_WREADY     <= '0';
    S10_AXI_GEN_BRESP      <= (others=>'0');
    S10_AXI_GEN_BID        <= (others=>'0');
    S10_AXI_GEN_BVALID     <= '0';
    S10_AXI_GEN_ARREADY    <= '0';
    S10_AXI_GEN_RID        <= (others=>'0');
    S10_AXI_GEN_RDATA      <= (others=>'0');
    S10_AXI_GEN_RRESP      <= (others=>'0');
    S10_AXI_GEN_RLAST      <= '0';
    S10_AXI_GEN_RVALID     <= '0';
    port_assert_error(26)  <= '0';
    GEN_IF10_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_10;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #11
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+11
  
  Use_Generic_Port_11: if ( C_NUM_GENERIC_PORTS > 11 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_11: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S11_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S11_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S11_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S11_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S11_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S11_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S11_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S11_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S11_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 11,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S11_AXI_GEN_AWID,
        S_AXI_AWADDR              => S11_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S11_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S11_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S11_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S11_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S11_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S11_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S11_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S11_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S11_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S11_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S11_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S11_AXI_GEN_WLAST,
        S_AXI_WVALID              => S11_AXI_GEN_WVALID,
        S_AXI_WREADY              => S11_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S11_AXI_GEN_BRESP,
        S_AXI_BID                 => S11_AXI_GEN_BID,
        S_AXI_BVALID              => S11_AXI_GEN_BVALID,
        S_AXI_BREADY              => S11_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S11_AXI_GEN_ARID,
        S_AXI_ARADDR              => S11_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S11_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S11_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S11_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S11_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S11_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S11_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S11_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S11_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S11_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S11_AXI_GEN_RID,
        S_AXI_RDATA               => S11_AXI_GEN_RDATA,
        S_AXI_RRESP               => S11_AXI_GEN_RRESP,
        S_AXI_RLAST               => S11_AXI_GEN_RLAST,
        S_AXI_RVALID              => S11_AXI_GEN_RVALID,
        S_AXI_RREADY              => S11_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(11),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 11),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 11),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 11),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 11),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 11 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 11 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(11),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(11),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(11),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(11),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(11),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(11),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(11),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(11),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(11),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(11),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(11),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(11),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(27),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF11_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 11)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 11)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 11)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 11);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 11);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 11);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 11)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 11)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 11)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 11)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 11)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 11) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 11)  <= '0';
  end generate Use_Generic_Port_11;
  
  No_Generic_Port_11: if ( C_NUM_GENERIC_PORTS < 12 ) generate
  begin
    S11_AXI_GEN_AWREADY    <= '0';
    S11_AXI_GEN_WREADY     <= '0';
    S11_AXI_GEN_BRESP      <= (others=>'0');
    S11_AXI_GEN_BID        <= (others=>'0');
    S11_AXI_GEN_BVALID     <= '0';
    S11_AXI_GEN_ARREADY    <= '0';
    S11_AXI_GEN_RID        <= (others=>'0');
    S11_AXI_GEN_RDATA      <= (others=>'0');
    S11_AXI_GEN_RRESP      <= (others=>'0');
    S11_AXI_GEN_RLAST      <= '0';
    S11_AXI_GEN_RVALID     <= '0';
    port_assert_error(27)  <= '0';
    GEN_IF11_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_11;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #12
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+12
  
  Use_Generic_Port_12: if ( C_NUM_GENERIC_PORTS > 12 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_12: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S12_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S12_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S12_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S12_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S12_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S12_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S12_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S12_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S12_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 12,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S12_AXI_GEN_AWID,
        S_AXI_AWADDR              => S12_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S12_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S12_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S12_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S12_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S12_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S12_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S12_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S12_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S12_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S12_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S12_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S12_AXI_GEN_WLAST,
        S_AXI_WVALID              => S12_AXI_GEN_WVALID,
        S_AXI_WREADY              => S12_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S12_AXI_GEN_BRESP,
        S_AXI_BID                 => S12_AXI_GEN_BID,
        S_AXI_BVALID              => S12_AXI_GEN_BVALID,
        S_AXI_BREADY              => S12_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S12_AXI_GEN_ARID,
        S_AXI_ARADDR              => S12_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S12_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S12_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S12_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S12_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S12_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S12_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S12_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S12_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S12_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S12_AXI_GEN_RID,
        S_AXI_RDATA               => S12_AXI_GEN_RDATA,
        S_AXI_RRESP               => S12_AXI_GEN_RRESP,
        S_AXI_RLAST               => S12_AXI_GEN_RLAST,
        S_AXI_RVALID              => S12_AXI_GEN_RVALID,
        S_AXI_RREADY              => S12_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(12),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 12),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 12),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 12),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 12),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 12 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 12 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(12),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(12),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(12),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(12),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(12),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(12),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(12),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(12),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(12),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(12),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(12),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(12),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(28),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF12_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 12)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 12)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 12)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 12);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 12);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 12);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 12)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 12)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 12)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 12)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 12)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 12) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 12)  <= '0';
  end generate Use_Generic_Port_12;
  
  No_Generic_Port_12: if ( C_NUM_GENERIC_PORTS < 13 ) generate
  begin
    S12_AXI_GEN_AWREADY    <= '0';
    S12_AXI_GEN_WREADY     <= '0';
    S12_AXI_GEN_BRESP      <= (others=>'0');
    S12_AXI_GEN_BID        <= (others=>'0');
    S12_AXI_GEN_BVALID     <= '0';
    S12_AXI_GEN_ARREADY    <= '0';
    S12_AXI_GEN_RID        <= (others=>'0');
    S12_AXI_GEN_RDATA      <= (others=>'0');
    S12_AXI_GEN_RRESP      <= (others=>'0');
    S12_AXI_GEN_RLAST      <= '0';
    S12_AXI_GEN_RVALID     <= '0';
    port_assert_error(28)  <= '0';
    GEN_IF12_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_12;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #13
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+13
  
  Use_Generic_Port_13: if ( C_NUM_GENERIC_PORTS > 13 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_13: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S13_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S13_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S13_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S13_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S13_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S13_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S13_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S13_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S13_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 13,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S13_AXI_GEN_AWID,
        S_AXI_AWADDR              => S13_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S13_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S13_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S13_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S13_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S13_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S13_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S13_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S13_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S13_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S13_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S13_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S13_AXI_GEN_WLAST,
        S_AXI_WVALID              => S13_AXI_GEN_WVALID,
        S_AXI_WREADY              => S13_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S13_AXI_GEN_BRESP,
        S_AXI_BID                 => S13_AXI_GEN_BID,
        S_AXI_BVALID              => S13_AXI_GEN_BVALID,
        S_AXI_BREADY              => S13_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S13_AXI_GEN_ARID,
        S_AXI_ARADDR              => S13_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S13_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S13_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S13_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S13_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S13_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S13_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S13_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S13_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S13_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S13_AXI_GEN_RID,
        S_AXI_RDATA               => S13_AXI_GEN_RDATA,
        S_AXI_RRESP               => S13_AXI_GEN_RRESP,
        S_AXI_RLAST               => S13_AXI_GEN_RLAST,
        S_AXI_RVALID              => S13_AXI_GEN_RVALID,
        S_AXI_RREADY              => S13_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(13),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 13),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 13),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 13),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 13),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 13 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 13 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(13),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(13),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(13),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(13),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(13),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(13),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(13),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(13),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(13),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(13),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(13),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(13),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(29),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF13_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 13)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 13)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 13)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 13);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 13);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 13);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 13)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 13)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 13)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 13)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 13)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 13) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 13)  <= '0';
  end generate Use_Generic_Port_13;
  
  No_Generic_Port_13: if ( C_NUM_GENERIC_PORTS < 14 ) generate
  begin
    S13_AXI_GEN_AWREADY    <= '0';
    S13_AXI_GEN_WREADY     <= '0';
    S13_AXI_GEN_BRESP      <= (others=>'0');
    S13_AXI_GEN_BID        <= (others=>'0');
    S13_AXI_GEN_BVALID     <= '0';
    S13_AXI_GEN_ARREADY    <= '0';
    S13_AXI_GEN_RID        <= (others=>'0');
    S13_AXI_GEN_RDATA      <= (others=>'0');
    S13_AXI_GEN_RRESP      <= (others=>'0');
    S13_AXI_GEN_RLAST      <= '0';
    S13_AXI_GEN_RVALID     <= '0';
    port_assert_error(29)  <= '0';
    GEN_IF13_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_13;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #14
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+14
  
  Use_Generic_Port_14: if ( C_NUM_GENERIC_PORTS > 14 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_14: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S14_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S14_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S14_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S14_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S14_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S14_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S14_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S14_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S14_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 14,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S14_AXI_GEN_AWID,
        S_AXI_AWADDR              => S14_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S14_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S14_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S14_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S14_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S14_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S14_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S14_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S14_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S14_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S14_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S14_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S14_AXI_GEN_WLAST,
        S_AXI_WVALID              => S14_AXI_GEN_WVALID,
        S_AXI_WREADY              => S14_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S14_AXI_GEN_BRESP,
        S_AXI_BID                 => S14_AXI_GEN_BID,
        S_AXI_BVALID              => S14_AXI_GEN_BVALID,
        S_AXI_BREADY              => S14_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S14_AXI_GEN_ARID,
        S_AXI_ARADDR              => S14_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S14_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S14_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S14_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S14_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S14_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S14_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S14_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S14_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S14_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S14_AXI_GEN_RID,
        S_AXI_RDATA               => S14_AXI_GEN_RDATA,
        S_AXI_RRESP               => S14_AXI_GEN_RRESP,
        S_AXI_RLAST               => S14_AXI_GEN_RLAST,
        S_AXI_RVALID              => S14_AXI_GEN_RVALID,
        S_AXI_RREADY              => S14_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(14),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 14),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 14),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 14),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 14),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 14 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 14 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(14),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(14),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(14),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(14),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(14),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(14),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(14),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(14),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(14),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(14),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(14),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(14),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(30),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF14_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 14)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 14)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 14)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 14);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 14);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 14);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 14)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 14)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 14)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 14)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 14)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 14) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 14)  <= '0';
  end generate Use_Generic_Port_14;
  
  No_Generic_Port_14: if ( C_NUM_GENERIC_PORTS < 15 ) generate
  begin
    S14_AXI_GEN_AWREADY    <= '0';
    S14_AXI_GEN_WREADY     <= '0';
    S14_AXI_GEN_BRESP      <= (others=>'0');
    S14_AXI_GEN_BID        <= (others=>'0');
    S14_AXI_GEN_BVALID     <= '0';
    S14_AXI_GEN_ARREADY    <= '0';
    S14_AXI_GEN_RID        <= (others=>'0');
    S14_AXI_GEN_RDATA      <= (others=>'0');
    S14_AXI_GEN_RRESP      <= (others=>'0');
    S14_AXI_GEN_RLAST      <= '0';
    S14_AXI_GEN_RVALID     <= '0';
    port_assert_error(30)  <= '0';
    GEN_IF14_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_14;
  
  
  -----------------------------------------------------------------------------
  -- Generic AXI Slave Interface #15
  -----------------------------------------------------------------------------
  -- idx=C_NUM_OPTIMIZED_PORTS+15
  
  Use_Generic_Port_15: if ( C_NUM_GENERIC_PORTS > 15 ) generate
    -- Internal Interface Signals (Write Data).
    signal wr_port_data_info_blk        : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Internal Interface Signals (Write response).
    signal access_bp_push_blk            : WRITE_EARLY_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal update_ext_bresp_info_blk     : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read request).
    signal lookup_read_data_new_blk      : READ_SOURCE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Internal Interface Signals (Read Data).
    signal read_info_status_blk          : STAT_RI_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal read_data_status_blk          : STAT_RD_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Lookup signals (Read Data).
    signal lookup_read_data_info_blk     : READ_HIT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Snoop signals (Read Data).
    signal snoop_read_data_info_blk      : READ_SNOOP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Update signals (Read Data).
    signal update_read_data_info_blk     : READ_MISS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_blk          : SNOOP_FETCH_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Request Stage Signals.
    signal snoop_req_info_blk            : SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
         
    -- Snoop Action Stage Signals.
    signal snoop_act_info_blk            : SNOOP_ACT_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_tag_info_blk        : SNOOP_ACT_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    signal snoop_act_ack_info_blk        : SNOOP_ACT_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_new_info_blk        : SNOOP_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_blk           : SNOOP_CRRESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
    -- Snoop Data Signals.
    signal snoop_data_info_blk           : SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
    -- Complete Transaction Signals.
    signal read_trans_comp_info_blk      : READ_COMPLETE_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
    
  begin
    AXI_15: sc_s_axi_gen_interface
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
        C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- AXI4 Interface Specific.
        C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
        C_S_AXI_BASEADDR          => C_S15_AXI_GEN_BASEADDR,
        C_S_AXI_HIGHADDR          => C_S15_AXI_GEN_HIGHADDR,
        C_S_AXI_DATA_WIDTH        => C_S15_AXI_GEN_DATA_WIDTH,
        C_S_AXI_ADDR_WIDTH        => C_S15_AXI_GEN_ADDR_WIDTH,
        C_S_AXI_ID_WIDTH          => C_S15_AXI_GEN_ID_WIDTH,
        C_S_AXI_FORCE_READ_ALLOCATE     => C_S15_AXI_GEN_FORCE_READ_ALLOCATE,
        C_S_AXI_PROHIBIT_READ_ALLOCATE  => C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE,
        C_S_AXI_FORCE_WRITE_ALLOCATE    => C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE,
        C_S_AXI_PROHIBIT_WRITE_ALLOCATE => C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
        C_S_AXI_FORCE_READ_BUFFER       => C_S15_AXI_GEN_FORCE_READ_BUFFER,
        C_S_AXI_PROHIBIT_READ_BUFFER    => C_S15_AXI_GEN_PROHIBIT_READ_BUFFER,
        C_S_AXI_FORCE_WRITE_BUFFER      => C_S15_AXI_GEN_FORCE_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_WRITE_BUFFER   => C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER,
        C_S_AXI_PROHIBIT_EXCLUSIVE      => C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE,
        
        -- Data type and settings specific.
        C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
        C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
        C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
        C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
        
        -- Lx Cache Specific.
        C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_HI,
        C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_LO,
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_HI,
        C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_LO,
        C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_HI,
        C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_LO,
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        
        -- IP Specific.
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE,
        
        -- System Cache Specific.
        C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        C_NUM_WAYS                => C_NUM_WAYS,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_PORT_NUM                => C_NUM_OPTIMIZED_PORTS + 15,
        C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
        C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_M_AXI_DATA_WIDTH        => C_M_AXI_DATA_WIDTH,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        -- ---------------------------------------------------
        -- AXI4/ACE Slave Interface Signals.
        
        -- AW-Channel
        S_AXI_AWID                => S15_AXI_GEN_AWID,
        S_AXI_AWADDR              => S15_AXI_GEN_AWADDR,
        S_AXI_AWLEN               => S15_AXI_GEN_AWLEN,
        S_AXI_AWSIZE              => S15_AXI_GEN_AWSIZE,
        S_AXI_AWBURST             => S15_AXI_GEN_AWBURST,
        S_AXI_AWLOCK              => S15_AXI_GEN_AWLOCK,
        S_AXI_AWCACHE             => S15_AXI_GEN_AWCACHE,
        S_AXI_AWPROT              => S15_AXI_GEN_AWPROT,
        S_AXI_AWQOS               => S15_AXI_GEN_AWQOS,
        S_AXI_AWVALID             => S15_AXI_GEN_AWVALID,
        S_AXI_AWREADY             => S15_AXI_GEN_AWREADY,
    
        -- W-Channel
        S_AXI_WDATA               => S15_AXI_GEN_WDATA,
        S_AXI_WSTRB               => S15_AXI_GEN_WSTRB,
        S_AXI_WLAST               => S15_AXI_GEN_WLAST,
        S_AXI_WVALID              => S15_AXI_GEN_WVALID,
        S_AXI_WREADY              => S15_AXI_GEN_WREADY,
    
        -- B-Channel
        S_AXI_BRESP               => S15_AXI_GEN_BRESP,
        S_AXI_BID                 => S15_AXI_GEN_BID,
        S_AXI_BVALID              => S15_AXI_GEN_BVALID,
        S_AXI_BREADY              => S15_AXI_GEN_BREADY,
    
        -- AR-Channel
        S_AXI_ARID                => S15_AXI_GEN_ARID,
        S_AXI_ARADDR              => S15_AXI_GEN_ARADDR,
        S_AXI_ARLEN               => S15_AXI_GEN_ARLEN,
        S_AXI_ARSIZE              => S15_AXI_GEN_ARSIZE,
        S_AXI_ARBURST             => S15_AXI_GEN_ARBURST,
        S_AXI_ARLOCK              => S15_AXI_GEN_ARLOCK,
        S_AXI_ARCACHE             => S15_AXI_GEN_ARCACHE,
        S_AXI_ARPROT              => S15_AXI_GEN_ARPROT,
        S_AXI_ARQOS               => S15_AXI_GEN_ARQOS,
        S_AXI_ARVALID             => S15_AXI_GEN_ARVALID,
        S_AXI_ARREADY             => S15_AXI_GEN_ARREADY,
    
        -- R-Channel
        S_AXI_RID                 => S15_AXI_GEN_RID,
        S_AXI_RDATA               => S15_AXI_GEN_RDATA,
        S_AXI_RRESP               => S15_AXI_GEN_RRESP,
        S_AXI_RLAST               => S15_AXI_GEN_RLAST,
        S_AXI_RVALID              => S15_AXI_GEN_RVALID,
        S_AXI_RREADY              => S15_AXI_GEN_RREADY,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        arbiter_piperun           => gen_port_piperun(15),
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access(C_NUM_OPTIMIZED_PORTS + 15),
        wr_port_ready             => wr_port_ready(C_NUM_OPTIMIZED_PORTS + 15),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access(C_NUM_OPTIMIZED_PORTS + 15),
        rd_port_ready             => rd_port_ready(C_NUM_OPTIMIZED_PORTS + 15),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun,
        snoop_fetch_info          => snoop_fetch_info_blk,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun,
        snoop_req_info            => snoop_req_info_blk,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun,
        snoop_act_info            => snoop_act_info_blk,
        snoop_act_tag_info        => snoop_act_tag_info_blk,
        snoop_act_ack_info        => snoop_act_ack_info_blk,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info,
        snoop_tag_new_info        => snoop_tag_new_info_blk,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_blk,
        snoop_resp_ready          => snoop_resp_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_blk,
        snoop_data_ready          => snoop_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                          (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_blk,
        wr_port_data_ready        => wr_port_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                            (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write response).
        
        access_bp_push            => access_bp_push_blk,
        
        update_ext_bresp_info     => update_ext_bresp_info_blk,
        update_ext_bresp_ready    => update_ext_bresp_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        lookup_read_data_new      => lookup_read_data_new_blk,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read Data).
        
        read_info_status          => read_info_status_blk,
        read_data_status          => read_data_status_blk,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_blk,
        snoop_read_data_ready     => snoop_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                               (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Lookup signals (Read Data).
        
        lookup_read_data_info     => lookup_read_data_info_blk,
        lookup_read_data_ready    => lookup_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Update signals (Read Data).
        
        update_read_data_info     => update_read_data_info_blk,
        update_read_data_ready    => update_read_data_ready_blk((C_NUM_OPTIMIZED_PORTS + 15 + 1) * C_CACHE_BLOCKS - 1 downto 
                                                                (C_NUM_OPTIMIZED_PORTS + 15 + 0) * C_CACHE_BLOCKS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments(15),
        stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments(15),
        stat_s_axi_gen_rip              => stat_s_axi_gen_rip(15),
        stat_s_axi_gen_r                => stat_s_axi_gen_r(15),
        stat_s_axi_gen_bip              => stat_s_axi_gen_bip(15),
        stat_s_axi_gen_bp               => stat_s_axi_gen_bp(15),
        stat_s_axi_gen_wip              => stat_s_axi_gen_wip(15),
        stat_s_axi_gen_w                => stat_s_axi_gen_w(15),
        stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency(15),
        stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency(15),
        stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf(15),
        stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf(15),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => port_assert_error(31),
        
        
        -- ---------------------------------------------------
        -- Debug Signals.
        
        IF_DEBUG                  => GEN_IF15_DEBUG 
      );
  
    Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    begin
      wr_port_data_info_all(J, C_NUM_OPTIMIZED_PORTS + 15)  <= wr_port_data_info_blk(J);
      read_info_status(J, C_NUM_OPTIMIZED_PORTS + 15)       <= read_info_status_blk(J);
      read_data_status_i(J, C_NUM_OPTIMIZED_PORTS + 15)     <= read_data_status_blk(J);
      
      update_ext_bresp_info_blk(J)                          <= update_ext_bresp_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      lookup_read_data_new_blk(J)                           <= lookup_read_data_new(J, C_NUM_OPTIMIZED_PORTS + 15);
      lookup_read_data_info_blk(J)                          <= lookup_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      snoop_read_data_info_blk(J)                           <= snoop_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      update_read_data_info_blk(J)                          <= update_read_data_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      access_bp_push_blk(J)                               <= access_bp_push(J, C_NUM_OPTIMIZED_PORTS + 15);
      
      snoop_fetch_info_blk(J)                             <= snoop_fetch_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      snoop_req_info_blk(J)                               <= snoop_req_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      snoop_act_info_blk(J)                               <= snoop_act_info(J, C_NUM_OPTIMIZED_PORTS + 15);
      
      snoop_act_tag_info(J, C_NUM_OPTIMIZED_PORTS + 15)   <= snoop_act_tag_info_blk(J);
      snoop_act_ack_info(J, C_NUM_OPTIMIZED_PORTS + 15)   <= snoop_act_ack_info_blk(J);
      snoop_tag_new_info(J, C_NUM_OPTIMIZED_PORTS + 15)   <= snoop_tag_new_info_blk(J);
      snoop_resp_info(J, C_NUM_OPTIMIZED_PORTS + 15)      <= snoop_resp_info_blk(J);
      snoop_data_info(J, C_NUM_OPTIMIZED_PORTS + 15)      <= snoop_data_info_blk(J);
      read_trans_comp_info(J, C_NUM_OPTIMIZED_PORTS + 15) <= read_trans_comp_info_blk(J);
    end generate Gen_Block;
    
    lx_cfg_support_dirty(C_NUM_OPTIMIZED_PORTS + 15)  <= '0';
  end generate Use_Generic_Port_15;
  
  No_Generic_Port_15: if ( C_NUM_GENERIC_PORTS < 16 ) generate
  begin
    S15_AXI_GEN_AWREADY    <= '0';
    S15_AXI_GEN_WREADY     <= '0';
    S15_AXI_GEN_BRESP      <= (others=>'0');
    S15_AXI_GEN_BID        <= (others=>'0');
    S15_AXI_GEN_BVALID     <= '0';
    S15_AXI_GEN_ARREADY    <= '0';
    S15_AXI_GEN_RID        <= (others=>'0');
    S15_AXI_GEN_RDATA      <= (others=>'0');
    S15_AXI_GEN_RRESP      <= (others=>'0');
    S15_AXI_GEN_RLAST      <= '0';
    S15_AXI_GEN_RVALID     <= '0';
    port_assert_error(31)  <= '0';
    GEN_IF15_DEBUG         <= (others=>'0');
  end generate No_Generic_Port_15;
  
  
  Gen_Block: for J in 0 to C_CACHE_BLOCKS - 1 generate
    
    signal arbiter_bp_push_prt        : WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal access_bp_push_prt         : WRITE_EARLY_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal wr_port_data_info_prt      : DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal access_data_info_prt       : DATA_PORTS_TYPE(C_NUM_INTERNAL_PORTS - 1 downto 0);
    signal read_data_status_prt       : STAT_RD_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_read_data_info_prt   : READ_SNOOP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Fetch Stage Signals
    signal snoop_fetch_info_prt       : SNOOP_FETCH_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Request Stage Signals.
    signal snoop_req_info_prt         : SNOOP_REQ_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Action Stage Signals.
    signal snoop_act_info_prt         : SNOOP_ACT_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_tag_info_prt     : SNOOP_ACT_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_act_ack_info_prt     : SNOOP_ACT_ACK_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Tag Information and Update Signals.
    signal snoop_tag_status_info_prt  : SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    signal snoop_tag_new_info_prt     : SNOOP_TAG_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Snoop Response Information Signals.
    signal snoop_resp_info_prt        : SNOOP_CRRESP_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
      
    -- Snoop Data Signals.
    signal snoop_data_info_prt        : SNOOP_DATA_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    -- Complete Transaction Signals.
    signal read_trans_comp_info_prt   : READ_COMPLETE_PORTS_TYPE(C_NUM_PORTS - 1 downto 0);
    
    signal stat_prt_arb_opt_read_blocked  : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
    signal stat_prt_arb_gen_read_blocked  : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
    
  begin
    -----------------------------------------------------------------------------
    -- Extract data
    -----------------------------------------------------------------------------
    
    Gen_Port: for I in 0 to C_NUM_PORTS - 1 generate
    begin
      -- Extract Info from matrix to Port vector (inputs on Access).
      wr_port_data_info_prt(I)                        <= wr_port_data_info_all(J, I);
      read_data_status_prt(I)                         <= read_data_status_i(J, I);
      snoop_act_tag_info_prt(I)                       <= snoop_act_tag_info(J, I);
      snoop_act_ack_info_prt(I)                       <= snoop_act_ack_info(J, I);
      snoop_tag_new_info_prt(I)                       <= snoop_tag_new_info(J, I);
      snoop_resp_info_prt(I)                          <= snoop_resp_info(J, I);
      snoop_data_info_prt(I)                          <= snoop_data_info(J, I);
      read_trans_comp_info_prt(I)                     <= read_trans_comp_info(J, I);
      
      -- Transpose "matrix": from slicing over Port to slicing over Block.
      wr_port_data_ready_blk(J + I * C_CACHE_BLOCKS)  <= wr_port_data_ready_prt(J * C_NUM_PORTS + I);
      lookup_read_data_ready(J * C_NUM_PORTS + I)     <= lookup_read_data_ready_blk(J + I * C_CACHE_BLOCKS);
      snoop_read_data_ready_prt(J * C_NUM_PORTS + I)  <= snoop_read_data_ready_blk(J + I * C_CACHE_BLOCKS);
      update_read_data_ready(J * C_NUM_PORTS + I)     <= update_read_data_ready_blk(J + I * C_CACHE_BLOCKS);
      update_ext_bresp_ready(J * C_NUM_PORTS + I)     <= update_ext_bresp_ready_blk(J + I * C_CACHE_BLOCKS);
      snoop_fetch_pos_hazard_prt(J * C_NUM_PORTS + I) <= snoop_fetch_pos_hazard_blk(J + I * C_CACHE_BLOCKS);
      snoop_resp_ready_blk(J + I * C_CACHE_BLOCKS)    <= snoop_resp_ready_prt(J * C_NUM_PORTS + I);
      snoop_data_ready_blk(J + I * C_CACHE_BLOCKS)    <= snoop_data_ready_prt(J * C_NUM_PORTS + I);
      
      -- Deposit Info from Port vector in matrix (outputs on Access).
      access_bp_push(J, I)                            <= access_bp_push_prt(I);
      access_data_info(J, I)                          <= access_data_info_prt(I);
      snoop_read_data_info(J, I)                      <= snoop_read_data_info_prt(I);
      snoop_fetch_info(J, I)                          <= snoop_fetch_info_prt(I);
      snoop_req_info(J, I)                            <= snoop_req_info_prt(I);
      snoop_act_info(J, I)                            <= snoop_act_info_prt(I);
      snoop_tag_status_info(J, I)                     <= snoop_tag_status_info_prt(I);
      
    end generate Gen_Port;
    Extra_Port: if ( C_NUM_INTERNAL_PORTS > C_NUM_PORTS ) generate
    begin
      access_data_info(J, C_NUM_PORTS)                <= access_data_info_prt(C_NUM_PORTS);
      
    end generate Extra_Port;

    Gen_Opt_Port: for I in 0 to C_NUM_OPTIMIZED_PORTS - 1 generate
    begin
      stat_arb_opt_read_blocked(J, I)                 <= stat_prt_arb_opt_read_blocked(I);  
    end generate Gen_Opt_Port;
      
    Gen_Gen_Port: for I in 0 to C_NUM_GENERIC_PORTS - 1 generate
    begin
      stat_arb_gen_read_blocked(J, I)                 <= stat_prt_arb_gen_read_blocked(I);
    end generate Gen_Gen_Port;
      
    
    -----------------------------------------------------------------------------
    -- Arbiter
    -----------------------------------------------------------------------------
    
    ARB: sc_arbiter
      generic map(
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- IP Specific.
        C_ID_WIDTH                => C_ID_WIDTH,
        C_ENABLE_CTRL             => C_ENABLE_CTRL,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_ENABLE_EARLY_BRESP      => C_ENABLE_EARLY_BRESP,
        C_KEEP_BUFFERABLE         => C_KEEP_BUFFERABLE,
        C_IGNORE_MODIFIABLE       => C_IGNORE_MODIFIABLE,
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_GENERIC_PORTS       => C_NUM_GENERIC_PORTS,
        C_NUM_FAST_PORTS          => C_NUM_FAST_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
    
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (All request).
        
        opt_port_piperun          => opt_port_piperun,
        arbiter_piperun           => arbiter_piperun,
        arbiter_allowed           => arbiter_allowed,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write request).
        
        wr_port_access            => wr_port_access,
        wr_port_ready             => wr_port_ready,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Read request).
        
        rd_port_access            => rd_port_access,
        rd_port_ready             => rd_port_ready,
        
        
        -- ---------------------------------------------------
        -- Arbiter signals (to Access).
        
        arb_access                => arb_access,
         
         
        -- ---------------------------------------------------
        -- Control If Transactions.
        
        ctrl_arbiter_allow        => ctrl_arbiter_allow,
        ctrl_access               => ctrl_access,
        ctrl_ready                => ctrl_ready,
        
        
        -- ---------------------------------------------------
        -- Port signals.
        
        arbiter_bp_push           => arbiter_bp_push_prt,
        
        wr_port_inbound           => wr_port_inbound,
        
        
        -- ---------------------------------------------------
        -- Access signals.
        
        access_piperun            => access_piperun,
        access_write_priority     => access_write_priority,
        access_other_write_prio   => access_other_write_prio,
        
        
        -- ---------------------------------------------------
        -- Port signals (to Arbiter).
        
        read_data_status          => read_data_status_prt,
        
        
        -- ---------------------------------------------------
        -- Lookup signals (to Arbiter).
        
        lookup_read_done          => lookup_read_done((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                      => stat_reset,
        stat_enable                     => stat_enable,
        
        stat_arb_valid                  => stat_arb_valid(J),
        stat_arb_concurrent_accesses    => stat_arb_concurrent_accesses(J),
        stat_arb_opt_read_blocked       => stat_prt_arb_opt_read_blocked,
        stat_arb_gen_read_blocked       => stat_prt_arb_gen_read_blocked,
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => arb_assert,
        
        
        -- ---------------------------------------------------
        -- Debug signals.
        
        ARBITER_DEBUG             => ARBITER_DEBUG(J)
      );
    
    
    -----------------------------------------------------------------------------
    -- Access
    -----------------------------------------------------------------------------
    
    ACS: sc_access 
      generic map (
        -- General.
        C_TARGET                  => C_TARGET,
        C_USE_DEBUG               => C_USE_DEBUG,
        C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
        C_USE_STATISTICS          => C_USE_STATISTICS,
        C_STAT_BITS               => C_STAT_BITS,
        C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
        C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
        C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
        C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
        
        -- Data type and settings specific.
        C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_HI,
        C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_LO,
        
        -- Lx Cache Specific.
        C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
        
        -- IP Specific.
        C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
        C_NUM_PORTS               => C_NUM_PORTS,
        C_NUM_INTERNAL_PORTS      => C_NUM_INTERNAL_PORTS,
        C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
        C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
        C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
        C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
        C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
        C_ID_WIDTH                => C_ID_WIDTH,
        
        -- Data type and settings specific.
        C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
        C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
        C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
        C_CACHE_DATA_ADDR_WIDTH   => C_CACHE_DATA_ADDR_WIDTH,
        C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
        C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low
      )
      port map(
        -- ---------------------------------------------------
        -- Common signals.
        
        ACLK                      => ACLK,
        ARESET                    => ARESET,
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Write Data).
        
        wr_port_data_info         => wr_port_data_info_prt,
        wr_port_data_ready        => wr_port_data_ready_prt((J+1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        
        -- ---------------------------------------------------
        -- Internal Interface Signals (Snoop communication).
        
        -- Snoop Fetch Stage Signals
        snoop_fetch_piperun       => snoop_fetch_piperun(J),
        snoop_fetch_info          => snoop_fetch_info_prt,
        snoop_fetch_pos_hazard    => snoop_fetch_pos_hazard_prt((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        -- Snoop Request Stage Signals.
        snoop_req_piperun         => snoop_req_piperun(J),
        snoop_req_info            => snoop_req_info_prt,
        
        -- Snoop Action Stage Signals.
        snoop_act_piperun         => snoop_act_piperun(J),
        snoop_act_info            => snoop_act_info_prt,
        snoop_act_tag_info        => snoop_act_tag_info_prt,
        snoop_act_ack_info        => snoop_act_ack_info_prt,
        
        -- Snoop Tag Information and Update Signals.
        snoop_tag_status_info     => snoop_tag_status_info_prt,
        snoop_tag_new_info        => snoop_tag_new_info_prt,
        
        -- Snoop Response Information Signals.
        snoop_resp_info           => snoop_resp_info_prt,
        snoop_resp_ready          => snoop_resp_ready_prt((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        -- Snoop Data Signals.
        snoop_data_info           => snoop_data_info_prt,
        snoop_data_ready          => snoop_data_ready_prt((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        -- Complete Transaction Signals.
        read_trans_comp_info      => read_trans_comp_info_prt,
          
        
        -- ---------------------------------------------------
        -- Arbiter signals.
        
        arb_access                => arb_access,
        
        arbiter_bp_push           => arbiter_bp_push_prt,
        
        wr_port_inbound           => wr_port_inbound,
        
        
        -- ---------------------------------------------------
        -- Lookup signals.
        
        lookup_piperun            => lookup_piperun(J),
        
        lookup_write_data_ready   => lookup_write_data_ready((J + 1) * C_NUM_INTERNAL_PORTS - 1 downto J * C_NUM_INTERNAL_PORTS),
        
        
        -- ---------------------------------------------------
        -- Update signals.
        
        update_write_data_ready   => update_write_data_ready((J + 1) * C_NUM_INTERNAL_PORTS - 1 downto J * C_NUM_INTERNAL_PORTS),
        
        
        -- ---------------------------------------------------
        -- Access signals (for Arbiter).
        
        access_piperun            => access_piperun,
        access_write_priority     => access_write_priority,
        access_other_write_prio   => access_other_write_prio,
        
        access_bp_push            => access_bp_push_prt,
        
        
        -- ---------------------------------------------------
        -- Access signals (to Lookup/Update).
        
        access_valid              => access_valid(J),
        access_info               => access_info(J),
        
        access_data_info          => access_data_info_prt,
        
        
        -- ---------------------------------------------------
        -- Snoop signals (Read Data & response).
        
        snoop_read_data_info      => snoop_read_data_info_prt,
        snoop_read_data_ready     => snoop_read_data_ready_prt((J + 1) * C_NUM_PORTS - 1 downto J * C_NUM_PORTS),
        
        
        -- ---------------------------------------------------
        -- ACE Downstream Barrier Request.
        
        ctrl_access_done          => ctrl_access_done(J),
        
        
        -- ---------------------------------------------------
        -- Lx Cache Configuration
        
        lx_cfg_support_dirty      => lx_cfg_support_dirty,
        
        
        -- ---------------------------------------------------
        -- Statistics Signals
        
        stat_reset                => stat_reset,
        stat_enable               => stat_enable,
        
        stat_access_valid         => stat_access_valid(J),
        stat_access_stall         => stat_access_stall(J),
        stat_access_fetch_stall   => stat_access_fetch_stall(J),
        stat_access_req_stall     => stat_access_req_stall(J),
        stat_access_act_stall     => stat_access_act_stall(J),
        
        
        -- ---------------------------------------------------
        -- Assert Signals
        
        assert_error              => acs_assert,
        
        
        -- ---------------------------------------------------
        -- Debug signals.
        
        ACCESS_DEBUG              => ACCESS_DEBUG(J)
      );
    
  end generate Gen_Block;
  
  -----------------------------------------------------------------------------
  -- External signals
  -----------------------------------------------------------------------------
  
  read_data_status  <= read_data_status_i;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_PORT_0_ERROR)  <= port_assert_error(0)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_1_ERROR)  <= port_assert_error(1)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_2_ERROR)  <= port_assert_error(2)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_3_ERROR)  <= port_assert_error(3)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_4_ERROR)  <= port_assert_error(4)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_5_ERROR)  <= port_assert_error(5)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_6_ERROR)  <= port_assert_error(6)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_7_ERROR)  <= port_assert_error(7)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_8_ERROR)  <= port_assert_error(8)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_9_ERROR)  <= port_assert_error(9)  when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_10_ERROR) <= port_assert_error(10) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_11_ERROR) <= port_assert_error(11) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_12_ERROR) <= port_assert_error(12) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_13_ERROR) <= port_assert_error(13) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_14_ERROR) <= port_assert_error(14) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_15_ERROR) <= port_assert_error(15) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_16_ERROR) <= port_assert_error(16) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_17_ERROR) <= port_assert_error(17) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_18_ERROR) <= port_assert_error(18) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_19_ERROR) <= port_assert_error(19) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_20_ERROR) <= port_assert_error(20) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_21_ERROR) <= port_assert_error(21) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_22_ERROR) <= port_assert_error(22) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_23_ERROR) <= port_assert_error(23) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_24_ERROR) <= port_assert_error(24) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_25_ERROR) <= port_assert_error(25) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_26_ERROR) <= port_assert_error(26) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_27_ERROR) <= port_assert_error(27) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_28_ERROR) <= port_assert_error(28) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_29_ERROR) <= port_assert_error(29) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_30_ERROR) <= port_assert_error(30) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_PORT_31_ERROR) <= port_assert_error(31) when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_ARBITER_ERROR) <= arb_assert            when C_USE_ASSERTIONS else '0';
    assert_err(C_ASSERT_ACCESS_ERROR)  <= acs_assert            when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_0_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 0 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_1_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 1 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_2_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 2 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_3_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 3 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_4_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 4 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_5_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 5 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_6_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 6 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_7_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 7 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_8_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 8 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_9_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 9 error."
        severity error;
    
    assert assert_err_1(C_ASSERT_PORT_10_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 10 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_11_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 11 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_12_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 12 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_13_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 13 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_14_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 14 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_15_ERROR) /= '1' 
      report "Frontend: Optimized AXI port 15 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_16_ERROR) /= '1' 
      report "Frontend: Generic AXI port 0 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_17_ERROR) /= '1' 
      report "Frontend: Generic AXI port 1 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_18_ERROR) /= '1' 
      report "Frontend: Generic AXI port 2 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_19_ERROR) /= '1' 
      report "Frontend: Generic AXI port 3 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_20_ERROR) /= '1' 
      report "Frontend: Generic AXI port 4 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_21_ERROR) /= '1' 
      report "Frontend: Generic AXI port 5 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_22_ERROR) /= '1' 
      report "Frontend: Generic AXI port 6 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_23_ERROR) /= '1' 
      report "Frontend: Generic AXI port 7 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_24_ERROR) /= '1' 
      report "Frontend: Generic AXI port 8 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_25_ERROR) /= '1' 
      report "Frontend: Generic AXI port 9 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_26_ERROR) /= '1' 
      report "Frontend: Generic AXI port 10 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_27_ERROR) /= '1' 
      report "Frontend: Generic AXI port 11 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_28_ERROR) /= '1' 
      report "Frontend: Generic AXI port 12 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_29_ERROR) /= '1' 
      report "Frontend: Generic AXI port 13 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_30_ERROR) /= '1' 
      report "Frontend: Generic AXI port 14 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_PORT_31_ERROR) /= '1' 
      report "Frontend: Generic AXI port 15 error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_ARBITER_ERROR) /= '1' 
      report "Frontend: Arbiter error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_ACCESS_ERROR) /= '1' 
      report "Frontend: Access error."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- ----------------------------------------
  -- Clocked to remove glites in simulation
  
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  -- Assign output
  assert_error  <= reduce_or(assert_err_1);
  
  
end architecture IMP;


-------------------------------------------------------------------------------
-- system_cache.vhd - Entity and architecture
-------------------------------------------------------------------------------
--
-- (c) Copyright 2011,2013,2014,2017-2018 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and 
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-------------------------------------------------------------------------------
-- Filename:        system_cache.vhd
--
-- Description:     
--                  
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:   
--              system_cache.vhd
--
-------------------------------------------------------------------------------
-- Author:          rikardw
--
-- History:
--   rikardw  2011-05-30    First Version
--
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x" 
--      reset signals:                          "rst", "rst_n" 
--      generics:                               "C_*" 
--      user defined types:                     "*_TYPE" 
--      state machine next state:               "*_ns" 
--      state machine current state:            "*_cs" 
--      combinatorial signals:                  "*_com" 
--      pipelined or register delay signals:    "*_d#" 
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce" 
--      internal version of output port         "*_i"
--      device pins:                            "*_pin" 
--      ports:                                  - Names begin with Uppercase 
--      processes:                              "*_PROCESS" 
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.system_cache_pkg.all;

entity system_cache is
  generic (
    -- General.
    C_FAMILY                  : string                        := "virtex7";
    C_INSTANCE                : string                        := "system_cache";
    C_FREQ                    : natural                       := 0;
    
    -- IP Specific.
    C_BASEADDR                : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
    C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
    C_ENABLE_STATISTICS       : natural range  0 to  255      := 255;
    C_ENABLE_VERSION_REGISTER : natural range  0 to    3      :=  0;
    C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
    C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
    C_NUM_MASTER_PORTS        : natural range  1 to    1      :=  1;
    C_ENABLE_COHERENCY        : natural range  0 to    2      :=  0;
    C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
    C_ENABLE_EXCLUSIVE        : natural range  0 to    1      :=  0;
    C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
    C_NUM_WAYS                : natural range  2 to    8      :=  2;
    C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
    C_CACHE_BLOCKS            : natural range  1 to    1      :=  1;
    C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
    C_CACHE_SIZE              : natural                       := 32768;
    C_GEN_MATCH_Lx_CACHE      : natural range  0 to    0      :=  0;
    C_ENABLE_PEER_PORT_DATA   : natural range  0 to    0      :=  0;
    C_SUPPORT_SNOOP_FILTER    : natural range  0 to    0      :=  0;
    C_KEEP_SHARED_WRITE       : natural range  1 to    1      :=  1;
    C_READ_ONLY_UNIQUE        : natural range  0 to    0      :=  0;
    C_READ_EXCLUSIVE_CLEAN    : natural range  1 to    1      :=  1;
    C_SNOOP_KEEP_READ_SHARED  : natural range  0 to    0      :=  0;
    C_SNOOP_KEEP_READ_CLEAN   : natural range  0 to    0      :=  0;
    C_SNOOP_KEEP_READ_NSD     : natural range  0 to    0      :=  0;
    C_SNOOP_KEEP_CLEAN_SHARED : natural range  0 to    0      :=  0;
    
    -- Lx Cache specific.
    C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  4;
    C_Lx_CACHE_SIZE           : natural                       := 1024;
    C_Lx_NUM_WAYS             : natural range  1 to    1      :=  1;
    
    -- Optimized AXI4 Slave Interface #0 specific.
    C_S0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S0_AXI_ID_WIDTH         : natural                       :=  1;
    C_S0_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S0_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S0_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S0_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S0_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S0_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S0_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S0_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S0_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S0_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #1 specific.
    C_S1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S1_AXI_ID_WIDTH         : natural                       :=  1;
    C_S1_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S1_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S1_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S1_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S1_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S1_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S1_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S1_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S1_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S1_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #2 specific.
    C_S2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S2_AXI_ID_WIDTH         : natural                       :=  1;
    C_S2_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S2_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S2_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S2_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S2_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S2_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S2_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S2_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S2_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S2_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #3 specific.
    C_S3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S3_AXI_ID_WIDTH         : natural                       :=  1;
    C_S3_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S3_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S3_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S3_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S3_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S3_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S3_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S3_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S3_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S3_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #4 specific.
    C_S4_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S4_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S4_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S4_AXI_ID_WIDTH         : natural                       :=  1;
    C_S4_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S4_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S4_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S4_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S4_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S4_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S4_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S4_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S4_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S4_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #5 specific.
    C_S5_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S5_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S5_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S5_AXI_ID_WIDTH         : natural                       :=  1;
    C_S5_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S5_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S5_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S5_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S5_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S5_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S5_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S5_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S5_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S5_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #6 specific.
    C_S6_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S6_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S6_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S6_AXI_ID_WIDTH         : natural                       :=  1;
    C_S6_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S6_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S6_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S6_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S6_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S6_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S6_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S6_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S6_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S6_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #7 specific.
    C_S7_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S7_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S7_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S7_AXI_ID_WIDTH         : natural                       :=  1;
    C_S7_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S7_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S7_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S7_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S7_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S7_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S7_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S7_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S7_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S7_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #8 specific.
    C_S8_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S8_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S8_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S8_AXI_ID_WIDTH         : natural                       :=  1;
    C_S8_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S8_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S8_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S8_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S8_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S8_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S8_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S8_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S8_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S8_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #9 specific.
    C_S9_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_S9_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_S9_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    C_S9_AXI_ID_WIDTH         : natural                       :=  1;
    C_S9_AXI_SUPPORT_UNIQUE            : natural range 0 to 0 :=  0;
    C_S9_AXI_SUPPORT_DIRTY             : natural range 0 to 0 :=  0;
    C_S9_AXI_FORCE_READ_ALLOCATE       : natural range 0 to 1 :=  0;
    C_S9_AXI_PROHIBIT_READ_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S9_AXI_FORCE_WRITE_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S9_AXI_PROHIBIT_WRITE_ALLOCATE   : natural range 0 to 1 :=  1;
    C_S9_AXI_FORCE_READ_BUFFER         : natural range 0 to 1 :=  0;
    C_S9_AXI_PROHIBIT_READ_BUFFER      : natural range 0 to 1 :=  0;
    C_S9_AXI_FORCE_WRITE_BUFFER        : natural range 0 to 1 :=  0;
    C_S9_AXI_PROHIBIT_WRITE_BUFFER     : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #10 specific.
    C_S10_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S10_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S10_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S10_AXI_ID_WIDTH        : natural                       :=  1;
    C_S10_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S10_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S10_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S10_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S10_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S10_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S10_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S10_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S10_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S10_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #11 specific.
    C_S11_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S11_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S11_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S11_AXI_ID_WIDTH        : natural                       :=  1;
    C_S11_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S11_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S11_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S11_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S11_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S11_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S11_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S11_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S11_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S11_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #12 specific.
    C_S12_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S12_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S12_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S12_AXI_ID_WIDTH        : natural                       :=  1;
    C_S12_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S12_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S12_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S12_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S12_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S12_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S12_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S12_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S12_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S12_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #13 specific.
    C_S13_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S13_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S13_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S13_AXI_ID_WIDTH        : natural                       :=  1;
    C_S13_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S13_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S13_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S13_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S13_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S13_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S13_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S13_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S13_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S13_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #14 specific.
    C_S14_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S14_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S14_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S14_AXI_ID_WIDTH        : natural                       :=  1;
    C_S14_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S14_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S14_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S14_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S14_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S14_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S14_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S14_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S14_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S14_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Optimized AXI4 Slave Interface #15 specific.
    C_S15_AXI_ADDR_WIDTH      : natural range 15 to   64      := 32;
    C_S15_AXI_DATA_WIDTH      : natural range 32 to 1024      := 32;
    C_S15_AXI_RRESP_WIDTH     : natural range  2 to    4      :=  2;
    C_S15_AXI_ID_WIDTH        : natural                       :=  1;
    C_S15_AXI_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S15_AXI_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S15_AXI_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S15_AXI_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S15_AXI_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S15_AXI_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S15_AXI_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S15_AXI_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S15_AXI_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S15_AXI_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #0 specific.
    C_S0_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S0_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S0_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S0_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S0_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S0_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S0_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #1 specific.
    C_S1_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S1_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S1_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S1_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S1_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S1_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S1_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #2 specific.
    C_S2_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S2_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S2_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S2_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S2_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S2_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S2_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #3 specific.
    C_S3_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S3_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S3_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S3_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S3_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S3_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S3_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #4 specific.
    C_S4_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S4_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S4_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S4_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S4_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S4_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S4_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #5 specific.
    C_S5_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S5_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S5_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S5_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S5_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S5_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S5_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #6 specific.
    C_S6_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S6_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S6_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S6_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S6_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S6_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S6_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #7 specific.
    C_S7_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S7_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S7_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S7_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S7_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S7_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S7_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #8 specific.
    C_S8_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S8_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S8_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S8_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S8_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S8_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S8_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #9 specific.
    C_S9_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
    C_S9_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
    C_S9_AXI_GEN_ID_WIDTH     : natural                       :=  1;
    C_S9_AXI_GEN_SUPPORT_UNIQUE           : natural range 0 to 0 :=  0;
    C_S9_AXI_GEN_SUPPORT_DIRTY            : natural range 0 to 0 :=  0;
    C_S9_AXI_GEN_FORCE_READ_ALLOCATE      : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range 0 to 1 :=  1;
    C_S9_AXI_GEN_FORCE_READ_BUFFER        : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_FORCE_WRITE_BUFFER       : natural range 0 to 1 :=  0;
    C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #10 specific.
    C_S10_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S10_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S10_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S10_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S10_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S10_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S10_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #11 specific.
    C_S11_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S11_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S11_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S11_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S11_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S11_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S11_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #12 specific.
    C_S12_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S12_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S12_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S12_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S12_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S12_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S12_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #13 specific.
    C_S13_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S13_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S13_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S13_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S13_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S13_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S13_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #14 specific.
    C_S14_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S14_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S14_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S14_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S14_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S14_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S14_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Generic AXI4 Slave Interface #15 specific.
    C_S15_AXI_GEN_ADDR_WIDTH  : natural range 15 to   64      := 32;
    C_S15_AXI_GEN_DATA_WIDTH  : natural range 32 to 1024      := 32;
    C_S15_AXI_GEN_ID_WIDTH    : natural                       :=  1;
    C_S15_AXI_GEN_SUPPORT_UNIQUE          : natural range 0 to 0 :=  0;
    C_S15_AXI_GEN_SUPPORT_DIRTY           : natural range 0 to 0 :=  0;
    C_S15_AXI_GEN_FORCE_READ_ALLOCATE     : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE  : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE    : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE : natural range 0 to 1 :=  1;
    C_S15_AXI_GEN_FORCE_READ_BUFFER       : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_PROHIBIT_READ_BUFFER    : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_FORCE_WRITE_BUFFER      : natural range 0 to 1 :=  0;
    C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER   : natural range 0 to 1 :=  0;
    
    -- Control AXI4-Lite Slave Interface specific.
    C_S_AXI_CTRL_ADDR_WIDTH   : natural range 17 to   64      := 32;
    C_S_AXI_CTRL_DATA_WIDTH   : natural range 32 to   64      := 32;
    
    -- AXI4 Master Interface #0 specific.
    C_M0_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #1 specific.
    C_M1_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #2 specific.
    C_M2_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
    
    -- AXI4 Master Interface #3 specific.
    C_M3_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
    C_M3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
    C_M3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
    C_M3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2
  );
  port (
    -- ---------------------------------------------------
    -- Common signals.
    
    ACLK                      : in  std_logic;
    ARESETN                   : in  std_logic;
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #0 Slave Signals.
    
    S0_AXI_AWID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_AWADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
    S0_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S0_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S0_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S0_AXI_AWLOCK             : in  std_logic;
    S0_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S0_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S0_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S0_AXI_AWVALID            : in  std_logic;
    S0_AXI_AWREADY            : out std_logic;
    S0_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S0_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S0_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S0_AXI_WDATA              : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
    S0_AXI_WSTRB              : in  std_logic_vector((C_S0_AXI_DATA_WIDTH/8)-1 downto 0);
    S0_AXI_WLAST              : in  std_logic;
    S0_AXI_WVALID             : in  std_logic;
    S0_AXI_WREADY             : out std_logic;
    
    S0_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S0_AXI_BID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_BVALID             : out std_logic;
    S0_AXI_BREADY             : in  std_logic;
    S0_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S0_AXI_ARID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_ARADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
    S0_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S0_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S0_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S0_AXI_ARLOCK             : in  std_logic;
    S0_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S0_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S0_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S0_AXI_ARVALID            : in  std_logic;
    S0_AXI_ARREADY            : out std_logic;
    S0_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S0_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S0_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S0_AXI_RID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
    S0_AXI_RDATA              : out std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
    S0_AXI_RRESP              : out std_logic_vector(C_S0_AXI_RRESP_WIDTH-1 downto 0);
    S0_AXI_RLAST              : out std_logic;
    S0_AXI_RVALID             : out std_logic;
    S0_AXI_RREADY             : in  std_logic;
    S0_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S0_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S0_AXI_ACADDR             : out std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S0_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S0_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S0_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S0_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S0_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S0_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S0_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S0_AXI_CDDATA             : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S0_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S0_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #1 Slave Signals.
    
    S1_AXI_AWID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_AWADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
    S1_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S1_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S1_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S1_AXI_AWLOCK             : in  std_logic;
    S1_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S1_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S1_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S1_AXI_AWVALID            : in  std_logic;
    S1_AXI_AWREADY            : out std_logic;
    S1_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S1_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S1_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S1_AXI_WDATA              : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
    S1_AXI_WSTRB              : in  std_logic_vector((C_S1_AXI_DATA_WIDTH/8)-1 downto 0);
    S1_AXI_WLAST              : in  std_logic;
    S1_AXI_WVALID             : in  std_logic;
    S1_AXI_WREADY             : out std_logic;
    
    S1_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S1_AXI_BID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_BVALID             : out std_logic;
    S1_AXI_BREADY             : in  std_logic;
    S1_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S1_AXI_ARID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_ARADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
    S1_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S1_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S1_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S1_AXI_ARLOCK             : in  std_logic;
    S1_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S1_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S1_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S1_AXI_ARVALID            : in  std_logic;
    S1_AXI_ARREADY            : out std_logic;
    S1_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S1_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S1_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S1_AXI_RID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
    S1_AXI_RDATA              : out std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
    S1_AXI_RRESP              : out std_logic_vector(C_S1_AXI_RRESP_WIDTH-1 downto 0);
    S1_AXI_RLAST              : out std_logic;
    S1_AXI_RVALID             : out std_logic;
    S1_AXI_RREADY             : in  std_logic;
    S1_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S1_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S1_AXI_ACADDR             : out std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S1_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S1_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S1_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S1_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S1_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S1_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S1_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S1_AXI_CDDATA             : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S1_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S1_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #2 Slave Signals.
    
    S2_AXI_AWID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_AWADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
    S2_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S2_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S2_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S2_AXI_AWLOCK             : in  std_logic;
    S2_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S2_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S2_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S2_AXI_AWVALID            : in  std_logic;
    S2_AXI_AWREADY            : out std_logic;
    S2_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S2_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S2_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S2_AXI_WDATA              : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
    S2_AXI_WSTRB              : in  std_logic_vector((C_S2_AXI_DATA_WIDTH/8)-1 downto 0);
    S2_AXI_WLAST              : in  std_logic;
    S2_AXI_WVALID             : in  std_logic;
    S2_AXI_WREADY             : out std_logic;
    
    S2_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S2_AXI_BID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_BVALID             : out std_logic;
    S2_AXI_BREADY             : in  std_logic;
    S2_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S2_AXI_ARID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_ARADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
    S2_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S2_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S2_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S2_AXI_ARLOCK             : in  std_logic;
    S2_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S2_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S2_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S2_AXI_ARVALID            : in  std_logic;
    S2_AXI_ARREADY            : out std_logic;
    S2_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S2_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S2_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S2_AXI_RID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
    S2_AXI_RDATA              : out std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
    S2_AXI_RRESP              : out std_logic_vector(C_S2_AXI_RRESP_WIDTH-1 downto 0);
    S2_AXI_RLAST              : out std_logic;
    S2_AXI_RVALID             : out std_logic;
    S2_AXI_RREADY             : in  std_logic;
    S2_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S2_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S2_AXI_ACADDR             : out std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S2_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S2_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S2_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S2_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S2_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S2_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S2_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S2_AXI_CDDATA             : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S2_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S2_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #3 Slave Signals.
    
    S3_AXI_AWID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_AWADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
    S3_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S3_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S3_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S3_AXI_AWLOCK             : in  std_logic;
    S3_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S3_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S3_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S3_AXI_AWVALID            : in  std_logic;
    S3_AXI_AWREADY            : out std_logic;
    S3_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S3_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S3_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S3_AXI_WDATA              : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
    S3_AXI_WSTRB              : in  std_logic_vector((C_S3_AXI_DATA_WIDTH/8)-1 downto 0);
    S3_AXI_WLAST              : in  std_logic;
    S3_AXI_WVALID             : in  std_logic;
    S3_AXI_WREADY             : out std_logic;
    
    S3_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S3_AXI_BID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_BVALID             : out std_logic;
    S3_AXI_BREADY             : in  std_logic;
    S3_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S3_AXI_ARID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_ARADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
    S3_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S3_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S3_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S3_AXI_ARLOCK             : in  std_logic;
    S3_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S3_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S3_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S3_AXI_ARVALID            : in  std_logic;
    S3_AXI_ARREADY            : out std_logic;
    S3_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S3_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S3_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S3_AXI_RID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
    S3_AXI_RDATA              : out std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
    S3_AXI_RRESP              : out std_logic_vector(C_S3_AXI_RRESP_WIDTH-1 downto 0);
    S3_AXI_RLAST              : out std_logic;
    S3_AXI_RVALID             : out std_logic;
    S3_AXI_RREADY             : in  std_logic;
    S3_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S3_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S3_AXI_ACADDR             : out std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S3_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S3_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S3_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S3_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S3_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S3_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S3_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S3_AXI_CDDATA             : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S3_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S3_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #4 Slave Signals.
    
    S4_AXI_AWID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_AWADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
    S4_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S4_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S4_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S4_AXI_AWLOCK             : in  std_logic;
    S4_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S4_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S4_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S4_AXI_AWVALID            : in  std_logic;
    S4_AXI_AWREADY            : out std_logic;
    S4_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S4_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S4_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S4_AXI_WDATA              : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
    S4_AXI_WSTRB              : in  std_logic_vector((C_S4_AXI_DATA_WIDTH/8)-1 downto 0);
    S4_AXI_WLAST              : in  std_logic;
    S4_AXI_WVALID             : in  std_logic;
    S4_AXI_WREADY             : out std_logic;
    
    S4_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S4_AXI_BID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_BVALID             : out std_logic;
    S4_AXI_BREADY             : in  std_logic;
    S4_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S4_AXI_ARID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_ARADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
    S4_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S4_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S4_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S4_AXI_ARLOCK             : in  std_logic;
    S4_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S4_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S4_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S4_AXI_ARVALID            : in  std_logic;
    S4_AXI_ARREADY            : out std_logic;
    S4_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S4_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S4_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S4_AXI_RID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
    S4_AXI_RDATA              : out std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
    S4_AXI_RRESP              : out std_logic_vector(C_S4_AXI_RRESP_WIDTH-1 downto 0);
    S4_AXI_RLAST              : out std_logic;
    S4_AXI_RVALID             : out std_logic;
    S4_AXI_RREADY             : in  std_logic;
    S4_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S4_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S4_AXI_ACADDR             : out std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S4_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S4_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S4_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S4_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S4_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S4_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S4_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S4_AXI_CDDATA             : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S4_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S4_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #5 Slave Signals.
    
    S5_AXI_AWID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_AWADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
    S5_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S5_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S5_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S5_AXI_AWLOCK             : in  std_logic;
    S5_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S5_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S5_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S5_AXI_AWVALID            : in  std_logic;
    S5_AXI_AWREADY            : out std_logic;
    S5_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S5_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S5_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S5_AXI_WDATA              : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
    S5_AXI_WSTRB              : in  std_logic_vector((C_S5_AXI_DATA_WIDTH/8)-1 downto 0);
    S5_AXI_WLAST              : in  std_logic;
    S5_AXI_WVALID             : in  std_logic;
    S5_AXI_WREADY             : out std_logic;
    
    S5_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S5_AXI_BID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_BVALID             : out std_logic;
    S5_AXI_BREADY             : in  std_logic;
    S5_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S5_AXI_ARID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_ARADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
    S5_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S5_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S5_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S5_AXI_ARLOCK             : in  std_logic;
    S5_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S5_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S5_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S5_AXI_ARVALID            : in  std_logic;
    S5_AXI_ARREADY            : out std_logic;
    S5_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S5_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S5_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S5_AXI_RID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
    S5_AXI_RDATA              : out std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
    S5_AXI_RRESP              : out std_logic_vector(C_S5_AXI_RRESP_WIDTH-1 downto 0);
    S5_AXI_RLAST              : out std_logic;
    S5_AXI_RVALID             : out std_logic;
    S5_AXI_RREADY             : in  std_logic;
    S5_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S5_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S5_AXI_ACADDR             : out std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S5_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S5_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S5_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S5_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S5_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S5_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S5_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S5_AXI_CDDATA             : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S5_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S5_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #6 Slave Signals.
    
    S6_AXI_AWID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_AWADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
    S6_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S6_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S6_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S6_AXI_AWLOCK             : in  std_logic;
    S6_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S6_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S6_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S6_AXI_AWVALID            : in  std_logic;
    S6_AXI_AWREADY            : out std_logic;
    S6_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S6_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S6_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S6_AXI_WDATA              : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
    S6_AXI_WSTRB              : in  std_logic_vector((C_S6_AXI_DATA_WIDTH/8)-1 downto 0);
    S6_AXI_WLAST              : in  std_logic;
    S6_AXI_WVALID             : in  std_logic;
    S6_AXI_WREADY             : out std_logic;
    
    S6_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S6_AXI_BID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_BVALID             : out std_logic;
    S6_AXI_BREADY             : in  std_logic;
    S6_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S6_AXI_ARID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_ARADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
    S6_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S6_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S6_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S6_AXI_ARLOCK             : in  std_logic;
    S6_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S6_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S6_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S6_AXI_ARVALID            : in  std_logic;
    S6_AXI_ARREADY            : out std_logic;
    S6_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S6_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S6_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S6_AXI_RID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
    S6_AXI_RDATA              : out std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
    S6_AXI_RRESP              : out std_logic_vector(C_S6_AXI_RRESP_WIDTH-1 downto 0);
    S6_AXI_RLAST              : out std_logic;
    S6_AXI_RVALID             : out std_logic;
    S6_AXI_RREADY             : in  std_logic;
    S6_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S6_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S6_AXI_ACADDR             : out std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S6_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S6_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S6_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S6_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S6_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S6_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S6_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S6_AXI_CDDATA             : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S6_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S6_AXI_CDREADY            : out std_logic;                                         -- For ACE
    

    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #7 Slave Signals.
    
    S7_AXI_AWID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_AWADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
    S7_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S7_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S7_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S7_AXI_AWLOCK             : in  std_logic;
    S7_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S7_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S7_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S7_AXI_AWVALID            : in  std_logic;
    S7_AXI_AWREADY            : out std_logic;
    S7_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S7_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S7_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S7_AXI_WDATA              : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
    S7_AXI_WSTRB              : in  std_logic_vector((C_S7_AXI_DATA_WIDTH/8)-1 downto 0);
    S7_AXI_WLAST              : in  std_logic;
    S7_AXI_WVALID             : in  std_logic;
    S7_AXI_WREADY             : out std_logic;
    
    S7_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S7_AXI_BID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_BVALID             : out std_logic;
    S7_AXI_BREADY             : in  std_logic;
    S7_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S7_AXI_ARID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_ARADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
    S7_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S7_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S7_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S7_AXI_ARLOCK             : in  std_logic;
    S7_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S7_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S7_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S7_AXI_ARVALID            : in  std_logic;
    S7_AXI_ARREADY            : out std_logic;
    S7_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S7_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S7_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S7_AXI_RID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
    S7_AXI_RDATA              : out std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
    S7_AXI_RRESP              : out std_logic_vector(C_S7_AXI_RRESP_WIDTH-1 downto 0);
    S7_AXI_RLAST              : out std_logic;
    S7_AXI_RVALID             : out std_logic;
    S7_AXI_RREADY             : in  std_logic;
    S7_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S7_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S7_AXI_ACADDR             : out std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S7_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S7_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S7_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S7_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S7_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S7_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S7_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S7_AXI_CDDATA             : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S7_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S7_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #8 Slave Signals.
    
    S8_AXI_AWID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_AWADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
    S8_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S8_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S8_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S8_AXI_AWLOCK             : in  std_logic;
    S8_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S8_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S8_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S8_AXI_AWVALID            : in  std_logic;
    S8_AXI_AWREADY            : out std_logic;
    S8_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S8_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S8_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S8_AXI_WDATA              : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
    S8_AXI_WSTRB              : in  std_logic_vector((C_S8_AXI_DATA_WIDTH/8)-1 downto 0);
    S8_AXI_WLAST              : in  std_logic;
    S8_AXI_WVALID             : in  std_logic;
    S8_AXI_WREADY             : out std_logic;
    
    S8_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S8_AXI_BID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_BVALID             : out std_logic;
    S8_AXI_BREADY             : in  std_logic;
    S8_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S8_AXI_ARID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_ARADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
    S8_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S8_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S8_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S8_AXI_ARLOCK             : in  std_logic;
    S8_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S8_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S8_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S8_AXI_ARVALID            : in  std_logic;
    S8_AXI_ARREADY            : out std_logic;
    S8_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S8_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S8_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S8_AXI_RID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
    S8_AXI_RDATA              : out std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
    S8_AXI_RRESP              : out std_logic_vector(C_S8_AXI_RRESP_WIDTH-1 downto 0);
    S8_AXI_RLAST              : out std_logic;
    S8_AXI_RVALID             : out std_logic;
    S8_AXI_RREADY             : in  std_logic;
    S8_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S8_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S8_AXI_ACADDR             : out std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S8_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S8_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S8_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S8_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S8_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S8_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S8_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S8_AXI_CDDATA             : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S8_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S8_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #9 Slave Signals.
    
    S9_AXI_AWID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_AWADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
    S9_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S9_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S9_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S9_AXI_AWLOCK             : in  std_logic;
    S9_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S9_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S9_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S9_AXI_AWVALID            : in  std_logic;
    S9_AXI_AWREADY            : out std_logic;
    S9_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S9_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S9_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S9_AXI_WDATA              : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
    S9_AXI_WSTRB              : in  std_logic_vector((C_S9_AXI_DATA_WIDTH/8)-1 downto 0);
    S9_AXI_WLAST              : in  std_logic;
    S9_AXI_WVALID             : in  std_logic;
    S9_AXI_WREADY             : out std_logic;
    
    S9_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S9_AXI_BID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_BVALID             : out std_logic;
    S9_AXI_BREADY             : in  std_logic;
    S9_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S9_AXI_ARID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_ARADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
    S9_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S9_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S9_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S9_AXI_ARLOCK             : in  std_logic;
    S9_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S9_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S9_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S9_AXI_ARVALID            : in  std_logic;
    S9_AXI_ARREADY            : out std_logic;
    S9_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S9_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S9_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S9_AXI_RID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
    S9_AXI_RDATA              : out std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
    S9_AXI_RRESP              : out std_logic_vector(C_S9_AXI_RRESP_WIDTH-1 downto 0);
    S9_AXI_RLAST              : out std_logic;
    S9_AXI_RVALID             : out std_logic;
    S9_AXI_RREADY             : in  std_logic;
    S9_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S9_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S9_AXI_ACADDR             : out std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    S9_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S9_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S9_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S9_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S9_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S9_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S9_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S9_AXI_CDDATA             : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    S9_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S9_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #10 Slave Signals.
    
    S10_AXI_AWID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_AWADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
    S10_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S10_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S10_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S10_AXI_AWLOCK             : in  std_logic;
    S10_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S10_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S10_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S10_AXI_AWVALID            : in  std_logic;
    S10_AXI_AWREADY            : out std_logic;
    S10_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S10_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S10_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S10_AXI_WDATA              : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
    S10_AXI_WSTRB              : in  std_logic_vector((C_S10_AXI_DATA_WIDTH/8)-1 downto 0);
    S10_AXI_WLAST              : in  std_logic;
    S10_AXI_WVALID             : in  std_logic;
    S10_AXI_WREADY             : out std_logic;
    
    S10_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S10_AXI_BID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_BVALID             : out std_logic;
    S10_AXI_BREADY             : in  std_logic;
    S10_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S10_AXI_ARID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_ARADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
    S10_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S10_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S10_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S10_AXI_ARLOCK             : in  std_logic;
    S10_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S10_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S10_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S10_AXI_ARVALID            : in  std_logic;
    S10_AXI_ARREADY            : out std_logic;
    S10_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S10_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S10_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S10_AXI_RID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
    S10_AXI_RDATA              : out std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
    S10_AXI_RRESP              : out std_logic_vector(C_S10_AXI_RRESP_WIDTH-1 downto 0);
    S10_AXI_RLAST              : out std_logic;
    S10_AXI_RVALID             : out std_logic;
    S10_AXI_RREADY             : in  std_logic;
    S10_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S10_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S10_AXI_ACADDR             : out std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S10_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S10_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S10_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S10_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S10_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S10_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S10_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S10_AXI_CDDATA             : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S10_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S10_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #11 Slave Signals.
    
    S11_AXI_AWID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_AWADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
    S11_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S11_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S11_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S11_AXI_AWLOCK             : in  std_logic;
    S11_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S11_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S11_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S11_AXI_AWVALID            : in  std_logic;
    S11_AXI_AWREADY            : out std_logic;
    S11_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S11_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S11_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S11_AXI_WDATA              : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
    S11_AXI_WSTRB              : in  std_logic_vector((C_S11_AXI_DATA_WIDTH/8)-1 downto 0);
    S11_AXI_WLAST              : in  std_logic;
    S11_AXI_WVALID             : in  std_logic;
    S11_AXI_WREADY             : out std_logic;
    
    S11_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S11_AXI_BID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_BVALID             : out std_logic;
    S11_AXI_BREADY             : in  std_logic;
    S11_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S11_AXI_ARID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_ARADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
    S11_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S11_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S11_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S11_AXI_ARLOCK             : in  std_logic;
    S11_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S11_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S11_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S11_AXI_ARVALID            : in  std_logic;
    S11_AXI_ARREADY            : out std_logic;
    S11_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S11_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S11_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S11_AXI_RID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
    S11_AXI_RDATA              : out std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
    S11_AXI_RRESP              : out std_logic_vector(C_S11_AXI_RRESP_WIDTH-1 downto 0);
    S11_AXI_RLAST              : out std_logic;
    S11_AXI_RVALID             : out std_logic;
    S11_AXI_RREADY             : in  std_logic;
    S11_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S11_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S11_AXI_ACADDR             : out std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S11_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S11_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S11_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S11_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S11_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S11_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S11_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S11_AXI_CDDATA             : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S11_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S11_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #12 Slave Signals.
    
    S12_AXI_AWID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_AWADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
    S12_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S12_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S12_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S12_AXI_AWLOCK             : in  std_logic;
    S12_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S12_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S12_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S12_AXI_AWVALID            : in  std_logic;
    S12_AXI_AWREADY            : out std_logic;
    S12_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S12_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S12_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S12_AXI_WDATA              : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
    S12_AXI_WSTRB              : in  std_logic_vector((C_S12_AXI_DATA_WIDTH/8)-1 downto 0);
    S12_AXI_WLAST              : in  std_logic;
    S12_AXI_WVALID             : in  std_logic;
    S12_AXI_WREADY             : out std_logic;
    
    S12_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S12_AXI_BID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_BVALID             : out std_logic;
    S12_AXI_BREADY             : in  std_logic;
    S12_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S12_AXI_ARID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_ARADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
    S12_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S12_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S12_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S12_AXI_ARLOCK             : in  std_logic;
    S12_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S12_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S12_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S12_AXI_ARVALID            : in  std_logic;
    S12_AXI_ARREADY            : out std_logic;
    S12_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S12_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S12_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S12_AXI_RID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
    S12_AXI_RDATA              : out std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
    S12_AXI_RRESP              : out std_logic_vector(C_S12_AXI_RRESP_WIDTH-1 downto 0);
    S12_AXI_RLAST              : out std_logic;
    S12_AXI_RVALID             : out std_logic;
    S12_AXI_RREADY             : in  std_logic;
    S12_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S12_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S12_AXI_ACADDR             : out std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S12_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S12_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S12_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S12_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S12_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S12_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S12_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S12_AXI_CDDATA             : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S12_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S12_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #13 Slave Signals.
    
    S13_AXI_AWID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_AWADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
    S13_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S13_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S13_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S13_AXI_AWLOCK             : in  std_logic;
    S13_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S13_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S13_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S13_AXI_AWVALID            : in  std_logic;
    S13_AXI_AWREADY            : out std_logic;
    S13_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S13_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S13_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S13_AXI_WDATA              : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
    S13_AXI_WSTRB              : in  std_logic_vector((C_S13_AXI_DATA_WIDTH/8)-1 downto 0);
    S13_AXI_WLAST              : in  std_logic;
    S13_AXI_WVALID             : in  std_logic;
    S13_AXI_WREADY             : out std_logic;
    
    S13_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S13_AXI_BID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_BVALID             : out std_logic;
    S13_AXI_BREADY             : in  std_logic;
    S13_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S13_AXI_ARID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_ARADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
    S13_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S13_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S13_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S13_AXI_ARLOCK             : in  std_logic;
    S13_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S13_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S13_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S13_AXI_ARVALID            : in  std_logic;
    S13_AXI_ARREADY            : out std_logic;
    S13_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S13_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S13_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S13_AXI_RID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
    S13_AXI_RDATA              : out std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
    S13_AXI_RRESP              : out std_logic_vector(C_S13_AXI_RRESP_WIDTH-1 downto 0);
    S13_AXI_RLAST              : out std_logic;
    S13_AXI_RVALID             : out std_logic;
    S13_AXI_RREADY             : in  std_logic;
    S13_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S13_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S13_AXI_ACADDR             : out std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S13_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S13_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S13_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S13_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S13_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S13_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S13_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S13_AXI_CDDATA             : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S13_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S13_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #14 Slave Signals.
    
    S14_AXI_AWID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_AWADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
    S14_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S14_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S14_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S14_AXI_AWLOCK             : in  std_logic;
    S14_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S14_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S14_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S14_AXI_AWVALID            : in  std_logic;
    S14_AXI_AWREADY            : out std_logic;
    S14_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S14_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S14_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S14_AXI_WDATA              : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
    S14_AXI_WSTRB              : in  std_logic_vector((C_S14_AXI_DATA_WIDTH/8)-1 downto 0);
    S14_AXI_WLAST              : in  std_logic;
    S14_AXI_WVALID             : in  std_logic;
    S14_AXI_WREADY             : out std_logic;
    
    S14_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S14_AXI_BID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_BVALID             : out std_logic;
    S14_AXI_BREADY             : in  std_logic;
    S14_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S14_AXI_ARID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_ARADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
    S14_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S14_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S14_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S14_AXI_ARLOCK             : in  std_logic;
    S14_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S14_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S14_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S14_AXI_ARVALID            : in  std_logic;
    S14_AXI_ARREADY            : out std_logic;
    S14_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S14_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S14_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S14_AXI_RID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
    S14_AXI_RDATA              : out std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
    S14_AXI_RRESP              : out std_logic_vector(C_S14_AXI_RRESP_WIDTH-1 downto 0);
    S14_AXI_RLAST              : out std_logic;
    S14_AXI_RVALID             : out std_logic;
    S14_AXI_RREADY             : in  std_logic;
    S14_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S14_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S14_AXI_ACADDR             : out std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S14_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S14_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S14_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S14_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S14_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S14_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S14_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S14_AXI_CDDATA             : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S14_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S14_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Optimized AXI4/ACE Interface #15 Slave Signals.
    
    S15_AXI_AWID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_AWADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
    S15_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
    S15_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
    S15_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
    S15_AXI_AWLOCK             : in  std_logic;
    S15_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
    S15_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
    S15_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
    S15_AXI_AWVALID            : in  std_logic;
    S15_AXI_AWREADY            : out std_logic;
    S15_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S15_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
    S15_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S15_AXI_WDATA              : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
    S15_AXI_WSTRB              : in  std_logic_vector((C_S15_AXI_DATA_WIDTH/8)-1 downto 0);
    S15_AXI_WLAST              : in  std_logic;
    S15_AXI_WVALID             : in  std_logic;
    S15_AXI_WREADY             : out std_logic;
    
    S15_AXI_BRESP              : out std_logic_vector(1 downto 0);
    S15_AXI_BID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_BVALID             : out std_logic;
    S15_AXI_BREADY             : in  std_logic;
    S15_AXI_WACK               : in  std_logic;                                         -- For ACE
    
    S15_AXI_ARID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_ARADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
    S15_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
    S15_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
    S15_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
    S15_AXI_ARLOCK             : in  std_logic;
    S15_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
    S15_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
    S15_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
    S15_AXI_ARVALID            : in  std_logic;
    S15_AXI_ARREADY            : out std_logic;
    S15_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
    S15_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    S15_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
    
    S15_AXI_RID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
    S15_AXI_RDATA              : out std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
    S15_AXI_RRESP              : out std_logic_vector(C_S15_AXI_RRESP_WIDTH-1 downto 0);
    S15_AXI_RLAST              : out std_logic;
    S15_AXI_RVALID             : out std_logic;
    S15_AXI_RREADY             : in  std_logic;
    S15_AXI_RACK               : in  std_logic;                                         -- For ACE
    
    S15_AXI_ACVALID            : out std_logic;                                         -- For ACE
    S15_AXI_ACADDR             : out std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
    S15_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    S15_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
    S15_AXI_ACREADY            : in  std_logic;                                         -- For ACE
    
    S15_AXI_CRVALID            : in  std_logic;                                         -- For ACE
    S15_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
    S15_AXI_CRREADY            : out std_logic;                                         -- For ACE
    
    S15_AXI_CDVALID            : in  std_logic;                                         -- For ACE
    S15_AXI_CDDATA             : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0); -- For ACE
    S15_AXI_CDLAST             : in  std_logic;                                         -- For ACE
    S15_AXI_CDREADY            : out std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #0 Slave Signals.
    
    S0_AXI_GEN_AWID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_AWADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S0_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S0_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S0_AXI_GEN_AWLOCK         : in  std_logic;
    S0_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_AWVALID        : in  std_logic;
    S0_AXI_GEN_AWREADY        : out std_logic;
    
    S0_AXI_GEN_WDATA          : in  std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
    S0_AXI_GEN_WSTRB          : in  std_logic_vector((C_S0_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S0_AXI_GEN_WLAST          : in  std_logic;
    S0_AXI_GEN_WVALID         : in  std_logic;
    S0_AXI_GEN_WREADY         : out std_logic;
    
    S0_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S0_AXI_GEN_BID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_BVALID         : out std_logic;
    S0_AXI_GEN_BREADY         : in  std_logic;
    
    S0_AXI_GEN_ARID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_ARADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S0_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S0_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S0_AXI_GEN_ARLOCK         : in  std_logic;
    S0_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S0_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S0_AXI_GEN_ARVALID        : in  std_logic;
    S0_AXI_GEN_ARREADY        : out std_logic;
    
    S0_AXI_GEN_RID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
    S0_AXI_GEN_RDATA          : out std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
    S0_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S0_AXI_GEN_RLAST          : out std_logic;
    S0_AXI_GEN_RVALID         : out std_logic;
    S0_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #1 Slave Signals.
    
    S1_AXI_GEN_AWID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_AWADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S1_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S1_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S1_AXI_GEN_AWLOCK         : in  std_logic;
    S1_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_AWVALID        : in  std_logic;
    S1_AXI_GEN_AWREADY        : out std_logic;
    
    S1_AXI_GEN_WDATA          : in  std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
    S1_AXI_GEN_WSTRB          : in  std_logic_vector((C_S1_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S1_AXI_GEN_WLAST          : in  std_logic;
    S1_AXI_GEN_WVALID         : in  std_logic;
    S1_AXI_GEN_WREADY         : out std_logic;
    
    S1_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S1_AXI_GEN_BID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_BVALID         : out std_logic;
    S1_AXI_GEN_BREADY         : in  std_logic;
    
    S1_AXI_GEN_ARID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_ARADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S1_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S1_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S1_AXI_GEN_ARLOCK         : in  std_logic;
    S1_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S1_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S1_AXI_GEN_ARVALID        : in  std_logic;
    S1_AXI_GEN_ARREADY        : out std_logic;
    
    S1_AXI_GEN_RID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
    S1_AXI_GEN_RDATA          : out std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
    S1_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S1_AXI_GEN_RLAST          : out std_logic;
    S1_AXI_GEN_RVALID         : out std_logic;
    S1_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #2 Slave Signals.
    
    S2_AXI_GEN_AWID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_AWADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S2_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S2_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S2_AXI_GEN_AWLOCK         : in  std_logic;
    S2_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_AWVALID        : in  std_logic;
    S2_AXI_GEN_AWREADY        : out std_logic;
    
    S2_AXI_GEN_WDATA          : in  std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
    S2_AXI_GEN_WSTRB          : in  std_logic_vector((C_S2_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S2_AXI_GEN_WLAST          : in  std_logic;
    S2_AXI_GEN_WVALID         : in  std_logic;
    S2_AXI_GEN_WREADY         : out std_logic;
    
    S2_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S2_AXI_GEN_BID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_BVALID         : out std_logic;
    S2_AXI_GEN_BREADY         : in  std_logic;
    
    S2_AXI_GEN_ARID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_ARADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S2_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S2_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S2_AXI_GEN_ARLOCK         : in  std_logic;
    S2_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S2_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S2_AXI_GEN_ARVALID        : in  std_logic;
    S2_AXI_GEN_ARREADY        : out std_logic;
    
    S2_AXI_GEN_RID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
    S2_AXI_GEN_RDATA          : out std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
    S2_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S2_AXI_GEN_RLAST          : out std_logic;
    S2_AXI_GEN_RVALID         : out std_logic;
    S2_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #3 Slave Signals.
    
    S3_AXI_GEN_AWID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_AWADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S3_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S3_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S3_AXI_GEN_AWLOCK         : in  std_logic;
    S3_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_AWVALID        : in  std_logic;
    S3_AXI_GEN_AWREADY        : out std_logic;
    
    S3_AXI_GEN_WDATA          : in  std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
    S3_AXI_GEN_WSTRB          : in  std_logic_vector((C_S3_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S3_AXI_GEN_WLAST          : in  std_logic;
    S3_AXI_GEN_WVALID         : in  std_logic;
    S3_AXI_GEN_WREADY         : out std_logic;
    
    S3_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S3_AXI_GEN_BID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_BVALID         : out std_logic;
    S3_AXI_GEN_BREADY         : in  std_logic;
    
    S3_AXI_GEN_ARID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_ARADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S3_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S3_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S3_AXI_GEN_ARLOCK         : in  std_logic;
    S3_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S3_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S3_AXI_GEN_ARVALID        : in  std_logic;
    S3_AXI_GEN_ARREADY        : out std_logic;
    
    S3_AXI_GEN_RID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
    S3_AXI_GEN_RDATA          : out std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
    S3_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S3_AXI_GEN_RLAST          : out std_logic;
    S3_AXI_GEN_RVALID         : out std_logic;
    S3_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #4 Slave Signals.
    
    S4_AXI_GEN_AWID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_AWADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S4_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S4_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S4_AXI_GEN_AWLOCK         : in  std_logic;
    S4_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_AWVALID        : in  std_logic;
    S4_AXI_GEN_AWREADY        : out std_logic;
    
    S4_AXI_GEN_WDATA          : in  std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
    S4_AXI_GEN_WSTRB          : in  std_logic_vector((C_S4_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S4_AXI_GEN_WLAST          : in  std_logic;
    S4_AXI_GEN_WVALID         : in  std_logic;
    S4_AXI_GEN_WREADY         : out std_logic;
    
    S4_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S4_AXI_GEN_BID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_BVALID         : out std_logic;
    S4_AXI_GEN_BREADY         : in  std_logic;
    
    S4_AXI_GEN_ARID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_ARADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S4_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S4_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S4_AXI_GEN_ARLOCK         : in  std_logic;
    S4_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S4_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S4_AXI_GEN_ARVALID        : in  std_logic;
    S4_AXI_GEN_ARREADY        : out std_logic;
    
    S4_AXI_GEN_RID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
    S4_AXI_GEN_RDATA          : out std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
    S4_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S4_AXI_GEN_RLAST          : out std_logic;
    S4_AXI_GEN_RVALID         : out std_logic;
    S4_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #5 Slave Signals.
    
    S5_AXI_GEN_AWID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_AWADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S5_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S5_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S5_AXI_GEN_AWLOCK         : in  std_logic;
    S5_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_AWVALID        : in  std_logic;
    S5_AXI_GEN_AWREADY        : out std_logic;
    
    S5_AXI_GEN_WDATA          : in  std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
    S5_AXI_GEN_WSTRB          : in  std_logic_vector((C_S5_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S5_AXI_GEN_WLAST          : in  std_logic;
    S5_AXI_GEN_WVALID         : in  std_logic;
    S5_AXI_GEN_WREADY         : out std_logic;
    
    S5_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S5_AXI_GEN_BID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_BVALID         : out std_logic;
    S5_AXI_GEN_BREADY         : in  std_logic;
    
    S5_AXI_GEN_ARID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_ARADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S5_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S5_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S5_AXI_GEN_ARLOCK         : in  std_logic;
    S5_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S5_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S5_AXI_GEN_ARVALID        : in  std_logic;
    S5_AXI_GEN_ARREADY        : out std_logic;
    
    S5_AXI_GEN_RID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
    S5_AXI_GEN_RDATA          : out std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
    S5_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S5_AXI_GEN_RLAST          : out std_logic;
    S5_AXI_GEN_RVALID         : out std_logic;
    S5_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #6 Slave Signals.
    
    S6_AXI_GEN_AWID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_AWADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S6_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S6_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S6_AXI_GEN_AWLOCK         : in  std_logic;
    S6_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_AWVALID        : in  std_logic;
    S6_AXI_GEN_AWREADY        : out std_logic;
    
    S6_AXI_GEN_WDATA          : in  std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
    S6_AXI_GEN_WSTRB          : in  std_logic_vector((C_S6_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S6_AXI_GEN_WLAST          : in  std_logic;
    S6_AXI_GEN_WVALID         : in  std_logic;
    S6_AXI_GEN_WREADY         : out std_logic;
    
    S6_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S6_AXI_GEN_BID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_BVALID         : out std_logic;
    S6_AXI_GEN_BREADY         : in  std_logic;
    
    S6_AXI_GEN_ARID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_ARADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S6_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S6_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S6_AXI_GEN_ARLOCK         : in  std_logic;
    S6_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S6_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S6_AXI_GEN_ARVALID        : in  std_logic;
    S6_AXI_GEN_ARREADY        : out std_logic;
    
    S6_AXI_GEN_RID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
    S6_AXI_GEN_RDATA          : out std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
    S6_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S6_AXI_GEN_RLAST          : out std_logic;
    S6_AXI_GEN_RVALID         : out std_logic;
    S6_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #7 Slave Signals.
    
    S7_AXI_GEN_AWID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_AWADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S7_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S7_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S7_AXI_GEN_AWLOCK         : in  std_logic;
    S7_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_AWVALID        : in  std_logic;
    S7_AXI_GEN_AWREADY        : out std_logic;
    
    S7_AXI_GEN_WDATA          : in  std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
    S7_AXI_GEN_WSTRB          : in  std_logic_vector((C_S7_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S7_AXI_GEN_WLAST          : in  std_logic;
    S7_AXI_GEN_WVALID         : in  std_logic;
    S7_AXI_GEN_WREADY         : out std_logic;
    
    S7_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S7_AXI_GEN_BID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_BVALID         : out std_logic;
    S7_AXI_GEN_BREADY         : in  std_logic;
    
    S7_AXI_GEN_ARID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_ARADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S7_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S7_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S7_AXI_GEN_ARLOCK         : in  std_logic;
    S7_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S7_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S7_AXI_GEN_ARVALID        : in  std_logic;
    S7_AXI_GEN_ARREADY        : out std_logic;
    
    S7_AXI_GEN_RID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
    S7_AXI_GEN_RDATA          : out std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
    S7_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S7_AXI_GEN_RLAST          : out std_logic;
    S7_AXI_GEN_RVALID         : out std_logic;
    S7_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #8 Slave Signals.
    
    S8_AXI_GEN_AWID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_AWADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S8_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S8_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S8_AXI_GEN_AWLOCK         : in  std_logic;
    S8_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_AWVALID        : in  std_logic;
    S8_AXI_GEN_AWREADY        : out std_logic;
    
    S8_AXI_GEN_WDATA          : in  std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
    S8_AXI_GEN_WSTRB          : in  std_logic_vector((C_S8_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S8_AXI_GEN_WLAST          : in  std_logic;
    S8_AXI_GEN_WVALID         : in  std_logic;
    S8_AXI_GEN_WREADY         : out std_logic;
    
    S8_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S8_AXI_GEN_BID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_BVALID         : out std_logic;
    S8_AXI_GEN_BREADY         : in  std_logic;
    
    S8_AXI_GEN_ARID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_ARADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S8_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S8_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S8_AXI_GEN_ARLOCK         : in  std_logic;
    S8_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S8_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S8_AXI_GEN_ARVALID        : in  std_logic;
    S8_AXI_GEN_ARREADY        : out std_logic;
    
    S8_AXI_GEN_RID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
    S8_AXI_GEN_RDATA          : out std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
    S8_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S8_AXI_GEN_RLAST          : out std_logic;
    S8_AXI_GEN_RVALID         : out std_logic;
    S8_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #9 Slave Signals.
    
    S9_AXI_GEN_AWID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_AWADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S9_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S9_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S9_AXI_GEN_AWLOCK         : in  std_logic;
    S9_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_AWVALID        : in  std_logic;
    S9_AXI_GEN_AWREADY        : out std_logic;
    
    S9_AXI_GEN_WDATA          : in  std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
    S9_AXI_GEN_WSTRB          : in  std_logic_vector((C_S9_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S9_AXI_GEN_WLAST          : in  std_logic;
    S9_AXI_GEN_WVALID         : in  std_logic;
    S9_AXI_GEN_WREADY         : out std_logic;
    
    S9_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S9_AXI_GEN_BID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_BVALID         : out std_logic;
    S9_AXI_GEN_BREADY         : in  std_logic;
    
    S9_AXI_GEN_ARID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_ARADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S9_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S9_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S9_AXI_GEN_ARLOCK         : in  std_logic;
    S9_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S9_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S9_AXI_GEN_ARVALID        : in  std_logic;
    S9_AXI_GEN_ARREADY        : out std_logic;
    
    S9_AXI_GEN_RID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
    S9_AXI_GEN_RDATA          : out std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
    S9_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S9_AXI_GEN_RLAST          : out std_logic;
    S9_AXI_GEN_RVALID         : out std_logic;
    S9_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #10 Slave Signals.
    
    S10_AXI_GEN_AWID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_AWADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S10_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S10_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S10_AXI_GEN_AWLOCK         : in  std_logic;
    S10_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_AWVALID        : in  std_logic;
    S10_AXI_GEN_AWREADY        : out std_logic;
    
    S10_AXI_GEN_WDATA          : in  std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
    S10_AXI_GEN_WSTRB          : in  std_logic_vector((C_S10_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S10_AXI_GEN_WLAST          : in  std_logic;
    S10_AXI_GEN_WVALID         : in  std_logic;
    S10_AXI_GEN_WREADY         : out std_logic;
    
    S10_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S10_AXI_GEN_BID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_BVALID         : out std_logic;
    S10_AXI_GEN_BREADY         : in  std_logic;
    
    S10_AXI_GEN_ARID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_ARADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S10_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S10_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S10_AXI_GEN_ARLOCK         : in  std_logic;
    S10_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S10_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S10_AXI_GEN_ARVALID        : in  std_logic;
    S10_AXI_GEN_ARREADY        : out std_logic;
    
    S10_AXI_GEN_RID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
    S10_AXI_GEN_RDATA          : out std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
    S10_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S10_AXI_GEN_RLAST          : out std_logic;
    S10_AXI_GEN_RVALID         : out std_logic;
    S10_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #11 Slave Signals.
    
    S11_AXI_GEN_AWID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_AWADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S11_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S11_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S11_AXI_GEN_AWLOCK         : in  std_logic;
    S11_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_AWVALID        : in  std_logic;
    S11_AXI_GEN_AWREADY        : out std_logic;
    
    S11_AXI_GEN_WDATA          : in  std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
    S11_AXI_GEN_WSTRB          : in  std_logic_vector((C_S11_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S11_AXI_GEN_WLAST          : in  std_logic;
    S11_AXI_GEN_WVALID         : in  std_logic;
    S11_AXI_GEN_WREADY         : out std_logic;
    
    S11_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S11_AXI_GEN_BID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_BVALID         : out std_logic;
    S11_AXI_GEN_BREADY         : in  std_logic;
    
    S11_AXI_GEN_ARID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_ARADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S11_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S11_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S11_AXI_GEN_ARLOCK         : in  std_logic;
    S11_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S11_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S11_AXI_GEN_ARVALID        : in  std_logic;
    S11_AXI_GEN_ARREADY        : out std_logic;
    
    S11_AXI_GEN_RID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
    S11_AXI_GEN_RDATA          : out std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
    S11_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S11_AXI_GEN_RLAST          : out std_logic;
    S11_AXI_GEN_RVALID         : out std_logic;
    S11_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #12 Slave Signals.
    
    S12_AXI_GEN_AWID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_AWADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S12_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S12_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S12_AXI_GEN_AWLOCK         : in  std_logic;
    S12_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_AWVALID        : in  std_logic;
    S12_AXI_GEN_AWREADY        : out std_logic;
    
    S12_AXI_GEN_WDATA          : in  std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
    S12_AXI_GEN_WSTRB          : in  std_logic_vector((C_S12_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S12_AXI_GEN_WLAST          : in  std_logic;
    S12_AXI_GEN_WVALID         : in  std_logic;
    S12_AXI_GEN_WREADY         : out std_logic;
    
    S12_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S12_AXI_GEN_BID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_BVALID         : out std_logic;
    S12_AXI_GEN_BREADY         : in  std_logic;
    
    S12_AXI_GEN_ARID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_ARADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S12_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S12_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S12_AXI_GEN_ARLOCK         : in  std_logic;
    S12_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S12_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S12_AXI_GEN_ARVALID        : in  std_logic;
    S12_AXI_GEN_ARREADY        : out std_logic;
    
    S12_AXI_GEN_RID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
    S12_AXI_GEN_RDATA          : out std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
    S12_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S12_AXI_GEN_RLAST          : out std_logic;
    S12_AXI_GEN_RVALID         : out std_logic;
    S12_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #13 Slave Signals.
    
    S13_AXI_GEN_AWID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_AWADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S13_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S13_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S13_AXI_GEN_AWLOCK         : in  std_logic;
    S13_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_AWVALID        : in  std_logic;
    S13_AXI_GEN_AWREADY        : out std_logic;
    
    S13_AXI_GEN_WDATA          : in  std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
    S13_AXI_GEN_WSTRB          : in  std_logic_vector((C_S13_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S13_AXI_GEN_WLAST          : in  std_logic;
    S13_AXI_GEN_WVALID         : in  std_logic;
    S13_AXI_GEN_WREADY         : out std_logic;
    
    S13_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S13_AXI_GEN_BID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_BVALID         : out std_logic;
    S13_AXI_GEN_BREADY         : in  std_logic;
    
    S13_AXI_GEN_ARID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_ARADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S13_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S13_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S13_AXI_GEN_ARLOCK         : in  std_logic;
    S13_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S13_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S13_AXI_GEN_ARVALID        : in  std_logic;
    S13_AXI_GEN_ARREADY        : out std_logic;
    
    S13_AXI_GEN_RID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
    S13_AXI_GEN_RDATA          : out std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
    S13_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S13_AXI_GEN_RLAST          : out std_logic;
    S13_AXI_GEN_RVALID         : out std_logic;
    S13_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #14 Slave Signals.
    
    S14_AXI_GEN_AWID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_AWADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S14_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S14_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S14_AXI_GEN_AWLOCK         : in  std_logic;
    S14_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_AWVALID        : in  std_logic;
    S14_AXI_GEN_AWREADY        : out std_logic;
    
    S14_AXI_GEN_WDATA          : in  std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
    S14_AXI_GEN_WSTRB          : in  std_logic_vector((C_S14_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S14_AXI_GEN_WLAST          : in  std_logic;
    S14_AXI_GEN_WVALID         : in  std_logic;
    S14_AXI_GEN_WREADY         : out std_logic;
    
    S14_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S14_AXI_GEN_BID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_BVALID         : out std_logic;
    S14_AXI_GEN_BREADY         : in  std_logic;
    
    S14_AXI_GEN_ARID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_ARADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S14_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S14_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S14_AXI_GEN_ARLOCK         : in  std_logic;
    S14_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S14_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S14_AXI_GEN_ARVALID        : in  std_logic;
    S14_AXI_GEN_ARREADY        : out std_logic;
    
    S14_AXI_GEN_RID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
    S14_AXI_GEN_RDATA          : out std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
    S14_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S14_AXI_GEN_RLAST          : out std_logic;
    S14_AXI_GEN_RVALID         : out std_logic;
    S14_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Generic AXI4/ACE Interface #15 Slave Signals.
    
    S15_AXI_GEN_AWID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_AWADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S15_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
    S15_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
    S15_AXI_GEN_AWLOCK         : in  std_logic;
    S15_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_AWVALID        : in  std_logic;
    S15_AXI_GEN_AWREADY        : out std_logic;
    
    S15_AXI_GEN_WDATA          : in  std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
    S15_AXI_GEN_WSTRB          : in  std_logic_vector((C_S15_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
    S15_AXI_GEN_WLAST          : in  std_logic;
    S15_AXI_GEN_WVALID         : in  std_logic;
    S15_AXI_GEN_WREADY         : out std_logic;
    
    S15_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
    S15_AXI_GEN_BID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_BVALID         : out std_logic;
    S15_AXI_GEN_BREADY         : in  std_logic;
    
    S15_AXI_GEN_ARID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_ARADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
    S15_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
    S15_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
    S15_AXI_GEN_ARLOCK         : in  std_logic;
    S15_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
    S15_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
    S15_AXI_GEN_ARVALID        : in  std_logic;
    S15_AXI_GEN_ARREADY        : out std_logic;
    
    S15_AXI_GEN_RID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
    S15_AXI_GEN_RDATA          : out std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
    S15_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
    S15_AXI_GEN_RLAST          : out std_logic;
    S15_AXI_GEN_RVALID         : out std_logic;
    S15_AXI_GEN_RREADY         : in  std_logic;
    
    
    -- ---------------------------------------------------
    -- Control AXI4-Lite Slave Interface Signals
    
    -- AW-Channel
    S_AXI_CTRL_AWADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    S_AXI_CTRL_AWPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_CTRL_AWVALID             : in  std_logic;
    S_AXI_CTRL_AWREADY             : out std_logic;

    -- W-Channel
    S_AXI_CTRL_WDATA               : in  std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
    S_AXI_CTRL_WVALID              : in  std_logic;
    S_AXI_CTRL_WREADY              : out std_logic;

    -- B-Channel
    S_AXI_CTRL_BRESP               : out std_logic_vector(1 downto 0);
    S_AXI_CTRL_BVALID              : out std_logic;
    S_AXI_CTRL_BREADY              : in  std_logic;

    -- AR-Channel
    S_AXI_CTRL_ARADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
    S_AXI_CTRL_ARPROT              : in  std_logic_vector(2 downto 0);
    S_AXI_CTRL_ARVALID             : in  std_logic;
    S_AXI_CTRL_ARREADY             : out std_logic;

    -- R-Channel
    S_AXI_CTRL_RDATA               : out std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
    S_AXI_CTRL_RRESP               : out std_logic_vector(1 downto 0);
    S_AXI_CTRL_RVALID              : out std_logic;
    S_AXI_CTRL_RREADY              : in  std_logic;

    
    -- ---------------------------------------------------
    -- AXI4/ACE Interface #0 master signals.
    
    M0_AXI_AWID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_AWADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
    M0_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M0_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M0_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M0_AXI_AWLOCK             : out std_logic;
    M0_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M0_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M0_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M0_AXI_AWVALID            : out std_logic;
    M0_AXI_AWREADY            : in  std_logic;
    M0_AXI_AWDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
    M0_AXI_AWSNOOP            : out std_logic_vector(2 downto 0);                      -- For ACE
    M0_AXI_AWBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M0_AXI_WDATA              : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
    M0_AXI_WSTRB              : out std_logic_vector((C_M0_AXI_DATA_WIDTH/8)-1 downto 0);
    M0_AXI_WLAST              : out std_logic;
    M0_AXI_WVALID             : out std_logic;
    M0_AXI_WREADY             : in  std_logic;
    
    M0_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M0_AXI_BID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_BVALID             : in  std_logic;
    M0_AXI_BREADY             : out std_logic;
    M0_AXI_WACK               : out std_logic;                                         -- For ACE
    
    M0_AXI_ARID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_ARADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
    M0_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M0_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M0_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M0_AXI_ARLOCK             : out std_logic;
    M0_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M0_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M0_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M0_AXI_ARVALID            : out std_logic;
    M0_AXI_ARREADY            : in  std_logic;
    M0_AXI_ARDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
    M0_AXI_ARSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
    M0_AXI_ARBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
    
    M0_AXI_RID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
    M0_AXI_RDATA              : in  std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
    M0_AXI_RRESP              : in  std_logic_vector(C_M0_AXI_RRESP_WIDTH-1 downto 0);
    M0_AXI_RLAST              : in  std_logic;
    M0_AXI_RVALID             : in  std_logic;
    M0_AXI_RREADY             : out std_logic;
    M0_AXI_RACK               : out std_logic;                                         -- For ACE
    
    M0_AXI_ACVALID            : in  std_logic;                                         -- For ACE
    M0_AXI_ACADDR             : in  std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
    M0_AXI_ACSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
    M0_AXI_ACPROT             : in  std_logic_vector(2 downto 0);                      -- For ACE
    M0_AXI_ACREADY            : out std_logic;                                         -- For ACE
    
    M0_AXI_CRVALID            : out std_logic;                                         -- For ACE
    M0_AXI_CRRESP             : out std_logic_vector(4 downto 0);                      -- For ACE
    M0_AXI_CRREADY            : in  std_logic;                                         -- For ACE
    
    M0_AXI_CDVALID            : out std_logic;                                         -- For ACE
    M0_AXI_CDDATA             : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
    M0_AXI_CDLAST             : out std_logic;                                         -- For ACE
    M0_AXI_CDREADY            : in  std_logic;                                         -- For ACE
    
    
    -- ---------------------------------------------------
    -- AXI4 Interface #1 master signals.
    
    M1_AXI_AWID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_AWADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
    M1_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M1_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M1_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M1_AXI_AWLOCK             : out std_logic;
    M1_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M1_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M1_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M1_AXI_AWVALID            : out std_logic;
    M1_AXI_AWREADY            : in  std_logic;
    
    M1_AXI_WDATA              : out std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
    M1_AXI_WSTRB              : out std_logic_vector((C_M1_AXI_DATA_WIDTH/8)-1 downto 0);
    M1_AXI_WLAST              : out std_logic;
    M1_AXI_WVALID             : out std_logic;
    M1_AXI_WREADY             : in  std_logic;
    
    M1_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M1_AXI_BID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_BVALID             : in  std_logic;
    M1_AXI_BREADY             : out std_logic;
    
    M1_AXI_ARID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_ARADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
    M1_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M1_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M1_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M1_AXI_ARLOCK             : out std_logic;
    M1_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M1_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M1_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M1_AXI_ARVALID            : out std_logic;
    M1_AXI_ARREADY            : in  std_logic;
    
    M1_AXI_RID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
    M1_AXI_RDATA              : in  std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
    M1_AXI_RRESP              : in  std_logic_vector(C_M1_AXI_RRESP_WIDTH-1 downto 0);
    M1_AXI_RLAST              : in  std_logic;
    M1_AXI_RVALID             : in  std_logic;
    M1_AXI_RREADY             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Interface #2 master signals.
    
    M2_AXI_AWID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_AWADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
    M2_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M2_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M2_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M2_AXI_AWLOCK             : out std_logic;
    M2_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M2_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M2_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M2_AXI_AWVALID            : out std_logic;
    M2_AXI_AWREADY            : in  std_logic;
    
    M2_AXI_WDATA              : out std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
    M2_AXI_WSTRB              : out std_logic_vector((C_M2_AXI_DATA_WIDTH/8)-1 downto 0);
    M2_AXI_WLAST              : out std_logic;
    M2_AXI_WVALID             : out std_logic;
    M2_AXI_WREADY             : in  std_logic;
    
    M2_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M2_AXI_BID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_BVALID             : in  std_logic;
    M2_AXI_BREADY             : out std_logic;
    
    M2_AXI_ARID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_ARADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
    M2_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M2_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M2_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M2_AXI_ARLOCK             : out std_logic;
    M2_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M2_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M2_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M2_AXI_ARVALID            : out std_logic;
    M2_AXI_ARREADY            : in  std_logic;
    
    M2_AXI_RID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
    M2_AXI_RDATA              : in  std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
    M2_AXI_RRESP              : in  std_logic_vector(C_M2_AXI_RRESP_WIDTH-1 downto 0);
    M2_AXI_RLAST              : in  std_logic;
    M2_AXI_RVALID             : in  std_logic;
    M2_AXI_RREADY             : out std_logic;
    
    
    -- ---------------------------------------------------
    -- AXI4 Interface #3 master signals.
    
    M3_AXI_AWID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_AWADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
    M3_AXI_AWLEN              : out std_logic_vector(7 downto 0);
    M3_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
    M3_AXI_AWBURST            : out std_logic_vector(1 downto 0);
    M3_AXI_AWLOCK             : out std_logic;
    M3_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
    M3_AXI_AWPROT             : out std_logic_vector(2 downto 0);
    M3_AXI_AWQOS              : out std_logic_vector(3 downto 0);
    M3_AXI_AWVALID            : out std_logic;
    M3_AXI_AWREADY            : in  std_logic;
    
    M3_AXI_WDATA              : out std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
    M3_AXI_WSTRB              : out std_logic_vector((C_M3_AXI_DATA_WIDTH/8)-1 downto 0);
    M3_AXI_WLAST              : out std_logic;
    M3_AXI_WVALID             : out std_logic;
    M3_AXI_WREADY             : in  std_logic;
    
    M3_AXI_BRESP              : in  std_logic_vector(1 downto 0);
    M3_AXI_BID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_BVALID             : in  std_logic;
    M3_AXI_BREADY             : out std_logic;
    
    M3_AXI_ARID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_ARADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
    M3_AXI_ARLEN              : out std_logic_vector(7 downto 0);
    M3_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
    M3_AXI_ARBURST            : out std_logic_vector(1 downto 0);
    M3_AXI_ARLOCK             : out std_logic;
    M3_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
    M3_AXI_ARPROT             : out std_logic_vector(2 downto 0);
    M3_AXI_ARQOS              : out std_logic_vector(3 downto 0);
    M3_AXI_ARVALID            : out std_logic;
    M3_AXI_ARREADY            : in  std_logic;
    
    M3_AXI_RID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
    M3_AXI_RDATA              : in  std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
    M3_AXI_RRESP              : in  std_logic_vector(C_M3_AXI_RRESP_WIDTH-1 downto 0);
    M3_AXI_RLAST              : in  std_logic;
    M3_AXI_RVALID             : in  std_logic;
    M3_AXI_RREADY             : out std_logic
  );
end entity system_cache;


library Unisim;
use Unisim.vcomponents.all;

library system_cache_v4_0_4;
use system_cache_v4_0_4.All;


architecture IMP of system_cache is

  -----------------------------------------------------------------------------
  -- Description
  -----------------------------------------------------------------------------
  --
  -- Top level for System Cache, instanciates the next level of the design and
  -- calculate constants for data wirdth, bit pattern etc form the current 
  -- configuration. 
  -- The four hierarcical blocks instantiated are:
  -- 
  -- * Front End (FE) for decoding and preparing incomming transactions to the
  --   internal data representation. Also arbitrates and from multiple ports 
  --   and forwards on transaction at the time to the next stage.
  --
  -- * Cache Core (CC) for the actual caching and mantainance of data.
  --
  -- * Back End (BE) for the communication with the memory sub system.
  --
  -- * Control interface for collecting and controlling statistics gathering.
  --
  --
  -- Address bit mapping:
  -- ====================
  --
  --                                    |<------------- Cache Size Addr Bits --------------->|
  --                  |<------- Tag Addr Bits ------->|
  --                                                  |<------ Data Index Bits ------->|
  --                                                  |<- Tag Index Bits ->|
  --   _______________ _________________ _____________ ____________________ ___________ _____
  --  |_______________|_________________|_____________|____________________|___________|_____|
  --
  --   \_____________/ \_______________/ \___________/ \__________________/ \_________/ \___/
  --    |               |                 |             |                    |           |                 
  --    IP Valid Addr   Offset Addr       Set Bits      Line                 Word Addr   Byte Addr
  --                                   /               \
  --                                  /                 \
  --                                 /                   \
  --                                /_____________________\ 
  --                                |_____________________|
  --                                                                     
  --                                \____________________/ 
  --                                  |              
  --                                  Addr  
  --
  --
  -- TAG contents:
  -- =============
  --
  --   _ _ _ _ _________________ 
  --  |_|_|_|_|_________________|
  --
  --   | | | | \_______________/ 
  --   | | | Locked     | 
  --   | | Dirty        Tag Address bits
  --   | Reused
  --   Valid 
  --
  --
  -- Meaning:
  --  Valid   - TAG is valid and cacheline contains valid data
  --  Dirty   - Cacheline contains dirty data
  --  Locked  - Cacheline is locked and access to it has to be stalled until lock is released. A cacheline is 
  --            locked when it is allocated and waits for data to arrive from external memory.
  --  Address - Address bit for the cacheline
  --
  --
  -- Transaction Latency:
  -- ====================
  -- 
  -- Read Hit:    
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 3   (Mem, Check, Pipeline)
  --  Interface : 1   (Read Queue)
  --  => Total 4 clk
  --  
  -- Read Miss:
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 2   (Mem, Check)
  --  Update    : 1   (Update)
  --  Backend   : 2   (Queue, Register)
  --  Exernal   : x   (Interconnect, Memory)
  --  Interface : 1   (Read Queue)
  --  => Total 6+x clk
  --  
  -- Evict:
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 2   (Mem, Check)
  --  Update    : 3+d (Update, Queue, Data, Queue) d=32*cl/maxi dw
  
  -- Read Miss Dirty:
  --  If 2+d > x
  --    => Total 6+d
  --  else
  --    Same as Read Miss.
  -- 
  -- Write Hit:
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 2+d (Mem, Check, Data) d=max(0, burst len - 1)
  --  Interface : 2   (Queue, Register)
  --  => Total 4+d clk
  --  
  -- Write Miss:
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 2   (Mem, Check)
  --  Update    : 1   (Update)
  --  Backend   : 2   (Queue, Register)
  --  Exernal   : x   (Interconnect, Memory)
  --  Interface : 1   (Read Queue)
  --  => Total 6+x clk
  --  
  -- Write Miss Allocate:
  --  Arbiter   : 0   (pre arbited)
  --  Lookup    : 2   (Mem, Check)
  --  Update    : 2+d (Queue, Data, Queue)  d=burst len
  --  Interface : 1   (Read Queue)
  --  => Total 5+d clk
  --  
  -- Write Miss Dirty:
  --  => max(Write Miss Allocate, Evict) clk
  --  
  
    
  -----------------------------------------------------------------------------
  -- Disabled Constants
  -----------------------------------------------------------------------------
  
  -- Debugging.
  constant C_USE_DEBUG               : natural range  0 to                 1 :=   0;
  constant C_ARBITER_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 628;
  constant C_ACCESS1_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 256;
  constant C_LOOKUP1_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 400;
  constant C_UPDATE1_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 256;
  constant C_UPDATE2_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 400;
  constant C_MEMORY1_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 768;
  constant C_MEMORY2_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 768;
  constant C_BACKEND_DEBUG_WIDTH     : natural range  0 to C_MAX_DEBUG_WIDTH := 360;
  constant C_M_IF_DEBUG_WIDTH        : natural range  0 to C_MAX_DEBUG_WIDTH := 645;
    
  -- IP Specific Optimizations.
  constant C_OPTIMIZE_ORDER          : natural range  4 to    4      :=  4;
  constant C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
  constant C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
  constant C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
    
  -- Static configuration of read data pipeline.
  constant C_PIPELINE_LU_READ_DATA   : boolean                       := true;
  
  -- How to handle automatic cleaning of dirty lines.
  constant C_ENABLE_AUTOMATIC_CLEAN     : natural             := 0;
  constant C_AUTOMATIC_CLEAN_MODE       : natural             := 1;
  
  -- Optimized AXI4 Slave Interface #0 to #15 specific.
  constant C_S0_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S1_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S2_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S3_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S4_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S5_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S6_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S7_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S8_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S9_AXI_PROHIBIT_EXCLUSIVE          : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S10_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S11_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S12_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S13_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S14_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S15_AXI_PROHIBIT_EXCLUSIVE         : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE + 
                                                                                  is_slv_coherent(C_ENABLE_COHERENCY));
  
  -- Generic AXI4 Slave Interface #0 specific.
  constant C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                            is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                            is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                           is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                            is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                            is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  constant C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE      : natural range 0 to 1 :=  is_off(C_ENABLE_EXCLUSIVE) * 
                                                                            is_off(is_slv_coherent(C_ENABLE_COHERENCY));
  
    
  -----------------------------------------------------------------------------
  -- Constant declaration
  -----------------------------------------------------------------------------
  
  -- Translate family string to enumerated type.
  constant C_TARGET                     : TARGET_FAMILY_TYPE  := String_To_Family(C_FAMILY, false);
  
  -- Enable/Disable the debug information.
  constant C_USE_DEBUG_BOOL             : boolean             := ( C_USE_DEBUG /= 0);
    
  -- Enable/Disable the assertions.
  constant C_USE_ASSERTIONS             : boolean             := C_USE_DEBUG_BOOL;
  
  -- If bufferable is enough to retain line (usually it is required that Allocate is set to keep line).
  constant C_KEEP_BUFFERABLE            : natural range  0 to    1      :=  0;
  
  -- Control if Modifiable is required to keep a line allocated.
  constant C_IGNORE_MODIFIABLE          : natural range  0 to    1      :=  0;
  
  -- Make AW/W accommodate slaves that require "well-defined" masters to work.
  constant C_ENABLE_SLV_WR_THROTTLE     : natural range  0 to    1      :=  is_mst_coherent(C_ENABLE_COHERENCY);
  
  -- Is it allowed to extract WriteBack data due to snoop.
  constant C_ENABLE_WB_EXTRACT          : natural range  0 to    1      :=  is_mst_coherent(C_ENABLE_COHERENCY);
  
  -- Enable/Disable the internal exclusive monitor.
  constant C_ENABLE_EX_MON              : natural range  0 to    1      :=  C_ENABLE_EXCLUSIVE * 
                                                                            ( 1 - is_slv_coherent(C_ENABLE_COHERENCY) );
  
  -- Static strict order for Master coherent.
  constant C_ENABLE_EARLY_BRESP         : natural range  0 to    1      :=  1 - is_mst_coherent(C_ENABLE_COHERENCY);
  
  -- Enable/Disable statistics.
  constant C_USE_STATISTICS             : boolean                       := ( C_ENABLE_CTRL /= 0 );
  constant C_STAT_OPT_LAT_RD_DEPTH      : natural range  1 to   32      :=  4;
  constant C_STAT_OPT_LAT_WR_DEPTH      : natural range  1 to   32      := 16;
  constant C_STAT_GEN_LAT_RD_DEPTH      : natural range  1 to   32      := 16;
  constant C_STAT_GEN_LAT_WR_DEPTH      : natural range  1 to   32      := 16;
  constant C_STAT_MEM_LAT_RD_DEPTH      : natural range  1 to   32      := 16;
  constant C_STAT_MEM_LAT_WR_DEPTH      : natural range  1 to   32      := 16;
  constant C_STAT_BITS                  : natural range  1 to   64      := 32;
  constant C_STAT_BIG_BITS              : natural range  1 to   64      := 48;
  constant C_STAT_COUNTER_BITS          : natural range  1 to   31      := 16;
  constant C_STAT_MAX_CYCLE_WIDTH       : natural range  2 to   16      := 16;
  constant C_STAT_USE_STDDEV            : natural range  0 to    1      :=  1;
  
  -- Total number of ports.
  constant C_NUM_PORTS                  : positive            := C_NUM_OPTIMIZED_PORTS + C_NUM_GENERIC_PORTS;
  
  -- Lookup side of BRAM.  
  constant C_CACHE_DATA_ADDR_WIDTH      : natural             := Log2(C_CACHE_DATA_WIDTH/8);
  
  -- Update side of BRAM.  
  constant C_EXTERNAL_DATA_WIDTH        : natural             := C_M0_AXI_DATA_WIDTH;
  constant C_EXTERNAL_DATA_ADDR_WIDTH   : natural             := Log2(C_EXTERNAL_DATA_WIDTH/8);
  
  -- Use same width for all addresses.
  constant C_M_AXI_ADDR_WIDTH           : natural             := 
                                                    max_of(max_of(sel(C_NUM_MASTER_PORTS >  0,  C_M0_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_MASTER_PORTS >  1,  C_M1_AXI_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_MASTER_PORTS >  2,  C_M2_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_MASTER_PORTS >  3,  C_M3_AXI_ADDR_WIDTH, 0)));
  
  -- Use same width for all addresses.
  constant C_S_AXI_ADDR_WIDTH           : natural             := 
                               max_of(max_of(max_of(max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  0,  C_S0_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  1,  C_S1_AXI_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS >  2,  C_S2_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  3,  C_S3_AXI_ADDR_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  4,  C_S4_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  5,  C_S5_AXI_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS >  6,  C_S6_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  7,  C_S7_AXI_ADDR_WIDTH, 0)))),
                                             max_of(max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  8,  C_S8_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  9,  C_S9_AXI_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS > 10, C_S10_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 11, C_S11_AXI_ADDR_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS > 12, C_S12_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 13, C_S12_AXI_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS > 14, C_S14_AXI_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 15, C_S15_AXI_ADDR_WIDTH, 0))))),
                                      max_of(max_of(max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  0,  C_S0_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  1,  C_S1_AXI_GEN_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   >  2,  C_S2_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  3,  C_S3_AXI_GEN_ADDR_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  4,  C_S4_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  5,  C_S5_AXI_GEN_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   >  6,  C_S6_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  7,  C_S7_AXI_GEN_ADDR_WIDTH, 0)))),
                                             max_of(max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  8,  C_S8_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  9,  C_S9_AXI_GEN_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   > 10, C_S10_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 11, C_S11_AXI_GEN_ADDR_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_GENERIC_PORTS   > 12, C_S12_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 13, C_S13_AXI_GEN_ADDR_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   > 14, C_S14_AXI_GEN_ADDR_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 15, C_S15_AXI_GEN_ADDR_WIDTH, 0))))));
  
  -- Use same width for snoop data.
  constant C_Lx_CACHE_DATA_WIDTH        : natural             := C_S0_AXI_DATA_WIDTH;
  
  -- Maximal ID width for all active ports.
  constant C_ID_WIDTH                   : natural range  1 to   32      :=  
                               max_of(max_of(max_of(max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  0,  C_S0_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  1,  C_S1_AXI_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS >  2,  C_S2_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  3,  C_S3_AXI_ID_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  4,  C_S4_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  5,  C_S5_AXI_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS >  6,  C_S6_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  7,  C_S7_AXI_ID_WIDTH, 0)))),
                                             max_of(max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS >  8,  C_S8_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS >  9,  C_S9_AXI_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS > 10, C_S10_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 11, C_S11_AXI_ID_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_OPTIMIZED_PORTS > 12, C_S12_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 13, C_S12_AXI_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_OPTIMIZED_PORTS > 14, C_S14_AXI_ID_WIDTH, 0),
                                                                  sel(C_NUM_OPTIMIZED_PORTS > 15, C_S15_AXI_ID_WIDTH, 0))))),
                                      max_of(max_of(max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  0,  C_S0_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  1,  C_S1_AXI_GEN_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   >  2,  C_S2_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  3,  C_S3_AXI_GEN_ID_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  4,  C_S4_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  5,  C_S5_AXI_GEN_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   >  6,  C_S6_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  7,  C_S7_AXI_GEN_ID_WIDTH, 0)))),
                                             max_of(max_of(max_of(sel(C_NUM_GENERIC_PORTS   >  8,  C_S8_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   >  9,  C_S9_AXI_GEN_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   > 10, C_S10_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 11, C_S11_AXI_GEN_ID_WIDTH, 0))),
                                                    max_of(max_of(sel(C_NUM_GENERIC_PORTS   > 12, C_S12_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 13, C_S13_AXI_GEN_ID_WIDTH, 0)),
                                                           max_of(sel(C_NUM_GENERIC_PORTS   > 14, C_S14_AXI_GEN_ID_WIDTH, 0),
                                                                  sel(C_NUM_GENERIC_PORTS   > 15, C_S15_AXI_GEN_ID_WIDTH, 0))))));
  
  constant C_ANY_SUPPORT_DIRTY          : natural := is_on(C_S0_AXI_SUPPORT_DIRTY      + 
                                                           C_S1_AXI_SUPPORT_DIRTY      + 
                                                           C_S2_AXI_SUPPORT_DIRTY      + 
                                                           C_S3_AXI_SUPPORT_DIRTY      + 
                                                           C_S4_AXI_SUPPORT_DIRTY      + 
                                                           C_S5_AXI_SUPPORT_DIRTY      + 
                                                           C_S6_AXI_SUPPORT_DIRTY      + 
                                                           C_S7_AXI_SUPPORT_DIRTY      + 
                                                           C_S8_AXI_SUPPORT_DIRTY      + 
                                                           C_S9_AXI_SUPPORT_DIRTY      + 
                                                           C_S10_AXI_SUPPORT_DIRTY     + 
                                                           C_S11_AXI_SUPPORT_DIRTY     + 
                                                           C_S12_AXI_SUPPORT_DIRTY     + 
                                                           C_S13_AXI_SUPPORT_DIRTY     + 
                                                           C_S14_AXI_SUPPORT_DIRTY     + 
                                                           C_S15_AXI_SUPPORT_DIRTY     + 
                                                           C_S0_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S1_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S2_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S3_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S4_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S5_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S6_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S7_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S8_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S9_AXI_GEN_SUPPORT_DIRTY  + 
                                                           C_S10_AXI_GEN_SUPPORT_DIRTY + 
                                                           C_S11_AXI_GEN_SUPPORT_DIRTY + 
                                                           C_S12_AXI_GEN_SUPPORT_DIRTY + 
                                                           C_S13_AXI_GEN_SUPPORT_DIRTY + 
                                                           C_S14_AXI_GEN_SUPPORT_DIRTY + 
                                                           C_S15_AXI_GEN_SUPPORT_DIRTY);
        
  constant C_NUM_INTERNAL_PORTS         : natural := C_NUM_PORTS + 
                                                     is_slv_coherent(C_ENABLE_COHERENCY) * 
                                                     C_ANY_SUPPORT_DIRTY;
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Assertions)
  -----------------------------------------------------------------------------
  
  -- Define offset to each assertion.
  constant C_ASSERT_FRONTEND_ERROR            : natural :=  0;
  constant C_ASSERT_CACHECORE_ERROR           : natural :=  1;
  constant C_ASSERT_BACKEND_ERROR             : natural :=  2;
  
  -- Total number of assertions.
  constant C_ASSERT_BITS                      : natural :=  3;
  
  
  -----------------------------------------------------------------------------
  -- Function declaration
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Constant declaration (Calculated or depending)
  -----------------------------------------------------------------------------
  
  -- Address bit sizes.
  constant C_VALID_ADDR_BITS          : natural := Addr_Bits(C_HIGHADDR, C_BASEADDR, C_S_AXI_ADDR_WIDTH);
  constant C_CACHE_SIZE_ADDR_BITS     : natural := log2(C_CACHE_SIZE);
  constant C_Lx_CACHE_SIZE_ADDR_BITS  : natural := log2(C_Lx_CACHE_SIZE);
  constant C_ASSOCIATIVE_ADDR_BITS    : natural := log2(C_NUM_WAYS);
  constant C_LINE_ADDR_BITS           : natural := log2(C_CACHE_LINE_LENGTH);
  constant C_Lx_LINE_ADDR_BITS        : natural := log2(C_Lx_CACHE_LINE_LENGTH);
  constant C_WORD_ADDR_BITS           : natural := log2(C_CACHE_DATA_WIDTH / 8);
  constant C_Lx_WORD_ADDR_BITS        : natural := log2(sel(C_NUM_OPTIMIZED_PORTS > 0, C_S0_AXI_DATA_WIDTH, 
                                                                                       C_S0_AXI_GEN_DATA_WIDTH) / 8);
  constant C_EXT_WORD_ADDR_BITS       : natural := log2(C_EXTERNAL_DATA_WIDTH / 8);
  
  -- TAG information size.
  constant C_Lx_NUM_ADDR_TAG_BITS     : natural := max_of(1, C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - C_Lx_CACHE_SIZE_ADDR_BITS);
  constant C_NUM_ADDR_TAG_BITS        : natural := C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - C_CACHE_SIZE_ADDR_BITS + 
                                                   C_ASSOCIATIVE_ADDR_BITS;
  constant C_NUM_STATUS_BITS          : natural := 4 + is_mst_coherent(C_ENABLE_COHERENCY) + is_on(C_ENABLE_NON_SECURE);
  constant C_TAG_SIZE                 : natural := C_NUM_STATUS_BITS + C_NUM_ADDR_TAG_BITS;
  
  -- Size information.
  constant C_NUM_DATA_WORDS           : natural := C_CACHE_SIZE / ( C_NUM_WAYS * C_CACHE_DATA_WIDTH / 8 );
  constant C_NUM_TAG_WORDS            : natural := C_CACHE_SIZE / ( C_NUM_WAYS * 32/8 ) / C_CACHE_LINE_LENGTH;
  constant C_DATA_ADDR_BITS           : natural := log2(C_NUM_DATA_WORDS);
  constant C_TAG_ADDR_BITS            : natural := log2(C_NUM_TAG_WORDS);
  constant C_LRU_ADDR_BITS            : natural := C_TAG_ADDR_BITS;
  
  -- Set information
  constant C_WAY_BITS                 : natural := log2(C_NUM_WAYS);
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Address)
  -----------------------------------------------------------------------------
  -- Subtypes of the address from all points of view.
  
  -- Ranges for address parts (System Cache).
  subtype C_ADDR_VALID_POS            is natural range C_MAX_ADDR_WIDTH - 1                                    downto 
                                                       C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS;
  subtype C_ADDR_INTERNAL_POS         is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       0;
  subtype C_ADDR_REQ_POS              is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_WORD_ADDR_BITS;
  subtype C_ADDR_DIRECT_POS           is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_LINE_ADDR_BITS + 2;
  subtype C_ADDR_TAG_CONTENTS_POS     is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_LINE_ADDR_BITS + 2;
  subtype C_ADDR_DATA_POS             is natural range C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS - 1    downto 
                                                       C_WORD_ADDR_BITS;
  subtype C_ADDR_EXT_DATA_POS         is natural range C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS - 1    downto 
                                                       C_EXT_WORD_ADDR_BITS;
  subtype C_ADDR_TAG_POS              is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS;
  subtype C_ADDR_ALL_WAYS_POS         is natural range C_CACHE_SIZE_ADDR_BITS - 1                              downto 
                                                       C_LINE_ADDR_BITS + 2;
  subtype C_ADDR_ASSOCIATIVE_POS      is natural range C_CACHE_SIZE_ADDR_BITS - 1                              downto 
                                                       C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS;
  subtype C_ADDR_FULL_LINE_POS        is natural range C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS - 1    downto 
                                                       C_LINE_ADDR_BITS + 2;
  subtype C_ADDR_LINE_POS             is natural range C_CACHE_SIZE_ADDR_BITS - C_ASSOCIATIVE_ADDR_BITS - 1    downto 
                                                       C_LINE_ADDR_BITS + 2;
  subtype C_ADDR_OFFSET_POS           is natural range C_LINE_ADDR_BITS + 2 - 1                                downto 
                                                       0;
  subtype C_ADDR_EXT_WORD_POS         is natural range C_LINE_ADDR_BITS + 2 - 1                                downto 
                                                       C_EXT_WORD_ADDR_BITS;
  subtype C_ADDR_WORD_POS             is natural range C_LINE_ADDR_BITS + 2 - 1                                downto 
                                                       C_WORD_ADDR_BITS;
  subtype C_ADDR_EXT_BYTE_POS         is natural range C_EXT_WORD_ADDR_BITS- 1                                 downto 
                                                       0;
  subtype C_ADDR_BYTE_POS             is natural range C_WORD_ADDR_BITS- 1                                     downto 
                                                       0;
  
  
  -- Ranges for address parts (Lx Cache).
  subtype C_Lx_ADDR_REQ_POS           is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_Lx_WORD_ADDR_BITS;
  subtype C_Lx_ADDR_DIRECT_POS        is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_Lx_LINE_ADDR_BITS + 2;
  subtype C_Lx_ADDR_DATA_POS          is natural range C_Lx_CACHE_SIZE_ADDR_BITS - 1                           downto 
                                                       C_Lx_WORD_ADDR_BITS;
  subtype C_Lx_ADDR_TAG_POS           is natural range C_MAX_ADDR_WIDTH - C_VALID_ADDR_BITS - 1                downto 
                                                       C_Lx_CACHE_SIZE_ADDR_BITS;
  subtype C_Lx_ADDR_LINE_POS          is natural range C_Lx_CACHE_SIZE_ADDR_BITS - 1                           downto 
                                                       C_Lx_LINE_ADDR_BITS + 2;
  subtype C_Lx_ADDR_OFFSET_POS        is natural range C_Lx_LINE_ADDR_BITS + 2 - 1                             downto 
                                                       0;
  subtype C_Lx_ADDR_WORD_POS          is natural range C_Lx_LINE_ADDR_BITS + 2 - 1                             downto 
                                                       C_Lx_WORD_ADDR_BITS;
  subtype C_Lx_ADDR_BYTE_POS          is natural range C_Lx_WORD_ADDR_BITS- 1                                  downto 
                                                       0;
  
  
  -- Subtypes for address parts.
  subtype ADDR_VALID_TYPE             is std_logic_vector(C_ADDR_VALID_POS);
  subtype ADDR_INTERNAL_TYPE          is std_logic_vector(C_ADDR_INTERNAL_POS);
  subtype ADDR_REQ_TYPE               is std_logic_vector(C_ADDR_REQ_POS);
  subtype ADDR_DIRECT_TYPE            is std_logic_vector(C_ADDR_DIRECT_POS);
  subtype ADDR_EXT_DATA_TYPE          is std_logic_vector(C_ADDR_EXT_DATA_POS);
  subtype ADDR_DATA_TYPE              is std_logic_vector(C_ADDR_DATA_POS);
  subtype ADDR_TAG_ADDR_TYPE          is std_logic_vector(C_ADDR_TAG_CONTENTS_POS);
  subtype ADDR_TAG_TYPE               is std_logic_vector(C_ADDR_TAG_POS);
  subtype ADDR_ALL_WAYS_TYPE          is std_logic_vector(C_ADDR_ALL_WAYS_POS);
  subtype ADDR_ASSOCIATIVE_TYPE       is std_logic_vector(C_ADDR_ASSOCIATIVE_POS);
  subtype ADDR_FULL_LINE_TYPE         is std_logic_vector(C_ADDR_FULL_LINE_POS);
  subtype ADDR_LINE_TYPE              is std_logic_vector(C_ADDR_LINE_POS);
  subtype ADDR_OFFSET_TYPE            is std_logic_vector(C_ADDR_OFFSET_POS);
  subtype ADDR_EXT_WORD_TYPE          is std_logic_vector(C_ADDR_EXT_WORD_POS);
  subtype ADDR_WORD_TYPE              is std_logic_vector(C_ADDR_WORD_POS);
  subtype ADDR_EXT_BYTE_TYPE          is std_logic_vector(C_ADDR_EXT_BYTE_POS);
  subtype ADDR_BYTE_TYPE              is std_logic_vector(C_ADDR_BYTE_POS);
  
  subtype Lx_ADDR_REQ_TYPE            is std_logic_vector(C_Lx_ADDR_REQ_POS);
  subtype Lx_ADDR_DIRECT_TYPE         is std_logic_vector(C_Lx_ADDR_DIRECT_POS);
  subtype Lx_ADDR_DATA_TYPE           is std_logic_vector(C_Lx_ADDR_DATA_POS);
  subtype Lx_ADDR_TAG_TYPE            is std_logic_vector(C_Lx_ADDR_TAG_POS);
  subtype Lx_ADDR_LINE_TYPE           is std_logic_vector(C_Lx_ADDR_LINE_POS);
  subtype Lx_ADDR_OFFSET_TYPE         is std_logic_vector(C_Lx_ADDR_OFFSET_POS);
  subtype Lx_ADDR_WORD_TYPE           is std_logic_vector(C_Lx_ADDR_WORD_POS);
  subtype Lx_ADDR_BYTE_TYPE           is std_logic_vector(C_Lx_ADDR_BYTE_POS);
  
  
  -----------------------------------------------------------------------------
  -- Custom types (Set)
  -----------------------------------------------------------------------------
  
  -- Set related.
  subtype C_WAY_BIT_POS               is natural range C_WAY_BITS - 1          downto 0;
  
  
  -----------------------------------------------------------------------------
  -- Components
  -----------------------------------------------------------------------------
  
  component sc_front_end is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_OPT_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_OPT_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_GEN_LAT_RD_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_GEN_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- Common for all ports.
      C_ANY_SUPPORT_DIRTY       : natural range  0 to    1      :=  0;
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S0_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S0_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S0_AXI_ID_WIDTH         : natural                       := 1;
      C_S0_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S0_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S0_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S0_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S0_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S0_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S0_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S0_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S0_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S0_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S0_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #1 specific.
      C_S1_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S1_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S1_AXI_ID_WIDTH         : natural                       := 1;
      C_S1_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S1_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S1_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S1_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S1_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S1_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S1_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S1_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S1_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S1_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S1_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #2 specific.
      C_S2_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S2_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S2_AXI_ID_WIDTH         : natural                       := 1;
      C_S2_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S2_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S2_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S2_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S2_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S2_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S2_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S2_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S2_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S2_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S2_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #3 specific.
      C_S3_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S3_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S3_AXI_ID_WIDTH         : natural                       := 1;
      C_S3_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S3_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S3_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S3_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S3_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S3_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S3_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S3_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S3_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S3_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S3_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #4 specific.
      C_S4_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S4_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S4_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S4_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S4_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S4_AXI_ID_WIDTH         : natural                       := 1;
      C_S4_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S4_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S4_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S4_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S4_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S4_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S4_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S4_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S4_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S4_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S4_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #5 specific.
      C_S5_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S5_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S5_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S5_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S5_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S5_AXI_ID_WIDTH         : natural                       := 1;
      C_S5_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S5_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S5_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S5_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S5_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S5_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S5_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S5_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S5_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S5_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S5_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #6 specific.
      C_S6_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S6_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S6_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S6_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S6_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S6_AXI_ID_WIDTH         : natural                       := 1;
      C_S6_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S6_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S6_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S6_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S6_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S6_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S6_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S6_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S6_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S6_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S6_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #7 specific.
      C_S7_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S7_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S7_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S7_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S7_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S7_AXI_ID_WIDTH         : natural                       := 1;
      C_S7_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S7_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S7_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S7_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S7_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S7_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S7_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S7_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S7_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S7_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S7_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #8 specific.
      C_S8_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S8_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S8_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S8_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S8_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S8_AXI_ID_WIDTH         : natural                       := 1;
      C_S8_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S8_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S8_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S8_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S8_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S8_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S8_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S8_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S8_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S8_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S8_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #9 specific.
      C_S9_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S9_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S9_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S9_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S9_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S9_AXI_ID_WIDTH         : natural                       := 1;
      C_S9_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S9_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S9_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S9_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S9_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S9_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S9_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S9_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S9_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S9_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S9_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #10 specific.
      C_S10_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S10_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S10_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S10_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S10_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S10_AXI_ID_WIDTH         : natural                       := 1;
      C_S10_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S10_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S10_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S10_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S10_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S10_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S10_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S10_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S10_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S10_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S10_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #11 specific.
      C_S11_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S11_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S11_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S11_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S11_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S11_AXI_ID_WIDTH         : natural                       := 1;
      C_S11_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S11_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S11_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S11_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S11_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S11_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S11_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S11_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S11_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S11_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S11_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #12 specific.
      C_S12_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S12_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S12_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S12_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S12_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S12_AXI_ID_WIDTH         : natural                       := 1;
      C_S12_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S12_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S12_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S12_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S12_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S12_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S12_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S12_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S12_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S12_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S12_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #13 specific.
      C_S13_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S13_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S13_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S13_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S13_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S13_AXI_ID_WIDTH         : natural                       := 1;
      C_S13_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S13_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S13_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S13_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S13_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S13_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S13_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S13_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S13_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S13_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S13_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #14 specific.
      C_S14_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S14_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S14_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S14_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S14_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S14_AXI_ID_WIDTH         : natural                       := 1;
      C_S14_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S14_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S14_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S14_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S14_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S14_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S14_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S14_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S14_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S14_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S14_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Optimized AXI4 Slave Interface #15 specific.
      C_S15_AXI_BASEADDR         : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S15_AXI_HIGHADDR         : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S15_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_S15_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_S15_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      C_S15_AXI_ID_WIDTH         : natural                       := 1;
      C_S15_AXI_SUPPORT_UNIQUE   : natural range  0 to    1      := 1;
      C_S15_AXI_SUPPORT_DIRTY    : natural range  0 to    1      := 0;
      C_S15_AXI_FORCE_READ_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S15_AXI_PROHIBIT_READ_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S15_AXI_FORCE_WRITE_ALLOCATE    : natural range  0 to    1      :=  0;
      C_S15_AXI_PROHIBIT_WRITE_ALLOCATE : natural range  0 to    1      :=  0;
      C_S15_AXI_FORCE_READ_BUFFER       : natural range  0 to    1      :=  0;
      C_S15_AXI_PROHIBIT_READ_BUFFER    : natural range  0 to    1      :=  0;
      C_S15_AXI_FORCE_WRITE_BUFFER      : natural range  0 to    1      :=  0;
      C_S15_AXI_PROHIBIT_WRITE_BUFFER   : natural range  0 to    1      :=  0;
      C_S15_AXI_PROHIBIT_EXCLUSIVE      : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S0_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S0_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S0_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S0_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S0_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S0_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #1 specific.
      C_S1_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S1_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S1_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S1_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S1_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S1_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #2 specific.
      C_S2_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S2_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S2_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S2_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S2_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S2_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #3 specific.
      C_S3_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S3_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S3_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S3_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S3_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S3_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #4 specific.
      C_S4_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S4_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S4_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S4_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S4_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S4_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #5 specific.
      C_S5_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S5_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S5_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S5_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S5_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S5_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #6 specific.
      C_S6_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S6_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S6_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S6_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S6_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S6_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #7 specific.
      C_S7_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S7_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S7_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S7_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S7_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S7_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #8 specific.
      C_S8_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S8_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S8_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S8_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S8_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S8_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #9 specific.
      C_S9_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S9_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S9_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S9_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S9_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S9_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #10 specific.
      C_S10_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S10_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S10_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S10_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S10_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S10_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #11 specific.
      C_S11_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S11_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S11_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S11_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S11_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S11_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #12 specific.
      C_S12_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S12_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S12_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S12_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S12_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S12_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #13 specific.
      C_S13_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S13_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S13_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S13_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S13_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S13_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #14 specific.
      C_S14_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S14_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S14_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S14_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S14_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S14_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Generic AXI4 Slave Interface #15 specific.
      C_S15_AXI_GEN_BASEADDR     : std_logic_vector(63 downto 0) := X"FFFF_FFFF_FFFF_FFFF";
      C_S15_AXI_GEN_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_S15_AXI_GEN_ADDR_WIDTH   : natural range 15 to   64      := 32;
      C_S15_AXI_GEN_DATA_WIDTH   : natural range 32 to 1024      := 32;
      C_S15_AXI_GEN_ID_WIDTH     : natural                       := 1;
      C_S15_AXI_GEN_FORCE_READ_ALLOCATE      : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE   : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE     : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_FORCE_READ_BUFFER        : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_PROHIBIT_READ_BUFFER     : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_FORCE_WRITE_BUFFER       : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER    : natural range  0 to    1      :=  0;
      C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE       : natural range  0 to    1      :=  1;
      
      -- Data type and settings specific.
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      C_Lx_ADDR_REQ_HI          : natural range  2 to   63      := 27;
      C_Lx_ADDR_REQ_LO          : natural range  2 to   63      :=  7;
      C_Lx_ADDR_DIRECT_HI       : natural range  4 to   63      := 27;
      C_Lx_ADDR_DIRECT_LO       : natural range  4 to   63      :=  7;
      C_Lx_ADDR_DATA_HI         : natural range  2 to   63      := 14;
      C_Lx_ADDR_DATA_LO         : natural range  2 to   63      :=  2;
      C_Lx_ADDR_TAG_HI          : natural range  4 to   63      := 27;
      C_Lx_ADDR_TAG_LO          : natural range  4 to   63      := 14;
      C_Lx_ADDR_LINE_HI         : natural range  4 to   63      := 13;
      C_Lx_ADDR_LINE_LO         : natural range  4 to   63      :=  7;
      C_Lx_ADDR_OFFSET_HI       : natural range  2 to   63      :=  6;
      C_Lx_ADDR_OFFSET_LO       : natural range  0 to   63      :=  0;
      C_Lx_ADDR_WORD_HI         : natural range  2 to   63      :=  6;
      C_Lx_ADDR_WORD_LO         : natural range  2 to   63      :=  2;
      C_Lx_ADDR_BYTE_HI         : natural range  0 to   63      :=  1;
      C_Lx_ADDR_BYTE_LO         : natural range  0 to   63      :=  0;
      
      -- Lx Cache Specific.
      C_Lx_CACHE_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_Lx_CACHE_SIZE           : natural                       := 1024;
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  8;
      C_Lx_NUM_WAYS             : natural range  1 to    8      :=  1;
      C_Lx_NUM_ADDR_TAG_BITS    : natural range  1 to   63      :=  8;
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_NUM_WAYS                : natural range  1 to    8      :=  1;
      C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
      C_ENABLE_PEER_PORT_DATA   : natural range  0 to    1      :=  0;
      C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
      C_IGNORE_MODIFIABLE       : natural range  0 to    1      :=  0;
      C_GEN_MATCH_Lx_CACHE      : natural range  0 to    1      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #0 Slave Signals.
      
      S0_AXI_AWID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
      S0_AXI_AWADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
      S0_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S0_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S0_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S0_AXI_AWLOCK             : in  std_logic;
      S0_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S0_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S0_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S0_AXI_AWVALID            : in  std_logic;
      S0_AXI_AWREADY            : out std_logic;
      S0_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S0_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S0_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S0_AXI_WDATA              : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
      S0_AXI_WSTRB              : in  std_logic_vector((C_S0_AXI_DATA_WIDTH/8)-1 downto 0);
      S0_AXI_WLAST              : in  std_logic;
      S0_AXI_WVALID             : in  std_logic;
      S0_AXI_WREADY             : out std_logic;
      
      S0_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S0_AXI_BID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
      S0_AXI_BVALID             : out std_logic;
      S0_AXI_BREADY             : in  std_logic;
      S0_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S0_AXI_ARID               : in  std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
      S0_AXI_ARADDR             : in  std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);
      S0_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S0_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S0_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S0_AXI_ARLOCK             : in  std_logic;
      S0_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S0_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S0_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S0_AXI_ARVALID            : in  std_logic;
      S0_AXI_ARREADY            : out std_logic;
      S0_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S0_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S0_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S0_AXI_RID                : out std_logic_vector(C_S0_AXI_ID_WIDTH-1 downto 0);
      S0_AXI_RDATA              : out std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);
      S0_AXI_RRESP              : out std_logic_vector(C_S0_AXI_RRESP_WIDTH-1 downto 0);
      S0_AXI_RLAST              : out std_logic;
      S0_AXI_RVALID             : out std_logic;
      S0_AXI_RREADY             : in  std_logic;
      S0_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S0_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S0_AXI_ACADDR             : out std_logic_vector(C_S0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S0_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S0_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S0_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S0_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S0_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S0_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S0_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S0_AXI_CDDATA             : in  std_logic_vector(C_S0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S0_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S0_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #1 Slave Signals.
      
      S1_AXI_AWID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
      S1_AXI_AWADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
      S1_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S1_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S1_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S1_AXI_AWLOCK             : in  std_logic;
      S1_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S1_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S1_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S1_AXI_AWVALID            : in  std_logic;
      S1_AXI_AWREADY            : out std_logic;
      S1_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S1_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S1_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S1_AXI_WDATA              : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
      S1_AXI_WSTRB              : in  std_logic_vector((C_S1_AXI_DATA_WIDTH/8)-1 downto 0);
      S1_AXI_WLAST              : in  std_logic;
      S1_AXI_WVALID             : in  std_logic;
      S1_AXI_WREADY             : out std_logic;
      
      S1_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S1_AXI_BID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
      S1_AXI_BVALID             : out std_logic;
      S1_AXI_BREADY             : in  std_logic;
      S1_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S1_AXI_ARID               : in  std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
      S1_AXI_ARADDR             : in  std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);
      S1_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S1_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S1_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S1_AXI_ARLOCK             : in  std_logic;
      S1_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S1_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S1_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S1_AXI_ARVALID            : in  std_logic;
      S1_AXI_ARREADY            : out std_logic;
      S1_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S1_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S1_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S1_AXI_RID                : out std_logic_vector(C_S1_AXI_ID_WIDTH-1 downto 0);
      S1_AXI_RDATA              : out std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);
      S1_AXI_RRESP              : out std_logic_vector(C_S1_AXI_RRESP_WIDTH-1 downto 0);
      S1_AXI_RLAST              : out std_logic;
      S1_AXI_RVALID             : out std_logic;
      S1_AXI_RREADY             : in  std_logic;
      S1_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S1_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S1_AXI_ACADDR             : out std_logic_vector(C_S1_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S1_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S1_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S1_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S1_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S1_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S1_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S1_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S1_AXI_CDDATA             : in  std_logic_vector(C_S1_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S1_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S1_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #2 Slave Signals.
      
      S2_AXI_AWID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
      S2_AXI_AWADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
      S2_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S2_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S2_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S2_AXI_AWLOCK             : in  std_logic;
      S2_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S2_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S2_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S2_AXI_AWVALID            : in  std_logic;
      S2_AXI_AWREADY            : out std_logic;
      S2_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S2_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S2_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S2_AXI_WDATA              : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
      S2_AXI_WSTRB              : in  std_logic_vector((C_S2_AXI_DATA_WIDTH/8)-1 downto 0);
      S2_AXI_WLAST              : in  std_logic;
      S2_AXI_WVALID             : in  std_logic;
      S2_AXI_WREADY             : out std_logic;
      
      S2_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S2_AXI_BID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
      S2_AXI_BVALID             : out std_logic;
      S2_AXI_BREADY             : in  std_logic;
      S2_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S2_AXI_ARID               : in  std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
      S2_AXI_ARADDR             : in  std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);
      S2_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S2_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S2_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S2_AXI_ARLOCK             : in  std_logic;
      S2_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S2_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S2_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S2_AXI_ARVALID            : in  std_logic;
      S2_AXI_ARREADY            : out std_logic;
      S2_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S2_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S2_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S2_AXI_RID                : out std_logic_vector(C_S2_AXI_ID_WIDTH-1 downto 0);
      S2_AXI_RDATA              : out std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);
      S2_AXI_RRESP              : out std_logic_vector(C_S2_AXI_RRESP_WIDTH-1 downto 0);
      S2_AXI_RLAST              : out std_logic;
      S2_AXI_RVALID             : out std_logic;
      S2_AXI_RREADY             : in  std_logic;
      S2_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S2_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S2_AXI_ACADDR             : out std_logic_vector(C_S2_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S2_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S2_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S2_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S2_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S2_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S2_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S2_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S2_AXI_CDDATA             : in  std_logic_vector(C_S2_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S2_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S2_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #3 Slave Signals.
      
      S3_AXI_AWID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
      S3_AXI_AWADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
      S3_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S3_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S3_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S3_AXI_AWLOCK             : in  std_logic;
      S3_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S3_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S3_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S3_AXI_AWVALID            : in  std_logic;
      S3_AXI_AWREADY            : out std_logic;
      S3_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S3_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S3_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S3_AXI_WDATA              : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
      S3_AXI_WSTRB              : in  std_logic_vector((C_S3_AXI_DATA_WIDTH/8)-1 downto 0);
      S3_AXI_WLAST              : in  std_logic;
      S3_AXI_WVALID             : in  std_logic;
      S3_AXI_WREADY             : out std_logic;
      
      S3_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S3_AXI_BID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
      S3_AXI_BVALID             : out std_logic;
      S3_AXI_BREADY             : in  std_logic;
      S3_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S3_AXI_ARID               : in  std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
      S3_AXI_ARADDR             : in  std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);
      S3_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S3_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S3_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S3_AXI_ARLOCK             : in  std_logic;
      S3_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S3_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S3_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S3_AXI_ARVALID            : in  std_logic;
      S3_AXI_ARREADY            : out std_logic;
      S3_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S3_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S3_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S3_AXI_RID                : out std_logic_vector(C_S3_AXI_ID_WIDTH-1 downto 0);
      S3_AXI_RDATA              : out std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);
      S3_AXI_RRESP              : out std_logic_vector(C_S3_AXI_RRESP_WIDTH-1 downto 0);
      S3_AXI_RLAST              : out std_logic;
      S3_AXI_RVALID             : out std_logic;
      S3_AXI_RREADY             : in  std_logic;
      S3_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S3_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S3_AXI_ACADDR             : out std_logic_vector(C_S3_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S3_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S3_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S3_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S3_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S3_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S3_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S3_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S3_AXI_CDDATA             : in  std_logic_vector(C_S3_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S3_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S3_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #4 Slave Signals.
      
      S4_AXI_AWID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
      S4_AXI_AWADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
      S4_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S4_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S4_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S4_AXI_AWLOCK             : in  std_logic;
      S4_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S4_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S4_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S4_AXI_AWVALID            : in  std_logic;
      S4_AXI_AWREADY            : out std_logic;
      S4_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S4_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S4_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S4_AXI_WDATA              : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
      S4_AXI_WSTRB              : in  std_logic_vector((C_S4_AXI_DATA_WIDTH/8)-1 downto 0);
      S4_AXI_WLAST              : in  std_logic;
      S4_AXI_WVALID             : in  std_logic;
      S4_AXI_WREADY             : out std_logic;
      
      S4_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S4_AXI_BID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
      S4_AXI_BVALID             : out std_logic;
      S4_AXI_BREADY             : in  std_logic;
      S4_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S4_AXI_ARID               : in  std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
      S4_AXI_ARADDR             : in  std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);
      S4_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S4_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S4_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S4_AXI_ARLOCK             : in  std_logic;
      S4_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S4_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S4_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S4_AXI_ARVALID            : in  std_logic;
      S4_AXI_ARREADY            : out std_logic;
      S4_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S4_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S4_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S4_AXI_RID                : out std_logic_vector(C_S4_AXI_ID_WIDTH-1 downto 0);
      S4_AXI_RDATA              : out std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);
      S4_AXI_RRESP              : out std_logic_vector(C_S4_AXI_RRESP_WIDTH-1 downto 0);
      S4_AXI_RLAST              : out std_logic;
      S4_AXI_RVALID             : out std_logic;
      S4_AXI_RREADY             : in  std_logic;
      S4_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S4_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S4_AXI_ACADDR             : out std_logic_vector(C_S4_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S4_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S4_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S4_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S4_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S4_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S4_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S4_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S4_AXI_CDDATA             : in  std_logic_vector(C_S4_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S4_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S4_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #5 Slave Signals.
      
      S5_AXI_AWID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
      S5_AXI_AWADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
      S5_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S5_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S5_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S5_AXI_AWLOCK             : in  std_logic;
      S5_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S5_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S5_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S5_AXI_AWVALID            : in  std_logic;
      S5_AXI_AWREADY            : out std_logic;
      S5_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S5_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S5_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S5_AXI_WDATA              : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
      S5_AXI_WSTRB              : in  std_logic_vector((C_S5_AXI_DATA_WIDTH/8)-1 downto 0);
      S5_AXI_WLAST              : in  std_logic;
      S5_AXI_WVALID             : in  std_logic;
      S5_AXI_WREADY             : out std_logic;
      
      S5_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S5_AXI_BID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
      S5_AXI_BVALID             : out std_logic;
      S5_AXI_BREADY             : in  std_logic;
      S5_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S5_AXI_ARID               : in  std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
      S5_AXI_ARADDR             : in  std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);
      S5_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S5_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S5_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S5_AXI_ARLOCK             : in  std_logic;
      S5_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S5_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S5_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S5_AXI_ARVALID            : in  std_logic;
      S5_AXI_ARREADY            : out std_logic;
      S5_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S5_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S5_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S5_AXI_RID                : out std_logic_vector(C_S5_AXI_ID_WIDTH-1 downto 0);
      S5_AXI_RDATA              : out std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);
      S5_AXI_RRESP              : out std_logic_vector(C_S5_AXI_RRESP_WIDTH-1 downto 0);
      S5_AXI_RLAST              : out std_logic;
      S5_AXI_RVALID             : out std_logic;
      S5_AXI_RREADY             : in  std_logic;
      S5_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S5_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S5_AXI_ACADDR             : out std_logic_vector(C_S5_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S5_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S5_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S5_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S5_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S5_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S5_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S5_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S5_AXI_CDDATA             : in  std_logic_vector(C_S5_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S5_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S5_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #6 Slave Signals.
      
      S6_AXI_AWID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
      S6_AXI_AWADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
      S6_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S6_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S6_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S6_AXI_AWLOCK             : in  std_logic;
      S6_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S6_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S6_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S6_AXI_AWVALID            : in  std_logic;
      S6_AXI_AWREADY            : out std_logic;
      S6_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S6_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S6_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S6_AXI_WDATA              : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
      S6_AXI_WSTRB              : in  std_logic_vector((C_S6_AXI_DATA_WIDTH/8)-1 downto 0);
      S6_AXI_WLAST              : in  std_logic;
      S6_AXI_WVALID             : in  std_logic;
      S6_AXI_WREADY             : out std_logic;
      
      S6_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S6_AXI_BID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
      S6_AXI_BVALID             : out std_logic;
      S6_AXI_BREADY             : in  std_logic;
      S6_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S6_AXI_ARID               : in  std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
      S6_AXI_ARADDR             : in  std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);
      S6_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S6_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S6_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S6_AXI_ARLOCK             : in  std_logic;
      S6_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S6_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S6_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S6_AXI_ARVALID            : in  std_logic;
      S6_AXI_ARREADY            : out std_logic;
      S6_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S6_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S6_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S6_AXI_RID                : out std_logic_vector(C_S6_AXI_ID_WIDTH-1 downto 0);
      S6_AXI_RDATA              : out std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);
      S6_AXI_RRESP              : out std_logic_vector(C_S6_AXI_RRESP_WIDTH-1 downto 0);
      S6_AXI_RLAST              : out std_logic;
      S6_AXI_RVALID             : out std_logic;
      S6_AXI_RREADY             : in  std_logic;
      S6_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S6_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S6_AXI_ACADDR             : out std_logic_vector(C_S6_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S6_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S6_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S6_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S6_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S6_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S6_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S6_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S6_AXI_CDDATA             : in  std_logic_vector(C_S6_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S6_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S6_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #7 Slave Signals.
      
      S7_AXI_AWID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
      S7_AXI_AWADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
      S7_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S7_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S7_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S7_AXI_AWLOCK             : in  std_logic;
      S7_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S7_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S7_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S7_AXI_AWVALID            : in  std_logic;
      S7_AXI_AWREADY            : out std_logic;
      S7_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S7_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S7_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S7_AXI_WDATA              : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
      S7_AXI_WSTRB              : in  std_logic_vector((C_S7_AXI_DATA_WIDTH/8)-1 downto 0);
      S7_AXI_WLAST              : in  std_logic;
      S7_AXI_WVALID             : in  std_logic;
      S7_AXI_WREADY             : out std_logic;
      
      S7_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S7_AXI_BID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
      S7_AXI_BVALID             : out std_logic;
      S7_AXI_BREADY             : in  std_logic;
      S7_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S7_AXI_ARID               : in  std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
      S7_AXI_ARADDR             : in  std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);
      S7_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S7_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S7_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S7_AXI_ARLOCK             : in  std_logic;
      S7_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S7_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S7_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S7_AXI_ARVALID            : in  std_logic;
      S7_AXI_ARREADY            : out std_logic;
      S7_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S7_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S7_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S7_AXI_RID                : out std_logic_vector(C_S7_AXI_ID_WIDTH-1 downto 0);
      S7_AXI_RDATA              : out std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);
      S7_AXI_RRESP              : out std_logic_vector(C_S7_AXI_RRESP_WIDTH-1 downto 0);
      S7_AXI_RLAST              : out std_logic;
      S7_AXI_RVALID             : out std_logic;
      S7_AXI_RREADY             : in  std_logic;
      S7_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S7_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S7_AXI_ACADDR             : out std_logic_vector(C_S7_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S7_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S7_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S7_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S7_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S7_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S7_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S7_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S7_AXI_CDDATA             : in  std_logic_vector(C_S7_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S7_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S7_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #8 Slave Signals.
      
      S8_AXI_AWID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
      S8_AXI_AWADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
      S8_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S8_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S8_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S8_AXI_AWLOCK             : in  std_logic;
      S8_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S8_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S8_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S8_AXI_AWVALID            : in  std_logic;
      S8_AXI_AWREADY            : out std_logic;
      S8_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S8_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S8_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S8_AXI_WDATA              : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
      S8_AXI_WSTRB              : in  std_logic_vector((C_S8_AXI_DATA_WIDTH/8)-1 downto 0);
      S8_AXI_WLAST              : in  std_logic;
      S8_AXI_WVALID             : in  std_logic;
      S8_AXI_WREADY             : out std_logic;
      
      S8_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S8_AXI_BID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
      S8_AXI_BVALID             : out std_logic;
      S8_AXI_BREADY             : in  std_logic;
      S8_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S8_AXI_ARID               : in  std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
      S8_AXI_ARADDR             : in  std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);
      S8_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S8_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S8_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S8_AXI_ARLOCK             : in  std_logic;
      S8_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S8_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S8_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S8_AXI_ARVALID            : in  std_logic;
      S8_AXI_ARREADY            : out std_logic;
      S8_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S8_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S8_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S8_AXI_RID                : out std_logic_vector(C_S8_AXI_ID_WIDTH-1 downto 0);
      S8_AXI_RDATA              : out std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);
      S8_AXI_RRESP              : out std_logic_vector(C_S8_AXI_RRESP_WIDTH-1 downto 0);
      S8_AXI_RLAST              : out std_logic;
      S8_AXI_RVALID             : out std_logic;
      S8_AXI_RREADY             : in  std_logic;
      S8_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S8_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S8_AXI_ACADDR             : out std_logic_vector(C_S8_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S8_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S8_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S8_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S8_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S8_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S8_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S8_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S8_AXI_CDDATA             : in  std_logic_vector(C_S8_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S8_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S8_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #9 Slave Signals.
      
      S9_AXI_AWID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
      S9_AXI_AWADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
      S9_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S9_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S9_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S9_AXI_AWLOCK             : in  std_logic;
      S9_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S9_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S9_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S9_AXI_AWVALID            : in  std_logic;
      S9_AXI_AWREADY            : out std_logic;
      S9_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S9_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S9_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S9_AXI_WDATA              : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
      S9_AXI_WSTRB              : in  std_logic_vector((C_S9_AXI_DATA_WIDTH/8)-1 downto 0);
      S9_AXI_WLAST              : in  std_logic;
      S9_AXI_WVALID             : in  std_logic;
      S9_AXI_WREADY             : out std_logic;
      
      S9_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S9_AXI_BID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
      S9_AXI_BVALID             : out std_logic;
      S9_AXI_BREADY             : in  std_logic;
      S9_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S9_AXI_ARID               : in  std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
      S9_AXI_ARADDR             : in  std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);
      S9_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S9_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S9_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S9_AXI_ARLOCK             : in  std_logic;
      S9_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S9_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S9_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S9_AXI_ARVALID            : in  std_logic;
      S9_AXI_ARREADY            : out std_logic;
      S9_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S9_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S9_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S9_AXI_RID                : out std_logic_vector(C_S9_AXI_ID_WIDTH-1 downto 0);
      S9_AXI_RDATA              : out std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);
      S9_AXI_RRESP              : out std_logic_vector(C_S9_AXI_RRESP_WIDTH-1 downto 0);
      S9_AXI_RLAST              : out std_logic;
      S9_AXI_RVALID             : out std_logic;
      S9_AXI_RREADY             : in  std_logic;
      S9_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S9_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S9_AXI_ACADDR             : out std_logic_vector(C_S9_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      S9_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S9_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S9_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S9_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S9_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S9_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S9_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S9_AXI_CDDATA             : in  std_logic_vector(C_S9_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      S9_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S9_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #10 Slave Signals.
      
      S10_AXI_AWID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
      S10_AXI_AWADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
      S10_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S10_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S10_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S10_AXI_AWLOCK             : in  std_logic;
      S10_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S10_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S10_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S10_AXI_AWVALID            : in  std_logic;
      S10_AXI_AWREADY            : out std_logic;
      S10_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S10_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S10_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S10_AXI_WDATA              : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
      S10_AXI_WSTRB              : in  std_logic_vector((C_S10_AXI_DATA_WIDTH/8)-1 downto 0);
      S10_AXI_WLAST              : in  std_logic;
      S10_AXI_WVALID             : in  std_logic;
      S10_AXI_WREADY             : out std_logic;
      
      S10_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S10_AXI_BID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
      S10_AXI_BVALID             : out std_logic;
      S10_AXI_BREADY             : in  std_logic;
      S10_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S10_AXI_ARID               : in  std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
      S10_AXI_ARADDR             : in  std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0);
      S10_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S10_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S10_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S10_AXI_ARLOCK             : in  std_logic;
      S10_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S10_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S10_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S10_AXI_ARVALID            : in  std_logic;
      S10_AXI_ARREADY            : out std_logic;
      S10_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S10_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S10_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S10_AXI_RID                : out std_logic_vector(C_S10_AXI_ID_WIDTH-1 downto 0);
      S10_AXI_RDATA              : out std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0);
      S10_AXI_RRESP              : out std_logic_vector(C_S10_AXI_RRESP_WIDTH-1 downto 0);
      S10_AXI_RLAST              : out std_logic;
      S10_AXI_RVALID             : out std_logic;
      S10_AXI_RREADY             : in  std_logic;
      S10_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S10_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S10_AXI_ACADDR             : out std_logic_vector(C_S10_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S10_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S10_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S10_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S10_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S10_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S10_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S10_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S10_AXI_CDDATA             : in  std_logic_vector(C_S10_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S10_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S10_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #11 Slave Signals.
      
      S11_AXI_AWID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
      S11_AXI_AWADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
      S11_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S11_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S11_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S11_AXI_AWLOCK             : in  std_logic;
      S11_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S11_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S11_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S11_AXI_AWVALID            : in  std_logic;
      S11_AXI_AWREADY            : out std_logic;
      S11_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S11_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S11_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S11_AXI_WDATA              : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
      S11_AXI_WSTRB              : in  std_logic_vector((C_S11_AXI_DATA_WIDTH/8)-1 downto 0);
      S11_AXI_WLAST              : in  std_logic;
      S11_AXI_WVALID             : in  std_logic;
      S11_AXI_WREADY             : out std_logic;
      
      S11_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S11_AXI_BID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
      S11_AXI_BVALID             : out std_logic;
      S11_AXI_BREADY             : in  std_logic;
      S11_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S11_AXI_ARID               : in  std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
      S11_AXI_ARADDR             : in  std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0);
      S11_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S11_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S11_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S11_AXI_ARLOCK             : in  std_logic;
      S11_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S11_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S11_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S11_AXI_ARVALID            : in  std_logic;
      S11_AXI_ARREADY            : out std_logic;
      S11_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S11_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S11_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S11_AXI_RID                : out std_logic_vector(C_S11_AXI_ID_WIDTH-1 downto 0);
      S11_AXI_RDATA              : out std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0);
      S11_AXI_RRESP              : out std_logic_vector(C_S11_AXI_RRESP_WIDTH-1 downto 0);
      S11_AXI_RLAST              : out std_logic;
      S11_AXI_RVALID             : out std_logic;
      S11_AXI_RREADY             : in  std_logic;
      S11_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S11_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S11_AXI_ACADDR             : out std_logic_vector(C_S11_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S11_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S11_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S11_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S11_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S11_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S11_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S11_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S11_AXI_CDDATA             : in  std_logic_vector(C_S11_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S11_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S11_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #12 Slave Signals.
      
      S12_AXI_AWID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
      S12_AXI_AWADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
      S12_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S12_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S12_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S12_AXI_AWLOCK             : in  std_logic;
      S12_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S12_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S12_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S12_AXI_AWVALID            : in  std_logic;
      S12_AXI_AWREADY            : out std_logic;
      S12_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S12_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S12_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S12_AXI_WDATA              : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
      S12_AXI_WSTRB              : in  std_logic_vector((C_S12_AXI_DATA_WIDTH/8)-1 downto 0);
      S12_AXI_WLAST              : in  std_logic;
      S12_AXI_WVALID             : in  std_logic;
      S12_AXI_WREADY             : out std_logic;
      
      S12_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S12_AXI_BID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
      S12_AXI_BVALID             : out std_logic;
      S12_AXI_BREADY             : in  std_logic;
      S12_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S12_AXI_ARID               : in  std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
      S12_AXI_ARADDR             : in  std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0);
      S12_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S12_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S12_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S12_AXI_ARLOCK             : in  std_logic;
      S12_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S12_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S12_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S12_AXI_ARVALID            : in  std_logic;
      S12_AXI_ARREADY            : out std_logic;
      S12_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S12_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S12_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S12_AXI_RID                : out std_logic_vector(C_S12_AXI_ID_WIDTH-1 downto 0);
      S12_AXI_RDATA              : out std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0);
      S12_AXI_RRESP              : out std_logic_vector(C_S12_AXI_RRESP_WIDTH-1 downto 0);
      S12_AXI_RLAST              : out std_logic;
      S12_AXI_RVALID             : out std_logic;
      S12_AXI_RREADY             : in  std_logic;
      S12_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S12_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S12_AXI_ACADDR             : out std_logic_vector(C_S12_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S12_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S12_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S12_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S12_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S12_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S12_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S12_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S12_AXI_CDDATA             : in  std_logic_vector(C_S12_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S12_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S12_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #13 Slave Signals.
      
      S13_AXI_AWID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
      S13_AXI_AWADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
      S13_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S13_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S13_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S13_AXI_AWLOCK             : in  std_logic;
      S13_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S13_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S13_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S13_AXI_AWVALID            : in  std_logic;
      S13_AXI_AWREADY            : out std_logic;
      S13_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S13_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S13_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S13_AXI_WDATA              : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
      S13_AXI_WSTRB              : in  std_logic_vector((C_S13_AXI_DATA_WIDTH/8)-1 downto 0);
      S13_AXI_WLAST              : in  std_logic;
      S13_AXI_WVALID             : in  std_logic;
      S13_AXI_WREADY             : out std_logic;
      
      S13_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S13_AXI_BID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
      S13_AXI_BVALID             : out std_logic;
      S13_AXI_BREADY             : in  std_logic;
      S13_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S13_AXI_ARID               : in  std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
      S13_AXI_ARADDR             : in  std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0);
      S13_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S13_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S13_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S13_AXI_ARLOCK             : in  std_logic;
      S13_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S13_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S13_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S13_AXI_ARVALID            : in  std_logic;
      S13_AXI_ARREADY            : out std_logic;
      S13_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S13_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S13_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S13_AXI_RID                : out std_logic_vector(C_S13_AXI_ID_WIDTH-1 downto 0);
      S13_AXI_RDATA              : out std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0);
      S13_AXI_RRESP              : out std_logic_vector(C_S13_AXI_RRESP_WIDTH-1 downto 0);
      S13_AXI_RLAST              : out std_logic;
      S13_AXI_RVALID             : out std_logic;
      S13_AXI_RREADY             : in  std_logic;
      S13_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S13_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S13_AXI_ACADDR             : out std_logic_vector(C_S13_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S13_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S13_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S13_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S13_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S13_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S13_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S13_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S13_AXI_CDDATA             : in  std_logic_vector(C_S13_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S13_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S13_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #14 Slave Signals.
      
      S14_AXI_AWID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
      S14_AXI_AWADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
      S14_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S14_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S14_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S14_AXI_AWLOCK             : in  std_logic;
      S14_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S14_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S14_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S14_AXI_AWVALID            : in  std_logic;
      S14_AXI_AWREADY            : out std_logic;
      S14_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S14_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S14_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S14_AXI_WDATA              : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
      S14_AXI_WSTRB              : in  std_logic_vector((C_S14_AXI_DATA_WIDTH/8)-1 downto 0);
      S14_AXI_WLAST              : in  std_logic;
      S14_AXI_WVALID             : in  std_logic;
      S14_AXI_WREADY             : out std_logic;
      
      S14_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S14_AXI_BID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
      S14_AXI_BVALID             : out std_logic;
      S14_AXI_BREADY             : in  std_logic;
      S14_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S14_AXI_ARID               : in  std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
      S14_AXI_ARADDR             : in  std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0);
      S14_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S14_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S14_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S14_AXI_ARLOCK             : in  std_logic;
      S14_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S14_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S14_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S14_AXI_ARVALID            : in  std_logic;
      S14_AXI_ARREADY            : out std_logic;
      S14_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S14_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S14_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S14_AXI_RID                : out std_logic_vector(C_S14_AXI_ID_WIDTH-1 downto 0);
      S14_AXI_RDATA              : out std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0);
      S14_AXI_RRESP              : out std_logic_vector(C_S14_AXI_RRESP_WIDTH-1 downto 0);
      S14_AXI_RLAST              : out std_logic;
      S14_AXI_RVALID             : out std_logic;
      S14_AXI_RREADY             : in  std_logic;
      S14_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S14_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S14_AXI_ACADDR             : out std_logic_vector(C_S14_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S14_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S14_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S14_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S14_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S14_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S14_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S14_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S14_AXI_CDDATA             : in  std_logic_vector(C_S14_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S14_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S14_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #15 Slave Signals.
      
      S15_AXI_AWID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
      S15_AXI_AWADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
      S15_AXI_AWLEN              : in  std_logic_vector(7 downto 0);
      S15_AXI_AWSIZE             : in  std_logic_vector(2 downto 0);
      S15_AXI_AWBURST            : in  std_logic_vector(1 downto 0);
      S15_AXI_AWLOCK             : in  std_logic;
      S15_AXI_AWCACHE            : in  std_logic_vector(3 downto 0);
      S15_AXI_AWPROT             : in  std_logic_vector(2 downto 0);
      S15_AXI_AWQOS              : in  std_logic_vector(3 downto 0);
      S15_AXI_AWVALID            : in  std_logic;
      S15_AXI_AWREADY            : out std_logic;
      S15_AXI_AWDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S15_AXI_AWSNOOP            : in  std_logic_vector(2 downto 0);                      -- For ACE
      S15_AXI_AWBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S15_AXI_WDATA              : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
      S15_AXI_WSTRB              : in  std_logic_vector((C_S15_AXI_DATA_WIDTH/8)-1 downto 0);
      S15_AXI_WLAST              : in  std_logic;
      S15_AXI_WVALID             : in  std_logic;
      S15_AXI_WREADY             : out std_logic;
      
      S15_AXI_BRESP              : out std_logic_vector(1 downto 0);
      S15_AXI_BID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
      S15_AXI_BVALID             : out std_logic;
      S15_AXI_BREADY             : in  std_logic;
      S15_AXI_WACK               : in  std_logic;                                         -- For ACE
      
      S15_AXI_ARID               : in  std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
      S15_AXI_ARADDR             : in  std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0);
      S15_AXI_ARLEN              : in  std_logic_vector(7 downto 0);
      S15_AXI_ARSIZE             : in  std_logic_vector(2 downto 0);
      S15_AXI_ARBURST            : in  std_logic_vector(1 downto 0);
      S15_AXI_ARLOCK             : in  std_logic;
      S15_AXI_ARCACHE            : in  std_logic_vector(3 downto 0);
      S15_AXI_ARPROT             : in  std_logic_vector(2 downto 0);
      S15_AXI_ARQOS              : in  std_logic_vector(3 downto 0);
      S15_AXI_ARVALID            : in  std_logic;
      S15_AXI_ARREADY            : out std_logic;
      S15_AXI_ARDOMAIN           : in  std_logic_vector(1 downto 0);                      -- For ACE
      S15_AXI_ARSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      S15_AXI_ARBAR              : in  std_logic_vector(1 downto 0);                      -- For ACE
      
      S15_AXI_RID                : out std_logic_vector(C_S15_AXI_ID_WIDTH-1 downto 0);
      S15_AXI_RDATA              : out std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0);
      S15_AXI_RRESP              : out std_logic_vector(C_S15_AXI_RRESP_WIDTH-1 downto 0);
      S15_AXI_RLAST              : out std_logic;
      S15_AXI_RVALID             : out std_logic;
      S15_AXI_RREADY             : in  std_logic;
      S15_AXI_RACK               : in  std_logic;                                         -- For ACE
      
      S15_AXI_ACVALID            : out std_logic;                                         -- For ACE
      S15_AXI_ACADDR             : out std_logic_vector(C_S15_AXI_ADDR_WIDTH-1 downto 0); -- For ACE
      S15_AXI_ACSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      S15_AXI_ACPROT             : out std_logic_vector(2 downto 0);                      -- For ACE
      S15_AXI_ACREADY            : in  std_logic;                                         -- For ACE
      
      S15_AXI_CRVALID            : in  std_logic;                                         -- For ACE
      S15_AXI_CRRESP             : in  std_logic_vector(4 downto 0);                      -- For ACE
      S15_AXI_CRREADY            : out std_logic;                                         -- For ACE
      
      S15_AXI_CDVALID            : in  std_logic;                                         -- For ACE
      S15_AXI_CDDATA             : in  std_logic_vector(C_S15_AXI_DATA_WIDTH-1 downto 0); -- For ACE
      S15_AXI_CDLAST             : in  std_logic;                                         -- For ACE
      S15_AXI_CDREADY            : out std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #0 Slave Signals.
      
      S0_AXI_GEN_AWID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
      S0_AXI_GEN_AWADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S0_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S0_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S0_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S0_AXI_GEN_AWLOCK         : in  std_logic;
      S0_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S0_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S0_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S0_AXI_GEN_AWVALID        : in  std_logic;
      S0_AXI_GEN_AWREADY        : out std_logic;
      
      S0_AXI_GEN_WDATA          : in  std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
      S0_AXI_GEN_WSTRB          : in  std_logic_vector((C_S0_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S0_AXI_GEN_WLAST          : in  std_logic;
      S0_AXI_GEN_WVALID         : in  std_logic;
      S0_AXI_GEN_WREADY         : out std_logic;
      
      S0_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S0_AXI_GEN_BID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
      S0_AXI_GEN_BVALID         : out std_logic;
      S0_AXI_GEN_BREADY         : in  std_logic;
      
      S0_AXI_GEN_ARID           : in  std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
      S0_AXI_GEN_ARADDR         : in  std_logic_vector(C_S0_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S0_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S0_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S0_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S0_AXI_GEN_ARLOCK         : in  std_logic;
      S0_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S0_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S0_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S0_AXI_GEN_ARVALID        : in  std_logic;
      S0_AXI_GEN_ARREADY        : out std_logic;
      
      S0_AXI_GEN_RID            : out std_logic_vector(C_S0_AXI_GEN_ID_WIDTH-1 downto 0);
      S0_AXI_GEN_RDATA          : out std_logic_vector(C_S0_AXI_GEN_DATA_WIDTH-1 downto 0);
      S0_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S0_AXI_GEN_RLAST          : out std_logic;
      S0_AXI_GEN_RVALID         : out std_logic;
      S0_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #1 Slave Signals.
      
      S1_AXI_GEN_AWID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
      S1_AXI_GEN_AWADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S1_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S1_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S1_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S1_AXI_GEN_AWLOCK         : in  std_logic;
      S1_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S1_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S1_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S1_AXI_GEN_AWVALID        : in  std_logic;
      S1_AXI_GEN_AWREADY        : out std_logic;
      
      S1_AXI_GEN_WDATA          : in  std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
      S1_AXI_GEN_WSTRB          : in  std_logic_vector((C_S1_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S1_AXI_GEN_WLAST          : in  std_logic;
      S1_AXI_GEN_WVALID         : in  std_logic;
      S1_AXI_GEN_WREADY         : out std_logic;
      
      S1_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S1_AXI_GEN_BID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
      S1_AXI_GEN_BVALID         : out std_logic;
      S1_AXI_GEN_BREADY         : in  std_logic;
      
      S1_AXI_GEN_ARID           : in  std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
      S1_AXI_GEN_ARADDR         : in  std_logic_vector(C_S1_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S1_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S1_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S1_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S1_AXI_GEN_ARLOCK         : in  std_logic;
      S1_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S1_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S1_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S1_AXI_GEN_ARVALID        : in  std_logic;
      S1_AXI_GEN_ARREADY        : out std_logic;
      
      S1_AXI_GEN_RID            : out std_logic_vector(C_S1_AXI_GEN_ID_WIDTH-1 downto 0);
      S1_AXI_GEN_RDATA          : out std_logic_vector(C_S1_AXI_GEN_DATA_WIDTH-1 downto 0);
      S1_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S1_AXI_GEN_RLAST          : out std_logic;
      S1_AXI_GEN_RVALID         : out std_logic;
      S1_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #2 Slave Signals.
      
      S2_AXI_GEN_AWID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
      S2_AXI_GEN_AWADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S2_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S2_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S2_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S2_AXI_GEN_AWLOCK         : in  std_logic;
      S2_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S2_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S2_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S2_AXI_GEN_AWVALID        : in  std_logic;
      S2_AXI_GEN_AWREADY        : out std_logic;
      
      S2_AXI_GEN_WDATA          : in  std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
      S2_AXI_GEN_WSTRB          : in  std_logic_vector((C_S2_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S2_AXI_GEN_WLAST          : in  std_logic;
      S2_AXI_GEN_WVALID         : in  std_logic;
      S2_AXI_GEN_WREADY         : out std_logic;
      
      S2_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S2_AXI_GEN_BID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
      S2_AXI_GEN_BVALID         : out std_logic;
      S2_AXI_GEN_BREADY         : in  std_logic;
      
      S2_AXI_GEN_ARID           : in  std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
      S2_AXI_GEN_ARADDR         : in  std_logic_vector(C_S2_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S2_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S2_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S2_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S2_AXI_GEN_ARLOCK         : in  std_logic;
      S2_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S2_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S2_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S2_AXI_GEN_ARVALID        : in  std_logic;
      S2_AXI_GEN_ARREADY        : out std_logic;
      
      S2_AXI_GEN_RID            : out std_logic_vector(C_S2_AXI_GEN_ID_WIDTH-1 downto 0);
      S2_AXI_GEN_RDATA          : out std_logic_vector(C_S2_AXI_GEN_DATA_WIDTH-1 downto 0);
      S2_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S2_AXI_GEN_RLAST          : out std_logic;
      S2_AXI_GEN_RVALID         : out std_logic;
      S2_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #3 Slave Signals.
      
      S3_AXI_GEN_AWID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
      S3_AXI_GEN_AWADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S3_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S3_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S3_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S3_AXI_GEN_AWLOCK         : in  std_logic;
      S3_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S3_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S3_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S3_AXI_GEN_AWVALID        : in  std_logic;
      S3_AXI_GEN_AWREADY        : out std_logic;
      
      S3_AXI_GEN_WDATA          : in  std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
      S3_AXI_GEN_WSTRB          : in  std_logic_vector((C_S3_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S3_AXI_GEN_WLAST          : in  std_logic;
      S3_AXI_GEN_WVALID         : in  std_logic;
      S3_AXI_GEN_WREADY         : out std_logic;
      
      S3_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S3_AXI_GEN_BID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
      S3_AXI_GEN_BVALID         : out std_logic;
      S3_AXI_GEN_BREADY         : in  std_logic;
      
      S3_AXI_GEN_ARID           : in  std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
      S3_AXI_GEN_ARADDR         : in  std_logic_vector(C_S3_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S3_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S3_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S3_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S3_AXI_GEN_ARLOCK         : in  std_logic;
      S3_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S3_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S3_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S3_AXI_GEN_ARVALID        : in  std_logic;
      S3_AXI_GEN_ARREADY        : out std_logic;
      
      S3_AXI_GEN_RID            : out std_logic_vector(C_S3_AXI_GEN_ID_WIDTH-1 downto 0);
      S3_AXI_GEN_RDATA          : out std_logic_vector(C_S3_AXI_GEN_DATA_WIDTH-1 downto 0);
      S3_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S3_AXI_GEN_RLAST          : out std_logic;
      S3_AXI_GEN_RVALID         : out std_logic;
      S3_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #4 Slave Signals.
      
      S4_AXI_GEN_AWID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
      S4_AXI_GEN_AWADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S4_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S4_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S4_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S4_AXI_GEN_AWLOCK         : in  std_logic;
      S4_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S4_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S4_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S4_AXI_GEN_AWVALID        : in  std_logic;
      S4_AXI_GEN_AWREADY        : out std_logic;
      
      S4_AXI_GEN_WDATA          : in  std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
      S4_AXI_GEN_WSTRB          : in  std_logic_vector((C_S4_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S4_AXI_GEN_WLAST          : in  std_logic;
      S4_AXI_GEN_WVALID         : in  std_logic;
      S4_AXI_GEN_WREADY         : out std_logic;
      
      S4_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S4_AXI_GEN_BID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
      S4_AXI_GEN_BVALID         : out std_logic;
      S4_AXI_GEN_BREADY         : in  std_logic;
      
      S4_AXI_GEN_ARID           : in  std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
      S4_AXI_GEN_ARADDR         : in  std_logic_vector(C_S4_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S4_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S4_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S4_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S4_AXI_GEN_ARLOCK         : in  std_logic;
      S4_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S4_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S4_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S4_AXI_GEN_ARVALID        : in  std_logic;
      S4_AXI_GEN_ARREADY        : out std_logic;
      
      S4_AXI_GEN_RID            : out std_logic_vector(C_S4_AXI_GEN_ID_WIDTH-1 downto 0);
      S4_AXI_GEN_RDATA          : out std_logic_vector(C_S4_AXI_GEN_DATA_WIDTH-1 downto 0);
      S4_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S4_AXI_GEN_RLAST          : out std_logic;
      S4_AXI_GEN_RVALID         : out std_logic;
      S4_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #5 Slave Signals.
      
      S5_AXI_GEN_AWID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
      S5_AXI_GEN_AWADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S5_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S5_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S5_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S5_AXI_GEN_AWLOCK         : in  std_logic;
      S5_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S5_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S5_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S5_AXI_GEN_AWVALID        : in  std_logic;
      S5_AXI_GEN_AWREADY        : out std_logic;
      
      S5_AXI_GEN_WDATA          : in  std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
      S5_AXI_GEN_WSTRB          : in  std_logic_vector((C_S5_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S5_AXI_GEN_WLAST          : in  std_logic;
      S5_AXI_GEN_WVALID         : in  std_logic;
      S5_AXI_GEN_WREADY         : out std_logic;
      
      S5_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S5_AXI_GEN_BID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
      S5_AXI_GEN_BVALID         : out std_logic;
      S5_AXI_GEN_BREADY         : in  std_logic;
      
      S5_AXI_GEN_ARID           : in  std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
      S5_AXI_GEN_ARADDR         : in  std_logic_vector(C_S5_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S5_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S5_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S5_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S5_AXI_GEN_ARLOCK         : in  std_logic;
      S5_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S5_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S5_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S5_AXI_GEN_ARVALID        : in  std_logic;
      S5_AXI_GEN_ARREADY        : out std_logic;
      
      S5_AXI_GEN_RID            : out std_logic_vector(C_S5_AXI_GEN_ID_WIDTH-1 downto 0);
      S5_AXI_GEN_RDATA          : out std_logic_vector(C_S5_AXI_GEN_DATA_WIDTH-1 downto 0);
      S5_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S5_AXI_GEN_RLAST          : out std_logic;
      S5_AXI_GEN_RVALID         : out std_logic;
      S5_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #6 Slave Signals.
      
      S6_AXI_GEN_AWID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
      S6_AXI_GEN_AWADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S6_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S6_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S6_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S6_AXI_GEN_AWLOCK         : in  std_logic;
      S6_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S6_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S6_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S6_AXI_GEN_AWVALID        : in  std_logic;
      S6_AXI_GEN_AWREADY        : out std_logic;
      
      S6_AXI_GEN_WDATA          : in  std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
      S6_AXI_GEN_WSTRB          : in  std_logic_vector((C_S6_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S6_AXI_GEN_WLAST          : in  std_logic;
      S6_AXI_GEN_WVALID         : in  std_logic;
      S6_AXI_GEN_WREADY         : out std_logic;
      
      S6_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S6_AXI_GEN_BID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
      S6_AXI_GEN_BVALID         : out std_logic;
      S6_AXI_GEN_BREADY         : in  std_logic;
      
      S6_AXI_GEN_ARID           : in  std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
      S6_AXI_GEN_ARADDR         : in  std_logic_vector(C_S6_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S6_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S6_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S6_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S6_AXI_GEN_ARLOCK         : in  std_logic;
      S6_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S6_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S6_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S6_AXI_GEN_ARVALID        : in  std_logic;
      S6_AXI_GEN_ARREADY        : out std_logic;
      
      S6_AXI_GEN_RID            : out std_logic_vector(C_S6_AXI_GEN_ID_WIDTH-1 downto 0);
      S6_AXI_GEN_RDATA          : out std_logic_vector(C_S6_AXI_GEN_DATA_WIDTH-1 downto 0);
      S6_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S6_AXI_GEN_RLAST          : out std_logic;
      S6_AXI_GEN_RVALID         : out std_logic;
      S6_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #7 Slave Signals.
      
      S7_AXI_GEN_AWID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
      S7_AXI_GEN_AWADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S7_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S7_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S7_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S7_AXI_GEN_AWLOCK         : in  std_logic;
      S7_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S7_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S7_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S7_AXI_GEN_AWVALID        : in  std_logic;
      S7_AXI_GEN_AWREADY        : out std_logic;
      
      S7_AXI_GEN_WDATA          : in  std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
      S7_AXI_GEN_WSTRB          : in  std_logic_vector((C_S7_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S7_AXI_GEN_WLAST          : in  std_logic;
      S7_AXI_GEN_WVALID         : in  std_logic;
      S7_AXI_GEN_WREADY         : out std_logic;
      
      S7_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S7_AXI_GEN_BID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
      S7_AXI_GEN_BVALID         : out std_logic;
      S7_AXI_GEN_BREADY         : in  std_logic;
      
      S7_AXI_GEN_ARID           : in  std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
      S7_AXI_GEN_ARADDR         : in  std_logic_vector(C_S7_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S7_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S7_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S7_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S7_AXI_GEN_ARLOCK         : in  std_logic;
      S7_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S7_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S7_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S7_AXI_GEN_ARVALID        : in  std_logic;
      S7_AXI_GEN_ARREADY        : out std_logic;
      
      S7_AXI_GEN_RID            : out std_logic_vector(C_S7_AXI_GEN_ID_WIDTH-1 downto 0);
      S7_AXI_GEN_RDATA          : out std_logic_vector(C_S7_AXI_GEN_DATA_WIDTH-1 downto 0);
      S7_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S7_AXI_GEN_RLAST          : out std_logic;
      S7_AXI_GEN_RVALID         : out std_logic;
      S7_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #8 Slave Signals.
      
      S8_AXI_GEN_AWID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
      S8_AXI_GEN_AWADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S8_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S8_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S8_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S8_AXI_GEN_AWLOCK         : in  std_logic;
      S8_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S8_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S8_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S8_AXI_GEN_AWVALID        : in  std_logic;
      S8_AXI_GEN_AWREADY        : out std_logic;
      
      S8_AXI_GEN_WDATA          : in  std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
      S8_AXI_GEN_WSTRB          : in  std_logic_vector((C_S8_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S8_AXI_GEN_WLAST          : in  std_logic;
      S8_AXI_GEN_WVALID         : in  std_logic;
      S8_AXI_GEN_WREADY         : out std_logic;
      
      S8_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S8_AXI_GEN_BID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
      S8_AXI_GEN_BVALID         : out std_logic;
      S8_AXI_GEN_BREADY         : in  std_logic;
      
      S8_AXI_GEN_ARID           : in  std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
      S8_AXI_GEN_ARADDR         : in  std_logic_vector(C_S8_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S8_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S8_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S8_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S8_AXI_GEN_ARLOCK         : in  std_logic;
      S8_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S8_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S8_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S8_AXI_GEN_ARVALID        : in  std_logic;
      S8_AXI_GEN_ARREADY        : out std_logic;
      
      S8_AXI_GEN_RID            : out std_logic_vector(C_S8_AXI_GEN_ID_WIDTH-1 downto 0);
      S8_AXI_GEN_RDATA          : out std_logic_vector(C_S8_AXI_GEN_DATA_WIDTH-1 downto 0);
      S8_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S8_AXI_GEN_RLAST          : out std_logic;
      S8_AXI_GEN_RVALID         : out std_logic;
      S8_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #9 Slave Signals.
      
      S9_AXI_GEN_AWID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
      S9_AXI_GEN_AWADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S9_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S9_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S9_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S9_AXI_GEN_AWLOCK         : in  std_logic;
      S9_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S9_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S9_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S9_AXI_GEN_AWVALID        : in  std_logic;
      S9_AXI_GEN_AWREADY        : out std_logic;
      
      S9_AXI_GEN_WDATA          : in  std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
      S9_AXI_GEN_WSTRB          : in  std_logic_vector((C_S9_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S9_AXI_GEN_WLAST          : in  std_logic;
      S9_AXI_GEN_WVALID         : in  std_logic;
      S9_AXI_GEN_WREADY         : out std_logic;
      
      S9_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S9_AXI_GEN_BID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
      S9_AXI_GEN_BVALID         : out std_logic;
      S9_AXI_GEN_BREADY         : in  std_logic;
      
      S9_AXI_GEN_ARID           : in  std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
      S9_AXI_GEN_ARADDR         : in  std_logic_vector(C_S9_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S9_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S9_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S9_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S9_AXI_GEN_ARLOCK         : in  std_logic;
      S9_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S9_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S9_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S9_AXI_GEN_ARVALID        : in  std_logic;
      S9_AXI_GEN_ARREADY        : out std_logic;
      
      S9_AXI_GEN_RID            : out std_logic_vector(C_S9_AXI_GEN_ID_WIDTH-1 downto 0);
      S9_AXI_GEN_RDATA          : out std_logic_vector(C_S9_AXI_GEN_DATA_WIDTH-1 downto 0);
      S9_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S9_AXI_GEN_RLAST          : out std_logic;
      S9_AXI_GEN_RVALID         : out std_logic;
      S9_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #10 Slave Signals.
      
      S10_AXI_GEN_AWID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
      S10_AXI_GEN_AWADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S10_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S10_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S10_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S10_AXI_GEN_AWLOCK         : in  std_logic;
      S10_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S10_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S10_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S10_AXI_GEN_AWVALID        : in  std_logic;
      S10_AXI_GEN_AWREADY        : out std_logic;
      
      S10_AXI_GEN_WDATA          : in  std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
      S10_AXI_GEN_WSTRB          : in  std_logic_vector((C_S10_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S10_AXI_GEN_WLAST          : in  std_logic;
      S10_AXI_GEN_WVALID         : in  std_logic;
      S10_AXI_GEN_WREADY         : out std_logic;
      
      S10_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S10_AXI_GEN_BID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
      S10_AXI_GEN_BVALID         : out std_logic;
      S10_AXI_GEN_BREADY         : in  std_logic;
      
      S10_AXI_GEN_ARID           : in  std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
      S10_AXI_GEN_ARADDR         : in  std_logic_vector(C_S10_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S10_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S10_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S10_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S10_AXI_GEN_ARLOCK         : in  std_logic;
      S10_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S10_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S10_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S10_AXI_GEN_ARVALID        : in  std_logic;
      S10_AXI_GEN_ARREADY        : out std_logic;
      
      S10_AXI_GEN_RID            : out std_logic_vector(C_S10_AXI_GEN_ID_WIDTH-1 downto 0);
      S10_AXI_GEN_RDATA          : out std_logic_vector(C_S10_AXI_GEN_DATA_WIDTH-1 downto 0);
      S10_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S10_AXI_GEN_RLAST          : out std_logic;
      S10_AXI_GEN_RVALID         : out std_logic;
      S10_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #11 Slave Signals.
      
      S11_AXI_GEN_AWID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
      S11_AXI_GEN_AWADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S11_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S11_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S11_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S11_AXI_GEN_AWLOCK         : in  std_logic;
      S11_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S11_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S11_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S11_AXI_GEN_AWVALID        : in  std_logic;
      S11_AXI_GEN_AWREADY        : out std_logic;
      
      S11_AXI_GEN_WDATA          : in  std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
      S11_AXI_GEN_WSTRB          : in  std_logic_vector((C_S11_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S11_AXI_GEN_WLAST          : in  std_logic;
      S11_AXI_GEN_WVALID         : in  std_logic;
      S11_AXI_GEN_WREADY         : out std_logic;
      
      S11_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S11_AXI_GEN_BID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
      S11_AXI_GEN_BVALID         : out std_logic;
      S11_AXI_GEN_BREADY         : in  std_logic;
      
      S11_AXI_GEN_ARID           : in  std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
      S11_AXI_GEN_ARADDR         : in  std_logic_vector(C_S11_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S11_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S11_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S11_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S11_AXI_GEN_ARLOCK         : in  std_logic;
      S11_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S11_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S11_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S11_AXI_GEN_ARVALID        : in  std_logic;
      S11_AXI_GEN_ARREADY        : out std_logic;
      
      S11_AXI_GEN_RID            : out std_logic_vector(C_S11_AXI_GEN_ID_WIDTH-1 downto 0);
      S11_AXI_GEN_RDATA          : out std_logic_vector(C_S11_AXI_GEN_DATA_WIDTH-1 downto 0);
      S11_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S11_AXI_GEN_RLAST          : out std_logic;
      S11_AXI_GEN_RVALID         : out std_logic;
      S11_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #12 Slave Signals.
      
      S12_AXI_GEN_AWID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
      S12_AXI_GEN_AWADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S12_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S12_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S12_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S12_AXI_GEN_AWLOCK         : in  std_logic;
      S12_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S12_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S12_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S12_AXI_GEN_AWVALID        : in  std_logic;
      S12_AXI_GEN_AWREADY        : out std_logic;
      
      S12_AXI_GEN_WDATA          : in  std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
      S12_AXI_GEN_WSTRB          : in  std_logic_vector((C_S12_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S12_AXI_GEN_WLAST          : in  std_logic;
      S12_AXI_GEN_WVALID         : in  std_logic;
      S12_AXI_GEN_WREADY         : out std_logic;
      
      S12_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S12_AXI_GEN_BID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
      S12_AXI_GEN_BVALID         : out std_logic;
      S12_AXI_GEN_BREADY         : in  std_logic;
      
      S12_AXI_GEN_ARID           : in  std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
      S12_AXI_GEN_ARADDR         : in  std_logic_vector(C_S12_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S12_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S12_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S12_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S12_AXI_GEN_ARLOCK         : in  std_logic;
      S12_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S12_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S12_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S12_AXI_GEN_ARVALID        : in  std_logic;
      S12_AXI_GEN_ARREADY        : out std_logic;
      
      S12_AXI_GEN_RID            : out std_logic_vector(C_S12_AXI_GEN_ID_WIDTH-1 downto 0);
      S12_AXI_GEN_RDATA          : out std_logic_vector(C_S12_AXI_GEN_DATA_WIDTH-1 downto 0);
      S12_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S12_AXI_GEN_RLAST          : out std_logic;
      S12_AXI_GEN_RVALID         : out std_logic;
      S12_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #13 Slave Signals.
      
      S13_AXI_GEN_AWID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
      S13_AXI_GEN_AWADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S13_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S13_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S13_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S13_AXI_GEN_AWLOCK         : in  std_logic;
      S13_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S13_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S13_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S13_AXI_GEN_AWVALID        : in  std_logic;
      S13_AXI_GEN_AWREADY        : out std_logic;
      
      S13_AXI_GEN_WDATA          : in  std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
      S13_AXI_GEN_WSTRB          : in  std_logic_vector((C_S13_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S13_AXI_GEN_WLAST          : in  std_logic;
      S13_AXI_GEN_WVALID         : in  std_logic;
      S13_AXI_GEN_WREADY         : out std_logic;
      
      S13_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S13_AXI_GEN_BID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
      S13_AXI_GEN_BVALID         : out std_logic;
      S13_AXI_GEN_BREADY         : in  std_logic;
      
      S13_AXI_GEN_ARID           : in  std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
      S13_AXI_GEN_ARADDR         : in  std_logic_vector(C_S13_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S13_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S13_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S13_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S13_AXI_GEN_ARLOCK         : in  std_logic;
      S13_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S13_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S13_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S13_AXI_GEN_ARVALID        : in  std_logic;
      S13_AXI_GEN_ARREADY        : out std_logic;
      
      S13_AXI_GEN_RID            : out std_logic_vector(C_S13_AXI_GEN_ID_WIDTH-1 downto 0);
      S13_AXI_GEN_RDATA          : out std_logic_vector(C_S13_AXI_GEN_DATA_WIDTH-1 downto 0);
      S13_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S13_AXI_GEN_RLAST          : out std_logic;
      S13_AXI_GEN_RVALID         : out std_logic;
      S13_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #14 Slave Signals.
      
      S14_AXI_GEN_AWID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
      S14_AXI_GEN_AWADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S14_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S14_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S14_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S14_AXI_GEN_AWLOCK         : in  std_logic;
      S14_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S14_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S14_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S14_AXI_GEN_AWVALID        : in  std_logic;
      S14_AXI_GEN_AWREADY        : out std_logic;
      
      S14_AXI_GEN_WDATA          : in  std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
      S14_AXI_GEN_WSTRB          : in  std_logic_vector((C_S14_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S14_AXI_GEN_WLAST          : in  std_logic;
      S14_AXI_GEN_WVALID         : in  std_logic;
      S14_AXI_GEN_WREADY         : out std_logic;
      
      S14_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S14_AXI_GEN_BID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
      S14_AXI_GEN_BVALID         : out std_logic;
      S14_AXI_GEN_BREADY         : in  std_logic;
      
      S14_AXI_GEN_ARID           : in  std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
      S14_AXI_GEN_ARADDR         : in  std_logic_vector(C_S14_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S14_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S14_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S14_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S14_AXI_GEN_ARLOCK         : in  std_logic;
      S14_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S14_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S14_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S14_AXI_GEN_ARVALID        : in  std_logic;
      S14_AXI_GEN_ARREADY        : out std_logic;
      
      S14_AXI_GEN_RID            : out std_logic_vector(C_S14_AXI_GEN_ID_WIDTH-1 downto 0);
      S14_AXI_GEN_RDATA          : out std_logic_vector(C_S14_AXI_GEN_DATA_WIDTH-1 downto 0);
      S14_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S14_AXI_GEN_RLAST          : out std_logic;
      S14_AXI_GEN_RVALID         : out std_logic;
      S14_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #15 Slave Signals.
      
      S15_AXI_GEN_AWID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
      S15_AXI_GEN_AWADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S15_AXI_GEN_AWLEN          : in  std_logic_vector(7 downto 0);
      S15_AXI_GEN_AWSIZE         : in  std_logic_vector(2 downto 0);
      S15_AXI_GEN_AWBURST        : in  std_logic_vector(1 downto 0);
      S15_AXI_GEN_AWLOCK         : in  std_logic;
      S15_AXI_GEN_AWCACHE        : in  std_logic_vector(3 downto 0);
      S15_AXI_GEN_AWPROT         : in  std_logic_vector(2 downto 0);
      S15_AXI_GEN_AWQOS          : in  std_logic_vector(3 downto 0);
      S15_AXI_GEN_AWVALID        : in  std_logic;
      S15_AXI_GEN_AWREADY        : out std_logic;
      
      S15_AXI_GEN_WDATA          : in  std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
      S15_AXI_GEN_WSTRB          : in  std_logic_vector((C_S15_AXI_GEN_DATA_WIDTH/8)-1 downto 0);
      S15_AXI_GEN_WLAST          : in  std_logic;
      S15_AXI_GEN_WVALID         : in  std_logic;
      S15_AXI_GEN_WREADY         : out std_logic;
      
      S15_AXI_GEN_BRESP          : out std_logic_vector(1 downto 0);
      S15_AXI_GEN_BID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
      S15_AXI_GEN_BVALID         : out std_logic;
      S15_AXI_GEN_BREADY         : in  std_logic;
      
      S15_AXI_GEN_ARID           : in  std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
      S15_AXI_GEN_ARADDR         : in  std_logic_vector(C_S15_AXI_GEN_ADDR_WIDTH-1 downto 0);
      S15_AXI_GEN_ARLEN          : in  std_logic_vector(7 downto 0);
      S15_AXI_GEN_ARSIZE         : in  std_logic_vector(2 downto 0);
      S15_AXI_GEN_ARBURST        : in  std_logic_vector(1 downto 0);
      S15_AXI_GEN_ARLOCK         : in  std_logic;
      S15_AXI_GEN_ARCACHE        : in  std_logic_vector(3 downto 0);
      S15_AXI_GEN_ARPROT         : in  std_logic_vector(2 downto 0);
      S15_AXI_GEN_ARQOS          : in  std_logic_vector(3 downto 0);
      S15_AXI_GEN_ARVALID        : in  std_logic;
      S15_AXI_GEN_ARREADY        : out std_logic;
      
      S15_AXI_GEN_RID            : out std_logic_vector(C_S15_AXI_GEN_ID_WIDTH-1 downto 0);
      S15_AXI_GEN_RDATA          : out std_logic_vector(C_S15_AXI_GEN_DATA_WIDTH-1 downto 0);
      S15_AXI_GEN_RRESP          : out std_logic_vector(1 downto 0);
      S15_AXI_GEN_RLAST          : out std_logic;
      S15_AXI_GEN_RVALID         : out std_logic;
      S15_AXI_GEN_RREADY         : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Control If Transactions.
      
      ctrl_arbiter_allow        : in  std_logic;
      ctrl_access               : in  ARBITRATION_TYPE;
      ctrl_ready                : out std_logic;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_access_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals.
      
      lookup_piperun            : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      lookup_write_data_ready   : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      lookup_read_done          : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      update_write_data_ready   : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (to Ports).
      
      -- Write miss response
      update_ext_bresp_info     : in  WRITE_RESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      update_ext_bresp_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Access signals (to Lookup/Update).
      
      access_valid              : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      access_info               : out ACCESS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      access_data_info          : out DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : in  READ_SOURCE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : out STAT_RI_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      read_data_status          : out STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     : in  READ_HIT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      lookup_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     : in  READ_MISS_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      update_read_data_ready    : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      -- Optimized ports.
      stat_s_axi_rd_segments          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_wr_segments          : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_rip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_r                    : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_bip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_bp                   : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wip                  : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_w                    : out STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_rd_latency           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wr_latency           : out STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_rd_latency_conf      : in  STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wr_latency_conf      : in  STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  
      -- Generic ports.
      stat_s_axi_gen_rd_segments      : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_gen_wr_segments      : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_gen_rip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_r                : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_bip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_bp               : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wip              : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_w                : out STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_rd_latency       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wr_latency       : out STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_rd_latency_conf  : in  STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wr_latency_conf  : in  STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      
      -- Arbiter
      stat_arb_valid                  : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid transactions exist
      stat_arb_concurrent_accesses    : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Transactions available each time command is arbitrated
      stat_arb_opt_read_blocked       : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
      stat_arb_gen_read_blocked       : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                                -- Time valid read is blocked by prohibit
      
      -- Access
      stat_access_valid               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid per transaction
      stat_access_stall               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction
      stat_access_fetch_stall         : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (fetch)
      stat_access_req_stall           : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (req)
      stat_access_act_stall           : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (act)
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug signals.
      
      OPT_IF0_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF1_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF2_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF3_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF4_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF5_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF6_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF7_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF8_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF9_DEBUG             : out std_logic_vector(255 downto 0);
      OPT_IF10_DEBUG            : out std_logic_vector(255 downto 0);
      OPT_IF11_DEBUG            : out std_logic_vector(255 downto 0);
      OPT_IF12_DEBUG            : out std_logic_vector(255 downto 0);
      OPT_IF13_DEBUG            : out std_logic_vector(255 downto 0);
      OPT_IF14_DEBUG            : out std_logic_vector(255 downto 0);
      OPT_IF15_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF0_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF1_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF2_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF3_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF4_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF5_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF6_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF7_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF8_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF9_DEBUG             : out std_logic_vector(255 downto 0);
      GEN_IF10_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF11_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF12_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF13_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF14_DEBUG            : out std_logic_vector(255 downto 0);
      GEN_IF15_DEBUG            : out std_logic_vector(255 downto 0);
      ARBITER_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      ACCESS_DEBUG              : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0)
    );
  end component sc_front_end;
  
  component sc_cache_core is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean:= false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_PIPELINE_LU_READ_DATA   : boolean                       := false;
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_INTERNAL_PORTS      : natural range  1 to   33      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EX_MON           : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_ENABLE_EARLY_BRESP      : natural range  0 to    1      :=  0;
      C_NUM_WAYS                : natural range  1 to    8      :=  2;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_ID_WIDTH                : natural range  1 to   32      :=  1;
      C_SUPPORT_SNOOP_FILTER    : natural range  0 to    1      :=  0;
      C_KEEP_SHARED_WRITE       : natural range  0 to    1      :=  1;
      C_READ_ONLY_UNIQUE        : natural range  0 to    1      :=  0;
      C_READ_EXCLUSIVE_CLEAN    : natural range  0 to    1      :=  1;
      C_KEEP_BUFFERABLE         : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_LRU_ADDR_BITS           : natural range  4 to   63      := 13;
      C_TAG_SIZE                : natural range  3 to   63      := 15;
      C_NUM_STATUS_BITS         : natural range  4 to    6      :=  4;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_DATA_ADDR_WIDTH   : natural range  2 to    7      :=  2;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_EXT_DATA_HI        : natural range  2 to   63      := 14;
      C_ADDR_EXT_DATA_LO        : natural range  2 to   63      :=  2;
      C_ADDR_DATA_HI            : natural range  2 to   63      := 14;
      C_ADDR_DATA_LO            : natural range  2 to   63      :=  2;
      C_ADDR_TAG_HI             : natural range  4 to   63      := 27;
      C_ADDR_TAG_LO             : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_HI       : natural range  4 to   63      := 14;
      C_ADDR_FULL_LINE_LO       : natural range  4 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
      C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
      C_ADDR_WORD_HI            : natural range  2 to   63      :=  6;
      C_ADDR_WORD_LO            : natural range  2 to   63      :=  2;
      C_ADDR_EXT_BYTE_HI        : natural range  0 to   63      :=  1;
      C_ADDR_EXT_BYTE_LO        : natural range  0 to   63      :=  0;
      C_ADDR_BYTE_HI            : natural range  0 to   63      :=  1;
      C_ADDR_BYTE_LO            : natural range  0 to   63      :=  0;
      C_WAY_BIT_HI              : natural range  0 to    3      :=  0;
      C_WAY_BIT_LO              : natural range  0 to    0      :=  0
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Access signals.
      
      access_valid              : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      access_info               : in  ACCESS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      access_data_info          : in  DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      : out READ_SOURCE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          : in  STAT_RI_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      read_data_status          : in  STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Access).
      
      lookup_piperun            : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Frontend).
      
      lookup_read_data_info     : out READ_HIT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      
      lookup_write_data_ready   : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Arbiter).
      
      lookup_read_done          : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (to Frontend).
      
      -- Read miss
      update_read_data_info     : out READ_MISS_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      update_read_data_ready    : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      -- Write Miss
      update_write_data_ready   : out std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
      
      -- Write miss response
      update_ext_bresp_info     : out WRITE_RESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
      update_ext_bresp_ready    : in  std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Automatic Clean Information.
      
      update_auto_clean_push    : out std_logic;
      update_auto_clean_addr    : out AXI_ADDR_TYPE;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_lookup_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      ctrl_update_done          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Update signals (to Backend).
      
      read_req_info             : out READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_req_ready            : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_req_info            : out WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_req_ready           : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_data_info           : out DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_data_ready          : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_almost_full    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_full           : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   : in  std_logic;
      be_writeback_inflight     : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      backend_wr_resp_info      : in  WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_wr_resp_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      backend_wr_resp_conf      : out WRITE_CONF_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      backend_rd_data_info      : in  READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_rd_data_ready     : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   : in  std_logic;
      mst_snoop_fetch_info      : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_piperun     : in  std_logic;
      mst_snoop_mem_info        : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_piperun   : in  std_logic;
      mst_snoop_check_info      : in  MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_fetch_ack_info  : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_ack_info    : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_ack_info  : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_update_ack_info : out MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_fetch_hazard     : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_mem_hazard       : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_check_hazard     : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_hazard    : out MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_mem_rm_alloc    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_rm_alloc  : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_tag_valid       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_way         : in  natural range C_NUM_WAYS - 1 downto 0;
      mst_snoop_tag_info        : in  WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_stall       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_sdr_push        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_info        : in  MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_empty       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_full        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_update_data_info : out MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_data_ready: in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : in  std_logic;
      stat_enable                     : in  std_logic;
      
      -- Lookup
      stat_lu_opt_write_hit           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss          : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss_dirty    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_hit            : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss_dirty     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_write_hit    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_read_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_first_write_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      
      stat_lu_gen_write_hit           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss          : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss_dirty    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_hit            : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss           : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss_dirty     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_write_hit    : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_read_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_first_write_hit     : out STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      
      stat_lu_stall                   : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_fetch_stall             : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_mem_stall               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_stall              : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_hit_stall          : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_miss_stall         : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      
      -- Update
      stat_ud_stall                   : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time transactions are stalled
      stat_ud_tag_free                : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles tag is free
      stat_ud_data_free               : out STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles data is free
      stat_ud_ri                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read Information
      stat_ud_r                       : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read data (optional)
      stat_ud_e                       : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Evict
      stat_ud_bs                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- BRESP Source
      stat_ud_wm                      : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss
      stat_ud_wma                     : out STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss Allocate (reserved)
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error                    : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      MEMORY_DEBUG1                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      MEMORY_DEBUG2                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      LOOKUP_DEBUG                    : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      UPDATE_DEBUG1                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      UPDATE_DEBUG2                   : out MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0)
    );
  end component sc_cache_core;
  
  component sc_back_end is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_MEM_LAT_RD_DEPTH   : natural range  1 to   32      :=  4;
      C_STAT_MEM_LAT_WR_DEPTH   : natural range  1 to   32      := 16;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      
      -- IP Specific.
      C_BASEADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_HIGHADDR                : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_NUM_PORTS               : natural range  1 to   32      :=  1;
      C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 32;
      C_EXTERNAL_DATA_WIDTH     : natural range 32 to 1024      := 32;
      C_EXTERNAL_DATA_ADDR_WIDTH: natural range  2 to    7      :=  2;
      C_OPTIMIZE_ORDER          : natural range  0 to    5      :=  0;
      C_ORDER_PER_PORT          : natural range  0 to    1      :=  0;
      C_NUM_ORDER_BINS          : natural range 16 to   64      := 16;
      C_ORDER_BINS_ADDR_MASK    : std_logic_vector(63 downto 0) := X"0000_0000_0000_0000";
      C_ENABLE_SLV_WR_THROTTLE  : natural range  0 to    1      :=  0;
      C_ENABLE_WB_EXTRACT       : natural range  0 to    1      :=  1;
      C_NUM_WAYS                : natural range  1 to    8      :=  2;
      C_SNOOP_KEEP_READ_SHARED  : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_READ_CLEAN   : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_READ_NSD     : natural range  0 to    1      :=  0;
      C_SNOOP_KEEP_CLEAN_SHARED : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_ADDR_VALID_HI           : natural range  0 to   63      := 31;
      C_ADDR_VALID_LO           : natural range  0 to   63      := 28;
      C_ADDR_INTERNAL_HI        : natural range  0 to   63      := 27;
      C_ADDR_INTERNAL_LO        : natural range  0 to   63      :=  0;
      C_ADDR_DIRECT_HI          : natural range  4 to   63      := 27;
      C_ADDR_DIRECT_LO          : natural range  4 to   63      :=  7;
      C_ADDR_REQ_HI             : natural range  2 to   63      := 27;
      C_ADDR_REQ_LO             : natural range  2 to   63      :=  7;
      C_ADDR_TAG_CONTENTS_HI    : natural range  0 to   63      := 27;
      C_ADDR_TAG_CONTENTS_LO    : natural range  0 to   63      :=  7;
      C_ADDR_LINE_HI            : natural range  4 to   63      := 13;
      C_ADDR_LINE_LO            : natural range  4 to   63      :=  7;
      C_ADDR_EXT_WORD_HI        : natural range  2 to   63      :=  6;
      C_ADDR_EXT_WORD_LO        : natural range  2 to   63      :=  2;
      C_ADDR_OFFSET_HI          : natural range  2 to   63      :=  6;
      C_ADDR_OFFSET_LO          : natural range  0 to   63      :=  0;
      
      -- AXI4/ACE Master Interface #0 specific.
      C_M0_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
      C_M0_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_M0_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_M0_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      
      -- AXI4 Master Interface #1 specific.
      C_M1_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
      C_M1_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_M1_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_M1_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      
      -- AXI4 Master Interface #2 specific.
      C_M2_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
      C_M2_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_M2_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_M2_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2;
      
      -- AXI4 Master Interface #3 specific.
      C_M3_AXI_THREAD_ID_WIDTH  : natural range  1 to   32      :=  1;
      C_M3_AXI_DATA_WIDTH       : natural range 32 to 1024      := 32;
      C_M3_AXI_ADDR_WIDTH       : natural range 15 to   64      := 32;
      C_M3_AXI_RRESP_WIDTH      : natural range  2 to    4      :=  2
    );
    port (
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      read_req_info             : in  READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      read_req_ready            : out  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_req_info            : in  WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_req_ready           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      write_data_info           : in  DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      write_data_ready          : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_almost_full    : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      write_data_full           : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Sync Request.
      
      ctrl_dvm_req              : in  INTERNAL_DVM_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_dvm_done             : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_backend_done         : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_bar_req              : in  INTERNAL_BAR_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_bar_done             : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_insert_running       : out std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   : out std_logic;
      be_writeback_inflight     : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Backend signals (to Update).
      
      backend_wr_resp_info      : out WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_wr_resp_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      backend_wr_resp_conf      : in  WRITE_CONF_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      backend_rd_data_info      : out READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      backend_rd_data_ready     : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   : out std_logic;
      mst_snoop_fetch_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_piperun     : out std_logic;
      mst_snoop_mem_info        : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_piperun   : out std_logic;
      mst_snoop_check_info      : out MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_fetch_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_mem_ack_info    : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_ack_info  : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_update_ack_info : in  MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_fetch_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_mem_hazard       : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_check_hazard     : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_hazard    : in  MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_mem_rm_alloc    : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_check_rm_alloc  : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_tag_valid       : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_way         : out rinteger range C_NUM_WAYS - 1 downto 0;
      mst_snoop_tag_info        : out WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_tag_stall       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_snoop_sdr_push        : out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_info        : out MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_empty       : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      mst_snoop_sdr_full        : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      mst_core_update_data_info : in  MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
      mst_core_update_data_ready: out std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Master Interface #0 signals.
      
      M0_AXI_AWID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
      M0_AXI_AWADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
      M0_AXI_AWLEN              : out std_logic_vector(7 downto 0);
      M0_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
      M0_AXI_AWBURST            : out std_logic_vector(1 downto 0);
      M0_AXI_AWLOCK             : out std_logic;
      M0_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
      M0_AXI_AWPROT             : out std_logic_vector(2 downto 0);
      M0_AXI_AWQOS              : out std_logic_vector(3 downto 0);
      M0_AXI_AWVALID            : out std_logic;
      M0_AXI_AWREADY            : in  std_logic;
      M0_AXI_AWDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
      M0_AXI_AWSNOOP            : out std_logic_vector(2 downto 0);                      -- For ACE
      M0_AXI_AWBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
      
      M0_AXI_WDATA              : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
      M0_AXI_WSTRB              : out std_logic_vector((C_M0_AXI_DATA_WIDTH/8)-1 downto 0);
      M0_AXI_WLAST              : out std_logic;
      M0_AXI_WVALID             : out std_logic;
      M0_AXI_WREADY             : in  std_logic;
      
      M0_AXI_BRESP              : in  std_logic_vector(1 downto 0);
      M0_AXI_BID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
      M0_AXI_BVALID             : in  std_logic;
      M0_AXI_BREADY             : out std_logic;
      M0_AXI_WACK               : out std_logic;                                         -- For ACE
      
      M0_AXI_ARID               : out std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
      M0_AXI_ARADDR             : out std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);
      M0_AXI_ARLEN              : out std_logic_vector(7 downto 0);
      M0_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
      M0_AXI_ARBURST            : out std_logic_vector(1 downto 0);
      M0_AXI_ARLOCK             : out std_logic;
      M0_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
      M0_AXI_ARPROT             : out std_logic_vector(2 downto 0);
      M0_AXI_ARQOS              : out std_logic_vector(3 downto 0);
      M0_AXI_ARVALID            : out std_logic;
      M0_AXI_ARREADY            : in  std_logic;
      M0_AXI_ARDOMAIN           : out std_logic_vector(1 downto 0);                      -- For ACE
      M0_AXI_ARSNOOP            : out std_logic_vector(3 downto 0);                      -- For ACE
      M0_AXI_ARBAR              : out std_logic_vector(1 downto 0);                      -- For ACE
      
      M0_AXI_RID                : in  std_logic_vector(C_M0_AXI_THREAD_ID_WIDTH-1 downto 0);
      M0_AXI_RDATA              : in  std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);
      M0_AXI_RRESP              : in  std_logic_vector(C_M0_AXI_RRESP_WIDTH-1 downto 0);
      M0_AXI_RLAST              : in  std_logic;
      M0_AXI_RVALID             : in  std_logic;
      M0_AXI_RREADY             : out std_logic;
      M0_AXI_RACK               : out std_logic;                                         -- For ACE
      
      M0_AXI_ACVALID            : in  std_logic;                                         -- For ACE
      M0_AXI_ACADDR             : in  std_logic_vector(C_M0_AXI_ADDR_WIDTH-1 downto 0);  -- For ACE
      M0_AXI_ACSNOOP            : in  std_logic_vector(3 downto 0);                      -- For ACE
      M0_AXI_ACPROT             : in  std_logic_vector(2 downto 0);                      -- For ACE
      M0_AXI_ACREADY            : out std_logic;                                         -- For ACE
      
      M0_AXI_CRVALID            : out std_logic;                                         -- For ACE
      M0_AXI_CRRESP             : out std_logic_vector(4 downto 0);                      -- For ACE
      M0_AXI_CRREADY            : in  std_logic;                                         -- For ACE
      
      M0_AXI_CDVALID            : out std_logic;                                         -- For ACE
      M0_AXI_CDDATA             : out std_logic_vector(C_M0_AXI_DATA_WIDTH-1 downto 0);  -- For ACE
      M0_AXI_CDLAST             : out std_logic;                                         -- For ACE
      M0_AXI_CDREADY            : in  std_logic;                                         -- For ACE
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #1 signals.
      
      M1_AXI_AWID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
      M1_AXI_AWADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
      M1_AXI_AWLEN              : out std_logic_vector(7 downto 0);
      M1_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
      M1_AXI_AWBURST            : out std_logic_vector(1 downto 0);
      M1_AXI_AWLOCK             : out std_logic;
      M1_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
      M1_AXI_AWPROT             : out std_logic_vector(2 downto 0);
      M1_AXI_AWQOS              : out std_logic_vector(3 downto 0);
      M1_AXI_AWVALID            : out std_logic;
      M1_AXI_AWREADY            : in  std_logic;
      
      M1_AXI_WDATA              : out std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
      M1_AXI_WSTRB              : out std_logic_vector((C_M1_AXI_DATA_WIDTH/8)-1 downto 0);
      M1_AXI_WLAST              : out std_logic;
      M1_AXI_WVALID             : out std_logic;
      M1_AXI_WREADY             : in  std_logic;
      
      M1_AXI_BRESP              : in  std_logic_vector(1 downto 0);
      M1_AXI_BID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
      M1_AXI_BVALID             : in  std_logic;
      M1_AXI_BREADY             : out std_logic;
      
      M1_AXI_ARID               : out std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
      M1_AXI_ARADDR             : out std_logic_vector(C_M1_AXI_ADDR_WIDTH-1 downto 0);
      M1_AXI_ARLEN              : out std_logic_vector(7 downto 0);
      M1_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
      M1_AXI_ARBURST            : out std_logic_vector(1 downto 0);
      M1_AXI_ARLOCK             : out std_logic;
      M1_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
      M1_AXI_ARPROT             : out std_logic_vector(2 downto 0);
      M1_AXI_ARQOS              : out std_logic_vector(3 downto 0);
      M1_AXI_ARVALID            : out std_logic;
      M1_AXI_ARREADY            : in  std_logic;
      
      M1_AXI_RID                : in  std_logic_vector(C_M1_AXI_THREAD_ID_WIDTH-1 downto 0);
      M1_AXI_RDATA              : in  std_logic_vector(C_M1_AXI_DATA_WIDTH-1 downto 0);
      M1_AXI_RRESP              : in  std_logic_vector(C_M1_AXI_RRESP_WIDTH-1 downto 0);
      M1_AXI_RLAST              : in  std_logic;
      M1_AXI_RVALID             : in  std_logic;
      M1_AXI_RREADY             : out std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #2 signals.
      
      M2_AXI_AWID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
      M2_AXI_AWADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
      M2_AXI_AWLEN              : out std_logic_vector(7 downto 0);
      M2_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
      M2_AXI_AWBURST            : out std_logic_vector(1 downto 0);
      M2_AXI_AWLOCK             : out std_logic;
      M2_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
      M2_AXI_AWPROT             : out std_logic_vector(2 downto 0);
      M2_AXI_AWQOS              : out std_logic_vector(3 downto 0);
      M2_AXI_AWVALID            : out std_logic;
      M2_AXI_AWREADY            : in  std_logic;
      
      M2_AXI_WDATA              : out std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
      M2_AXI_WSTRB              : out std_logic_vector((C_M2_AXI_DATA_WIDTH/8)-1 downto 0);
      M2_AXI_WLAST              : out std_logic;
      M2_AXI_WVALID             : out std_logic;
      M2_AXI_WREADY             : in  std_logic;
      
      M2_AXI_BRESP              : in  std_logic_vector(1 downto 0);
      M2_AXI_BID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
      M2_AXI_BVALID             : in  std_logic;
      M2_AXI_BREADY             : out std_logic;
      
      M2_AXI_ARID               : out std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
      M2_AXI_ARADDR             : out std_logic_vector(C_M2_AXI_ADDR_WIDTH-1 downto 0);
      M2_AXI_ARLEN              : out std_logic_vector(7 downto 0);
      M2_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
      M2_AXI_ARBURST            : out std_logic_vector(1 downto 0);
      M2_AXI_ARLOCK             : out std_logic;
      M2_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
      M2_AXI_ARPROT             : out std_logic_vector(2 downto 0);
      M2_AXI_ARQOS              : out std_logic_vector(3 downto 0);
      M2_AXI_ARVALID            : out std_logic;
      M2_AXI_ARREADY            : in  std_logic;
      
      M2_AXI_RID                : in  std_logic_vector(C_M2_AXI_THREAD_ID_WIDTH-1 downto 0);
      M2_AXI_RDATA              : in  std_logic_vector(C_M2_AXI_DATA_WIDTH-1 downto 0);
      M2_AXI_RRESP              : in  std_logic_vector(C_M2_AXI_RRESP_WIDTH-1 downto 0);
      M2_AXI_RLAST              : in  std_logic;
      M2_AXI_RVALID             : in  std_logic;
      M2_AXI_RREADY             : out std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #3 signals.
      
      M3_AXI_AWID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
      M3_AXI_AWADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
      M3_AXI_AWLEN              : out std_logic_vector(7 downto 0);
      M3_AXI_AWSIZE             : out std_logic_vector(2 downto 0);
      M3_AXI_AWBURST            : out std_logic_vector(1 downto 0);
      M3_AXI_AWLOCK             : out std_logic;
      M3_AXI_AWCACHE            : out std_logic_vector(3 downto 0);
      M3_AXI_AWPROT             : out std_logic_vector(2 downto 0);
      M3_AXI_AWQOS              : out std_logic_vector(3 downto 0);
      M3_AXI_AWVALID            : out std_logic;
      M3_AXI_AWREADY            : in  std_logic;
      
      M3_AXI_WDATA              : out std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
      M3_AXI_WSTRB              : out std_logic_vector((C_M3_AXI_DATA_WIDTH/8)-1 downto 0);
      M3_AXI_WLAST              : out std_logic;
      M3_AXI_WVALID             : out std_logic;
      M3_AXI_WREADY             : in  std_logic;
      
      M3_AXI_BRESP              : in  std_logic_vector(1 downto 0);
      M3_AXI_BID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
      M3_AXI_BVALID             : in  std_logic;
      M3_AXI_BREADY             : out std_logic;
      
      M3_AXI_ARID               : out std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
      M3_AXI_ARADDR             : out std_logic_vector(C_M3_AXI_ADDR_WIDTH-1 downto 0);
      M3_AXI_ARLEN              : out std_logic_vector(7 downto 0);
      M3_AXI_ARSIZE             : out std_logic_vector(2 downto 0);
      M3_AXI_ARBURST            : out std_logic_vector(1 downto 0);
      M3_AXI_ARLOCK             : out std_logic;
      M3_AXI_ARCACHE            : out std_logic_vector(3 downto 0);
      M3_AXI_ARPROT             : out std_logic_vector(2 downto 0);
      M3_AXI_ARQOS              : out std_logic_vector(3 downto 0);
      M3_AXI_ARVALID            : out std_logic;
      M3_AXI_ARREADY            : in  std_logic;
      
      M3_AXI_RID                : in  std_logic_vector(C_M3_AXI_THREAD_ID_WIDTH-1 downto 0);
      M3_AXI_RDATA              : in  std_logic_vector(C_M3_AXI_DATA_WIDTH-1 downto 0);
      M3_AXI_RRESP              : in  std_logic_vector(C_M3_AXI_RRESP_WIDTH-1 downto 0);
      M3_AXI_RLAST              : in  std_logic;
      M3_AXI_RVALID             : in  std_logic;
      M3_AXI_RREADY             : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                : in  std_logic;
      stat_enable               : in  std_logic;
      
      -- Backend
      stat_be_aw                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
      stat_be_w                 : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
      stat_be_ar                : out STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
      stat_be_ar_search_depth   : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
      stat_be_ar_stall          : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
      stat_be_ar_protect_stall  : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
      stat_be_rd_latency        : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Read Latency
      stat_be_wr_latency        : out STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Write Latency
      stat_be_rd_latency_conf   : in  STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_be_wr_latency_conf   : in  STAT_CONF_TYPE;     -- External Write Latency Configuration
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              : out std_logic;
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      BACKEND_DEBUG             : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      M_IF_DEBUG                : out MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0)
    );
  end component sc_back_end;
  
  component sc_s_axi_ctrl_interface is
    generic (
      -- General.
      C_TARGET                  : TARGET_FAMILY_TYPE;
      C_USE_DEBUG               : boolean                       := false;
      C_USE_ASSERTIONS          : boolean                       := false;
      C_USE_STATISTICS          : boolean                       := false;
      C_STAT_BITS               : natural range  1 to   64      := 32;
      C_STAT_BIG_BITS           : natural range  1 to   64      := 48;
      C_STAT_COUNTER_BITS       : natural range  1 to   31      := 16;
      C_STAT_MAX_CYCLE_WIDTH    : natural range  2 to   16      := 16;
      C_STAT_USE_STDDEV         : natural range  0 to    1      :=  0;
      C_ENABLE_CTRL             : natural range  0 to    1      :=  0;
      C_ENABLE_AUTOMATIC_CLEAN  : natural range  0 to    1      :=  0;
      C_AUTOMATIC_CLEAN_MODE    : natural range  0 to    1      :=  0;
      
      -- Data type and settings specific.
      C_ADDR_ALL_WAYS_HI        : natural range  4 to   63      := 14;
      C_ADDR_ALL_WAYS_LO        : natural range  4 to   63      :=  7;
      
      -- IP Specific.
      C_ENABLE_STATISTICS       : natural range  0 to  255      := 255;
      C_ENABLE_VERSION_REGISTER : natural range  0 to    3      :=  0;
      C_NUM_OPTIMIZED_PORTS     : natural range  0 to   32      :=  1;
      C_NUM_GENERIC_PORTS       : natural range  0 to   32      :=  0;
      C_NUM_MASTER_PORTS        : natural range  1 to    4      :=  1;
      C_ENABLE_COHERENCY        : natural range  0 to    3      :=  0;
      C_ENABLE_NON_SECURE       : natural range  0 to    1      :=  0;
      C_ENABLE_EXCLUSIVE        : natural range  0 to    1      :=  0;
      C_ENABLE_ERROR_HANDLING   : natural range  0 to    1      :=  0;
      C_NUM_WAYS                : natural range  2 to    8      :=  2;
      C_CACHE_DATA_WIDTH        : natural range 32 to 1024      := 32;
      C_CACHE_BLOCKS            : natural range  1 to    8      :=  1;
      C_CACHE_LINE_LENGTH       : natural range  8 to  128      := 16;
      C_CACHE_SIZE              : natural                       := 32768;
      C_Lx_CACHE_LINE_LENGTH    : natural range  4 to   16      :=  4;
      C_Lx_CACHE_SIZE           : natural                       := 1024;
      C_S_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32;
      C_M_AXI_ADDR_WIDTH        : natural range 15 to   64      := 32;
      C_M_AXI_DATA_WIDTH        : natural range 32 to 1024      := 32;
      
      -- AXI4-Lite Interface Specific.
      C_S_AXI_CTRL_BASEADDR     : std_logic_vector(63 downto 0) := X"0000_0000_8000_0000";
      C_S_AXI_CTRL_HIGHADDR     : std_logic_vector(63 downto 0) := X"0000_0000_8FFF_FFFF";
      C_S_AXI_CTRL_DATA_WIDTH   : natural range 32 to   64      := 32;
      C_S_AXI_CTRL_ADDR_WIDTH   : natural range 17 to   64      := 32
    );
    port (
      -- ---------------------------------------------------
      -- Common signals
      
      ACLK                      : in  std_logic;
      ARESET                    : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- AXI4-Lite Slave Interface Signals
      
      -- AW-Channel
      S_AXI_CTRL_AWADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
      S_AXI_CTRL_AWPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_CTRL_AWVALID             : in  std_logic;
      S_AXI_CTRL_AWREADY             : out std_logic;
  
      -- W-Channel
      S_AXI_CTRL_WDATA               : in  std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
      S_AXI_CTRL_WVALID              : in  std_logic;
      S_AXI_CTRL_WREADY              : out std_logic;
  
      -- B-Channel
      S_AXI_CTRL_BRESP               : out std_logic_vector(1 downto 0);
      S_AXI_CTRL_BVALID              : out std_logic;
      S_AXI_CTRL_BREADY              : in  std_logic;
  
      -- AR-Channel
      S_AXI_CTRL_ARADDR              : in  std_logic_vector(C_S_AXI_CTRL_ADDR_WIDTH-1 downto 0);
      S_AXI_CTRL_ARPROT              : in  std_logic_vector(2 downto 0);
      S_AXI_CTRL_ARVALID             : in  std_logic;
      S_AXI_CTRL_ARREADY             : out std_logic;
  
      -- R-Channel
      S_AXI_CTRL_RDATA               : out std_logic_vector(C_S_AXI_CTRL_DATA_WIDTH-1 downto 0);
      S_AXI_CTRL_RRESP               : out std_logic_vector(1 downto 0);
      S_AXI_CTRL_RVALID              : out std_logic;
      S_AXI_CTRL_RREADY              : in  std_logic;
  
      
      -- ---------------------------------------------------
      -- Control If Transactions.
      
      ctrl_arbiter_allow              : out std_logic;
      ctrl_access                     : out ARBITRATION_TYPE;
      ctrl_ready                      : in  std_logic;
      
      
      -- ---------------------------------------------------
      -- Automatic Clean Information.
      
      update_auto_clean_push          : in  std_logic;
      update_auto_clean_addr          : in  AXI_ADDR_TYPE;
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_access_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      ctrl_lookup_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      ctrl_update_done                : in  std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      ctrl_backend_done               : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_bar_req                    : out INTERNAL_BAR_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_bar_done                   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_insert_running             : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Sync Request.
      
      ctrl_dvm_req                    : out INTERNAL_DVM_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
      ctrl_dvm_done                   : in  std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      : out std_logic;
      stat_enable                     : out std_logic;
      
      -- Optimized ports.
      stat_s_axi_rd_segments          : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_wr_segments          : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_rip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_r                    : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_bip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_bp                   : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wip                  : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_w                    : in  STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_rd_latency           : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wr_latency           : in  STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_rd_latency_conf      : out STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_s_axi_wr_latency_conf      : out STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  
      -- Generic ports.
      stat_s_axi_gen_rd_segments      : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_gen_wr_segments      : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
      stat_s_axi_gen_rip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_r                : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_bip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_bp               : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wip              : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_w                : in  STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_rd_latency       : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wr_latency       : in  STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_rd_latency_conf  : out STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_s_axi_gen_wr_latency_conf  : out STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
      
      -- Arbiter
      stat_arb_valid                  : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid transactions exist
      stat_arb_concurrent_accesses    : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Transactions available each time command is arbitrated
      stat_arb_opt_read_blocked       : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
      stat_arb_gen_read_blocked       : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                                -- Time valid read is blocked by prohibit
      
      -- Access
      stat_access_valid               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid per transaction
      stat_access_stall               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction
      stat_access_fetch_stall         : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (fetch)
      stat_access_req_stall           : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (req)
      stat_access_act_stall           : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (act)
      
      -- Lookup
      stat_lu_opt_write_hit           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss          : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_write_miss_dirty    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_hit            : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_read_miss_dirty     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_write_hit    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_locked_read_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      stat_lu_opt_first_write_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
      
      stat_lu_gen_write_hit           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss          : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_write_miss_dirty    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_hit            : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss           : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_read_miss_dirty     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_write_hit    : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_locked_read_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      stat_lu_gen_first_write_hit     : in  STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
      
      stat_lu_stall                   : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_fetch_stall             : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_mem_stall               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_stall              : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_hit_stall          : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      stat_lu_data_miss_stall         : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
      
      -- Update
      stat_ud_stall                   : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time transactions are stalled
      stat_ud_tag_free                : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles tag is free
      stat_ud_data_free               : in  STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles data is free
      stat_ud_ri                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read Information
      stat_ud_r                       : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read data (optional)
      stat_ud_e                       : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Evict
      stat_ud_bs                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- BRESP Source
      stat_ud_wm                      : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss
      stat_ud_wma                     : in  STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss Allocate (reserved)
      
      -- Backend
      stat_be_aw                      : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
      stat_be_w                       : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
      stat_be_ar                      : in  STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
      stat_be_ar_search_depth         : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
      stat_be_ar_stall                : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
      stat_be_ar_protect_stall        : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
      stat_be_rd_latency              : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Read Latency
      stat_be_wr_latency              : in  STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Write Latency
      stat_be_rd_latency_conf         : out STAT_CONF_TYPE;     -- External Read Latency Configuration
      stat_be_wr_latency_conf         : out STAT_CONF_TYPE;     -- External Write Latency Configuration
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      IF_DEBUG                  : out std_logic_vector(255 downto 0)
    );
  end component sc_s_axi_ctrl_interface;
  
  
  -----------------------------------------------------------------------------
  -- Signal declaration
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Common signals.
  
  signal ARESET                     : std_logic;


  -- ---------------------------------------------------
  -- Debug signals.
    
  signal OPT_IF0_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF1_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF2_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF3_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF4_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF5_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF6_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF7_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF8_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF9_DEBUG             : std_logic_vector(255 downto 0);
  signal OPT_IF10_DEBUG            : std_logic_vector(255 downto 0);
  signal OPT_IF11_DEBUG            : std_logic_vector(255 downto 0);
  signal OPT_IF12_DEBUG            : std_logic_vector(255 downto 0);
  signal OPT_IF13_DEBUG            : std_logic_vector(255 downto 0);
  signal OPT_IF14_DEBUG            : std_logic_vector(255 downto 0);
  signal OPT_IF15_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF0_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF1_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF2_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF3_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF4_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF5_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF6_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF7_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF8_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF9_DEBUG             : std_logic_vector(255 downto 0);
  signal GEN_IF10_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF11_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF12_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF13_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF14_DEBUG            : std_logic_vector(255 downto 0);
  signal GEN_IF15_DEBUG            : std_logic_vector(255 downto 0);
  signal CTRL_IF_DEBUG             : std_logic_vector(255 downto 0);
  signal ARBITER0_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER1_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER2_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER3_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER4_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER5_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER6_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ARBITER7_DEBUG            : std_logic_vector(C_ARBITER_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS0_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS1_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS2_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS3_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS4_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS5_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS6_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal ACCESS7_DEBUG             : std_logic_vector(C_ACCESS1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY0_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY0_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY1_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY1_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY2_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY2_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY3_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY3_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY4_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY4_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY5_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY5_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY6_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY6_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY7_DEBUG1            : std_logic_vector(C_MEMORY1_DEBUG_WIDTH - 1 downto 0);
  signal MEMORY7_DEBUG2            : std_logic_vector(C_MEMORY2_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP0_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP1_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP2_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP3_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP4_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP5_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP6_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal LOOKUP7_DEBUG             : std_logic_vector(C_LOOKUP1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE0_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE0_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE1_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE1_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE2_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE2_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE3_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE3_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE4_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE4_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE5_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE5_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE6_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE6_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE7_DEBUG1            : std_logic_vector(C_UPDATE1_DEBUG_WIDTH - 1 downto 0);
  signal UPDATE7_DEBUG2            : std_logic_vector(C_UPDATE2_DEBUG_WIDTH - 1 downto 0);
  signal BACKEND0_DEBUG            : std_logic_vector(C_BACKEND_DEBUG_WIDTH - 1 downto 0);
  signal BACKEND1_DEBUG            : std_logic_vector(C_BACKEND_DEBUG_WIDTH - 1 downto 0);
  signal BACKEND2_DEBUG            : std_logic_vector(C_BACKEND_DEBUG_WIDTH - 1 downto 0);
  signal BACKEND3_DEBUG            : std_logic_vector(C_BACKEND_DEBUG_WIDTH - 1 downto 0);
  signal M0_IF_DEBUG               : std_logic_vector(C_M_IF_DEBUG_WIDTH - 1 downto 0);
  signal M1_IF_DEBUG               : std_logic_vector(C_M_IF_DEBUG_WIDTH - 1 downto 0);
  signal M2_IF_DEBUG               : std_logic_vector(C_M_IF_DEBUG_WIDTH - 1 downto 0);
  signal M3_IF_DEBUG               : std_logic_vector(C_M_IF_DEBUG_WIDTH - 1 downto 0);
  
  attribute MARK_DEBUG                               : string;
  attribute MARK_DEBUG of OPT_IF0_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  0 ) );
  attribute MARK_DEBUG of OPT_IF1_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  1 ) );
  attribute MARK_DEBUG of OPT_IF2_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  2 ) );
  attribute MARK_DEBUG of OPT_IF3_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  3 ) );
  attribute MARK_DEBUG of OPT_IF4_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  4 ) );
  attribute MARK_DEBUG of OPT_IF5_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  5 ) );
  attribute MARK_DEBUG of OPT_IF6_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  6 ) );
  attribute MARK_DEBUG of OPT_IF7_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  7 ) );
  attribute MARK_DEBUG of OPT_IF8_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  8 ) );
  attribute MARK_DEBUG of OPT_IF9_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS >  9 ) );
  attribute MARK_DEBUG of OPT_IF10_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 10 ) );
  attribute MARK_DEBUG of OPT_IF11_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 11 ) );
  attribute MARK_DEBUG of OPT_IF12_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 12 ) );
  attribute MARK_DEBUG of OPT_IF13_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 13 ) );
  attribute MARK_DEBUG of OPT_IF14_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 14 ) );
  attribute MARK_DEBUG of OPT_IF15_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_OPTIMIZED_PORTS > 15 ) );
  attribute MARK_DEBUG of GEN_IF0_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  0 ) );
  attribute MARK_DEBUG of GEN_IF1_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  1 ) );
  attribute MARK_DEBUG of GEN_IF2_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  2 ) );
  attribute MARK_DEBUG of GEN_IF3_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  3 ) );
  attribute MARK_DEBUG of GEN_IF4_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  4 ) );
  attribute MARK_DEBUG of GEN_IF5_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  5 ) );
  attribute MARK_DEBUG of GEN_IF6_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  6 ) );
  attribute MARK_DEBUG of GEN_IF7_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  7 ) );
  attribute MARK_DEBUG of GEN_IF8_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  8 ) );
  attribute MARK_DEBUG of GEN_IF9_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   >  9 ) );
  attribute MARK_DEBUG of GEN_IF10_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 10 ) );
  attribute MARK_DEBUG of GEN_IF11_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 11 ) );
  attribute MARK_DEBUG of GEN_IF12_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 12 ) );
  attribute MARK_DEBUG of GEN_IF13_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 13 ) );
  attribute MARK_DEBUG of GEN_IF14_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 14 ) );
  attribute MARK_DEBUG of GEN_IF15_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_GENERIC_PORTS   > 15 ) );
  attribute MARK_DEBUG of CTRL_IF_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL );
  attribute MARK_DEBUG of ARBITER0_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of ARBITER1_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of ARBITER2_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of ARBITER3_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of ARBITER4_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of ARBITER5_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of ARBITER6_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of ARBITER7_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of ACCESS0_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of ACCESS1_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of ACCESS2_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of ACCESS3_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of ACCESS4_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of ACCESS5_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of ACCESS6_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of ACCESS7_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of MEMORY0_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of MEMORY0_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of MEMORY1_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of MEMORY1_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of MEMORY2_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of MEMORY2_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of MEMORY3_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of MEMORY3_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of MEMORY4_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of MEMORY4_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of MEMORY5_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of MEMORY5_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of MEMORY6_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of MEMORY6_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of MEMORY7_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of MEMORY7_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of LOOKUP0_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of LOOKUP1_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of LOOKUP2_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of LOOKUP3_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of LOOKUP4_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of LOOKUP5_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of LOOKUP6_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of LOOKUP7_DEBUG              : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of UPDATE0_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of UPDATE0_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 0 ) );
  attribute MARK_DEBUG of UPDATE1_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of UPDATE1_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 1 ) );
  attribute MARK_DEBUG of UPDATE2_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of UPDATE2_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 2 ) );
  attribute MARK_DEBUG of UPDATE3_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of UPDATE3_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 3 ) );
  attribute MARK_DEBUG of UPDATE4_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of UPDATE4_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 4 ) );
  attribute MARK_DEBUG of UPDATE5_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of UPDATE5_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 5 ) );
  attribute MARK_DEBUG of UPDATE6_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of UPDATE6_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 6 ) );
  attribute MARK_DEBUG of UPDATE7_DEBUG1             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of UPDATE7_DEBUG2             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_CACHE_BLOCKS > 7 ) );
  attribute MARK_DEBUG of BACKEND0_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 0 ) );
  attribute MARK_DEBUG of BACKEND1_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 1 ) );
  attribute MARK_DEBUG of BACKEND2_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 2 ) );
  attribute MARK_DEBUG of BACKEND3_DEBUG             : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 3 ) );
  attribute MARK_DEBUG of M0_IF_DEBUG                : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 0 ) );
  attribute MARK_DEBUG of M1_IF_DEBUG                : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 1 ) );
  attribute MARK_DEBUG of M2_IF_DEBUG                : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 2 ) );
  attribute MARK_DEBUG of M3_IF_DEBUG                : signal is has_debug( C_USE_DEBUG_BOOL and ( C_NUM_MASTER_PORTS > 3 ) );
  
  signal ARBITER_DEBUG_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal ACCESS_DEBUG1_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal MEMORY_DEBUG1_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal MEMORY_DEBUG2_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal LOOKUP_DEBUG1_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal UPDATE_DEBUG1_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal UPDATE_DEBUG2_I           : MAX_DEBUG_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal BACKEND_DEBUG_I           : MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal M_IF_DEBUG_I              : MAX_DEBUG_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  
  -- ----------------------------------------
  -- Signals between Backend and Core
  -- 
  
  -- Write miss response (to Ports)
  signal update_ext_bresp_info      : WRITE_RESP_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal update_ext_bresp_ready     : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  -- Automatic Clean Information. (ctrl if)
  signal update_auto_clean_push     : std_logic;
  signal update_auto_clean_addr     : AXI_ADDR_TYPE;
  
  -- Lookup signals (to Arbiter).
  signal lookup_read_done           : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  -- Lookup signals
  signal lookup_piperun             : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  -- Write Miss
  signal lookup_write_data_ready    : std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
  
  signal update_write_data_ready    : std_logic_vector(C_CACHE_BLOCKS * C_NUM_INTERNAL_PORTS - 1 downto 0);
  
  -- Access signals (to Lookup).
  signal access_valid               : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal access_info                : ACCESS_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
  signal access_data_info           : DATA_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_INTERNAL_PORTS - 1 downto 0);
  
  -- Internal Interface Signals (Read request).
  signal lookup_read_data_new       : READ_SOURCE_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  
  -- Internal Interface Signals (Read Data).
  signal read_info_status           : STAT_RI_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal read_data_status           : STAT_RD_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  
  -- Read miss
  signal lookup_read_data_info      : READ_HIT_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal lookup_read_data_ready     : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  signal update_read_data_info      : READ_MISS_BLOCKS_PORTS_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_PORTS - 1 downto 0);
  signal update_read_data_ready     : std_logic_vector(C_CACHE_BLOCKS * C_NUM_PORTS - 1 downto 0);
  
  
  -- ---------------------------------------------------
  -- Signals between Core and Backend
  
  -- Update signals.
  signal read_req_info              : READ_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal read_req_ready             : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  signal write_req_info             : WRITE_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal write_req_ready            : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  signal write_data_info            : DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal write_data_ready           : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal write_data_almost_full     : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal write_data_full            : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ACE Downstream Sync Request.
  signal ctrl_dvm_req               : INTERNAL_DVM_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal ctrl_dvm_done              : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  
  -- Status signals (to Lookup).
  signal be_writeunique_inflight    : std_logic;
  signal be_writeback_inflight      : std_logic;
    
    
  -- Backend signals (to Update).
  signal backend_wr_resp_info       : WRITE_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal backend_wr_resp_ready      : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal backend_wr_resp_conf       : WRITE_CONF_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
  signal backend_rd_data_info       : READ_RESP_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal backend_rd_data_ready      : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
    
  -- Master Snoop Interface Signals.
  signal mst_snoop_fetch_piperun    : std_logic;
  signal mst_snoop_fetch_info       : MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_mem_piperun      : std_logic;
  signal mst_snoop_mem_info         : MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_check_piperun    : std_logic;
  signal mst_snoop_check_info       : MST_SNOOP_REQ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
  signal mst_snoop_fetch_ack_info   : MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_mem_ack_info     : MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_check_ack_info   : MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_update_ack_info  : MST_SNOOP_ACK_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
  signal mst_core_fetch_hazard      : MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_core_mem_hazard        : MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_core_check_hazard      : MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_core_update_hazard     : MST_SNOOP_HAZ_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  
  signal mst_snoop_mem_rm_alloc     : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_check_rm_alloc   : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
  signal mst_snoop_tag_valid        : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_tag_way          : natural range C_NUM_WAYS - 1 downto 0;
  signal mst_snoop_tag_info         : WAY_LINE_TAG_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_tag_stall        : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
    
  signal mst_snoop_sdr_push         : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_sdr_info         : MST_SNOOP_ADDR_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_sdr_empty        : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_snoop_sdr_full         : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
      
  signal mst_core_update_data_info  : MST_SNOOP_DATA_BLOCKS_TYPE(C_CACHE_BLOCKS - 1 downto 0);
  signal mst_core_update_data_ready : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  
  
  -- ---------------------------------------------------
  -- Control If Transactions.
  
  signal ctrl_arbiter_allow         : std_logic;
  signal ctrl_access                : ARBITRATION_TYPE;
  signal ctrl_ready                 : std_logic;
  
  
  -- ---------------------------------------------------
  -- ACE Downstream Barrier Request.
  
  signal ctrl_access_done           : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal ctrl_lookup_done           : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal ctrl_update_done           : std_logic_vector(C_CACHE_BLOCKS - 1 downto 0);
  signal ctrl_backend_done          : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal ctrl_bar_req               : INTERNAL_BAR_PORTS_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);
  signal ctrl_bar_done              : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  signal ctrl_insert_running        : std_logic_vector(C_NUM_MASTER_PORTS - 1 downto 0);
  
  
  -- ----------------------------------------
  -- Statistics signals.
  
  signal stat_reset                      : std_logic;
  signal stat_enable                     : std_logic;
    
  -- Optimized ports.
  signal stat_s_axi_rd_segments          : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
  signal stat_s_axi_wr_segments          : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0); -- Per transaction
  signal stat_s_axi_rip                  : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_r                    : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_bip                  : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_bp                   : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_wip                  : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_w                    : STAT_FIFO_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_rd_latency           : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_wr_latency           : STAT_POINT_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_rd_latency_conf      : STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_s_axi_wr_latency_conf      : STAT_CONF_VECTOR_TYPE(C_NUM_OPTIMIZED_PORTS - 1 downto 0);

  -- Generic ports.
  signal stat_s_axi_gen_rd_segments      : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
  signal stat_s_axi_gen_wr_segments      : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0); -- Per transaction
  signal stat_s_axi_gen_rip              : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_r                : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_bip              : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_bp               : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_wip              : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_w                : STAT_FIFO_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_rd_latency       : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_wr_latency       : STAT_POINT_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_rd_latency_conf  : STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_s_axi_gen_wr_latency_conf  : STAT_CONF_VECTOR_TYPE(C_NUM_GENERIC_PORTS - 1 downto 0);
   
  -- Arbiter
  signal stat_arb_valid                  : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid transactions exist
  signal stat_arb_concurrent_accesses    : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Transactions available each time command is arbitrated
  signal stat_arb_opt_read_blocked       : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);    
  signal stat_arb_gen_read_blocked       : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);    
                                                               -- Time valid read is blocked by prohibit
   
  -- Access
  signal stat_access_valid               : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time valid per transaction
  signal stat_access_stall               : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction
  signal stat_access_fetch_stall         : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (fetch)
  signal stat_access_req_stall           : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (req)
  signal stat_access_act_stall           : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time stalled per transaction (act)
   
  -- Lookup
  signal stat_lu_opt_write_hit           : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_write_miss          : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_write_miss_dirty    : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_read_hit            : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_read_miss           : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_read_miss_dirty     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_locked_write_hit    : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_locked_read_hit     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_opt_first_write_hit     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_OPTIMIZED_PORTS - 1 downto 0);
  signal stat_lu_gen_write_hit           : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_write_miss          : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_write_miss_dirty    : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_read_hit            : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_read_miss           : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_read_miss_dirty     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_locked_write_hit    : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_locked_read_hit     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_gen_first_write_hit     : STAT_POINT_MATRIX_TYPE(C_CACHE_BLOCKS - 1 downto 0, C_NUM_GENERIC_PORTS - 1 downto 0);
  signal stat_lu_stall                   : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
  signal stat_lu_fetch_stall             : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
  signal stat_lu_mem_stall               : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
  signal stat_lu_data_stall              : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
  signal stat_lu_data_hit_stall          : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
  signal stat_lu_data_miss_stall         : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time per occurance
   
  -- Update
  signal stat_ud_stall                   : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Time transactions are stalled
  signal stat_ud_tag_free                : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles tag is free
  signal stat_ud_data_free               : STAT_POINT_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);    -- Cycles data is free
  signal stat_ud_ri                      : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read Information
  signal stat_ud_r                       : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Read data (optional)
  signal stat_ud_e                       : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Evict
  signal stat_ud_bs                      : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- BRESP Source
  signal stat_ud_wm                      : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss
  signal stat_ud_wma                     : STAT_FIFO_VECTOR_TYPE(C_CACHE_BLOCKS - 1 downto 0);     -- Write Miss Allocate (reserved)
   
  -- Backend
  signal stat_be_aw                      : STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Address
  signal stat_be_w                       : STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Write Data
  signal stat_be_ar                      : STAT_FIFO_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);     -- Read Address
  signal stat_be_ar_search_depth         : STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average search depth
  signal stat_be_ar_stall                : STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average total stall
  signal stat_be_ar_protect_stall        : STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- Average protected stall
  signal stat_be_rd_latency              : STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Read Latency
  signal stat_be_wr_latency              : STAT_POINT_VECTOR_TYPE(C_NUM_MASTER_PORTS - 1 downto 0);    -- External Write Latency
  signal stat_be_rd_latency_conf         : STAT_CONF_TYPE;     -- External Read Latency Configuration
  signal stat_be_wr_latency_conf         : STAT_CONF_TYPE;     -- External Write Latency Configuration
  
  
  -- ----------------------------------------
  -- Assertion signals.
  
  signal frontend_assert            : std_logic;
  signal cachecore_assert           : std_logic;
  signal backend_assert             : std_logic;
  signal assert_err                 : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  signal assert_err_1               : std_logic_vector(C_ASSERT_BITS-1 downto 0);
  
  
begin  -- architecture IMP


  -----------------------------------------------------------------------------
  -- Active high internal reset
  -----------------------------------------------------------------------------
  Reset_Handle : process (ACLK) is
  begin  -- process Reset_Handle
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      ARESET  <= not ARESETN;
    end if;
  end process Reset_Handle;
  
  
  -----------------------------------------------------------------------------
  -- Frontend
  -----------------------------------------------------------------------------
  
  FE: sc_front_end
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG_BOOL,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_OPT_LAT_RD_DEPTH   => C_STAT_OPT_LAT_RD_DEPTH,
      C_STAT_OPT_LAT_WR_DEPTH   => C_STAT_OPT_LAT_WR_DEPTH,
      C_STAT_GEN_LAT_RD_DEPTH   => C_STAT_GEN_LAT_RD_DEPTH,
      C_STAT_GEN_LAT_WR_DEPTH   => C_STAT_GEN_LAT_WR_DEPTH,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- Common for all ports.
      C_ANY_SUPPORT_DIRTY       => C_ANY_SUPPORT_DIRTY,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S0_AXI_BASEADDR         => C_BASEADDR,
      C_S0_AXI_HIGHADDR         => C_HIGHADDR,
      C_S0_AXI_ADDR_WIDTH       => C_S0_AXI_ADDR_WIDTH,
      C_S0_AXI_DATA_WIDTH       => C_S0_AXI_DATA_WIDTH,
      C_S0_AXI_RRESP_WIDTH      => C_S0_AXI_RRESP_WIDTH,
      C_S0_AXI_ID_WIDTH         => C_S0_AXI_ID_WIDTH,
      C_S0_AXI_SUPPORT_UNIQUE   => C_S0_AXI_SUPPORT_UNIQUE,
      C_S0_AXI_SUPPORT_DIRTY    => C_S0_AXI_SUPPORT_DIRTY,
      C_S0_AXI_FORCE_READ_ALLOCATE     => C_S0_AXI_FORCE_READ_ALLOCATE,
      C_S0_AXI_PROHIBIT_READ_ALLOCATE  => C_S0_AXI_PROHIBIT_READ_ALLOCATE,
      C_S0_AXI_FORCE_WRITE_ALLOCATE    => C_S0_AXI_FORCE_WRITE_ALLOCATE,
      C_S0_AXI_PROHIBIT_WRITE_ALLOCATE => C_S0_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S0_AXI_FORCE_READ_BUFFER       => C_S0_AXI_FORCE_READ_BUFFER,
      C_S0_AXI_PROHIBIT_READ_BUFFER    => C_S0_AXI_PROHIBIT_READ_BUFFER,
      C_S0_AXI_FORCE_WRITE_BUFFER      => C_S0_AXI_FORCE_WRITE_BUFFER,
      C_S0_AXI_PROHIBIT_WRITE_BUFFER   => C_S0_AXI_PROHIBIT_WRITE_BUFFER,
      C_S0_AXI_PROHIBIT_EXCLUSIVE      => C_S0_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #1 specific.
      C_S1_AXI_BASEADDR         => C_BASEADDR,
      C_S1_AXI_HIGHADDR         => C_HIGHADDR,
      C_S1_AXI_ADDR_WIDTH       => C_S1_AXI_ADDR_WIDTH,
      C_S1_AXI_DATA_WIDTH       => C_S1_AXI_DATA_WIDTH,
      C_S1_AXI_RRESP_WIDTH      => C_S1_AXI_RRESP_WIDTH,
      C_S1_AXI_ID_WIDTH         => C_S1_AXI_ID_WIDTH,
      C_S1_AXI_SUPPORT_UNIQUE   => C_S1_AXI_SUPPORT_UNIQUE,
      C_S1_AXI_SUPPORT_DIRTY    => C_S1_AXI_SUPPORT_DIRTY,
      C_S1_AXI_FORCE_READ_ALLOCATE     => C_S1_AXI_FORCE_READ_ALLOCATE,
      C_S1_AXI_PROHIBIT_READ_ALLOCATE  => C_S1_AXI_PROHIBIT_READ_ALLOCATE,
      C_S1_AXI_FORCE_WRITE_ALLOCATE    => C_S1_AXI_FORCE_WRITE_ALLOCATE,
      C_S1_AXI_PROHIBIT_WRITE_ALLOCATE => C_S1_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S1_AXI_FORCE_READ_BUFFER       => C_S1_AXI_FORCE_READ_BUFFER,
      C_S1_AXI_PROHIBIT_READ_BUFFER    => C_S1_AXI_PROHIBIT_READ_BUFFER,
      C_S1_AXI_FORCE_WRITE_BUFFER      => C_S1_AXI_FORCE_WRITE_BUFFER,
      C_S1_AXI_PROHIBIT_WRITE_BUFFER   => C_S1_AXI_PROHIBIT_WRITE_BUFFER,
      C_S1_AXI_PROHIBIT_EXCLUSIVE      => C_S1_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #2 specific.
      C_S2_AXI_BASEADDR         => C_BASEADDR,
      C_S2_AXI_HIGHADDR         => C_HIGHADDR,
      C_S2_AXI_ADDR_WIDTH       => C_S2_AXI_ADDR_WIDTH,
      C_S2_AXI_DATA_WIDTH       => C_S2_AXI_DATA_WIDTH,
      C_S2_AXI_RRESP_WIDTH      => C_S2_AXI_RRESP_WIDTH,
      C_S2_AXI_ID_WIDTH         => C_S2_AXI_ID_WIDTH,
      C_S2_AXI_SUPPORT_UNIQUE   => C_S2_AXI_SUPPORT_UNIQUE,
      C_S2_AXI_SUPPORT_DIRTY    => C_S2_AXI_SUPPORT_DIRTY,
      C_S2_AXI_FORCE_READ_ALLOCATE     => C_S2_AXI_FORCE_READ_ALLOCATE,
      C_S2_AXI_PROHIBIT_READ_ALLOCATE  => C_S2_AXI_PROHIBIT_READ_ALLOCATE,
      C_S2_AXI_FORCE_WRITE_ALLOCATE    => C_S2_AXI_FORCE_WRITE_ALLOCATE,
      C_S2_AXI_PROHIBIT_WRITE_ALLOCATE => C_S2_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S2_AXI_FORCE_READ_BUFFER       => C_S2_AXI_FORCE_READ_BUFFER,
      C_S2_AXI_PROHIBIT_READ_BUFFER    => C_S2_AXI_PROHIBIT_READ_BUFFER,
      C_S2_AXI_FORCE_WRITE_BUFFER      => C_S2_AXI_FORCE_WRITE_BUFFER,
      C_S2_AXI_PROHIBIT_WRITE_BUFFER   => C_S2_AXI_PROHIBIT_WRITE_BUFFER,
      C_S2_AXI_PROHIBIT_EXCLUSIVE      => C_S2_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #3 specific.
      C_S3_AXI_BASEADDR         => C_BASEADDR,
      C_S3_AXI_HIGHADDR         => C_HIGHADDR,
      C_S3_AXI_ADDR_WIDTH       => C_S3_AXI_ADDR_WIDTH,
      C_S3_AXI_DATA_WIDTH       => C_S3_AXI_DATA_WIDTH,
      C_S3_AXI_RRESP_WIDTH      => C_S3_AXI_RRESP_WIDTH,
      C_S3_AXI_ID_WIDTH         => C_S3_AXI_ID_WIDTH,
      C_S3_AXI_SUPPORT_UNIQUE   => C_S3_AXI_SUPPORT_UNIQUE,
      C_S3_AXI_SUPPORT_DIRTY    => C_S3_AXI_SUPPORT_DIRTY,
      C_S3_AXI_FORCE_READ_ALLOCATE     => C_S3_AXI_FORCE_READ_ALLOCATE,
      C_S3_AXI_PROHIBIT_READ_ALLOCATE  => C_S3_AXI_PROHIBIT_READ_ALLOCATE,
      C_S3_AXI_FORCE_WRITE_ALLOCATE    => C_S3_AXI_FORCE_WRITE_ALLOCATE,
      C_S3_AXI_PROHIBIT_WRITE_ALLOCATE => C_S3_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S3_AXI_FORCE_READ_BUFFER       => C_S3_AXI_FORCE_READ_BUFFER,
      C_S3_AXI_PROHIBIT_READ_BUFFER    => C_S3_AXI_PROHIBIT_READ_BUFFER,
      C_S3_AXI_FORCE_WRITE_BUFFER      => C_S3_AXI_FORCE_WRITE_BUFFER,
      C_S3_AXI_PROHIBIT_WRITE_BUFFER   => C_S3_AXI_PROHIBIT_WRITE_BUFFER,
      C_S3_AXI_PROHIBIT_EXCLUSIVE      => C_S3_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #4 specific.
      C_S4_AXI_BASEADDR         => C_BASEADDR,
      C_S4_AXI_HIGHADDR         => C_HIGHADDR,
      C_S4_AXI_ADDR_WIDTH       => C_S4_AXI_ADDR_WIDTH,
      C_S4_AXI_DATA_WIDTH       => C_S4_AXI_DATA_WIDTH,
      C_S4_AXI_RRESP_WIDTH      => C_S4_AXI_RRESP_WIDTH,
      C_S4_AXI_ID_WIDTH         => C_S4_AXI_ID_WIDTH,
      C_S4_AXI_SUPPORT_UNIQUE   => C_S4_AXI_SUPPORT_UNIQUE,
      C_S4_AXI_SUPPORT_DIRTY    => C_S4_AXI_SUPPORT_DIRTY,
      C_S4_AXI_FORCE_READ_ALLOCATE     => C_S4_AXI_FORCE_READ_ALLOCATE,
      C_S4_AXI_PROHIBIT_READ_ALLOCATE  => C_S4_AXI_PROHIBIT_READ_ALLOCATE,
      C_S4_AXI_FORCE_WRITE_ALLOCATE    => C_S4_AXI_FORCE_WRITE_ALLOCATE,
      C_S4_AXI_PROHIBIT_WRITE_ALLOCATE => C_S4_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S4_AXI_FORCE_READ_BUFFER       => C_S4_AXI_FORCE_READ_BUFFER,
      C_S4_AXI_PROHIBIT_READ_BUFFER    => C_S4_AXI_PROHIBIT_READ_BUFFER,
      C_S4_AXI_FORCE_WRITE_BUFFER      => C_S4_AXI_FORCE_WRITE_BUFFER,
      C_S4_AXI_PROHIBIT_WRITE_BUFFER   => C_S4_AXI_PROHIBIT_WRITE_BUFFER,
      C_S4_AXI_PROHIBIT_EXCLUSIVE      => C_S4_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #5 specific.
      C_S5_AXI_BASEADDR         => C_BASEADDR,
      C_S5_AXI_HIGHADDR         => C_HIGHADDR,
      C_S5_AXI_ADDR_WIDTH       => C_S5_AXI_ADDR_WIDTH,
      C_S5_AXI_DATA_WIDTH       => C_S5_AXI_DATA_WIDTH,
      C_S5_AXI_RRESP_WIDTH      => C_S5_AXI_RRESP_WIDTH,
      C_S5_AXI_ID_WIDTH         => C_S5_AXI_ID_WIDTH,
      C_S5_AXI_SUPPORT_UNIQUE   => C_S5_AXI_SUPPORT_UNIQUE,
      C_S5_AXI_SUPPORT_DIRTY    => C_S5_AXI_SUPPORT_DIRTY,
      C_S5_AXI_FORCE_READ_ALLOCATE     => C_S5_AXI_FORCE_READ_ALLOCATE,
      C_S5_AXI_PROHIBIT_READ_ALLOCATE  => C_S5_AXI_PROHIBIT_READ_ALLOCATE,
      C_S5_AXI_FORCE_WRITE_ALLOCATE    => C_S5_AXI_FORCE_WRITE_ALLOCATE,
      C_S5_AXI_PROHIBIT_WRITE_ALLOCATE => C_S5_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S5_AXI_FORCE_READ_BUFFER       => C_S5_AXI_FORCE_READ_BUFFER,
      C_S5_AXI_PROHIBIT_READ_BUFFER    => C_S5_AXI_PROHIBIT_READ_BUFFER,
      C_S5_AXI_FORCE_WRITE_BUFFER      => C_S5_AXI_FORCE_WRITE_BUFFER,
      C_S5_AXI_PROHIBIT_WRITE_BUFFER   => C_S5_AXI_PROHIBIT_WRITE_BUFFER,
      C_S5_AXI_PROHIBIT_EXCLUSIVE      => C_S5_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #6 specific.
      C_S6_AXI_BASEADDR         => C_BASEADDR,
      C_S6_AXI_HIGHADDR         => C_HIGHADDR,
      C_S6_AXI_ADDR_WIDTH       => C_S6_AXI_ADDR_WIDTH,
      C_S6_AXI_DATA_WIDTH       => C_S6_AXI_DATA_WIDTH,
      C_S6_AXI_RRESP_WIDTH      => C_S6_AXI_RRESP_WIDTH,
      C_S6_AXI_ID_WIDTH         => C_S6_AXI_ID_WIDTH,
      C_S6_AXI_SUPPORT_UNIQUE   => C_S6_AXI_SUPPORT_UNIQUE,
      C_S6_AXI_SUPPORT_DIRTY    => C_S6_AXI_SUPPORT_DIRTY,
      C_S6_AXI_FORCE_READ_ALLOCATE     => C_S6_AXI_FORCE_READ_ALLOCATE,
      C_S6_AXI_PROHIBIT_READ_ALLOCATE  => C_S6_AXI_PROHIBIT_READ_ALLOCATE,
      C_S6_AXI_FORCE_WRITE_ALLOCATE    => C_S6_AXI_FORCE_WRITE_ALLOCATE,
      C_S6_AXI_PROHIBIT_WRITE_ALLOCATE => C_S6_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S6_AXI_FORCE_READ_BUFFER       => C_S6_AXI_FORCE_READ_BUFFER,
      C_S6_AXI_PROHIBIT_READ_BUFFER    => C_S6_AXI_PROHIBIT_READ_BUFFER,
      C_S6_AXI_FORCE_WRITE_BUFFER      => C_S6_AXI_FORCE_WRITE_BUFFER,
      C_S6_AXI_PROHIBIT_WRITE_BUFFER   => C_S6_AXI_PROHIBIT_WRITE_BUFFER,
      C_S6_AXI_PROHIBIT_EXCLUSIVE      => C_S6_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #7 specific.
      C_S7_AXI_BASEADDR         => C_BASEADDR,
      C_S7_AXI_HIGHADDR         => C_HIGHADDR,
      C_S7_AXI_ADDR_WIDTH       => C_S7_AXI_ADDR_WIDTH,
      C_S7_AXI_DATA_WIDTH       => C_S7_AXI_DATA_WIDTH,
      C_S7_AXI_RRESP_WIDTH      => C_S7_AXI_RRESP_WIDTH,
      C_S7_AXI_ID_WIDTH         => C_S7_AXI_ID_WIDTH,
      C_S7_AXI_SUPPORT_UNIQUE   => C_S7_AXI_SUPPORT_UNIQUE,
      C_S7_AXI_SUPPORT_DIRTY    => C_S7_AXI_SUPPORT_DIRTY,
      C_S7_AXI_FORCE_READ_ALLOCATE     => C_S7_AXI_FORCE_READ_ALLOCATE,
      C_S7_AXI_PROHIBIT_READ_ALLOCATE  => C_S7_AXI_PROHIBIT_READ_ALLOCATE,
      C_S7_AXI_FORCE_WRITE_ALLOCATE    => C_S7_AXI_FORCE_WRITE_ALLOCATE,
      C_S7_AXI_PROHIBIT_WRITE_ALLOCATE => C_S7_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S7_AXI_FORCE_READ_BUFFER       => C_S7_AXI_FORCE_READ_BUFFER,
      C_S7_AXI_PROHIBIT_READ_BUFFER    => C_S7_AXI_PROHIBIT_READ_BUFFER,
      C_S7_AXI_FORCE_WRITE_BUFFER      => C_S7_AXI_FORCE_WRITE_BUFFER,
      C_S7_AXI_PROHIBIT_WRITE_BUFFER   => C_S7_AXI_PROHIBIT_WRITE_BUFFER,
      C_S7_AXI_PROHIBIT_EXCLUSIVE      => C_S7_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S8_AXI_BASEADDR         => C_BASEADDR,
      C_S8_AXI_HIGHADDR         => C_HIGHADDR,
      C_S8_AXI_ADDR_WIDTH       => C_S8_AXI_ADDR_WIDTH,
      C_S8_AXI_DATA_WIDTH       => C_S8_AXI_DATA_WIDTH,
      C_S8_AXI_RRESP_WIDTH      => C_S8_AXI_RRESP_WIDTH,
      C_S8_AXI_ID_WIDTH         => C_S8_AXI_ID_WIDTH,
      C_S8_AXI_SUPPORT_UNIQUE   => C_S8_AXI_SUPPORT_UNIQUE,
      C_S8_AXI_SUPPORT_DIRTY    => C_S8_AXI_SUPPORT_DIRTY,
      C_S8_AXI_FORCE_READ_ALLOCATE     => C_S8_AXI_FORCE_READ_ALLOCATE,
      C_S8_AXI_PROHIBIT_READ_ALLOCATE  => C_S8_AXI_PROHIBIT_READ_ALLOCATE,
      C_S8_AXI_FORCE_WRITE_ALLOCATE    => C_S8_AXI_FORCE_WRITE_ALLOCATE,
      C_S8_AXI_PROHIBIT_WRITE_ALLOCATE => C_S8_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S8_AXI_FORCE_READ_BUFFER       => C_S8_AXI_FORCE_READ_BUFFER,
      C_S8_AXI_PROHIBIT_READ_BUFFER    => C_S8_AXI_PROHIBIT_READ_BUFFER,
      C_S8_AXI_FORCE_WRITE_BUFFER      => C_S8_AXI_FORCE_WRITE_BUFFER,
      C_S8_AXI_PROHIBIT_WRITE_BUFFER   => C_S8_AXI_PROHIBIT_WRITE_BUFFER,
      C_S8_AXI_PROHIBIT_EXCLUSIVE      => C_S8_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S9_AXI_BASEADDR         => C_BASEADDR,
      C_S9_AXI_HIGHADDR         => C_HIGHADDR,
      C_S9_AXI_ADDR_WIDTH       => C_S9_AXI_ADDR_WIDTH,
      C_S9_AXI_DATA_WIDTH       => C_S9_AXI_DATA_WIDTH,
      C_S9_AXI_RRESP_WIDTH      => C_S9_AXI_RRESP_WIDTH,
      C_S9_AXI_ID_WIDTH         => C_S9_AXI_ID_WIDTH,
      C_S9_AXI_SUPPORT_UNIQUE   => C_S9_AXI_SUPPORT_UNIQUE,
      C_S9_AXI_SUPPORT_DIRTY    => C_S9_AXI_SUPPORT_DIRTY,
      C_S9_AXI_FORCE_READ_ALLOCATE     => C_S9_AXI_FORCE_READ_ALLOCATE,
      C_S9_AXI_PROHIBIT_READ_ALLOCATE  => C_S9_AXI_PROHIBIT_READ_ALLOCATE,
      C_S9_AXI_FORCE_WRITE_ALLOCATE    => C_S9_AXI_FORCE_WRITE_ALLOCATE,
      C_S9_AXI_PROHIBIT_WRITE_ALLOCATE => C_S9_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S9_AXI_FORCE_READ_BUFFER       => C_S9_AXI_FORCE_READ_BUFFER,
      C_S9_AXI_PROHIBIT_READ_BUFFER    => C_S9_AXI_PROHIBIT_READ_BUFFER,
      C_S9_AXI_FORCE_WRITE_BUFFER      => C_S9_AXI_FORCE_WRITE_BUFFER,
      C_S9_AXI_PROHIBIT_WRITE_BUFFER   => C_S9_AXI_PROHIBIT_WRITE_BUFFER,
      C_S9_AXI_PROHIBIT_EXCLUSIVE      => C_S9_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S10_AXI_BASEADDR         => C_BASEADDR,
      C_S10_AXI_HIGHADDR         => C_HIGHADDR,
      C_S10_AXI_ADDR_WIDTH       => C_S10_AXI_ADDR_WIDTH,
      C_S10_AXI_DATA_WIDTH       => C_S10_AXI_DATA_WIDTH,
      C_S10_AXI_RRESP_WIDTH      => C_S10_AXI_RRESP_WIDTH,
      C_S10_AXI_ID_WIDTH         => C_S10_AXI_ID_WIDTH,
      C_S10_AXI_SUPPORT_UNIQUE   => C_S10_AXI_SUPPORT_UNIQUE,
      C_S10_AXI_SUPPORT_DIRTY    => C_S10_AXI_SUPPORT_DIRTY,
      C_S10_AXI_FORCE_READ_ALLOCATE     => C_S10_AXI_FORCE_READ_ALLOCATE,
      C_S10_AXI_PROHIBIT_READ_ALLOCATE  => C_S10_AXI_PROHIBIT_READ_ALLOCATE,
      C_S10_AXI_FORCE_WRITE_ALLOCATE    => C_S10_AXI_FORCE_WRITE_ALLOCATE,
      C_S10_AXI_PROHIBIT_WRITE_ALLOCATE => C_S10_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S10_AXI_FORCE_READ_BUFFER       => C_S10_AXI_FORCE_READ_BUFFER,
      C_S10_AXI_PROHIBIT_READ_BUFFER    => C_S10_AXI_PROHIBIT_READ_BUFFER,
      C_S10_AXI_FORCE_WRITE_BUFFER      => C_S10_AXI_FORCE_WRITE_BUFFER,
      C_S10_AXI_PROHIBIT_WRITE_BUFFER   => C_S10_AXI_PROHIBIT_WRITE_BUFFER,
      C_S10_AXI_PROHIBIT_EXCLUSIVE      => C_S10_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S11_AXI_BASEADDR         => C_BASEADDR,
      C_S11_AXI_HIGHADDR         => C_HIGHADDR,
      C_S11_AXI_ADDR_WIDTH       => C_S11_AXI_ADDR_WIDTH,
      C_S11_AXI_DATA_WIDTH       => C_S11_AXI_DATA_WIDTH,
      C_S11_AXI_RRESP_WIDTH      => C_S11_AXI_RRESP_WIDTH,
      C_S11_AXI_ID_WIDTH         => C_S11_AXI_ID_WIDTH,
      C_S11_AXI_SUPPORT_UNIQUE   => C_S11_AXI_SUPPORT_UNIQUE,
      C_S11_AXI_SUPPORT_DIRTY    => C_S11_AXI_SUPPORT_DIRTY,
      C_S11_AXI_FORCE_READ_ALLOCATE     => C_S11_AXI_FORCE_READ_ALLOCATE,
      C_S11_AXI_PROHIBIT_READ_ALLOCATE  => C_S11_AXI_PROHIBIT_READ_ALLOCATE,
      C_S11_AXI_FORCE_WRITE_ALLOCATE    => C_S11_AXI_FORCE_WRITE_ALLOCATE,
      C_S11_AXI_PROHIBIT_WRITE_ALLOCATE => C_S11_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S11_AXI_FORCE_READ_BUFFER       => C_S11_AXI_FORCE_READ_BUFFER,
      C_S11_AXI_PROHIBIT_READ_BUFFER    => C_S11_AXI_PROHIBIT_READ_BUFFER,
      C_S11_AXI_FORCE_WRITE_BUFFER      => C_S11_AXI_FORCE_WRITE_BUFFER,
      C_S11_AXI_PROHIBIT_WRITE_BUFFER   => C_S11_AXI_PROHIBIT_WRITE_BUFFER,
      C_S11_AXI_PROHIBIT_EXCLUSIVE      => C_S11_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S12_AXI_BASEADDR         => C_BASEADDR,
      C_S12_AXI_HIGHADDR         => C_HIGHADDR,
      C_S12_AXI_ADDR_WIDTH       => C_S12_AXI_ADDR_WIDTH,
      C_S12_AXI_DATA_WIDTH       => C_S12_AXI_DATA_WIDTH,
      C_S12_AXI_RRESP_WIDTH      => C_S12_AXI_RRESP_WIDTH,
      C_S12_AXI_ID_WIDTH         => C_S12_AXI_ID_WIDTH,
      C_S12_AXI_SUPPORT_UNIQUE   => C_S12_AXI_SUPPORT_UNIQUE,
      C_S12_AXI_SUPPORT_DIRTY    => C_S12_AXI_SUPPORT_DIRTY,
      C_S12_AXI_FORCE_READ_ALLOCATE     => C_S12_AXI_FORCE_READ_ALLOCATE,
      C_S12_AXI_PROHIBIT_READ_ALLOCATE  => C_S12_AXI_PROHIBIT_READ_ALLOCATE,
      C_S12_AXI_FORCE_WRITE_ALLOCATE    => C_S12_AXI_FORCE_WRITE_ALLOCATE,
      C_S12_AXI_PROHIBIT_WRITE_ALLOCATE => C_S12_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S12_AXI_FORCE_READ_BUFFER       => C_S12_AXI_FORCE_READ_BUFFER,
      C_S12_AXI_PROHIBIT_READ_BUFFER    => C_S12_AXI_PROHIBIT_READ_BUFFER,
      C_S12_AXI_FORCE_WRITE_BUFFER      => C_S12_AXI_FORCE_WRITE_BUFFER,
      C_S12_AXI_PROHIBIT_WRITE_BUFFER   => C_S12_AXI_PROHIBIT_WRITE_BUFFER,
      C_S12_AXI_PROHIBIT_EXCLUSIVE      => C_S12_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S13_AXI_BASEADDR         => C_BASEADDR,
      C_S13_AXI_HIGHADDR         => C_HIGHADDR,
      C_S13_AXI_ADDR_WIDTH       => C_S13_AXI_ADDR_WIDTH,
      C_S13_AXI_DATA_WIDTH       => C_S13_AXI_DATA_WIDTH,
      C_S13_AXI_RRESP_WIDTH      => C_S13_AXI_RRESP_WIDTH,
      C_S13_AXI_ID_WIDTH         => C_S13_AXI_ID_WIDTH,
      C_S13_AXI_SUPPORT_UNIQUE   => C_S13_AXI_SUPPORT_UNIQUE,
      C_S13_AXI_SUPPORT_DIRTY    => C_S13_AXI_SUPPORT_DIRTY,
      C_S13_AXI_FORCE_READ_ALLOCATE     => C_S13_AXI_FORCE_READ_ALLOCATE,
      C_S13_AXI_PROHIBIT_READ_ALLOCATE  => C_S13_AXI_PROHIBIT_READ_ALLOCATE,
      C_S13_AXI_FORCE_WRITE_ALLOCATE    => C_S13_AXI_FORCE_WRITE_ALLOCATE,
      C_S13_AXI_PROHIBIT_WRITE_ALLOCATE => C_S13_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S13_AXI_FORCE_READ_BUFFER       => C_S13_AXI_FORCE_READ_BUFFER,
      C_S13_AXI_PROHIBIT_READ_BUFFER    => C_S13_AXI_PROHIBIT_READ_BUFFER,
      C_S13_AXI_FORCE_WRITE_BUFFER      => C_S13_AXI_FORCE_WRITE_BUFFER,
      C_S13_AXI_PROHIBIT_WRITE_BUFFER   => C_S13_AXI_PROHIBIT_WRITE_BUFFER,
      C_S13_AXI_PROHIBIT_EXCLUSIVE      => C_S13_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S14_AXI_BASEADDR         => C_BASEADDR,
      C_S14_AXI_HIGHADDR         => C_HIGHADDR,
      C_S14_AXI_ADDR_WIDTH       => C_S14_AXI_ADDR_WIDTH,
      C_S14_AXI_DATA_WIDTH       => C_S14_AXI_DATA_WIDTH,
      C_S14_AXI_RRESP_WIDTH      => C_S14_AXI_RRESP_WIDTH,
      C_S14_AXI_ID_WIDTH         => C_S14_AXI_ID_WIDTH,
      C_S14_AXI_SUPPORT_UNIQUE   => C_S14_AXI_SUPPORT_UNIQUE,
      C_S14_AXI_SUPPORT_DIRTY    => C_S14_AXI_SUPPORT_DIRTY,
      C_S14_AXI_FORCE_READ_ALLOCATE     => C_S14_AXI_FORCE_READ_ALLOCATE,
      C_S14_AXI_PROHIBIT_READ_ALLOCATE  => C_S14_AXI_PROHIBIT_READ_ALLOCATE,
      C_S14_AXI_FORCE_WRITE_ALLOCATE    => C_S14_AXI_FORCE_WRITE_ALLOCATE,
      C_S14_AXI_PROHIBIT_WRITE_ALLOCATE => C_S14_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S14_AXI_FORCE_READ_BUFFER       => C_S14_AXI_FORCE_READ_BUFFER,
      C_S14_AXI_PROHIBIT_READ_BUFFER    => C_S14_AXI_PROHIBIT_READ_BUFFER,
      C_S14_AXI_FORCE_WRITE_BUFFER      => C_S14_AXI_FORCE_WRITE_BUFFER,
      C_S14_AXI_PROHIBIT_WRITE_BUFFER   => C_S14_AXI_PROHIBIT_WRITE_BUFFER,
      C_S14_AXI_PROHIBIT_EXCLUSIVE      => C_S14_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Optimized AXI4 Slave Interface #0 specific.
      C_S15_AXI_BASEADDR         => C_BASEADDR,
      C_S15_AXI_HIGHADDR         => C_HIGHADDR,
      C_S15_AXI_ADDR_WIDTH       => C_S15_AXI_ADDR_WIDTH,
      C_S15_AXI_DATA_WIDTH       => C_S15_AXI_DATA_WIDTH,
      C_S15_AXI_RRESP_WIDTH      => C_S15_AXI_RRESP_WIDTH,
      C_S15_AXI_ID_WIDTH         => C_S15_AXI_ID_WIDTH,
      C_S15_AXI_SUPPORT_UNIQUE   => C_S15_AXI_SUPPORT_UNIQUE,
      C_S15_AXI_SUPPORT_DIRTY    => C_S15_AXI_SUPPORT_DIRTY,
      C_S15_AXI_FORCE_READ_ALLOCATE     => C_S15_AXI_FORCE_READ_ALLOCATE,
      C_S15_AXI_PROHIBIT_READ_ALLOCATE  => C_S15_AXI_PROHIBIT_READ_ALLOCATE,
      C_S15_AXI_FORCE_WRITE_ALLOCATE    => C_S15_AXI_FORCE_WRITE_ALLOCATE,
      C_S15_AXI_PROHIBIT_WRITE_ALLOCATE => C_S15_AXI_PROHIBIT_WRITE_ALLOCATE,
      C_S15_AXI_FORCE_READ_BUFFER       => C_S15_AXI_FORCE_READ_BUFFER,
      C_S15_AXI_PROHIBIT_READ_BUFFER    => C_S15_AXI_PROHIBIT_READ_BUFFER,
      C_S15_AXI_FORCE_WRITE_BUFFER      => C_S15_AXI_FORCE_WRITE_BUFFER,
      C_S15_AXI_PROHIBIT_WRITE_BUFFER   => C_S15_AXI_PROHIBIT_WRITE_BUFFER,
      C_S15_AXI_PROHIBIT_EXCLUSIVE      => C_S15_AXI_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S0_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S0_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S0_AXI_GEN_ADDR_WIDTH   => C_S0_AXI_GEN_ADDR_WIDTH,
      C_S0_AXI_GEN_DATA_WIDTH   => C_S0_AXI_GEN_DATA_WIDTH,
      C_S0_AXI_GEN_ID_WIDTH     => C_S0_AXI_GEN_ID_WIDTH,
      C_S0_AXI_GEN_FORCE_READ_ALLOCATE      => C_S0_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S0_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S0_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S0_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S0_AXI_GEN_FORCE_READ_BUFFER        => C_S0_AXI_GEN_FORCE_READ_BUFFER,
      C_S0_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S0_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S0_AXI_GEN_FORCE_WRITE_BUFFER       => C_S0_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S0_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S0_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S1_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S1_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S1_AXI_GEN_ADDR_WIDTH   => C_S1_AXI_GEN_ADDR_WIDTH,
      C_S1_AXI_GEN_DATA_WIDTH   => C_S1_AXI_GEN_DATA_WIDTH,
      C_S1_AXI_GEN_ID_WIDTH     => C_S1_AXI_GEN_ID_WIDTH,
      C_S1_AXI_GEN_FORCE_READ_ALLOCATE      => C_S1_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S1_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S1_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S1_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S1_AXI_GEN_FORCE_READ_BUFFER        => C_S1_AXI_GEN_FORCE_READ_BUFFER,
      C_S1_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S1_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S1_AXI_GEN_FORCE_WRITE_BUFFER       => C_S1_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S1_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S1_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S2_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S2_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S2_AXI_GEN_ADDR_WIDTH   => C_S2_AXI_GEN_ADDR_WIDTH,
      C_S2_AXI_GEN_DATA_WIDTH   => C_S2_AXI_GEN_DATA_WIDTH,
      C_S2_AXI_GEN_ID_WIDTH     => C_S2_AXI_GEN_ID_WIDTH,
      C_S2_AXI_GEN_FORCE_READ_ALLOCATE      => C_S2_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S2_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S2_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S2_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S2_AXI_GEN_FORCE_READ_BUFFER        => C_S2_AXI_GEN_FORCE_READ_BUFFER,
      C_S2_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S2_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S2_AXI_GEN_FORCE_WRITE_BUFFER       => C_S2_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S2_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S2_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S3_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S3_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S3_AXI_GEN_ADDR_WIDTH   => C_S3_AXI_GEN_ADDR_WIDTH,
      C_S3_AXI_GEN_DATA_WIDTH   => C_S3_AXI_GEN_DATA_WIDTH,
      C_S3_AXI_GEN_ID_WIDTH     => C_S3_AXI_GEN_ID_WIDTH,
      C_S3_AXI_GEN_FORCE_READ_ALLOCATE      => C_S3_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S3_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S3_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S3_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S3_AXI_GEN_FORCE_READ_BUFFER        => C_S3_AXI_GEN_FORCE_READ_BUFFER,
      C_S3_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S3_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S3_AXI_GEN_FORCE_WRITE_BUFFER       => C_S3_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S3_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S3_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S4_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S4_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S4_AXI_GEN_ADDR_WIDTH   => C_S4_AXI_GEN_ADDR_WIDTH,
      C_S4_AXI_GEN_DATA_WIDTH   => C_S4_AXI_GEN_DATA_WIDTH,
      C_S4_AXI_GEN_ID_WIDTH     => C_S4_AXI_GEN_ID_WIDTH,
      C_S4_AXI_GEN_FORCE_READ_ALLOCATE      => C_S4_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S4_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S4_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S4_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S4_AXI_GEN_FORCE_READ_BUFFER        => C_S4_AXI_GEN_FORCE_READ_BUFFER,
      C_S4_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S4_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S4_AXI_GEN_FORCE_WRITE_BUFFER       => C_S4_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S4_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S4_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S5_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S5_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S5_AXI_GEN_ADDR_WIDTH   => C_S5_AXI_GEN_ADDR_WIDTH,
      C_S5_AXI_GEN_DATA_WIDTH   => C_S5_AXI_GEN_DATA_WIDTH,
      C_S5_AXI_GEN_ID_WIDTH     => C_S5_AXI_GEN_ID_WIDTH,
      C_S5_AXI_GEN_FORCE_READ_ALLOCATE      => C_S5_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S5_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S5_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S5_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S5_AXI_GEN_FORCE_READ_BUFFER        => C_S5_AXI_GEN_FORCE_READ_BUFFER,
      C_S5_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S5_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S5_AXI_GEN_FORCE_WRITE_BUFFER       => C_S5_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S5_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S5_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S6_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S6_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S6_AXI_GEN_ADDR_WIDTH   => C_S6_AXI_GEN_ADDR_WIDTH,
      C_S6_AXI_GEN_DATA_WIDTH   => C_S6_AXI_GEN_DATA_WIDTH,
      C_S6_AXI_GEN_ID_WIDTH     => C_S6_AXI_GEN_ID_WIDTH,
      C_S6_AXI_GEN_FORCE_READ_ALLOCATE      => C_S6_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S6_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S6_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S6_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S6_AXI_GEN_FORCE_READ_BUFFER        => C_S6_AXI_GEN_FORCE_READ_BUFFER,
      C_S6_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S6_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S6_AXI_GEN_FORCE_WRITE_BUFFER       => C_S6_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S6_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S6_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S7_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S7_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S7_AXI_GEN_ADDR_WIDTH   => C_S7_AXI_GEN_ADDR_WIDTH,
      C_S7_AXI_GEN_DATA_WIDTH   => C_S7_AXI_GEN_DATA_WIDTH,
      C_S7_AXI_GEN_ID_WIDTH     => C_S7_AXI_GEN_ID_WIDTH,
      C_S7_AXI_GEN_FORCE_READ_ALLOCATE      => C_S7_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S7_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S7_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S7_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S7_AXI_GEN_FORCE_READ_BUFFER        => C_S7_AXI_GEN_FORCE_READ_BUFFER,
      C_S7_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S7_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S7_AXI_GEN_FORCE_WRITE_BUFFER       => C_S7_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S7_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S7_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S8_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S8_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S8_AXI_GEN_ADDR_WIDTH   => C_S8_AXI_GEN_ADDR_WIDTH,
      C_S8_AXI_GEN_DATA_WIDTH   => C_S8_AXI_GEN_DATA_WIDTH,
      C_S8_AXI_GEN_ID_WIDTH     => C_S8_AXI_GEN_ID_WIDTH,
      C_S8_AXI_GEN_FORCE_READ_ALLOCATE      => C_S8_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S8_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S8_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S8_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S8_AXI_GEN_FORCE_READ_BUFFER        => C_S8_AXI_GEN_FORCE_READ_BUFFER,
      C_S8_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S8_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S8_AXI_GEN_FORCE_WRITE_BUFFER       => C_S8_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S8_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S8_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S9_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S9_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S9_AXI_GEN_ADDR_WIDTH   => C_S9_AXI_GEN_ADDR_WIDTH,
      C_S9_AXI_GEN_DATA_WIDTH   => C_S9_AXI_GEN_DATA_WIDTH,
      C_S9_AXI_GEN_ID_WIDTH     => C_S9_AXI_GEN_ID_WIDTH,
      C_S9_AXI_GEN_FORCE_READ_ALLOCATE      => C_S9_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S9_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S9_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S9_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S9_AXI_GEN_FORCE_READ_BUFFER        => C_S9_AXI_GEN_FORCE_READ_BUFFER,
      C_S9_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S9_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S9_AXI_GEN_FORCE_WRITE_BUFFER       => C_S9_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S9_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S9_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S10_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S10_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S10_AXI_GEN_ADDR_WIDTH   => C_S10_AXI_GEN_ADDR_WIDTH,
      C_S10_AXI_GEN_DATA_WIDTH   => C_S10_AXI_GEN_DATA_WIDTH,
      C_S10_AXI_GEN_ID_WIDTH     => C_S10_AXI_GEN_ID_WIDTH,
      C_S10_AXI_GEN_FORCE_READ_ALLOCATE      => C_S10_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S10_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S10_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S10_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S10_AXI_GEN_FORCE_READ_BUFFER        => C_S10_AXI_GEN_FORCE_READ_BUFFER,
      C_S10_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S10_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S10_AXI_GEN_FORCE_WRITE_BUFFER       => C_S10_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S10_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S10_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S11_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S11_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S11_AXI_GEN_ADDR_WIDTH   => C_S11_AXI_GEN_ADDR_WIDTH,
      C_S11_AXI_GEN_DATA_WIDTH   => C_S11_AXI_GEN_DATA_WIDTH,
      C_S11_AXI_GEN_ID_WIDTH     => C_S11_AXI_GEN_ID_WIDTH,
      C_S11_AXI_GEN_FORCE_READ_ALLOCATE      => C_S11_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S11_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S11_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S11_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S11_AXI_GEN_FORCE_READ_BUFFER        => C_S11_AXI_GEN_FORCE_READ_BUFFER,
      C_S11_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S11_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S11_AXI_GEN_FORCE_WRITE_BUFFER       => C_S11_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S11_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S11_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S12_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S12_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S12_AXI_GEN_ADDR_WIDTH   => C_S12_AXI_GEN_ADDR_WIDTH,
      C_S12_AXI_GEN_DATA_WIDTH   => C_S12_AXI_GEN_DATA_WIDTH,
      C_S12_AXI_GEN_ID_WIDTH     => C_S12_AXI_GEN_ID_WIDTH,
      C_S12_AXI_GEN_FORCE_READ_ALLOCATE      => C_S12_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S12_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S12_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S12_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S12_AXI_GEN_FORCE_READ_BUFFER        => C_S12_AXI_GEN_FORCE_READ_BUFFER,
      C_S12_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S12_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S12_AXI_GEN_FORCE_WRITE_BUFFER       => C_S12_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S12_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S12_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S13_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S13_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S13_AXI_GEN_ADDR_WIDTH   => C_S13_AXI_GEN_ADDR_WIDTH,
      C_S13_AXI_GEN_DATA_WIDTH   => C_S13_AXI_GEN_DATA_WIDTH,
      C_S13_AXI_GEN_ID_WIDTH     => C_S13_AXI_GEN_ID_WIDTH,
      C_S13_AXI_GEN_FORCE_READ_ALLOCATE      => C_S13_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S13_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S13_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S13_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S13_AXI_GEN_FORCE_READ_BUFFER        => C_S13_AXI_GEN_FORCE_READ_BUFFER,
      C_S13_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S13_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S13_AXI_GEN_FORCE_WRITE_BUFFER       => C_S13_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S13_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S13_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S14_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S14_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S14_AXI_GEN_ADDR_WIDTH   => C_S14_AXI_GEN_ADDR_WIDTH,
      C_S14_AXI_GEN_DATA_WIDTH   => C_S14_AXI_GEN_DATA_WIDTH,
      C_S14_AXI_GEN_ID_WIDTH     => C_S14_AXI_GEN_ID_WIDTH,
      C_S14_AXI_GEN_FORCE_READ_ALLOCATE      => C_S14_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S14_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S14_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S14_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S14_AXI_GEN_FORCE_READ_BUFFER        => C_S14_AXI_GEN_FORCE_READ_BUFFER,
      C_S14_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S14_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S14_AXI_GEN_FORCE_WRITE_BUFFER       => C_S14_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S14_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S14_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Generic AXI4 Slave Interface #0 specific.
      C_S15_AXI_GEN_BASEADDR     => C_BASEADDR,
      C_S15_AXI_GEN_HIGHADDR     => C_HIGHADDR,
      C_S15_AXI_GEN_ADDR_WIDTH   => C_S15_AXI_GEN_ADDR_WIDTH,
      C_S15_AXI_GEN_DATA_WIDTH   => C_S15_AXI_GEN_DATA_WIDTH,
      C_S15_AXI_GEN_ID_WIDTH     => C_S15_AXI_GEN_ID_WIDTH,
      C_S15_AXI_GEN_FORCE_READ_ALLOCATE      => C_S15_AXI_GEN_FORCE_READ_ALLOCATE,
      C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE   => C_S15_AXI_GEN_PROHIBIT_READ_ALLOCATE,
      C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE     => C_S15_AXI_GEN_FORCE_WRITE_ALLOCATE,
      C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE  => C_S15_AXI_GEN_PROHIBIT_WRITE_ALLOCATE,
      C_S15_AXI_GEN_FORCE_READ_BUFFER        => C_S15_AXI_GEN_FORCE_READ_BUFFER,
      C_S15_AXI_GEN_PROHIBIT_READ_BUFFER     => C_S15_AXI_GEN_PROHIBIT_READ_BUFFER,
      C_S15_AXI_GEN_FORCE_WRITE_BUFFER       => C_S15_AXI_GEN_FORCE_WRITE_BUFFER,
      C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER    => C_S15_AXI_GEN_PROHIBIT_WRITE_BUFFER,
      C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE       => C_S15_AXI_GEN_PROHIBIT_EXCLUSIVE,
      
      -- Data type and settings specific.
      C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_POS'high,
      C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_POS'low,
      C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
      C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
      C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
      C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      C_Lx_ADDR_REQ_HI          => C_Lx_ADDR_REQ_POS'high,
      C_Lx_ADDR_REQ_LO          => C_Lx_ADDR_REQ_POS'low,
      C_Lx_ADDR_DIRECT_HI       => C_Lx_ADDR_DIRECT_POS'high,
      C_Lx_ADDR_DIRECT_LO       => C_Lx_ADDR_DIRECT_POS'low,
      C_Lx_ADDR_DATA_HI         => C_Lx_ADDR_DATA_POS'high,
      C_Lx_ADDR_DATA_LO         => C_Lx_ADDR_DATA_POS'low,
      C_Lx_ADDR_TAG_HI          => C_Lx_ADDR_TAG_POS'high,
      C_Lx_ADDR_TAG_LO          => C_Lx_ADDR_TAG_POS'low,
      C_Lx_ADDR_LINE_HI         => C_Lx_ADDR_LINE_POS'high,
      C_Lx_ADDR_LINE_LO         => C_Lx_ADDR_LINE_POS'low,
      C_Lx_ADDR_OFFSET_HI       => C_Lx_ADDR_OFFSET_POS'high,
      C_Lx_ADDR_OFFSET_LO       => C_Lx_ADDR_OFFSET_POS'low,
      C_Lx_ADDR_WORD_HI         => C_Lx_ADDR_WORD_POS'high,
      C_Lx_ADDR_WORD_LO         => C_Lx_ADDR_WORD_POS'low,
      C_Lx_ADDR_BYTE_HI         => C_Lx_ADDR_BYTE_POS'high,
      C_Lx_ADDR_BYTE_LO         => C_Lx_ADDR_BYTE_POS'low,
      
      -- Lx Cache Specific.
      C_Lx_CACHE_DATA_WIDTH     => C_Lx_CACHE_DATA_WIDTH,
      C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      C_Lx_NUM_WAYS             => C_Lx_NUM_WAYS,
      C_Lx_NUM_ADDR_TAG_BITS    => C_Lx_NUM_ADDR_TAG_BITS,
      
      -- System Cache Specific.
      C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
      C_ID_WIDTH                => C_ID_WIDTH,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_ENABLE_CTRL             => C_ENABLE_CTRL,
      C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
      C_NUM_GENERIC_PORTS       => C_NUM_GENERIC_PORTS,
      C_NUM_PORTS               => C_NUM_PORTS,
      C_NUM_INTERNAL_PORTS      => C_NUM_INTERNAL_PORTS,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_DATA_ADDR_WIDTH   => C_CACHE_DATA_ADDR_WIDTH,
      C_M_AXI_DATA_WIDTH        => C_EXTERNAL_DATA_WIDTH,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
      C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
      C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
      C_ENABLE_EARLY_BRESP      => C_ENABLE_EARLY_BRESP,
      C_ENABLE_PEER_PORT_DATA   => C_ENABLE_PEER_PORT_DATA,
      C_KEEP_BUFFERABLE         => C_KEEP_BUFFERABLE,
      C_IGNORE_MODIFIABLE       => C_IGNORE_MODIFIABLE,
      C_GEN_MATCH_Lx_CACHE      => C_GEN_MATCH_Lx_CACHE
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      ACLK                      => ACLK,
      ARESET                    => ARESET,
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #0 Slave Signals.
      
      S0_AXI_AWID               => S0_AXI_AWID,
      S0_AXI_AWADDR             => S0_AXI_AWADDR,
      S0_AXI_AWLEN              => S0_AXI_AWLEN,
      S0_AXI_AWSIZE             => S0_AXI_AWSIZE,
      S0_AXI_AWBURST            => S0_AXI_AWBURST,
      S0_AXI_AWLOCK             => S0_AXI_AWLOCK,
      S0_AXI_AWCACHE            => S0_AXI_AWCACHE,
      S0_AXI_AWPROT             => S0_AXI_AWPROT,
      S0_AXI_AWQOS              => S0_AXI_AWQOS,
      S0_AXI_AWVALID            => S0_AXI_AWVALID,
      S0_AXI_AWREADY            => S0_AXI_AWREADY,
      S0_AXI_AWDOMAIN           => S0_AXI_AWDOMAIN,
      S0_AXI_AWSNOOP            => S0_AXI_AWSNOOP,
      S0_AXI_AWBAR              => S0_AXI_AWBAR,
      
      S0_AXI_WDATA              => S0_AXI_WDATA,
      S0_AXI_WSTRB              => S0_AXI_WSTRB,
      S0_AXI_WLAST              => S0_AXI_WLAST,
      S0_AXI_WVALID             => S0_AXI_WVALID,
      S0_AXI_WREADY             => S0_AXI_WREADY,
      
      S0_AXI_BRESP              => S0_AXI_BRESP,
      S0_AXI_BID                => S0_AXI_BID,
      S0_AXI_BVALID             => S0_AXI_BVALID,
      S0_AXI_BREADY             => S0_AXI_BREADY,
      S0_AXI_WACK               => S0_AXI_WACK,
      
      S0_AXI_ARID               => S0_AXI_ARID,
      S0_AXI_ARADDR             => S0_AXI_ARADDR,
      S0_AXI_ARLEN              => S0_AXI_ARLEN,
      S0_AXI_ARSIZE             => S0_AXI_ARSIZE,
      S0_AXI_ARBURST            => S0_AXI_ARBURST,
      S0_AXI_ARLOCK             => S0_AXI_ARLOCK,
      S0_AXI_ARCACHE            => S0_AXI_ARCACHE,
      S0_AXI_ARPROT             => S0_AXI_ARPROT,
      S0_AXI_ARQOS              => S0_AXI_ARQOS,
      S0_AXI_ARVALID            => S0_AXI_ARVALID,
      S0_AXI_ARREADY            => S0_AXI_ARREADY,
      S0_AXI_ARDOMAIN           => S0_AXI_ARDOMAIN,
      S0_AXI_ARSNOOP            => S0_AXI_ARSNOOP,
      S0_AXI_ARBAR              => S0_AXI_ARBAR,
      
      S0_AXI_RID                => S0_AXI_RID,
      S0_AXI_RDATA              => S0_AXI_RDATA,
      S0_AXI_RRESP              => S0_AXI_RRESP,
      S0_AXI_RLAST              => S0_AXI_RLAST,
      S0_AXI_RVALID             => S0_AXI_RVALID,
      S0_AXI_RREADY             => S0_AXI_RREADY,
      S0_AXI_RACK               => S0_AXI_RACK,
      
      S0_AXI_ACVALID            => S0_AXI_ACVALID,
      S0_AXI_ACADDR             => S0_AXI_ACADDR,
      S0_AXI_ACSNOOP            => S0_AXI_ACSNOOP,
      S0_AXI_ACPROT             => S0_AXI_ACPROT,
      S0_AXI_ACREADY            => S0_AXI_ACREADY,
      
      S0_AXI_CRVALID            => S0_AXI_CRVALID,
      S0_AXI_CRRESP             => S0_AXI_CRRESP,
      S0_AXI_CRREADY            => S0_AXI_CRREADY,
      
      S0_AXI_CDVALID            => S0_AXI_CDVALID,
      S0_AXI_CDDATA             => S0_AXI_CDDATA,
      S0_AXI_CDLAST             => S0_AXI_CDLAST,
      S0_AXI_CDREADY            => S0_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #1 Slave Signals.
      
      S1_AXI_AWID               => S1_AXI_AWID,
      S1_AXI_AWADDR             => S1_AXI_AWADDR,
      S1_AXI_AWLEN              => S1_AXI_AWLEN,
      S1_AXI_AWSIZE             => S1_AXI_AWSIZE,
      S1_AXI_AWBURST            => S1_AXI_AWBURST,
      S1_AXI_AWLOCK             => S1_AXI_AWLOCK,
      S1_AXI_AWCACHE            => S1_AXI_AWCACHE,
      S1_AXI_AWPROT             => S1_AXI_AWPROT,
      S1_AXI_AWQOS              => S1_AXI_AWQOS,
      S1_AXI_AWVALID            => S1_AXI_AWVALID,
      S1_AXI_AWREADY            => S1_AXI_AWREADY,
      S1_AXI_AWDOMAIN           => S1_AXI_AWDOMAIN,
      S1_AXI_AWSNOOP            => S1_AXI_AWSNOOP,
      S1_AXI_AWBAR              => S1_AXI_AWBAR,
      
      S1_AXI_WDATA              => S1_AXI_WDATA,
      S1_AXI_WSTRB              => S1_AXI_WSTRB,
      S1_AXI_WLAST              => S1_AXI_WLAST,
      S1_AXI_WVALID             => S1_AXI_WVALID,
      S1_AXI_WREADY             => S1_AXI_WREADY,
      
      S1_AXI_BRESP              => S1_AXI_BRESP,
      S1_AXI_BID                => S1_AXI_BID,
      S1_AXI_BVALID             => S1_AXI_BVALID,
      S1_AXI_BREADY             => S1_AXI_BREADY,
      S1_AXI_WACK               => S1_AXI_WACK,
      
      S1_AXI_ARID               => S1_AXI_ARID,
      S1_AXI_ARADDR             => S1_AXI_ARADDR,
      S1_AXI_ARLEN              => S1_AXI_ARLEN,
      S1_AXI_ARSIZE             => S1_AXI_ARSIZE,
      S1_AXI_ARBURST            => S1_AXI_ARBURST,
      S1_AXI_ARLOCK             => S1_AXI_ARLOCK,
      S1_AXI_ARCACHE            => S1_AXI_ARCACHE,
      S1_AXI_ARPROT             => S1_AXI_ARPROT,
      S1_AXI_ARQOS              => S1_AXI_ARQOS,
      S1_AXI_ARVALID            => S1_AXI_ARVALID,
      S1_AXI_ARREADY            => S1_AXI_ARREADY,
      S1_AXI_ARDOMAIN           => S1_AXI_ARDOMAIN,
      S1_AXI_ARSNOOP            => S1_AXI_ARSNOOP,
      S1_AXI_ARBAR              => S1_AXI_ARBAR,
      
      S1_AXI_RID                => S1_AXI_RID,
      S1_AXI_RDATA              => S1_AXI_RDATA,
      S1_AXI_RRESP              => S1_AXI_RRESP,
      S1_AXI_RLAST              => S1_AXI_RLAST,
      S1_AXI_RVALID             => S1_AXI_RVALID,
      S1_AXI_RREADY             => S1_AXI_RREADY,
      S1_AXI_RACK               => S1_AXI_RACK,
      
      S1_AXI_ACVALID            => S1_AXI_ACVALID,
      S1_AXI_ACADDR             => S1_AXI_ACADDR,
      S1_AXI_ACSNOOP            => S1_AXI_ACSNOOP,
      S1_AXI_ACPROT             => S1_AXI_ACPROT,
      S1_AXI_ACREADY            => S1_AXI_ACREADY,
      
      S1_AXI_CRVALID            => S1_AXI_CRVALID,
      S1_AXI_CRRESP             => S1_AXI_CRRESP,
      S1_AXI_CRREADY            => S1_AXI_CRREADY,
      
      S1_AXI_CDVALID            => S1_AXI_CDVALID,
      S1_AXI_CDDATA             => S1_AXI_CDDATA,
      S1_AXI_CDLAST             => S1_AXI_CDLAST,
      S1_AXI_CDREADY            => S1_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #2 Slave Signals.
      
      S2_AXI_AWID               => S2_AXI_AWID,
      S2_AXI_AWADDR             => S2_AXI_AWADDR,
      S2_AXI_AWLEN              => S2_AXI_AWLEN,
      S2_AXI_AWSIZE             => S2_AXI_AWSIZE,
      S2_AXI_AWBURST            => S2_AXI_AWBURST,
      S2_AXI_AWLOCK             => S2_AXI_AWLOCK,
      S2_AXI_AWCACHE            => S2_AXI_AWCACHE,
      S2_AXI_AWPROT             => S2_AXI_AWPROT,
      S2_AXI_AWQOS              => S2_AXI_AWQOS,
      S2_AXI_AWVALID            => S2_AXI_AWVALID,
      S2_AXI_AWREADY            => S2_AXI_AWREADY,
      S2_AXI_AWDOMAIN           => S2_AXI_AWDOMAIN,
      S2_AXI_AWSNOOP            => S2_AXI_AWSNOOP,
      S2_AXI_AWBAR              => S2_AXI_AWBAR,
      
      S2_AXI_WDATA              => S2_AXI_WDATA,
      S2_AXI_WSTRB              => S2_AXI_WSTRB,
      S2_AXI_WLAST              => S2_AXI_WLAST,
      S2_AXI_WVALID             => S2_AXI_WVALID,
      S2_AXI_WREADY             => S2_AXI_WREADY,
      
      S2_AXI_BRESP              => S2_AXI_BRESP,
      S2_AXI_BID                => S2_AXI_BID,
      S2_AXI_BVALID             => S2_AXI_BVALID,
      S2_AXI_BREADY             => S2_AXI_BREADY,
      S2_AXI_WACK               => S2_AXI_WACK,
      
      S2_AXI_ARID               => S2_AXI_ARID,
      S2_AXI_ARADDR             => S2_AXI_ARADDR,
      S2_AXI_ARLEN              => S2_AXI_ARLEN,
      S2_AXI_ARSIZE             => S2_AXI_ARSIZE,
      S2_AXI_ARBURST            => S2_AXI_ARBURST,
      S2_AXI_ARLOCK             => S2_AXI_ARLOCK,
      S2_AXI_ARCACHE            => S2_AXI_ARCACHE,
      S2_AXI_ARPROT             => S2_AXI_ARPROT,
      S2_AXI_ARQOS              => S2_AXI_ARQOS,
      S2_AXI_ARVALID            => S2_AXI_ARVALID,
      S2_AXI_ARREADY            => S2_AXI_ARREADY,
      S2_AXI_ARDOMAIN           => S2_AXI_ARDOMAIN,
      S2_AXI_ARSNOOP            => S2_AXI_ARSNOOP,
      S2_AXI_ARBAR              => S2_AXI_ARBAR,
      
      S2_AXI_RID                => S2_AXI_RID,
      S2_AXI_RDATA              => S2_AXI_RDATA,
      S2_AXI_RRESP              => S2_AXI_RRESP,
      S2_AXI_RLAST              => S2_AXI_RLAST,
      S2_AXI_RVALID             => S2_AXI_RVALID,
      S2_AXI_RREADY             => S2_AXI_RREADY,
      S2_AXI_RACK               => S2_AXI_RACK,
      
      S2_AXI_ACVALID            => S2_AXI_ACVALID,
      S2_AXI_ACADDR             => S2_AXI_ACADDR,
      S2_AXI_ACSNOOP            => S2_AXI_ACSNOOP,
      S2_AXI_ACPROT             => S2_AXI_ACPROT,
      S2_AXI_ACREADY            => S2_AXI_ACREADY,
      
      S2_AXI_CRVALID            => S2_AXI_CRVALID,
      S2_AXI_CRRESP             => S2_AXI_CRRESP,
      S2_AXI_CRREADY            => S2_AXI_CRREADY,
      
      S2_AXI_CDVALID            => S2_AXI_CDVALID,
      S2_AXI_CDDATA             => S2_AXI_CDDATA,
      S2_AXI_CDLAST             => S2_AXI_CDLAST,
      S2_AXI_CDREADY            => S2_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #3 Slave Signals.
      
      S3_AXI_AWID               => S3_AXI_AWID,
      S3_AXI_AWADDR             => S3_AXI_AWADDR,
      S3_AXI_AWLEN              => S3_AXI_AWLEN,
      S3_AXI_AWSIZE             => S3_AXI_AWSIZE,
      S3_AXI_AWBURST            => S3_AXI_AWBURST,
      S3_AXI_AWLOCK             => S3_AXI_AWLOCK,
      S3_AXI_AWCACHE            => S3_AXI_AWCACHE,
      S3_AXI_AWPROT             => S3_AXI_AWPROT,
      S3_AXI_AWQOS              => S3_AXI_AWQOS,
      S3_AXI_AWVALID            => S3_AXI_AWVALID,
      S3_AXI_AWREADY            => S3_AXI_AWREADY,
      S3_AXI_AWDOMAIN           => S3_AXI_AWDOMAIN,
      S3_AXI_AWSNOOP            => S3_AXI_AWSNOOP,
      S3_AXI_AWBAR              => S3_AXI_AWBAR,
      
      S3_AXI_WDATA              => S3_AXI_WDATA,
      S3_AXI_WSTRB              => S3_AXI_WSTRB,
      S3_AXI_WLAST              => S3_AXI_WLAST,
      S3_AXI_WVALID             => S3_AXI_WVALID,
      S3_AXI_WREADY             => S3_AXI_WREADY,
      
      S3_AXI_BRESP              => S3_AXI_BRESP,
      S3_AXI_BID                => S3_AXI_BID,
      S3_AXI_BVALID             => S3_AXI_BVALID,
      S3_AXI_BREADY             => S3_AXI_BREADY,
      S3_AXI_WACK               => S3_AXI_WACK,
      
      S3_AXI_ARID               => S3_AXI_ARID,
      S3_AXI_ARADDR             => S3_AXI_ARADDR,
      S3_AXI_ARLEN              => S3_AXI_ARLEN,
      S3_AXI_ARSIZE             => S3_AXI_ARSIZE,
      S3_AXI_ARBURST            => S3_AXI_ARBURST,
      S3_AXI_ARLOCK             => S3_AXI_ARLOCK,
      S3_AXI_ARCACHE            => S3_AXI_ARCACHE,
      S3_AXI_ARPROT             => S3_AXI_ARPROT,
      S3_AXI_ARQOS              => S3_AXI_ARQOS,
      S3_AXI_ARVALID            => S3_AXI_ARVALID,
      S3_AXI_ARREADY            => S3_AXI_ARREADY,
      S3_AXI_ARDOMAIN           => S3_AXI_ARDOMAIN,
      S3_AXI_ARSNOOP            => S3_AXI_ARSNOOP,
      S3_AXI_ARBAR              => S3_AXI_ARBAR,
      
      S3_AXI_RID                => S3_AXI_RID,
      S3_AXI_RDATA              => S3_AXI_RDATA,
      S3_AXI_RRESP              => S3_AXI_RRESP,
      S3_AXI_RLAST              => S3_AXI_RLAST,
      S3_AXI_RVALID             => S3_AXI_RVALID,
      S3_AXI_RREADY             => S3_AXI_RREADY,
      S3_AXI_RACK               => S3_AXI_RACK,
      
      S3_AXI_ACVALID            => S3_AXI_ACVALID,
      S3_AXI_ACADDR             => S3_AXI_ACADDR,
      S3_AXI_ACSNOOP            => S3_AXI_ACSNOOP,
      S3_AXI_ACPROT             => S3_AXI_ACPROT,
      S3_AXI_ACREADY            => S3_AXI_ACREADY,
      
      S3_AXI_CRVALID            => S3_AXI_CRVALID,
      S3_AXI_CRRESP             => S3_AXI_CRRESP,
      S3_AXI_CRREADY            => S3_AXI_CRREADY,
      
      S3_AXI_CDVALID            => S3_AXI_CDVALID,
      S3_AXI_CDDATA             => S3_AXI_CDDATA,
      S3_AXI_CDLAST             => S3_AXI_CDLAST,
      S3_AXI_CDREADY            => S3_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #4 Slave Signals.
      
      S4_AXI_AWID               => S4_AXI_AWID,
      S4_AXI_AWADDR             => S4_AXI_AWADDR,
      S4_AXI_AWLEN              => S4_AXI_AWLEN,
      S4_AXI_AWSIZE             => S4_AXI_AWSIZE,
      S4_AXI_AWBURST            => S4_AXI_AWBURST,
      S4_AXI_AWLOCK             => S4_AXI_AWLOCK,
      S4_AXI_AWCACHE            => S4_AXI_AWCACHE,
      S4_AXI_AWPROT             => S4_AXI_AWPROT,
      S4_AXI_AWQOS              => S4_AXI_AWQOS,
      S4_AXI_AWVALID            => S4_AXI_AWVALID,
      S4_AXI_AWREADY            => S4_AXI_AWREADY,
      S4_AXI_AWDOMAIN           => S4_AXI_AWDOMAIN,
      S4_AXI_AWSNOOP            => S4_AXI_AWSNOOP,
      S4_AXI_AWBAR              => S4_AXI_AWBAR,
      
      S4_AXI_WDATA              => S4_AXI_WDATA,
      S4_AXI_WSTRB              => S4_AXI_WSTRB,
      S4_AXI_WLAST              => S4_AXI_WLAST,
      S4_AXI_WVALID             => S4_AXI_WVALID,
      S4_AXI_WREADY             => S4_AXI_WREADY,
      
      S4_AXI_BRESP              => S4_AXI_BRESP,
      S4_AXI_BID                => S4_AXI_BID,
      S4_AXI_BVALID             => S4_AXI_BVALID,
      S4_AXI_BREADY             => S4_AXI_BREADY,
      S4_AXI_WACK               => S4_AXI_WACK,
      
      S4_AXI_ARID               => S4_AXI_ARID,
      S4_AXI_ARADDR             => S4_AXI_ARADDR,
      S4_AXI_ARLEN              => S4_AXI_ARLEN,
      S4_AXI_ARSIZE             => S4_AXI_ARSIZE,
      S4_AXI_ARBURST            => S4_AXI_ARBURST,
      S4_AXI_ARLOCK             => S4_AXI_ARLOCK,
      S4_AXI_ARCACHE            => S4_AXI_ARCACHE,
      S4_AXI_ARPROT             => S4_AXI_ARPROT,
      S4_AXI_ARQOS              => S4_AXI_ARQOS,
      S4_AXI_ARVALID            => S4_AXI_ARVALID,
      S4_AXI_ARREADY            => S4_AXI_ARREADY,
      S4_AXI_ARDOMAIN           => S4_AXI_ARDOMAIN,
      S4_AXI_ARSNOOP            => S4_AXI_ARSNOOP,
      S4_AXI_ARBAR              => S4_AXI_ARBAR,
      
      S4_AXI_RID                => S4_AXI_RID,
      S4_AXI_RDATA              => S4_AXI_RDATA,
      S4_AXI_RRESP              => S4_AXI_RRESP,
      S4_AXI_RLAST              => S4_AXI_RLAST,
      S4_AXI_RVALID             => S4_AXI_RVALID,
      S4_AXI_RREADY             => S4_AXI_RREADY,
      S4_AXI_RACK               => S4_AXI_RACK,
      
      S4_AXI_ACVALID            => S4_AXI_ACVALID,
      S4_AXI_ACADDR             => S4_AXI_ACADDR,
      S4_AXI_ACSNOOP            => S4_AXI_ACSNOOP,
      S4_AXI_ACPROT             => S4_AXI_ACPROT,
      S4_AXI_ACREADY            => S4_AXI_ACREADY,
      
      S4_AXI_CRVALID            => S4_AXI_CRVALID,
      S4_AXI_CRRESP             => S4_AXI_CRRESP,
      S4_AXI_CRREADY            => S4_AXI_CRREADY,
      
      S4_AXI_CDVALID            => S4_AXI_CDVALID,
      S4_AXI_CDDATA             => S4_AXI_CDDATA,
      S4_AXI_CDLAST             => S4_AXI_CDLAST,
      S4_AXI_CDREADY            => S4_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #5 Slave Signals.
      
      S5_AXI_AWID               => S5_AXI_AWID,
      S5_AXI_AWADDR             => S5_AXI_AWADDR,
      S5_AXI_AWLEN              => S5_AXI_AWLEN,
      S5_AXI_AWSIZE             => S5_AXI_AWSIZE,
      S5_AXI_AWBURST            => S5_AXI_AWBURST,
      S5_AXI_AWLOCK             => S5_AXI_AWLOCK,
      S5_AXI_AWCACHE            => S5_AXI_AWCACHE,
      S5_AXI_AWPROT             => S5_AXI_AWPROT,
      S5_AXI_AWQOS              => S5_AXI_AWQOS,
      S5_AXI_AWVALID            => S5_AXI_AWVALID,
      S5_AXI_AWREADY            => S5_AXI_AWREADY,
      S5_AXI_AWDOMAIN           => S5_AXI_AWDOMAIN,
      S5_AXI_AWSNOOP            => S5_AXI_AWSNOOP,
      S5_AXI_AWBAR              => S5_AXI_AWBAR,
      
      S5_AXI_WDATA              => S5_AXI_WDATA,
      S5_AXI_WSTRB              => S5_AXI_WSTRB,
      S5_AXI_WLAST              => S5_AXI_WLAST,
      S5_AXI_WVALID             => S5_AXI_WVALID,
      S5_AXI_WREADY             => S5_AXI_WREADY,
      
      S5_AXI_BRESP              => S5_AXI_BRESP,
      S5_AXI_BID                => S5_AXI_BID,
      S5_AXI_BVALID             => S5_AXI_BVALID,
      S5_AXI_BREADY             => S5_AXI_BREADY,
      S5_AXI_WACK               => S5_AXI_WACK,
      
      S5_AXI_ARID               => S5_AXI_ARID,
      S5_AXI_ARADDR             => S5_AXI_ARADDR,
      S5_AXI_ARLEN              => S5_AXI_ARLEN,
      S5_AXI_ARSIZE             => S5_AXI_ARSIZE,
      S5_AXI_ARBURST            => S5_AXI_ARBURST,
      S5_AXI_ARLOCK             => S5_AXI_ARLOCK,
      S5_AXI_ARCACHE            => S5_AXI_ARCACHE,
      S5_AXI_ARPROT             => S5_AXI_ARPROT,
      S5_AXI_ARQOS              => S5_AXI_ARQOS,
      S5_AXI_ARVALID            => S5_AXI_ARVALID,
      S5_AXI_ARREADY            => S5_AXI_ARREADY,
      S5_AXI_ARDOMAIN           => S5_AXI_ARDOMAIN,
      S5_AXI_ARSNOOP            => S5_AXI_ARSNOOP,
      S5_AXI_ARBAR              => S5_AXI_ARBAR,
      
      S5_AXI_RID                => S5_AXI_RID,
      S5_AXI_RDATA              => S5_AXI_RDATA,
      S5_AXI_RRESP              => S5_AXI_RRESP,
      S5_AXI_RLAST              => S5_AXI_RLAST,
      S5_AXI_RVALID             => S5_AXI_RVALID,
      S5_AXI_RREADY             => S5_AXI_RREADY,
      S5_AXI_RACK               => S5_AXI_RACK,
      
      S5_AXI_ACVALID            => S5_AXI_ACVALID,
      S5_AXI_ACADDR             => S5_AXI_ACADDR,
      S5_AXI_ACSNOOP            => S5_AXI_ACSNOOP,
      S5_AXI_ACPROT             => S5_AXI_ACPROT,
      S5_AXI_ACREADY            => S5_AXI_ACREADY,
      
      S5_AXI_CRVALID            => S5_AXI_CRVALID,
      S5_AXI_CRRESP             => S5_AXI_CRRESP,
      S5_AXI_CRREADY            => S5_AXI_CRREADY,
      
      S5_AXI_CDVALID            => S5_AXI_CDVALID,
      S5_AXI_CDDATA             => S5_AXI_CDDATA,
      S5_AXI_CDLAST             => S5_AXI_CDLAST,
      S5_AXI_CDREADY            => S5_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #6 Slave Signals.
      
      S6_AXI_AWID               => S6_AXI_AWID,
      S6_AXI_AWADDR             => S6_AXI_AWADDR,
      S6_AXI_AWLEN              => S6_AXI_AWLEN,
      S6_AXI_AWSIZE             => S6_AXI_AWSIZE,
      S6_AXI_AWBURST            => S6_AXI_AWBURST,
      S6_AXI_AWLOCK             => S6_AXI_AWLOCK,
      S6_AXI_AWCACHE            => S6_AXI_AWCACHE,
      S6_AXI_AWPROT             => S6_AXI_AWPROT,
      S6_AXI_AWQOS              => S6_AXI_AWQOS,
      S6_AXI_AWVALID            => S6_AXI_AWVALID,
      S6_AXI_AWREADY            => S6_AXI_AWREADY,
      S6_AXI_AWDOMAIN           => S6_AXI_AWDOMAIN,
      S6_AXI_AWSNOOP            => S6_AXI_AWSNOOP,
      S6_AXI_AWBAR              => S6_AXI_AWBAR,
      
      S6_AXI_WDATA              => S6_AXI_WDATA,
      S6_AXI_WSTRB              => S6_AXI_WSTRB,
      S6_AXI_WLAST              => S6_AXI_WLAST,
      S6_AXI_WVALID             => S6_AXI_WVALID,
      S6_AXI_WREADY             => S6_AXI_WREADY,
      
      S6_AXI_BRESP              => S6_AXI_BRESP,
      S6_AXI_BID                => S6_AXI_BID,
      S6_AXI_BVALID             => S6_AXI_BVALID,
      S6_AXI_BREADY             => S6_AXI_BREADY,
      S6_AXI_WACK               => S6_AXI_WACK,
      
      S6_AXI_ARID               => S6_AXI_ARID,
      S6_AXI_ARADDR             => S6_AXI_ARADDR,
      S6_AXI_ARLEN              => S6_AXI_ARLEN,
      S6_AXI_ARSIZE             => S6_AXI_ARSIZE,
      S6_AXI_ARBURST            => S6_AXI_ARBURST,
      S6_AXI_ARLOCK             => S6_AXI_ARLOCK,
      S6_AXI_ARCACHE            => S6_AXI_ARCACHE,
      S6_AXI_ARPROT             => S6_AXI_ARPROT,
      S6_AXI_ARQOS              => S6_AXI_ARQOS,
      S6_AXI_ARVALID            => S6_AXI_ARVALID,
      S6_AXI_ARREADY            => S6_AXI_ARREADY,
      S6_AXI_ARDOMAIN           => S6_AXI_ARDOMAIN,
      S6_AXI_ARSNOOP            => S6_AXI_ARSNOOP,
      S6_AXI_ARBAR              => S6_AXI_ARBAR,
      
      S6_AXI_RID                => S6_AXI_RID,
      S6_AXI_RDATA              => S6_AXI_RDATA,
      S6_AXI_RRESP              => S6_AXI_RRESP,
      S6_AXI_RLAST              => S6_AXI_RLAST,
      S6_AXI_RVALID             => S6_AXI_RVALID,
      S6_AXI_RREADY             => S6_AXI_RREADY,
      S6_AXI_RACK               => S6_AXI_RACK,
      
      S6_AXI_ACVALID            => S6_AXI_ACVALID,
      S6_AXI_ACADDR             => S6_AXI_ACADDR,
      S6_AXI_ACSNOOP            => S6_AXI_ACSNOOP,
      S6_AXI_ACPROT             => S6_AXI_ACPROT,
      S6_AXI_ACREADY            => S6_AXI_ACREADY,
      
      S6_AXI_CRVALID            => S6_AXI_CRVALID,
      S6_AXI_CRRESP             => S6_AXI_CRRESP,
      S6_AXI_CRREADY            => S6_AXI_CRREADY,
      
      S6_AXI_CDVALID            => S6_AXI_CDVALID,
      S6_AXI_CDDATA             => S6_AXI_CDDATA,
      S6_AXI_CDLAST             => S6_AXI_CDLAST,
      S6_AXI_CDREADY            => S6_AXI_CDREADY,
      
  
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #7 Slave Signals.
      
      S7_AXI_AWID               => S7_AXI_AWID,
      S7_AXI_AWADDR             => S7_AXI_AWADDR,
      S7_AXI_AWLEN              => S7_AXI_AWLEN,
      S7_AXI_AWSIZE             => S7_AXI_AWSIZE,
      S7_AXI_AWBURST            => S7_AXI_AWBURST,
      S7_AXI_AWLOCK             => S7_AXI_AWLOCK,
      S7_AXI_AWCACHE            => S7_AXI_AWCACHE,
      S7_AXI_AWPROT             => S7_AXI_AWPROT,
      S7_AXI_AWQOS              => S7_AXI_AWQOS,
      S7_AXI_AWVALID            => S7_AXI_AWVALID,
      S7_AXI_AWREADY            => S7_AXI_AWREADY,
      S7_AXI_AWDOMAIN           => S7_AXI_AWDOMAIN,
      S7_AXI_AWSNOOP            => S7_AXI_AWSNOOP,
      S7_AXI_AWBAR              => S7_AXI_AWBAR,
      
      S7_AXI_WDATA              => S7_AXI_WDATA,
      S7_AXI_WSTRB              => S7_AXI_WSTRB,
      S7_AXI_WLAST              => S7_AXI_WLAST,
      S7_AXI_WVALID             => S7_AXI_WVALID,
      S7_AXI_WREADY             => S7_AXI_WREADY,
      
      S7_AXI_BRESP              => S7_AXI_BRESP,
      S7_AXI_BID                => S7_AXI_BID,
      S7_AXI_BVALID             => S7_AXI_BVALID,
      S7_AXI_BREADY             => S7_AXI_BREADY,
      S7_AXI_WACK               => S7_AXI_WACK,
      
      S7_AXI_ARID               => S7_AXI_ARID,
      S7_AXI_ARADDR             => S7_AXI_ARADDR,
      S7_AXI_ARLEN              => S7_AXI_ARLEN,
      S7_AXI_ARSIZE             => S7_AXI_ARSIZE,
      S7_AXI_ARBURST            => S7_AXI_ARBURST,
      S7_AXI_ARLOCK             => S7_AXI_ARLOCK,
      S7_AXI_ARCACHE            => S7_AXI_ARCACHE,
      S7_AXI_ARPROT             => S7_AXI_ARPROT,
      S7_AXI_ARQOS              => S7_AXI_ARQOS,
      S7_AXI_ARVALID            => S7_AXI_ARVALID,
      S7_AXI_ARREADY            => S7_AXI_ARREADY,
      S7_AXI_ARDOMAIN           => S7_AXI_ARDOMAIN,
      S7_AXI_ARSNOOP            => S7_AXI_ARSNOOP,
      S7_AXI_ARBAR              => S7_AXI_ARBAR,
      
      S7_AXI_RID                => S7_AXI_RID,
      S7_AXI_RDATA              => S7_AXI_RDATA,
      S7_AXI_RRESP              => S7_AXI_RRESP,
      S7_AXI_RLAST              => S7_AXI_RLAST,
      S7_AXI_RVALID             => S7_AXI_RVALID,
      S7_AXI_RREADY             => S7_AXI_RREADY,
      S7_AXI_RACK               => S7_AXI_RACK,
      
      S7_AXI_ACVALID            => S7_AXI_ACVALID,
      S7_AXI_ACADDR             => S7_AXI_ACADDR,
      S7_AXI_ACSNOOP            => S7_AXI_ACSNOOP,
      S7_AXI_ACPROT             => S7_AXI_ACPROT,
      S7_AXI_ACREADY            => S7_AXI_ACREADY,
      
      S7_AXI_CRVALID            => S7_AXI_CRVALID,
      S7_AXI_CRRESP             => S7_AXI_CRRESP,
      S7_AXI_CRREADY            => S7_AXI_CRREADY,
      
      S7_AXI_CDVALID            => S7_AXI_CDVALID,
      S7_AXI_CDDATA             => S7_AXI_CDDATA,
      S7_AXI_CDLAST             => S7_AXI_CDLAST,
      S7_AXI_CDREADY            => S7_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #8 Slave Signals.
      
      S8_AXI_AWID               => S8_AXI_AWID,
      S8_AXI_AWADDR             => S8_AXI_AWADDR,
      S8_AXI_AWLEN              => S8_AXI_AWLEN,
      S8_AXI_AWSIZE             => S8_AXI_AWSIZE,
      S8_AXI_AWBURST            => S8_AXI_AWBURST,
      S8_AXI_AWLOCK             => S8_AXI_AWLOCK,
      S8_AXI_AWCACHE            => S8_AXI_AWCACHE,
      S8_AXI_AWPROT             => S8_AXI_AWPROT,
      S8_AXI_AWQOS              => S8_AXI_AWQOS,
      S8_AXI_AWVALID            => S8_AXI_AWVALID,
      S8_AXI_AWREADY            => S8_AXI_AWREADY,
      S8_AXI_AWDOMAIN           => S8_AXI_AWDOMAIN,
      S8_AXI_AWSNOOP            => S8_AXI_AWSNOOP,
      S8_AXI_AWBAR              => S8_AXI_AWBAR,
      
      S8_AXI_WDATA              => S8_AXI_WDATA,
      S8_AXI_WSTRB              => S8_AXI_WSTRB,
      S8_AXI_WLAST              => S8_AXI_WLAST,
      S8_AXI_WVALID             => S8_AXI_WVALID,
      S8_AXI_WREADY             => S8_AXI_WREADY,
      
      S8_AXI_BRESP              => S8_AXI_BRESP,
      S8_AXI_BID                => S8_AXI_BID,
      S8_AXI_BVALID             => S8_AXI_BVALID,
      S8_AXI_BREADY             => S8_AXI_BREADY,
      S8_AXI_WACK               => S8_AXI_WACK,
      
      S8_AXI_ARID               => S8_AXI_ARID,
      S8_AXI_ARADDR             => S8_AXI_ARADDR,
      S8_AXI_ARLEN              => S8_AXI_ARLEN,
      S8_AXI_ARSIZE             => S8_AXI_ARSIZE,
      S8_AXI_ARBURST            => S8_AXI_ARBURST,
      S8_AXI_ARLOCK             => S8_AXI_ARLOCK,
      S8_AXI_ARCACHE            => S8_AXI_ARCACHE,
      S8_AXI_ARPROT             => S8_AXI_ARPROT,
      S8_AXI_ARQOS              => S8_AXI_ARQOS,
      S8_AXI_ARVALID            => S8_AXI_ARVALID,
      S8_AXI_ARREADY            => S8_AXI_ARREADY,
      S8_AXI_ARDOMAIN           => S8_AXI_ARDOMAIN,
      S8_AXI_ARSNOOP            => S8_AXI_ARSNOOP,
      S8_AXI_ARBAR              => S8_AXI_ARBAR,
      
      S8_AXI_RID                => S8_AXI_RID,
      S8_AXI_RDATA              => S8_AXI_RDATA,
      S8_AXI_RRESP              => S8_AXI_RRESP,
      S8_AXI_RLAST              => S8_AXI_RLAST,
      S8_AXI_RVALID             => S8_AXI_RVALID,
      S8_AXI_RREADY             => S8_AXI_RREADY,
      S8_AXI_RACK               => S8_AXI_RACK,
      
      S8_AXI_ACVALID            => S8_AXI_ACVALID,
      S8_AXI_ACADDR             => S8_AXI_ACADDR,
      S8_AXI_ACSNOOP            => S8_AXI_ACSNOOP,
      S8_AXI_ACPROT             => S8_AXI_ACPROT,
      S8_AXI_ACREADY            => S8_AXI_ACREADY,
      
      S8_AXI_CRVALID            => S8_AXI_CRVALID,
      S8_AXI_CRRESP             => S8_AXI_CRRESP,
      S8_AXI_CRREADY            => S8_AXI_CRREADY,
      
      S8_AXI_CDVALID            => S8_AXI_CDVALID,
      S8_AXI_CDDATA             => S8_AXI_CDDATA,
      S8_AXI_CDLAST             => S8_AXI_CDLAST,
      S8_AXI_CDREADY            => S8_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #9 Slave Signals.
      
      S9_AXI_AWID               => S9_AXI_AWID,
      S9_AXI_AWADDR             => S9_AXI_AWADDR,
      S9_AXI_AWLEN              => S9_AXI_AWLEN,
      S9_AXI_AWSIZE             => S9_AXI_AWSIZE,
      S9_AXI_AWBURST            => S9_AXI_AWBURST,
      S9_AXI_AWLOCK             => S9_AXI_AWLOCK,
      S9_AXI_AWCACHE            => S9_AXI_AWCACHE,
      S9_AXI_AWPROT             => S9_AXI_AWPROT,
      S9_AXI_AWQOS              => S9_AXI_AWQOS,
      S9_AXI_AWVALID            => S9_AXI_AWVALID,
      S9_AXI_AWREADY            => S9_AXI_AWREADY,
      S9_AXI_AWDOMAIN           => S9_AXI_AWDOMAIN,
      S9_AXI_AWSNOOP            => S9_AXI_AWSNOOP,
      S9_AXI_AWBAR              => S9_AXI_AWBAR,
      
      S9_AXI_WDATA              => S9_AXI_WDATA,
      S9_AXI_WSTRB              => S9_AXI_WSTRB,
      S9_AXI_WLAST              => S9_AXI_WLAST,
      S9_AXI_WVALID             => S9_AXI_WVALID,
      S9_AXI_WREADY             => S9_AXI_WREADY,
      
      S9_AXI_BRESP              => S9_AXI_BRESP,
      S9_AXI_BID                => S9_AXI_BID,
      S9_AXI_BVALID             => S9_AXI_BVALID,
      S9_AXI_BREADY             => S9_AXI_BREADY,
      S9_AXI_WACK               => S9_AXI_WACK,
      
      S9_AXI_ARID               => S9_AXI_ARID,
      S9_AXI_ARADDR             => S9_AXI_ARADDR,
      S9_AXI_ARLEN              => S9_AXI_ARLEN,
      S9_AXI_ARSIZE             => S9_AXI_ARSIZE,
      S9_AXI_ARBURST            => S9_AXI_ARBURST,
      S9_AXI_ARLOCK             => S9_AXI_ARLOCK,
      S9_AXI_ARCACHE            => S9_AXI_ARCACHE,
      S9_AXI_ARPROT             => S9_AXI_ARPROT,
      S9_AXI_ARQOS              => S9_AXI_ARQOS,
      S9_AXI_ARVALID            => S9_AXI_ARVALID,
      S9_AXI_ARREADY            => S9_AXI_ARREADY,
      S9_AXI_ARDOMAIN           => S9_AXI_ARDOMAIN,
      S9_AXI_ARSNOOP            => S9_AXI_ARSNOOP,
      S9_AXI_ARBAR              => S9_AXI_ARBAR,
      
      S9_AXI_RID                => S9_AXI_RID,
      S9_AXI_RDATA              => S9_AXI_RDATA,
      S9_AXI_RRESP              => S9_AXI_RRESP,
      S9_AXI_RLAST              => S9_AXI_RLAST,
      S9_AXI_RVALID             => S9_AXI_RVALID,
      S9_AXI_RREADY             => S9_AXI_RREADY,
      S9_AXI_RACK               => S9_AXI_RACK,
      
      S9_AXI_ACVALID            => S9_AXI_ACVALID,
      S9_AXI_ACADDR             => S9_AXI_ACADDR,
      S9_AXI_ACSNOOP            => S9_AXI_ACSNOOP,
      S9_AXI_ACPROT             => S9_AXI_ACPROT,
      S9_AXI_ACREADY            => S9_AXI_ACREADY,
      
      S9_AXI_CRVALID            => S9_AXI_CRVALID,
      S9_AXI_CRRESP             => S9_AXI_CRRESP,
      S9_AXI_CRREADY            => S9_AXI_CRREADY,
      
      S9_AXI_CDVALID            => S9_AXI_CDVALID,
      S9_AXI_CDDATA             => S9_AXI_CDDATA,
      S9_AXI_CDLAST             => S9_AXI_CDLAST,
      S9_AXI_CDREADY            => S9_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #10 Slave Signals.
      
      S10_AXI_AWID               => S10_AXI_AWID,
      S10_AXI_AWADDR             => S10_AXI_AWADDR,
      S10_AXI_AWLEN              => S10_AXI_AWLEN,
      S10_AXI_AWSIZE             => S10_AXI_AWSIZE,
      S10_AXI_AWBURST            => S10_AXI_AWBURST,
      S10_AXI_AWLOCK             => S10_AXI_AWLOCK,
      S10_AXI_AWCACHE            => S10_AXI_AWCACHE,
      S10_AXI_AWPROT             => S10_AXI_AWPROT,
      S10_AXI_AWQOS              => S10_AXI_AWQOS,
      S10_AXI_AWVALID            => S10_AXI_AWVALID,
      S10_AXI_AWREADY            => S10_AXI_AWREADY,
      S10_AXI_AWDOMAIN           => S10_AXI_AWDOMAIN,
      S10_AXI_AWSNOOP            => S10_AXI_AWSNOOP,
      S10_AXI_AWBAR              => S10_AXI_AWBAR,
      
      S10_AXI_WDATA              => S10_AXI_WDATA,
      S10_AXI_WSTRB              => S10_AXI_WSTRB,
      S10_AXI_WLAST              => S10_AXI_WLAST,
      S10_AXI_WVALID             => S10_AXI_WVALID,
      S10_AXI_WREADY             => S10_AXI_WREADY,
      
      S10_AXI_BRESP              => S10_AXI_BRESP,
      S10_AXI_BID                => S10_AXI_BID,
      S10_AXI_BVALID             => S10_AXI_BVALID,
      S10_AXI_BREADY             => S10_AXI_BREADY,
      S10_AXI_WACK               => S10_AXI_WACK,
      
      S10_AXI_ARID               => S10_AXI_ARID,
      S10_AXI_ARADDR             => S10_AXI_ARADDR,
      S10_AXI_ARLEN              => S10_AXI_ARLEN,
      S10_AXI_ARSIZE             => S10_AXI_ARSIZE,
      S10_AXI_ARBURST            => S10_AXI_ARBURST,
      S10_AXI_ARLOCK             => S10_AXI_ARLOCK,
      S10_AXI_ARCACHE            => S10_AXI_ARCACHE,
      S10_AXI_ARPROT             => S10_AXI_ARPROT,
      S10_AXI_ARQOS              => S10_AXI_ARQOS,
      S10_AXI_ARVALID            => S10_AXI_ARVALID,
      S10_AXI_ARREADY            => S10_AXI_ARREADY,
      S10_AXI_ARDOMAIN           => S10_AXI_ARDOMAIN,
      S10_AXI_ARSNOOP            => S10_AXI_ARSNOOP,
      S10_AXI_ARBAR              => S10_AXI_ARBAR,
      
      S10_AXI_RID                => S10_AXI_RID,
      S10_AXI_RDATA              => S10_AXI_RDATA,
      S10_AXI_RRESP              => S10_AXI_RRESP,
      S10_AXI_RLAST              => S10_AXI_RLAST,
      S10_AXI_RVALID             => S10_AXI_RVALID,
      S10_AXI_RREADY             => S10_AXI_RREADY,
      S10_AXI_RACK               => S10_AXI_RACK,
      
      S10_AXI_ACVALID            => S10_AXI_ACVALID,
      S10_AXI_ACADDR             => S10_AXI_ACADDR,
      S10_AXI_ACSNOOP            => S10_AXI_ACSNOOP,
      S10_AXI_ACPROT             => S10_AXI_ACPROT,
      S10_AXI_ACREADY            => S10_AXI_ACREADY,
      
      S10_AXI_CRVALID            => S10_AXI_CRVALID,
      S10_AXI_CRRESP             => S10_AXI_CRRESP,
      S10_AXI_CRREADY            => S10_AXI_CRREADY,
      
      S10_AXI_CDVALID            => S10_AXI_CDVALID,
      S10_AXI_CDDATA             => S10_AXI_CDDATA,
      S10_AXI_CDLAST             => S10_AXI_CDLAST,
      S10_AXI_CDREADY            => S10_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #11 Slave Signals.
      
      S11_AXI_AWID               => S11_AXI_AWID,
      S11_AXI_AWADDR             => S11_AXI_AWADDR,
      S11_AXI_AWLEN              => S11_AXI_AWLEN,
      S11_AXI_AWSIZE             => S11_AXI_AWSIZE,
      S11_AXI_AWBURST            => S11_AXI_AWBURST,
      S11_AXI_AWLOCK             => S11_AXI_AWLOCK,
      S11_AXI_AWCACHE            => S11_AXI_AWCACHE,
      S11_AXI_AWPROT             => S11_AXI_AWPROT,
      S11_AXI_AWQOS              => S11_AXI_AWQOS,
      S11_AXI_AWVALID            => S11_AXI_AWVALID,
      S11_AXI_AWREADY            => S11_AXI_AWREADY,
      S11_AXI_AWDOMAIN           => S11_AXI_AWDOMAIN,
      S11_AXI_AWSNOOP            => S11_AXI_AWSNOOP,
      S11_AXI_AWBAR              => S11_AXI_AWBAR,
      
      S11_AXI_WDATA              => S11_AXI_WDATA,
      S11_AXI_WSTRB              => S11_AXI_WSTRB,
      S11_AXI_WLAST              => S11_AXI_WLAST,
      S11_AXI_WVALID             => S11_AXI_WVALID,
      S11_AXI_WREADY             => S11_AXI_WREADY,
      
      S11_AXI_BRESP              => S11_AXI_BRESP,
      S11_AXI_BID                => S11_AXI_BID,
      S11_AXI_BVALID             => S11_AXI_BVALID,
      S11_AXI_BREADY             => S11_AXI_BREADY,
      S11_AXI_WACK               => S11_AXI_WACK,
      
      S11_AXI_ARID               => S11_AXI_ARID,
      S11_AXI_ARADDR             => S11_AXI_ARADDR,
      S11_AXI_ARLEN              => S11_AXI_ARLEN,
      S11_AXI_ARSIZE             => S11_AXI_ARSIZE,
      S11_AXI_ARBURST            => S11_AXI_ARBURST,
      S11_AXI_ARLOCK             => S11_AXI_ARLOCK,
      S11_AXI_ARCACHE            => S11_AXI_ARCACHE,
      S11_AXI_ARPROT             => S11_AXI_ARPROT,
      S11_AXI_ARQOS              => S11_AXI_ARQOS,
      S11_AXI_ARVALID            => S11_AXI_ARVALID,
      S11_AXI_ARREADY            => S11_AXI_ARREADY,
      S11_AXI_ARDOMAIN           => S11_AXI_ARDOMAIN,
      S11_AXI_ARSNOOP            => S11_AXI_ARSNOOP,
      S11_AXI_ARBAR              => S11_AXI_ARBAR,
      
      S11_AXI_RID                => S11_AXI_RID,
      S11_AXI_RDATA              => S11_AXI_RDATA,
      S11_AXI_RRESP              => S11_AXI_RRESP,
      S11_AXI_RLAST              => S11_AXI_RLAST,
      S11_AXI_RVALID             => S11_AXI_RVALID,
      S11_AXI_RREADY             => S11_AXI_RREADY,
      S11_AXI_RACK               => S11_AXI_RACK,
      
      S11_AXI_ACVALID            => S11_AXI_ACVALID,
      S11_AXI_ACADDR             => S11_AXI_ACADDR,
      S11_AXI_ACSNOOP            => S11_AXI_ACSNOOP,
      S11_AXI_ACPROT             => S11_AXI_ACPROT,
      S11_AXI_ACREADY            => S11_AXI_ACREADY,
      
      S11_AXI_CRVALID            => S11_AXI_CRVALID,
      S11_AXI_CRRESP             => S11_AXI_CRRESP,
      S11_AXI_CRREADY            => S11_AXI_CRREADY,
      
      S11_AXI_CDVALID            => S11_AXI_CDVALID,
      S11_AXI_CDDATA             => S11_AXI_CDDATA,
      S11_AXI_CDLAST             => S11_AXI_CDLAST,
      S11_AXI_CDREADY            => S11_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #12 Slave Signals.
      
      S12_AXI_AWID               => S12_AXI_AWID,
      S12_AXI_AWADDR             => S12_AXI_AWADDR,
      S12_AXI_AWLEN              => S12_AXI_AWLEN,
      S12_AXI_AWSIZE             => S12_AXI_AWSIZE,
      S12_AXI_AWBURST            => S12_AXI_AWBURST,
      S12_AXI_AWLOCK             => S12_AXI_AWLOCK,
      S12_AXI_AWCACHE            => S12_AXI_AWCACHE,
      S12_AXI_AWPROT             => S12_AXI_AWPROT,
      S12_AXI_AWQOS              => S12_AXI_AWQOS,
      S12_AXI_AWVALID            => S12_AXI_AWVALID,
      S12_AXI_AWREADY            => S12_AXI_AWREADY,
      S12_AXI_AWDOMAIN           => S12_AXI_AWDOMAIN,
      S12_AXI_AWSNOOP            => S12_AXI_AWSNOOP,
      S12_AXI_AWBAR              => S12_AXI_AWBAR,
      
      S12_AXI_WDATA              => S12_AXI_WDATA,
      S12_AXI_WSTRB              => S12_AXI_WSTRB,
      S12_AXI_WLAST              => S12_AXI_WLAST,
      S12_AXI_WVALID             => S12_AXI_WVALID,
      S12_AXI_WREADY             => S12_AXI_WREADY,
      
      S12_AXI_BRESP              => S12_AXI_BRESP,
      S12_AXI_BID                => S12_AXI_BID,
      S12_AXI_BVALID             => S12_AXI_BVALID,
      S12_AXI_BREADY             => S12_AXI_BREADY,
      S12_AXI_WACK               => S12_AXI_WACK,
      
      S12_AXI_ARID               => S12_AXI_ARID,
      S12_AXI_ARADDR             => S12_AXI_ARADDR,
      S12_AXI_ARLEN              => S12_AXI_ARLEN,
      S12_AXI_ARSIZE             => S12_AXI_ARSIZE,
      S12_AXI_ARBURST            => S12_AXI_ARBURST,
      S12_AXI_ARLOCK             => S12_AXI_ARLOCK,
      S12_AXI_ARCACHE            => S12_AXI_ARCACHE,
      S12_AXI_ARPROT             => S12_AXI_ARPROT,
      S12_AXI_ARQOS              => S12_AXI_ARQOS,
      S12_AXI_ARVALID            => S12_AXI_ARVALID,
      S12_AXI_ARREADY            => S12_AXI_ARREADY,
      S12_AXI_ARDOMAIN           => S12_AXI_ARDOMAIN,
      S12_AXI_ARSNOOP            => S12_AXI_ARSNOOP,
      S12_AXI_ARBAR              => S12_AXI_ARBAR,
      
      S12_AXI_RID                => S12_AXI_RID,
      S12_AXI_RDATA              => S12_AXI_RDATA,
      S12_AXI_RRESP              => S12_AXI_RRESP,
      S12_AXI_RLAST              => S12_AXI_RLAST,
      S12_AXI_RVALID             => S12_AXI_RVALID,
      S12_AXI_RREADY             => S12_AXI_RREADY,
      S12_AXI_RACK               => S12_AXI_RACK,
      
      S12_AXI_ACVALID            => S12_AXI_ACVALID,
      S12_AXI_ACADDR             => S12_AXI_ACADDR,
      S12_AXI_ACSNOOP            => S12_AXI_ACSNOOP,
      S12_AXI_ACPROT             => S12_AXI_ACPROT,
      S12_AXI_ACREADY            => S12_AXI_ACREADY,
      
      S12_AXI_CRVALID            => S12_AXI_CRVALID,
      S12_AXI_CRRESP             => S12_AXI_CRRESP,
      S12_AXI_CRREADY            => S12_AXI_CRREADY,
      
      S12_AXI_CDVALID            => S12_AXI_CDVALID,
      S12_AXI_CDDATA             => S12_AXI_CDDATA,
      S12_AXI_CDLAST             => S12_AXI_CDLAST,
      S12_AXI_CDREADY            => S12_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #13 Slave Signals.
      
      S13_AXI_AWID               => S13_AXI_AWID,
      S13_AXI_AWADDR             => S13_AXI_AWADDR,
      S13_AXI_AWLEN              => S13_AXI_AWLEN,
      S13_AXI_AWSIZE             => S13_AXI_AWSIZE,
      S13_AXI_AWBURST            => S13_AXI_AWBURST,
      S13_AXI_AWLOCK             => S13_AXI_AWLOCK,
      S13_AXI_AWCACHE            => S13_AXI_AWCACHE,
      S13_AXI_AWPROT             => S13_AXI_AWPROT,
      S13_AXI_AWQOS              => S13_AXI_AWQOS,
      S13_AXI_AWVALID            => S13_AXI_AWVALID,
      S13_AXI_AWREADY            => S13_AXI_AWREADY,
      S13_AXI_AWDOMAIN           => S13_AXI_AWDOMAIN,
      S13_AXI_AWSNOOP            => S13_AXI_AWSNOOP,
      S13_AXI_AWBAR              => S13_AXI_AWBAR,
      
      S13_AXI_WDATA              => S13_AXI_WDATA,
      S13_AXI_WSTRB              => S13_AXI_WSTRB,
      S13_AXI_WLAST              => S13_AXI_WLAST,
      S13_AXI_WVALID             => S13_AXI_WVALID,
      S13_AXI_WREADY             => S13_AXI_WREADY,
      
      S13_AXI_BRESP              => S13_AXI_BRESP,
      S13_AXI_BID                => S13_AXI_BID,
      S13_AXI_BVALID             => S13_AXI_BVALID,
      S13_AXI_BREADY             => S13_AXI_BREADY,
      S13_AXI_WACK               => S13_AXI_WACK,
      
      S13_AXI_ARID               => S13_AXI_ARID,
      S13_AXI_ARADDR             => S13_AXI_ARADDR,
      S13_AXI_ARLEN              => S13_AXI_ARLEN,
      S13_AXI_ARSIZE             => S13_AXI_ARSIZE,
      S13_AXI_ARBURST            => S13_AXI_ARBURST,
      S13_AXI_ARLOCK             => S13_AXI_ARLOCK,
      S13_AXI_ARCACHE            => S13_AXI_ARCACHE,
      S13_AXI_ARPROT             => S13_AXI_ARPROT,
      S13_AXI_ARQOS              => S13_AXI_ARQOS,
      S13_AXI_ARVALID            => S13_AXI_ARVALID,
      S13_AXI_ARREADY            => S13_AXI_ARREADY,
      S13_AXI_ARDOMAIN           => S13_AXI_ARDOMAIN,
      S13_AXI_ARSNOOP            => S13_AXI_ARSNOOP,
      S13_AXI_ARBAR              => S13_AXI_ARBAR,
      
      S13_AXI_RID                => S13_AXI_RID,
      S13_AXI_RDATA              => S13_AXI_RDATA,
      S13_AXI_RRESP              => S13_AXI_RRESP,
      S13_AXI_RLAST              => S13_AXI_RLAST,
      S13_AXI_RVALID             => S13_AXI_RVALID,
      S13_AXI_RREADY             => S13_AXI_RREADY,
      S13_AXI_RACK               => S13_AXI_RACK,
      
      S13_AXI_ACVALID            => S13_AXI_ACVALID,
      S13_AXI_ACADDR             => S13_AXI_ACADDR,
      S13_AXI_ACSNOOP            => S13_AXI_ACSNOOP,
      S13_AXI_ACPROT             => S13_AXI_ACPROT,
      S13_AXI_ACREADY            => S13_AXI_ACREADY,
      
      S13_AXI_CRVALID            => S13_AXI_CRVALID,
      S13_AXI_CRRESP             => S13_AXI_CRRESP,
      S13_AXI_CRREADY            => S13_AXI_CRREADY,
      
      S13_AXI_CDVALID            => S13_AXI_CDVALID,
      S13_AXI_CDDATA             => S13_AXI_CDDATA,
      S13_AXI_CDLAST             => S13_AXI_CDLAST,
      S13_AXI_CDREADY            => S13_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #14 Slave Signals.
      
      S14_AXI_AWID               => S14_AXI_AWID,
      S14_AXI_AWADDR             => S14_AXI_AWADDR,
      S14_AXI_AWLEN              => S14_AXI_AWLEN,
      S14_AXI_AWSIZE             => S14_AXI_AWSIZE,
      S14_AXI_AWBURST            => S14_AXI_AWBURST,
      S14_AXI_AWLOCK             => S14_AXI_AWLOCK,
      S14_AXI_AWCACHE            => S14_AXI_AWCACHE,
      S14_AXI_AWPROT             => S14_AXI_AWPROT,
      S14_AXI_AWQOS              => S14_AXI_AWQOS,
      S14_AXI_AWVALID            => S14_AXI_AWVALID,
      S14_AXI_AWREADY            => S14_AXI_AWREADY,
      S14_AXI_AWDOMAIN           => S14_AXI_AWDOMAIN,
      S14_AXI_AWSNOOP            => S14_AXI_AWSNOOP,
      S14_AXI_AWBAR              => S14_AXI_AWBAR,
      
      S14_AXI_WDATA              => S14_AXI_WDATA,
      S14_AXI_WSTRB              => S14_AXI_WSTRB,
      S14_AXI_WLAST              => S14_AXI_WLAST,
      S14_AXI_WVALID             => S14_AXI_WVALID,
      S14_AXI_WREADY             => S14_AXI_WREADY,
      
      S14_AXI_BRESP              => S14_AXI_BRESP,
      S14_AXI_BID                => S14_AXI_BID,
      S14_AXI_BVALID             => S14_AXI_BVALID,
      S14_AXI_BREADY             => S14_AXI_BREADY,
      S14_AXI_WACK               => S14_AXI_WACK,
      
      S14_AXI_ARID               => S14_AXI_ARID,
      S14_AXI_ARADDR             => S14_AXI_ARADDR,
      S14_AXI_ARLEN              => S14_AXI_ARLEN,
      S14_AXI_ARSIZE             => S14_AXI_ARSIZE,
      S14_AXI_ARBURST            => S14_AXI_ARBURST,
      S14_AXI_ARLOCK             => S14_AXI_ARLOCK,
      S14_AXI_ARCACHE            => S14_AXI_ARCACHE,
      S14_AXI_ARPROT             => S14_AXI_ARPROT,
      S14_AXI_ARQOS              => S14_AXI_ARQOS,
      S14_AXI_ARVALID            => S14_AXI_ARVALID,
      S14_AXI_ARREADY            => S14_AXI_ARREADY,
      S14_AXI_ARDOMAIN           => S14_AXI_ARDOMAIN,
      S14_AXI_ARSNOOP            => S14_AXI_ARSNOOP,
      S14_AXI_ARBAR              => S14_AXI_ARBAR,
      
      S14_AXI_RID                => S14_AXI_RID,
      S14_AXI_RDATA              => S14_AXI_RDATA,
      S14_AXI_RRESP              => S14_AXI_RRESP,
      S14_AXI_RLAST              => S14_AXI_RLAST,
      S14_AXI_RVALID             => S14_AXI_RVALID,
      S14_AXI_RREADY             => S14_AXI_RREADY,
      S14_AXI_RACK               => S14_AXI_RACK,
      
      S14_AXI_ACVALID            => S14_AXI_ACVALID,
      S14_AXI_ACADDR             => S14_AXI_ACADDR,
      S14_AXI_ACSNOOP            => S14_AXI_ACSNOOP,
      S14_AXI_ACPROT             => S14_AXI_ACPROT,
      S14_AXI_ACREADY            => S14_AXI_ACREADY,
      
      S14_AXI_CRVALID            => S14_AXI_CRVALID,
      S14_AXI_CRRESP             => S14_AXI_CRRESP,
      S14_AXI_CRREADY            => S14_AXI_CRREADY,
      
      S14_AXI_CDVALID            => S14_AXI_CDVALID,
      S14_AXI_CDDATA             => S14_AXI_CDDATA,
      S14_AXI_CDLAST             => S14_AXI_CDLAST,
      S14_AXI_CDREADY            => S14_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Optimized AXI4/ACE Interface #15 Slave Signals.
      
      S15_AXI_AWID               => S15_AXI_AWID,
      S15_AXI_AWADDR             => S15_AXI_AWADDR,
      S15_AXI_AWLEN              => S15_AXI_AWLEN,
      S15_AXI_AWSIZE             => S15_AXI_AWSIZE,
      S15_AXI_AWBURST            => S15_AXI_AWBURST,
      S15_AXI_AWLOCK             => S15_AXI_AWLOCK,
      S15_AXI_AWCACHE            => S15_AXI_AWCACHE,
      S15_AXI_AWPROT             => S15_AXI_AWPROT,
      S15_AXI_AWQOS              => S15_AXI_AWQOS,
      S15_AXI_AWVALID            => S15_AXI_AWVALID,
      S15_AXI_AWREADY            => S15_AXI_AWREADY,
      S15_AXI_AWDOMAIN           => S15_AXI_AWDOMAIN,
      S15_AXI_AWSNOOP            => S15_AXI_AWSNOOP,
      S15_AXI_AWBAR              => S15_AXI_AWBAR,
      
      S15_AXI_WDATA              => S15_AXI_WDATA,
      S15_AXI_WSTRB              => S15_AXI_WSTRB,
      S15_AXI_WLAST              => S15_AXI_WLAST,
      S15_AXI_WVALID             => S15_AXI_WVALID,
      S15_AXI_WREADY             => S15_AXI_WREADY,
      
      S15_AXI_BRESP              => S15_AXI_BRESP,
      S15_AXI_BID                => S15_AXI_BID,
      S15_AXI_BVALID             => S15_AXI_BVALID,
      S15_AXI_BREADY             => S15_AXI_BREADY,
      S15_AXI_WACK               => S15_AXI_WACK,
      
      S15_AXI_ARID               => S15_AXI_ARID,
      S15_AXI_ARADDR             => S15_AXI_ARADDR,
      S15_AXI_ARLEN              => S15_AXI_ARLEN,
      S15_AXI_ARSIZE             => S15_AXI_ARSIZE,
      S15_AXI_ARBURST            => S15_AXI_ARBURST,
      S15_AXI_ARLOCK             => S15_AXI_ARLOCK,
      S15_AXI_ARCACHE            => S15_AXI_ARCACHE,
      S15_AXI_ARPROT             => S15_AXI_ARPROT,
      S15_AXI_ARQOS              => S15_AXI_ARQOS,
      S15_AXI_ARVALID            => S15_AXI_ARVALID,
      S15_AXI_ARREADY            => S15_AXI_ARREADY,
      S15_AXI_ARDOMAIN           => S15_AXI_ARDOMAIN,
      S15_AXI_ARSNOOP            => S15_AXI_ARSNOOP,
      S15_AXI_ARBAR              => S15_AXI_ARBAR,
      
      S15_AXI_RID                => S15_AXI_RID,
      S15_AXI_RDATA              => S15_AXI_RDATA,
      S15_AXI_RRESP              => S15_AXI_RRESP,
      S15_AXI_RLAST              => S15_AXI_RLAST,
      S15_AXI_RVALID             => S15_AXI_RVALID,
      S15_AXI_RREADY             => S15_AXI_RREADY,
      S15_AXI_RACK               => S15_AXI_RACK,
      
      S15_AXI_ACVALID            => S15_AXI_ACVALID,
      S15_AXI_ACADDR             => S15_AXI_ACADDR,
      S15_AXI_ACSNOOP            => S15_AXI_ACSNOOP,
      S15_AXI_ACPROT             => S15_AXI_ACPROT,
      S15_AXI_ACREADY            => S15_AXI_ACREADY,
      
      S15_AXI_CRVALID            => S15_AXI_CRVALID,
      S15_AXI_CRRESP             => S15_AXI_CRRESP,
      S15_AXI_CRREADY            => S15_AXI_CRREADY,
      
      S15_AXI_CDVALID            => S15_AXI_CDVALID,
      S15_AXI_CDDATA             => S15_AXI_CDDATA,
      S15_AXI_CDLAST             => S15_AXI_CDLAST,
      S15_AXI_CDREADY            => S15_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #0 Slave Signals.
      
      S0_AXI_GEN_AWID           => S0_AXI_GEN_AWID,
      S0_AXI_GEN_AWADDR         => S0_AXI_GEN_AWADDR,
      S0_AXI_GEN_AWLEN          => S0_AXI_GEN_AWLEN,
      S0_AXI_GEN_AWSIZE         => S0_AXI_GEN_AWSIZE,
      S0_AXI_GEN_AWBURST        => S0_AXI_GEN_AWBURST,
      S0_AXI_GEN_AWLOCK         => S0_AXI_GEN_AWLOCK,
      S0_AXI_GEN_AWCACHE        => S0_AXI_GEN_AWCACHE,
      S0_AXI_GEN_AWPROT         => S0_AXI_GEN_AWPROT,
      S0_AXI_GEN_AWQOS          => S0_AXI_GEN_AWQOS,
      S0_AXI_GEN_AWVALID        => S0_AXI_GEN_AWVALID,
      S0_AXI_GEN_AWREADY        => S0_AXI_GEN_AWREADY,
      
      S0_AXI_GEN_WDATA          => S0_AXI_GEN_WDATA,
      S0_AXI_GEN_WSTRB          => S0_AXI_GEN_WSTRB,
      S0_AXI_GEN_WLAST          => S0_AXI_GEN_WLAST,
      S0_AXI_GEN_WVALID         => S0_AXI_GEN_WVALID,
      S0_AXI_GEN_WREADY         => S0_AXI_GEN_WREADY,
      
      S0_AXI_GEN_BRESP          => S0_AXI_GEN_BRESP,
      S0_AXI_GEN_BID            => S0_AXI_GEN_BID,
      S0_AXI_GEN_BVALID         => S0_AXI_GEN_BVALID,
      S0_AXI_GEN_BREADY         => S0_AXI_GEN_BREADY,
      
      S0_AXI_GEN_ARID           => S0_AXI_GEN_ARID,
      S0_AXI_GEN_ARADDR         => S0_AXI_GEN_ARADDR,
      S0_AXI_GEN_ARLEN          => S0_AXI_GEN_ARLEN,
      S0_AXI_GEN_ARSIZE         => S0_AXI_GEN_ARSIZE,
      S0_AXI_GEN_ARBURST        => S0_AXI_GEN_ARBURST,
      S0_AXI_GEN_ARLOCK         => S0_AXI_GEN_ARLOCK,
      S0_AXI_GEN_ARCACHE        => S0_AXI_GEN_ARCACHE,
      S0_AXI_GEN_ARPROT         => S0_AXI_GEN_ARPROT,
      S0_AXI_GEN_ARQOS          => S0_AXI_GEN_ARQOS,
      S0_AXI_GEN_ARVALID        => S0_AXI_GEN_ARVALID,
      S0_AXI_GEN_ARREADY        => S0_AXI_GEN_ARREADY,
      
      S0_AXI_GEN_RID            => S0_AXI_GEN_RID,
      S0_AXI_GEN_RDATA          => S0_AXI_GEN_RDATA,
      S0_AXI_GEN_RRESP          => S0_AXI_GEN_RRESP,
      S0_AXI_GEN_RLAST          => S0_AXI_GEN_RLAST,
      S0_AXI_GEN_RVALID         => S0_AXI_GEN_RVALID,
      S0_AXI_GEN_RREADY         => S0_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #1 Slave Signals.
      
      S1_AXI_GEN_AWID           => S1_AXI_GEN_AWID,
      S1_AXI_GEN_AWADDR         => S1_AXI_GEN_AWADDR,
      S1_AXI_GEN_AWLEN          => S1_AXI_GEN_AWLEN,
      S1_AXI_GEN_AWSIZE         => S1_AXI_GEN_AWSIZE,
      S1_AXI_GEN_AWBURST        => S1_AXI_GEN_AWBURST,
      S1_AXI_GEN_AWLOCK         => S1_AXI_GEN_AWLOCK,
      S1_AXI_GEN_AWCACHE        => S1_AXI_GEN_AWCACHE,
      S1_AXI_GEN_AWPROT         => S1_AXI_GEN_AWPROT,
      S1_AXI_GEN_AWQOS          => S1_AXI_GEN_AWQOS,
      S1_AXI_GEN_AWVALID        => S1_AXI_GEN_AWVALID,
      S1_AXI_GEN_AWREADY        => S1_AXI_GEN_AWREADY,
      
      S1_AXI_GEN_WDATA          => S1_AXI_GEN_WDATA,
      S1_AXI_GEN_WSTRB          => S1_AXI_GEN_WSTRB,
      S1_AXI_GEN_WLAST          => S1_AXI_GEN_WLAST,
      S1_AXI_GEN_WVALID         => S1_AXI_GEN_WVALID,
      S1_AXI_GEN_WREADY         => S1_AXI_GEN_WREADY,
      
      S1_AXI_GEN_BRESP          => S1_AXI_GEN_BRESP,
      S1_AXI_GEN_BID            => S1_AXI_GEN_BID,
      S1_AXI_GEN_BVALID         => S1_AXI_GEN_BVALID,
      S1_AXI_GEN_BREADY         => S1_AXI_GEN_BREADY,
      
      S1_AXI_GEN_ARID           => S1_AXI_GEN_ARID,
      S1_AXI_GEN_ARADDR         => S1_AXI_GEN_ARADDR,
      S1_AXI_GEN_ARLEN          => S1_AXI_GEN_ARLEN,
      S1_AXI_GEN_ARSIZE         => S1_AXI_GEN_ARSIZE,
      S1_AXI_GEN_ARBURST        => S1_AXI_GEN_ARBURST,
      S1_AXI_GEN_ARLOCK         => S1_AXI_GEN_ARLOCK,
      S1_AXI_GEN_ARCACHE        => S1_AXI_GEN_ARCACHE,
      S1_AXI_GEN_ARPROT         => S1_AXI_GEN_ARPROT,
      S1_AXI_GEN_ARQOS          => S1_AXI_GEN_ARQOS,
      S1_AXI_GEN_ARVALID        => S1_AXI_GEN_ARVALID,
      S1_AXI_GEN_ARREADY        => S1_AXI_GEN_ARREADY,
      
      S1_AXI_GEN_RID            => S1_AXI_GEN_RID,
      S1_AXI_GEN_RDATA          => S1_AXI_GEN_RDATA,
      S1_AXI_GEN_RRESP          => S1_AXI_GEN_RRESP,
      S1_AXI_GEN_RLAST          => S1_AXI_GEN_RLAST,
      S1_AXI_GEN_RVALID         => S1_AXI_GEN_RVALID,
      S1_AXI_GEN_RREADY         => S1_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #2 Slave Signals.
      
      S2_AXI_GEN_AWID           => S2_AXI_GEN_AWID,
      S2_AXI_GEN_AWADDR         => S2_AXI_GEN_AWADDR,
      S2_AXI_GEN_AWLEN          => S2_AXI_GEN_AWLEN,
      S2_AXI_GEN_AWSIZE         => S2_AXI_GEN_AWSIZE,
      S2_AXI_GEN_AWBURST        => S2_AXI_GEN_AWBURST,
      S2_AXI_GEN_AWLOCK         => S2_AXI_GEN_AWLOCK,
      S2_AXI_GEN_AWCACHE        => S2_AXI_GEN_AWCACHE,
      S2_AXI_GEN_AWPROT         => S2_AXI_GEN_AWPROT,
      S2_AXI_GEN_AWQOS          => S2_AXI_GEN_AWQOS,
      S2_AXI_GEN_AWVALID        => S2_AXI_GEN_AWVALID,
      S2_AXI_GEN_AWREADY        => S2_AXI_GEN_AWREADY,
      
      S2_AXI_GEN_WDATA          => S2_AXI_GEN_WDATA,
      S2_AXI_GEN_WSTRB          => S2_AXI_GEN_WSTRB,
      S2_AXI_GEN_WLAST          => S2_AXI_GEN_WLAST,
      S2_AXI_GEN_WVALID         => S2_AXI_GEN_WVALID,
      S2_AXI_GEN_WREADY         => S2_AXI_GEN_WREADY,
      
      S2_AXI_GEN_BRESP          => S2_AXI_GEN_BRESP,
      S2_AXI_GEN_BID            => S2_AXI_GEN_BID,
      S2_AXI_GEN_BVALID         => S2_AXI_GEN_BVALID,
      S2_AXI_GEN_BREADY         => S2_AXI_GEN_BREADY,
      
      S2_AXI_GEN_ARID           => S2_AXI_GEN_ARID,
      S2_AXI_GEN_ARADDR         => S2_AXI_GEN_ARADDR,
      S2_AXI_GEN_ARLEN          => S2_AXI_GEN_ARLEN,
      S2_AXI_GEN_ARSIZE         => S2_AXI_GEN_ARSIZE,
      S2_AXI_GEN_ARBURST        => S2_AXI_GEN_ARBURST,
      S2_AXI_GEN_ARLOCK         => S2_AXI_GEN_ARLOCK,
      S2_AXI_GEN_ARCACHE        => S2_AXI_GEN_ARCACHE,
      S2_AXI_GEN_ARPROT         => S2_AXI_GEN_ARPROT,
      S2_AXI_GEN_ARQOS          => S2_AXI_GEN_ARQOS,
      S2_AXI_GEN_ARVALID        => S2_AXI_GEN_ARVALID,
      S2_AXI_GEN_ARREADY        => S2_AXI_GEN_ARREADY,
      
      S2_AXI_GEN_RID            => S2_AXI_GEN_RID,
      S2_AXI_GEN_RDATA          => S2_AXI_GEN_RDATA,
      S2_AXI_GEN_RRESP          => S2_AXI_GEN_RRESP,
      S2_AXI_GEN_RLAST          => S2_AXI_GEN_RLAST,
      S2_AXI_GEN_RVALID         => S2_AXI_GEN_RVALID,
      S2_AXI_GEN_RREADY         => S2_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #3 Slave Signals.
      
      S3_AXI_GEN_AWID           => S3_AXI_GEN_AWID,
      S3_AXI_GEN_AWADDR         => S3_AXI_GEN_AWADDR,
      S3_AXI_GEN_AWLEN          => S3_AXI_GEN_AWLEN,
      S3_AXI_GEN_AWSIZE         => S3_AXI_GEN_AWSIZE,
      S3_AXI_GEN_AWBURST        => S3_AXI_GEN_AWBURST,
      S3_AXI_GEN_AWLOCK         => S3_AXI_GEN_AWLOCK,
      S3_AXI_GEN_AWCACHE        => S3_AXI_GEN_AWCACHE,
      S3_AXI_GEN_AWPROT         => S3_AXI_GEN_AWPROT,
      S3_AXI_GEN_AWQOS          => S3_AXI_GEN_AWQOS,
      S3_AXI_GEN_AWVALID        => S3_AXI_GEN_AWVALID,
      S3_AXI_GEN_AWREADY        => S3_AXI_GEN_AWREADY,
      
      S3_AXI_GEN_WDATA          => S3_AXI_GEN_WDATA,
      S3_AXI_GEN_WSTRB          => S3_AXI_GEN_WSTRB,
      S3_AXI_GEN_WLAST          => S3_AXI_GEN_WLAST,
      S3_AXI_GEN_WVALID         => S3_AXI_GEN_WVALID,
      S3_AXI_GEN_WREADY         => S3_AXI_GEN_WREADY,
      
      S3_AXI_GEN_BRESP          => S3_AXI_GEN_BRESP,
      S3_AXI_GEN_BID            => S3_AXI_GEN_BID,
      S3_AXI_GEN_BVALID         => S3_AXI_GEN_BVALID,
      S3_AXI_GEN_BREADY         => S3_AXI_GEN_BREADY,
      
      S3_AXI_GEN_ARID           => S3_AXI_GEN_ARID,
      S3_AXI_GEN_ARADDR         => S3_AXI_GEN_ARADDR,
      S3_AXI_GEN_ARLEN          => S3_AXI_GEN_ARLEN,
      S3_AXI_GEN_ARSIZE         => S3_AXI_GEN_ARSIZE,
      S3_AXI_GEN_ARBURST        => S3_AXI_GEN_ARBURST,
      S3_AXI_GEN_ARLOCK         => S3_AXI_GEN_ARLOCK,
      S3_AXI_GEN_ARCACHE        => S3_AXI_GEN_ARCACHE,
      S3_AXI_GEN_ARPROT         => S3_AXI_GEN_ARPROT,
      S3_AXI_GEN_ARQOS          => S3_AXI_GEN_ARQOS,
      S3_AXI_GEN_ARVALID        => S3_AXI_GEN_ARVALID,
      S3_AXI_GEN_ARREADY        => S3_AXI_GEN_ARREADY,
      
      S3_AXI_GEN_RID            => S3_AXI_GEN_RID,
      S3_AXI_GEN_RDATA          => S3_AXI_GEN_RDATA,
      S3_AXI_GEN_RRESP          => S3_AXI_GEN_RRESP,
      S3_AXI_GEN_RLAST          => S3_AXI_GEN_RLAST,
      S3_AXI_GEN_RVALID         => S3_AXI_GEN_RVALID,
      S3_AXI_GEN_RREADY         => S3_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #4 Slave Signals.
      
      S4_AXI_GEN_AWID           => S4_AXI_GEN_AWID,
      S4_AXI_GEN_AWADDR         => S4_AXI_GEN_AWADDR,
      S4_AXI_GEN_AWLEN          => S4_AXI_GEN_AWLEN,
      S4_AXI_GEN_AWSIZE         => S4_AXI_GEN_AWSIZE,
      S4_AXI_GEN_AWBURST        => S4_AXI_GEN_AWBURST,
      S4_AXI_GEN_AWLOCK         => S4_AXI_GEN_AWLOCK,
      S4_AXI_GEN_AWCACHE        => S4_AXI_GEN_AWCACHE,
      S4_AXI_GEN_AWPROT         => S4_AXI_GEN_AWPROT,
      S4_AXI_GEN_AWQOS          => S4_AXI_GEN_AWQOS,
      S4_AXI_GEN_AWVALID        => S4_AXI_GEN_AWVALID,
      S4_AXI_GEN_AWREADY        => S4_AXI_GEN_AWREADY,
      
      S4_AXI_GEN_WDATA          => S4_AXI_GEN_WDATA,
      S4_AXI_GEN_WSTRB          => S4_AXI_GEN_WSTRB,
      S4_AXI_GEN_WLAST          => S4_AXI_GEN_WLAST,
      S4_AXI_GEN_WVALID         => S4_AXI_GEN_WVALID,
      S4_AXI_GEN_WREADY         => S4_AXI_GEN_WREADY,
      
      S4_AXI_GEN_BRESP          => S4_AXI_GEN_BRESP,
      S4_AXI_GEN_BID            => S4_AXI_GEN_BID,
      S4_AXI_GEN_BVALID         => S4_AXI_GEN_BVALID,
      S4_AXI_GEN_BREADY         => S4_AXI_GEN_BREADY,
      
      S4_AXI_GEN_ARID           => S4_AXI_GEN_ARID,
      S4_AXI_GEN_ARADDR         => S4_AXI_GEN_ARADDR,
      S4_AXI_GEN_ARLEN          => S4_AXI_GEN_ARLEN,
      S4_AXI_GEN_ARSIZE         => S4_AXI_GEN_ARSIZE,
      S4_AXI_GEN_ARBURST        => S4_AXI_GEN_ARBURST,
      S4_AXI_GEN_ARLOCK         => S4_AXI_GEN_ARLOCK,
      S4_AXI_GEN_ARCACHE        => S4_AXI_GEN_ARCACHE,
      S4_AXI_GEN_ARPROT         => S4_AXI_GEN_ARPROT,
      S4_AXI_GEN_ARQOS          => S4_AXI_GEN_ARQOS,
      S4_AXI_GEN_ARVALID        => S4_AXI_GEN_ARVALID,
      S4_AXI_GEN_ARREADY        => S4_AXI_GEN_ARREADY,
      
      S4_AXI_GEN_RID            => S4_AXI_GEN_RID,
      S4_AXI_GEN_RDATA          => S4_AXI_GEN_RDATA,
      S4_AXI_GEN_RRESP          => S4_AXI_GEN_RRESP,
      S4_AXI_GEN_RLAST          => S4_AXI_GEN_RLAST,
      S4_AXI_GEN_RVALID         => S4_AXI_GEN_RVALID,
      S4_AXI_GEN_RREADY         => S4_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #5 Slave Signals.
      
      S5_AXI_GEN_AWID           => S5_AXI_GEN_AWID,
      S5_AXI_GEN_AWADDR         => S5_AXI_GEN_AWADDR,
      S5_AXI_GEN_AWLEN          => S5_AXI_GEN_AWLEN,
      S5_AXI_GEN_AWSIZE         => S5_AXI_GEN_AWSIZE,
      S5_AXI_GEN_AWBURST        => S5_AXI_GEN_AWBURST,
      S5_AXI_GEN_AWLOCK         => S5_AXI_GEN_AWLOCK,
      S5_AXI_GEN_AWCACHE        => S5_AXI_GEN_AWCACHE,
      S5_AXI_GEN_AWPROT         => S5_AXI_GEN_AWPROT,
      S5_AXI_GEN_AWQOS          => S5_AXI_GEN_AWQOS,
      S5_AXI_GEN_AWVALID        => S5_AXI_GEN_AWVALID,
      S5_AXI_GEN_AWREADY        => S5_AXI_GEN_AWREADY,
      
      S5_AXI_GEN_WDATA          => S5_AXI_GEN_WDATA,
      S5_AXI_GEN_WSTRB          => S5_AXI_GEN_WSTRB,
      S5_AXI_GEN_WLAST          => S5_AXI_GEN_WLAST,
      S5_AXI_GEN_WVALID         => S5_AXI_GEN_WVALID,
      S5_AXI_GEN_WREADY         => S5_AXI_GEN_WREADY,
      
      S5_AXI_GEN_BRESP          => S5_AXI_GEN_BRESP,
      S5_AXI_GEN_BID            => S5_AXI_GEN_BID,
      S5_AXI_GEN_BVALID         => S5_AXI_GEN_BVALID,
      S5_AXI_GEN_BREADY         => S5_AXI_GEN_BREADY,
      
      S5_AXI_GEN_ARID           => S5_AXI_GEN_ARID,
      S5_AXI_GEN_ARADDR         => S5_AXI_GEN_ARADDR,
      S5_AXI_GEN_ARLEN          => S5_AXI_GEN_ARLEN,
      S5_AXI_GEN_ARSIZE         => S5_AXI_GEN_ARSIZE,
      S5_AXI_GEN_ARBURST        => S5_AXI_GEN_ARBURST,
      S5_AXI_GEN_ARLOCK         => S5_AXI_GEN_ARLOCK,
      S5_AXI_GEN_ARCACHE        => S5_AXI_GEN_ARCACHE,
      S5_AXI_GEN_ARPROT         => S5_AXI_GEN_ARPROT,
      S5_AXI_GEN_ARQOS          => S5_AXI_GEN_ARQOS,
      S5_AXI_GEN_ARVALID        => S5_AXI_GEN_ARVALID,
      S5_AXI_GEN_ARREADY        => S5_AXI_GEN_ARREADY,
      
      S5_AXI_GEN_RID            => S5_AXI_GEN_RID,
      S5_AXI_GEN_RDATA          => S5_AXI_GEN_RDATA,
      S5_AXI_GEN_RRESP          => S5_AXI_GEN_RRESP,
      S5_AXI_GEN_RLAST          => S5_AXI_GEN_RLAST,
      S5_AXI_GEN_RVALID         => S5_AXI_GEN_RVALID,
      S5_AXI_GEN_RREADY         => S5_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #6 Slave Signals.
      
      S6_AXI_GEN_AWID           => S6_AXI_GEN_AWID,
      S6_AXI_GEN_AWADDR         => S6_AXI_GEN_AWADDR,
      S6_AXI_GEN_AWLEN          => S6_AXI_GEN_AWLEN,
      S6_AXI_GEN_AWSIZE         => S6_AXI_GEN_AWSIZE,
      S6_AXI_GEN_AWBURST        => S6_AXI_GEN_AWBURST,
      S6_AXI_GEN_AWLOCK         => S6_AXI_GEN_AWLOCK,
      S6_AXI_GEN_AWCACHE        => S6_AXI_GEN_AWCACHE,
      S6_AXI_GEN_AWPROT         => S6_AXI_GEN_AWPROT,
      S6_AXI_GEN_AWQOS          => S6_AXI_GEN_AWQOS,
      S6_AXI_GEN_AWVALID        => S6_AXI_GEN_AWVALID,
      S6_AXI_GEN_AWREADY        => S6_AXI_GEN_AWREADY,
      
      S6_AXI_GEN_WDATA          => S6_AXI_GEN_WDATA,
      S6_AXI_GEN_WSTRB          => S6_AXI_GEN_WSTRB,
      S6_AXI_GEN_WLAST          => S6_AXI_GEN_WLAST,
      S6_AXI_GEN_WVALID         => S6_AXI_GEN_WVALID,
      S6_AXI_GEN_WREADY         => S6_AXI_GEN_WREADY,
      
      S6_AXI_GEN_BRESP          => S6_AXI_GEN_BRESP,
      S6_AXI_GEN_BID            => S6_AXI_GEN_BID,
      S6_AXI_GEN_BVALID         => S6_AXI_GEN_BVALID,
      S6_AXI_GEN_BREADY         => S6_AXI_GEN_BREADY,
      
      S6_AXI_GEN_ARID           => S6_AXI_GEN_ARID,
      S6_AXI_GEN_ARADDR         => S6_AXI_GEN_ARADDR,
      S6_AXI_GEN_ARLEN          => S6_AXI_GEN_ARLEN,
      S6_AXI_GEN_ARSIZE         => S6_AXI_GEN_ARSIZE,
      S6_AXI_GEN_ARBURST        => S6_AXI_GEN_ARBURST,
      S6_AXI_GEN_ARLOCK         => S6_AXI_GEN_ARLOCK,
      S6_AXI_GEN_ARCACHE        => S6_AXI_GEN_ARCACHE,
      S6_AXI_GEN_ARPROT         => S6_AXI_GEN_ARPROT,
      S6_AXI_GEN_ARQOS          => S6_AXI_GEN_ARQOS,
      S6_AXI_GEN_ARVALID        => S6_AXI_GEN_ARVALID,
      S6_AXI_GEN_ARREADY        => S6_AXI_GEN_ARREADY,
      
      S6_AXI_GEN_RID            => S6_AXI_GEN_RID,
      S6_AXI_GEN_RDATA          => S6_AXI_GEN_RDATA,
      S6_AXI_GEN_RRESP          => S6_AXI_GEN_RRESP,
      S6_AXI_GEN_RLAST          => S6_AXI_GEN_RLAST,
      S6_AXI_GEN_RVALID         => S6_AXI_GEN_RVALID,
      S6_AXI_GEN_RREADY         => S6_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #7 Slave Signals.
      
      S7_AXI_GEN_AWID           => S7_AXI_GEN_AWID,
      S7_AXI_GEN_AWADDR         => S7_AXI_GEN_AWADDR,
      S7_AXI_GEN_AWLEN          => S7_AXI_GEN_AWLEN,
      S7_AXI_GEN_AWSIZE         => S7_AXI_GEN_AWSIZE,
      S7_AXI_GEN_AWBURST        => S7_AXI_GEN_AWBURST,
      S7_AXI_GEN_AWLOCK         => S7_AXI_GEN_AWLOCK,
      S7_AXI_GEN_AWCACHE        => S7_AXI_GEN_AWCACHE,
      S7_AXI_GEN_AWPROT         => S7_AXI_GEN_AWPROT,
      S7_AXI_GEN_AWQOS          => S7_AXI_GEN_AWQOS,
      S7_AXI_GEN_AWVALID        => S7_AXI_GEN_AWVALID,
      S7_AXI_GEN_AWREADY        => S7_AXI_GEN_AWREADY,
      
      S7_AXI_GEN_WDATA          => S7_AXI_GEN_WDATA,
      S7_AXI_GEN_WSTRB          => S7_AXI_GEN_WSTRB,
      S7_AXI_GEN_WLAST          => S7_AXI_GEN_WLAST,
      S7_AXI_GEN_WVALID         => S7_AXI_GEN_WVALID,
      S7_AXI_GEN_WREADY         => S7_AXI_GEN_WREADY,
      
      S7_AXI_GEN_BRESP          => S7_AXI_GEN_BRESP,
      S7_AXI_GEN_BID            => S7_AXI_GEN_BID,
      S7_AXI_GEN_BVALID         => S7_AXI_GEN_BVALID,
      S7_AXI_GEN_BREADY         => S7_AXI_GEN_BREADY,
      
      S7_AXI_GEN_ARID           => S7_AXI_GEN_ARID,
      S7_AXI_GEN_ARADDR         => S7_AXI_GEN_ARADDR,
      S7_AXI_GEN_ARLEN          => S7_AXI_GEN_ARLEN,
      S7_AXI_GEN_ARSIZE         => S7_AXI_GEN_ARSIZE,
      S7_AXI_GEN_ARBURST        => S7_AXI_GEN_ARBURST,
      S7_AXI_GEN_ARLOCK         => S7_AXI_GEN_ARLOCK,
      S7_AXI_GEN_ARCACHE        => S7_AXI_GEN_ARCACHE,
      S7_AXI_GEN_ARPROT         => S7_AXI_GEN_ARPROT,
      S7_AXI_GEN_ARQOS          => S7_AXI_GEN_ARQOS,
      S7_AXI_GEN_ARVALID        => S7_AXI_GEN_ARVALID,
      S7_AXI_GEN_ARREADY        => S7_AXI_GEN_ARREADY,
      
      S7_AXI_GEN_RID            => S7_AXI_GEN_RID,
      S7_AXI_GEN_RDATA          => S7_AXI_GEN_RDATA,
      S7_AXI_GEN_RRESP          => S7_AXI_GEN_RRESP,
      S7_AXI_GEN_RLAST          => S7_AXI_GEN_RLAST,
      S7_AXI_GEN_RVALID         => S7_AXI_GEN_RVALID,
      S7_AXI_GEN_RREADY         => S7_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #8 Slave Signals.
      
      S8_AXI_GEN_AWID           => S8_AXI_GEN_AWID,
      S8_AXI_GEN_AWADDR         => S8_AXI_GEN_AWADDR,
      S8_AXI_GEN_AWLEN          => S8_AXI_GEN_AWLEN,
      S8_AXI_GEN_AWSIZE         => S8_AXI_GEN_AWSIZE,
      S8_AXI_GEN_AWBURST        => S8_AXI_GEN_AWBURST,
      S8_AXI_GEN_AWLOCK         => S8_AXI_GEN_AWLOCK,
      S8_AXI_GEN_AWCACHE        => S8_AXI_GEN_AWCACHE,
      S8_AXI_GEN_AWPROT         => S8_AXI_GEN_AWPROT,
      S8_AXI_GEN_AWQOS          => S8_AXI_GEN_AWQOS,
      S8_AXI_GEN_AWVALID        => S8_AXI_GEN_AWVALID,
      S8_AXI_GEN_AWREADY        => S8_AXI_GEN_AWREADY,
      
      S8_AXI_GEN_WDATA          => S8_AXI_GEN_WDATA,
      S8_AXI_GEN_WSTRB          => S8_AXI_GEN_WSTRB,
      S8_AXI_GEN_WLAST          => S8_AXI_GEN_WLAST,
      S8_AXI_GEN_WVALID         => S8_AXI_GEN_WVALID,
      S8_AXI_GEN_WREADY         => S8_AXI_GEN_WREADY,
      
      S8_AXI_GEN_BRESP          => S8_AXI_GEN_BRESP,
      S8_AXI_GEN_BID            => S8_AXI_GEN_BID,
      S8_AXI_GEN_BVALID         => S8_AXI_GEN_BVALID,
      S8_AXI_GEN_BREADY         => S8_AXI_GEN_BREADY,
      
      S8_AXI_GEN_ARID           => S8_AXI_GEN_ARID,
      S8_AXI_GEN_ARADDR         => S8_AXI_GEN_ARADDR,
      S8_AXI_GEN_ARLEN          => S8_AXI_GEN_ARLEN,
      S8_AXI_GEN_ARSIZE         => S8_AXI_GEN_ARSIZE,
      S8_AXI_GEN_ARBURST        => S8_AXI_GEN_ARBURST,
      S8_AXI_GEN_ARLOCK         => S8_AXI_GEN_ARLOCK,
      S8_AXI_GEN_ARCACHE        => S8_AXI_GEN_ARCACHE,
      S8_AXI_GEN_ARPROT         => S8_AXI_GEN_ARPROT,
      S8_AXI_GEN_ARQOS          => S8_AXI_GEN_ARQOS,
      S8_AXI_GEN_ARVALID        => S8_AXI_GEN_ARVALID,
      S8_AXI_GEN_ARREADY        => S8_AXI_GEN_ARREADY,
      
      S8_AXI_GEN_RID            => S8_AXI_GEN_RID,
      S8_AXI_GEN_RDATA          => S8_AXI_GEN_RDATA,
      S8_AXI_GEN_RRESP          => S8_AXI_GEN_RRESP,
      S8_AXI_GEN_RLAST          => S8_AXI_GEN_RLAST,
      S8_AXI_GEN_RVALID         => S8_AXI_GEN_RVALID,
      S8_AXI_GEN_RREADY         => S8_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #9 Slave Signals.
      
      S9_AXI_GEN_AWID           => S9_AXI_GEN_AWID,
      S9_AXI_GEN_AWADDR         => S9_AXI_GEN_AWADDR,
      S9_AXI_GEN_AWLEN          => S9_AXI_GEN_AWLEN,
      S9_AXI_GEN_AWSIZE         => S9_AXI_GEN_AWSIZE,
      S9_AXI_GEN_AWBURST        => S9_AXI_GEN_AWBURST,
      S9_AXI_GEN_AWLOCK         => S9_AXI_GEN_AWLOCK,
      S9_AXI_GEN_AWCACHE        => S9_AXI_GEN_AWCACHE,
      S9_AXI_GEN_AWPROT         => S9_AXI_GEN_AWPROT,
      S9_AXI_GEN_AWQOS          => S9_AXI_GEN_AWQOS,
      S9_AXI_GEN_AWVALID        => S9_AXI_GEN_AWVALID,
      S9_AXI_GEN_AWREADY        => S9_AXI_GEN_AWREADY,
      
      S9_AXI_GEN_WDATA          => S9_AXI_GEN_WDATA,
      S9_AXI_GEN_WSTRB          => S9_AXI_GEN_WSTRB,
      S9_AXI_GEN_WLAST          => S9_AXI_GEN_WLAST,
      S9_AXI_GEN_WVALID         => S9_AXI_GEN_WVALID,
      S9_AXI_GEN_WREADY         => S9_AXI_GEN_WREADY,
      
      S9_AXI_GEN_BRESP          => S9_AXI_GEN_BRESP,
      S9_AXI_GEN_BID            => S9_AXI_GEN_BID,
      S9_AXI_GEN_BVALID         => S9_AXI_GEN_BVALID,
      S9_AXI_GEN_BREADY         => S9_AXI_GEN_BREADY,
      
      S9_AXI_GEN_ARID           => S9_AXI_GEN_ARID,
      S9_AXI_GEN_ARADDR         => S9_AXI_GEN_ARADDR,
      S9_AXI_GEN_ARLEN          => S9_AXI_GEN_ARLEN,
      S9_AXI_GEN_ARSIZE         => S9_AXI_GEN_ARSIZE,
      S9_AXI_GEN_ARBURST        => S9_AXI_GEN_ARBURST,
      S9_AXI_GEN_ARLOCK         => S9_AXI_GEN_ARLOCK,
      S9_AXI_GEN_ARCACHE        => S9_AXI_GEN_ARCACHE,
      S9_AXI_GEN_ARPROT         => S9_AXI_GEN_ARPROT,
      S9_AXI_GEN_ARQOS          => S9_AXI_GEN_ARQOS,
      S9_AXI_GEN_ARVALID        => S9_AXI_GEN_ARVALID,
      S9_AXI_GEN_ARREADY        => S9_AXI_GEN_ARREADY,
      
      S9_AXI_GEN_RID            => S9_AXI_GEN_RID,
      S9_AXI_GEN_RDATA          => S9_AXI_GEN_RDATA,
      S9_AXI_GEN_RRESP          => S9_AXI_GEN_RRESP,
      S9_AXI_GEN_RLAST          => S9_AXI_GEN_RLAST,
      S9_AXI_GEN_RVALID         => S9_AXI_GEN_RVALID,
      S9_AXI_GEN_RREADY         => S9_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #10 Slave Signals.
      
      S10_AXI_GEN_AWID           => S10_AXI_GEN_AWID,
      S10_AXI_GEN_AWADDR         => S10_AXI_GEN_AWADDR,
      S10_AXI_GEN_AWLEN          => S10_AXI_GEN_AWLEN,
      S10_AXI_GEN_AWSIZE         => S10_AXI_GEN_AWSIZE,
      S10_AXI_GEN_AWBURST        => S10_AXI_GEN_AWBURST,
      S10_AXI_GEN_AWLOCK         => S10_AXI_GEN_AWLOCK,
      S10_AXI_GEN_AWCACHE        => S10_AXI_GEN_AWCACHE,
      S10_AXI_GEN_AWPROT         => S10_AXI_GEN_AWPROT,
      S10_AXI_GEN_AWQOS          => S10_AXI_GEN_AWQOS,
      S10_AXI_GEN_AWVALID        => S10_AXI_GEN_AWVALID,
      S10_AXI_GEN_AWREADY        => S10_AXI_GEN_AWREADY,
      
      S10_AXI_GEN_WDATA          => S10_AXI_GEN_WDATA,
      S10_AXI_GEN_WSTRB          => S10_AXI_GEN_WSTRB,
      S10_AXI_GEN_WLAST          => S10_AXI_GEN_WLAST,
      S10_AXI_GEN_WVALID         => S10_AXI_GEN_WVALID,
      S10_AXI_GEN_WREADY         => S10_AXI_GEN_WREADY,
      
      S10_AXI_GEN_BRESP          => S10_AXI_GEN_BRESP,
      S10_AXI_GEN_BID            => S10_AXI_GEN_BID,
      S10_AXI_GEN_BVALID         => S10_AXI_GEN_BVALID,
      S10_AXI_GEN_BREADY         => S10_AXI_GEN_BREADY,
      
      S10_AXI_GEN_ARID           => S10_AXI_GEN_ARID,
      S10_AXI_GEN_ARADDR         => S10_AXI_GEN_ARADDR,
      S10_AXI_GEN_ARLEN          => S10_AXI_GEN_ARLEN,
      S10_AXI_GEN_ARSIZE         => S10_AXI_GEN_ARSIZE,
      S10_AXI_GEN_ARBURST        => S10_AXI_GEN_ARBURST,
      S10_AXI_GEN_ARLOCK         => S10_AXI_GEN_ARLOCK,
      S10_AXI_GEN_ARCACHE        => S10_AXI_GEN_ARCACHE,
      S10_AXI_GEN_ARPROT         => S10_AXI_GEN_ARPROT,
      S10_AXI_GEN_ARQOS          => S10_AXI_GEN_ARQOS,
      S10_AXI_GEN_ARVALID        => S10_AXI_GEN_ARVALID,
      S10_AXI_GEN_ARREADY        => S10_AXI_GEN_ARREADY,
      
      S10_AXI_GEN_RID            => S10_AXI_GEN_RID,
      S10_AXI_GEN_RDATA          => S10_AXI_GEN_RDATA,
      S10_AXI_GEN_RRESP          => S10_AXI_GEN_RRESP,
      S10_AXI_GEN_RLAST          => S10_AXI_GEN_RLAST,
      S10_AXI_GEN_RVALID         => S10_AXI_GEN_RVALID,
      S10_AXI_GEN_RREADY         => S10_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #11 Slave Signals.
      
      S11_AXI_GEN_AWID           => S11_AXI_GEN_AWID,
      S11_AXI_GEN_AWADDR         => S11_AXI_GEN_AWADDR,
      S11_AXI_GEN_AWLEN          => S11_AXI_GEN_AWLEN,
      S11_AXI_GEN_AWSIZE         => S11_AXI_GEN_AWSIZE,
      S11_AXI_GEN_AWBURST        => S11_AXI_GEN_AWBURST,
      S11_AXI_GEN_AWLOCK         => S11_AXI_GEN_AWLOCK,
      S11_AXI_GEN_AWCACHE        => S11_AXI_GEN_AWCACHE,
      S11_AXI_GEN_AWPROT         => S11_AXI_GEN_AWPROT,
      S11_AXI_GEN_AWQOS          => S11_AXI_GEN_AWQOS,
      S11_AXI_GEN_AWVALID        => S11_AXI_GEN_AWVALID,
      S11_AXI_GEN_AWREADY        => S11_AXI_GEN_AWREADY,
      
      S11_AXI_GEN_WDATA          => S11_AXI_GEN_WDATA,
      S11_AXI_GEN_WSTRB          => S11_AXI_GEN_WSTRB,
      S11_AXI_GEN_WLAST          => S11_AXI_GEN_WLAST,
      S11_AXI_GEN_WVALID         => S11_AXI_GEN_WVALID,
      S11_AXI_GEN_WREADY         => S11_AXI_GEN_WREADY,
      
      S11_AXI_GEN_BRESP          => S11_AXI_GEN_BRESP,
      S11_AXI_GEN_BID            => S11_AXI_GEN_BID,
      S11_AXI_GEN_BVALID         => S11_AXI_GEN_BVALID,
      S11_AXI_GEN_BREADY         => S11_AXI_GEN_BREADY,
      
      S11_AXI_GEN_ARID           => S11_AXI_GEN_ARID,
      S11_AXI_GEN_ARADDR         => S11_AXI_GEN_ARADDR,
      S11_AXI_GEN_ARLEN          => S11_AXI_GEN_ARLEN,
      S11_AXI_GEN_ARSIZE         => S11_AXI_GEN_ARSIZE,
      S11_AXI_GEN_ARBURST        => S11_AXI_GEN_ARBURST,
      S11_AXI_GEN_ARLOCK         => S11_AXI_GEN_ARLOCK,
      S11_AXI_GEN_ARCACHE        => S11_AXI_GEN_ARCACHE,
      S11_AXI_GEN_ARPROT         => S11_AXI_GEN_ARPROT,
      S11_AXI_GEN_ARQOS          => S11_AXI_GEN_ARQOS,
      S11_AXI_GEN_ARVALID        => S11_AXI_GEN_ARVALID,
      S11_AXI_GEN_ARREADY        => S11_AXI_GEN_ARREADY,
      
      S11_AXI_GEN_RID            => S11_AXI_GEN_RID,
      S11_AXI_GEN_RDATA          => S11_AXI_GEN_RDATA,
      S11_AXI_GEN_RRESP          => S11_AXI_GEN_RRESP,
      S11_AXI_GEN_RLAST          => S11_AXI_GEN_RLAST,
      S11_AXI_GEN_RVALID         => S11_AXI_GEN_RVALID,
      S11_AXI_GEN_RREADY         => S11_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #12 Slave Signals.
      
      S12_AXI_GEN_AWID           => S12_AXI_GEN_AWID,
      S12_AXI_GEN_AWADDR         => S12_AXI_GEN_AWADDR,
      S12_AXI_GEN_AWLEN          => S12_AXI_GEN_AWLEN,
      S12_AXI_GEN_AWSIZE         => S12_AXI_GEN_AWSIZE,
      S12_AXI_GEN_AWBURST        => S12_AXI_GEN_AWBURST,
      S12_AXI_GEN_AWLOCK         => S12_AXI_GEN_AWLOCK,
      S12_AXI_GEN_AWCACHE        => S12_AXI_GEN_AWCACHE,
      S12_AXI_GEN_AWPROT         => S12_AXI_GEN_AWPROT,
      S12_AXI_GEN_AWQOS          => S12_AXI_GEN_AWQOS,
      S12_AXI_GEN_AWVALID        => S12_AXI_GEN_AWVALID,
      S12_AXI_GEN_AWREADY        => S12_AXI_GEN_AWREADY,
      
      S12_AXI_GEN_WDATA          => S12_AXI_GEN_WDATA,
      S12_AXI_GEN_WSTRB          => S12_AXI_GEN_WSTRB,
      S12_AXI_GEN_WLAST          => S12_AXI_GEN_WLAST,
      S12_AXI_GEN_WVALID         => S12_AXI_GEN_WVALID,
      S12_AXI_GEN_WREADY         => S12_AXI_GEN_WREADY,
      
      S12_AXI_GEN_BRESP          => S12_AXI_GEN_BRESP,
      S12_AXI_GEN_BID            => S12_AXI_GEN_BID,
      S12_AXI_GEN_BVALID         => S12_AXI_GEN_BVALID,
      S12_AXI_GEN_BREADY         => S12_AXI_GEN_BREADY,
      
      S12_AXI_GEN_ARID           => S12_AXI_GEN_ARID,
      S12_AXI_GEN_ARADDR         => S12_AXI_GEN_ARADDR,
      S12_AXI_GEN_ARLEN          => S12_AXI_GEN_ARLEN,
      S12_AXI_GEN_ARSIZE         => S12_AXI_GEN_ARSIZE,
      S12_AXI_GEN_ARBURST        => S12_AXI_GEN_ARBURST,
      S12_AXI_GEN_ARLOCK         => S12_AXI_GEN_ARLOCK,
      S12_AXI_GEN_ARCACHE        => S12_AXI_GEN_ARCACHE,
      S12_AXI_GEN_ARPROT         => S12_AXI_GEN_ARPROT,
      S12_AXI_GEN_ARQOS          => S12_AXI_GEN_ARQOS,
      S12_AXI_GEN_ARVALID        => S12_AXI_GEN_ARVALID,
      S12_AXI_GEN_ARREADY        => S12_AXI_GEN_ARREADY,
      
      S12_AXI_GEN_RID            => S12_AXI_GEN_RID,
      S12_AXI_GEN_RDATA          => S12_AXI_GEN_RDATA,
      S12_AXI_GEN_RRESP          => S12_AXI_GEN_RRESP,
      S12_AXI_GEN_RLAST          => S12_AXI_GEN_RLAST,
      S12_AXI_GEN_RVALID         => S12_AXI_GEN_RVALID,
      S12_AXI_GEN_RREADY         => S12_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #13 Slave Signals.
      
      S13_AXI_GEN_AWID           => S13_AXI_GEN_AWID,
      S13_AXI_GEN_AWADDR         => S13_AXI_GEN_AWADDR,
      S13_AXI_GEN_AWLEN          => S13_AXI_GEN_AWLEN,
      S13_AXI_GEN_AWSIZE         => S13_AXI_GEN_AWSIZE,
      S13_AXI_GEN_AWBURST        => S13_AXI_GEN_AWBURST,
      S13_AXI_GEN_AWLOCK         => S13_AXI_GEN_AWLOCK,
      S13_AXI_GEN_AWCACHE        => S13_AXI_GEN_AWCACHE,
      S13_AXI_GEN_AWPROT         => S13_AXI_GEN_AWPROT,
      S13_AXI_GEN_AWQOS          => S13_AXI_GEN_AWQOS,
      S13_AXI_GEN_AWVALID        => S13_AXI_GEN_AWVALID,
      S13_AXI_GEN_AWREADY        => S13_AXI_GEN_AWREADY,
      
      S13_AXI_GEN_WDATA          => S13_AXI_GEN_WDATA,
      S13_AXI_GEN_WSTRB          => S13_AXI_GEN_WSTRB,
      S13_AXI_GEN_WLAST          => S13_AXI_GEN_WLAST,
      S13_AXI_GEN_WVALID         => S13_AXI_GEN_WVALID,
      S13_AXI_GEN_WREADY         => S13_AXI_GEN_WREADY,
      
      S13_AXI_GEN_BRESP          => S13_AXI_GEN_BRESP,
      S13_AXI_GEN_BID            => S13_AXI_GEN_BID,
      S13_AXI_GEN_BVALID         => S13_AXI_GEN_BVALID,
      S13_AXI_GEN_BREADY         => S13_AXI_GEN_BREADY,
      
      S13_AXI_GEN_ARID           => S13_AXI_GEN_ARID,
      S13_AXI_GEN_ARADDR         => S13_AXI_GEN_ARADDR,
      S13_AXI_GEN_ARLEN          => S13_AXI_GEN_ARLEN,
      S13_AXI_GEN_ARSIZE         => S13_AXI_GEN_ARSIZE,
      S13_AXI_GEN_ARBURST        => S13_AXI_GEN_ARBURST,
      S13_AXI_GEN_ARLOCK         => S13_AXI_GEN_ARLOCK,
      S13_AXI_GEN_ARCACHE        => S13_AXI_GEN_ARCACHE,
      S13_AXI_GEN_ARPROT         => S13_AXI_GEN_ARPROT,
      S13_AXI_GEN_ARQOS          => S13_AXI_GEN_ARQOS,
      S13_AXI_GEN_ARVALID        => S13_AXI_GEN_ARVALID,
      S13_AXI_GEN_ARREADY        => S13_AXI_GEN_ARREADY,
      
      S13_AXI_GEN_RID            => S13_AXI_GEN_RID,
      S13_AXI_GEN_RDATA          => S13_AXI_GEN_RDATA,
      S13_AXI_GEN_RRESP          => S13_AXI_GEN_RRESP,
      S13_AXI_GEN_RLAST          => S13_AXI_GEN_RLAST,
      S13_AXI_GEN_RVALID         => S13_AXI_GEN_RVALID,
      S13_AXI_GEN_RREADY         => S13_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #14 Slave Signals.
      
      S14_AXI_GEN_AWID           => S14_AXI_GEN_AWID,
      S14_AXI_GEN_AWADDR         => S14_AXI_GEN_AWADDR,
      S14_AXI_GEN_AWLEN          => S14_AXI_GEN_AWLEN,
      S14_AXI_GEN_AWSIZE         => S14_AXI_GEN_AWSIZE,
      S14_AXI_GEN_AWBURST        => S14_AXI_GEN_AWBURST,
      S14_AXI_GEN_AWLOCK         => S14_AXI_GEN_AWLOCK,
      S14_AXI_GEN_AWCACHE        => S14_AXI_GEN_AWCACHE,
      S14_AXI_GEN_AWPROT         => S14_AXI_GEN_AWPROT,
      S14_AXI_GEN_AWQOS          => S14_AXI_GEN_AWQOS,
      S14_AXI_GEN_AWVALID        => S14_AXI_GEN_AWVALID,
      S14_AXI_GEN_AWREADY        => S14_AXI_GEN_AWREADY,
      
      S14_AXI_GEN_WDATA          => S14_AXI_GEN_WDATA,
      S14_AXI_GEN_WSTRB          => S14_AXI_GEN_WSTRB,
      S14_AXI_GEN_WLAST          => S14_AXI_GEN_WLAST,
      S14_AXI_GEN_WVALID         => S14_AXI_GEN_WVALID,
      S14_AXI_GEN_WREADY         => S14_AXI_GEN_WREADY,
      
      S14_AXI_GEN_BRESP          => S14_AXI_GEN_BRESP,
      S14_AXI_GEN_BID            => S14_AXI_GEN_BID,
      S14_AXI_GEN_BVALID         => S14_AXI_GEN_BVALID,
      S14_AXI_GEN_BREADY         => S14_AXI_GEN_BREADY,
      
      S14_AXI_GEN_ARID           => S14_AXI_GEN_ARID,
      S14_AXI_GEN_ARADDR         => S14_AXI_GEN_ARADDR,
      S14_AXI_GEN_ARLEN          => S14_AXI_GEN_ARLEN,
      S14_AXI_GEN_ARSIZE         => S14_AXI_GEN_ARSIZE,
      S14_AXI_GEN_ARBURST        => S14_AXI_GEN_ARBURST,
      S14_AXI_GEN_ARLOCK         => S14_AXI_GEN_ARLOCK,
      S14_AXI_GEN_ARCACHE        => S14_AXI_GEN_ARCACHE,
      S14_AXI_GEN_ARPROT         => S14_AXI_GEN_ARPROT,
      S14_AXI_GEN_ARQOS          => S14_AXI_GEN_ARQOS,
      S14_AXI_GEN_ARVALID        => S14_AXI_GEN_ARVALID,
      S14_AXI_GEN_ARREADY        => S14_AXI_GEN_ARREADY,
      
      S14_AXI_GEN_RID            => S14_AXI_GEN_RID,
      S14_AXI_GEN_RDATA          => S14_AXI_GEN_RDATA,
      S14_AXI_GEN_RRESP          => S14_AXI_GEN_RRESP,
      S14_AXI_GEN_RLAST          => S14_AXI_GEN_RLAST,
      S14_AXI_GEN_RVALID         => S14_AXI_GEN_RVALID,
      S14_AXI_GEN_RREADY         => S14_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Generic AXI4/ACE Interface #15 Slave Signals.
      
      S15_AXI_GEN_AWID           => S15_AXI_GEN_AWID,
      S15_AXI_GEN_AWADDR         => S15_AXI_GEN_AWADDR,
      S15_AXI_GEN_AWLEN          => S15_AXI_GEN_AWLEN,
      S15_AXI_GEN_AWSIZE         => S15_AXI_GEN_AWSIZE,
      S15_AXI_GEN_AWBURST        => S15_AXI_GEN_AWBURST,
      S15_AXI_GEN_AWLOCK         => S15_AXI_GEN_AWLOCK,
      S15_AXI_GEN_AWCACHE        => S15_AXI_GEN_AWCACHE,
      S15_AXI_GEN_AWPROT         => S15_AXI_GEN_AWPROT,
      S15_AXI_GEN_AWQOS          => S15_AXI_GEN_AWQOS,
      S15_AXI_GEN_AWVALID        => S15_AXI_GEN_AWVALID,
      S15_AXI_GEN_AWREADY        => S15_AXI_GEN_AWREADY,
      
      S15_AXI_GEN_WDATA          => S15_AXI_GEN_WDATA,
      S15_AXI_GEN_WSTRB          => S15_AXI_GEN_WSTRB,
      S15_AXI_GEN_WLAST          => S15_AXI_GEN_WLAST,
      S15_AXI_GEN_WVALID         => S15_AXI_GEN_WVALID,
      S15_AXI_GEN_WREADY         => S15_AXI_GEN_WREADY,
      
      S15_AXI_GEN_BRESP          => S15_AXI_GEN_BRESP,
      S15_AXI_GEN_BID            => S15_AXI_GEN_BID,
      S15_AXI_GEN_BVALID         => S15_AXI_GEN_BVALID,
      S15_AXI_GEN_BREADY         => S15_AXI_GEN_BREADY,
      
      S15_AXI_GEN_ARID           => S15_AXI_GEN_ARID,
      S15_AXI_GEN_ARADDR         => S15_AXI_GEN_ARADDR,
      S15_AXI_GEN_ARLEN          => S15_AXI_GEN_ARLEN,
      S15_AXI_GEN_ARSIZE         => S15_AXI_GEN_ARSIZE,
      S15_AXI_GEN_ARBURST        => S15_AXI_GEN_ARBURST,
      S15_AXI_GEN_ARLOCK         => S15_AXI_GEN_ARLOCK,
      S15_AXI_GEN_ARCACHE        => S15_AXI_GEN_ARCACHE,
      S15_AXI_GEN_ARPROT         => S15_AXI_GEN_ARPROT,
      S15_AXI_GEN_ARQOS          => S15_AXI_GEN_ARQOS,
      S15_AXI_GEN_ARVALID        => S15_AXI_GEN_ARVALID,
      S15_AXI_GEN_ARREADY        => S15_AXI_GEN_ARREADY,
      
      S15_AXI_GEN_RID            => S15_AXI_GEN_RID,
      S15_AXI_GEN_RDATA          => S15_AXI_GEN_RDATA,
      S15_AXI_GEN_RRESP          => S15_AXI_GEN_RRESP,
      S15_AXI_GEN_RLAST          => S15_AXI_GEN_RLAST,
      S15_AXI_GEN_RVALID         => S15_AXI_GEN_RVALID,
      S15_AXI_GEN_RREADY         => S15_AXI_GEN_RREADY,
      
      
      -- ---------------------------------------------------
      -- Control If Transactions.
      
      ctrl_arbiter_allow        => ctrl_arbiter_allow,
      ctrl_access               => ctrl_access,
      ctrl_ready                => ctrl_ready,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_access_done          => ctrl_access_done,
      
      
      -- ---------------------------------------------------
      -- Lookup signals.
      
      lookup_piperun            => lookup_piperun,
      
      lookup_write_data_ready   => lookup_write_data_ready,
      
      lookup_read_done          => lookup_read_done,
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      update_write_data_ready   => update_write_data_ready,
      
      
      -- ---------------------------------------------------
      -- Update signals (to Ports).
      
      -- Write miss response
      update_ext_bresp_info     => update_ext_bresp_info,
      update_ext_bresp_ready    => update_ext_bresp_ready,
      
      
      -- ---------------------------------------------------
      -- Access signals (to Lookup/Update).
      
      access_valid              => access_valid,
      access_info               => access_info,
      
      access_data_info          => access_data_info,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      => lookup_read_data_new,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          => read_info_status,
      read_data_status          => read_data_status,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (Read Data).
      
      lookup_read_data_info     => lookup_read_data_info,
      lookup_read_data_ready    => lookup_read_data_ready,
      
      
      -- ---------------------------------------------------
      -- Update signals (Read Data).
      
      update_read_data_info     => update_read_data_info,
      update_read_data_ready    => update_read_data_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      => stat_reset,
      stat_enable                     => stat_enable,
      
      -- Optimized ports.
      stat_s_axi_rd_segments          => stat_s_axi_rd_segments,
      stat_s_axi_wr_segments          => stat_s_axi_wr_segments,
      stat_s_axi_rip                  => stat_s_axi_rip,
      stat_s_axi_r                    => stat_s_axi_r,
      stat_s_axi_bip                  => stat_s_axi_bip,
      stat_s_axi_bp                   => stat_s_axi_bp,
      stat_s_axi_wip                  => stat_s_axi_wip,
      stat_s_axi_w                    => stat_s_axi_w,
      stat_s_axi_rd_latency           => stat_s_axi_rd_latency,
      stat_s_axi_wr_latency           => stat_s_axi_wr_latency,
      stat_s_axi_rd_latency_conf      => stat_s_axi_rd_latency_conf,
      stat_s_axi_wr_latency_conf      => stat_s_axi_wr_latency_conf,
  
      -- Generic ports.
      stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments,
      stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments,
      stat_s_axi_gen_rip              => stat_s_axi_gen_rip,
      stat_s_axi_gen_r                => stat_s_axi_gen_r,
      stat_s_axi_gen_bip              => stat_s_axi_gen_bip,
      stat_s_axi_gen_bp               => stat_s_axi_gen_bp,
      stat_s_axi_gen_wip              => stat_s_axi_gen_wip,
      stat_s_axi_gen_w                => stat_s_axi_gen_w,
      stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency,
      stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency,
      stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf,
      stat_s_axi_gen_wr_latency_conf  =>stat_s_axi_gen_wr_latency_conf ,
      
      -- Arbiter
      stat_arb_valid                  => stat_arb_valid,
      stat_arb_concurrent_accesses    => stat_arb_concurrent_accesses,
      stat_arb_opt_read_blocked       => stat_arb_opt_read_blocked,
      stat_arb_gen_read_blocked       => stat_arb_gen_read_blocked,
      
      -- Access
      stat_access_valid               => stat_access_valid,
      stat_access_stall               => stat_access_stall,
      stat_access_fetch_stall         => stat_access_fetch_stall,
      stat_access_req_stall           => stat_access_req_stall,
      stat_access_act_stall           => stat_access_act_stall,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => frontend_assert,
      
      
      -- ---------------------------------------------------
      -- Debug signals.
      
      OPT_IF0_DEBUG             => OPT_IF0_DEBUG,
      OPT_IF1_DEBUG             => OPT_IF1_DEBUG,
      OPT_IF2_DEBUG             => OPT_IF2_DEBUG,
      OPT_IF3_DEBUG             => OPT_IF3_DEBUG,
      OPT_IF4_DEBUG             => OPT_IF4_DEBUG,
      OPT_IF5_DEBUG             => OPT_IF5_DEBUG,
      OPT_IF6_DEBUG             => OPT_IF6_DEBUG,
      OPT_IF7_DEBUG             => OPT_IF7_DEBUG,
      OPT_IF8_DEBUG             => OPT_IF8_DEBUG,
      OPT_IF9_DEBUG             => OPT_IF9_DEBUG,
      OPT_IF10_DEBUG            => OPT_IF10_DEBUG,
      OPT_IF11_DEBUG            => OPT_IF11_DEBUG,
      OPT_IF12_DEBUG            => OPT_IF12_DEBUG,
      OPT_IF13_DEBUG            => OPT_IF13_DEBUG,
      OPT_IF14_DEBUG            => OPT_IF14_DEBUG,
      OPT_IF15_DEBUG            => OPT_IF15_DEBUG,
      GEN_IF0_DEBUG             => GEN_IF0_DEBUG,
      GEN_IF1_DEBUG             => GEN_IF1_DEBUG,
      GEN_IF2_DEBUG             => GEN_IF2_DEBUG,
      GEN_IF3_DEBUG             => GEN_IF3_DEBUG,
      GEN_IF4_DEBUG             => GEN_IF4_DEBUG,
      GEN_IF5_DEBUG             => GEN_IF5_DEBUG,
      GEN_IF6_DEBUG             => GEN_IF6_DEBUG,
      GEN_IF7_DEBUG             => GEN_IF7_DEBUG,
      GEN_IF8_DEBUG             => GEN_IF8_DEBUG,
      GEN_IF9_DEBUG             => GEN_IF9_DEBUG,
      GEN_IF10_DEBUG            => GEN_IF10_DEBUG,
      GEN_IF11_DEBUG            => GEN_IF11_DEBUG,
      GEN_IF12_DEBUG            => GEN_IF12_DEBUG,
      GEN_IF13_DEBUG            => GEN_IF13_DEBUG,
      GEN_IF14_DEBUG            => GEN_IF14_DEBUG,
      GEN_IF15_DEBUG            => GEN_IF15_DEBUG,
      ARBITER_DEBUG             => ARBITER_DEBUG_I,
      ACCESS_DEBUG              => ACCESS_DEBUG1_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Cache Core
  -----------------------------------------------------------------------------
  
  CC: sc_cache_core
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG_BOOL,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- IP Specific.
      C_PIPELINE_LU_READ_DATA   => C_PIPELINE_LU_READ_DATA,
      C_BASEADDR                => C_BASEADDR,
      C_HIGHADDR                => C_HIGHADDR,
      C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
      C_NUM_GENERIC_PORTS       => C_NUM_GENERIC_PORTS,
      C_NUM_PORTS               => C_NUM_PORTS,
      C_NUM_INTERNAL_PORTS      => C_NUM_INTERNAL_PORTS,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
      C_ENABLE_EX_MON           => C_ENABLE_EX_MON,
      C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
      C_ENABLE_EARLY_BRESP      => C_ENABLE_EARLY_BRESP,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
      C_ID_WIDTH                => C_ID_WIDTH,
      C_SUPPORT_SNOOP_FILTER    => C_SUPPORT_SNOOP_FILTER,
      C_KEEP_SHARED_WRITE       => C_KEEP_SHARED_WRITE,
      C_READ_ONLY_UNIQUE        => C_READ_ONLY_UNIQUE,
      C_READ_EXCLUSIVE_CLEAN    => C_READ_EXCLUSIVE_CLEAN,
      C_KEEP_BUFFERABLE         => C_KEEP_BUFFERABLE,
      
      -- Data type and settings specific.
      C_LRU_ADDR_BITS           => C_LRU_ADDR_BITS,
      C_TAG_SIZE                => C_TAG_SIZE,
      C_NUM_STATUS_BITS         => C_NUM_STATUS_BITS,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_DATA_ADDR_WIDTH   => C_CACHE_DATA_ADDR_WIDTH,
      C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
      C_EXTERNAL_DATA_ADDR_WIDTH=> C_EXTERNAL_DATA_ADDR_WIDTH,
      C_ADDR_VALID_HI           => C_ADDR_VALID_POS'high,
      C_ADDR_VALID_LO           => C_ADDR_VALID_POS'low,
      C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_POS'high,
      C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_POS'low,
      C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
      C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
      C_ADDR_EXT_DATA_HI        => C_ADDR_EXT_DATA_POS'high,
      C_ADDR_EXT_DATA_LO        => C_ADDR_EXT_DATA_POS'low,
      C_ADDR_DATA_HI            => C_ADDR_DATA_POS'high,
      C_ADDR_DATA_LO            => C_ADDR_DATA_POS'low,
      C_ADDR_TAG_HI             => C_ADDR_TAG_POS'high,
      C_ADDR_TAG_LO             => C_ADDR_TAG_POS'low,
      C_ADDR_FULL_LINE_HI       => C_ADDR_FULL_LINE_POS'high,
      C_ADDR_FULL_LINE_LO       => C_ADDR_FULL_LINE_POS'low,
      C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
      C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
      C_ADDR_EXT_WORD_HI        => C_ADDR_EXT_WORD_POS'high,
      C_ADDR_EXT_WORD_LO        => C_ADDR_EXT_WORD_POS'low,
      C_ADDR_WORD_HI            => C_ADDR_WORD_POS'high,
      C_ADDR_WORD_LO            => C_ADDR_WORD_POS'low,
      C_ADDR_EXT_BYTE_HI        => C_ADDR_EXT_BYTE_POS'high,
      C_ADDR_EXT_BYTE_LO        => C_ADDR_EXT_BYTE_POS'low,
      C_ADDR_BYTE_HI            => C_ADDR_BYTE_POS'high,
      C_ADDR_BYTE_LO            => C_ADDR_BYTE_POS'low,
      C_WAY_BIT_HI              => C_WAY_BIT_POS'high,
      C_WAY_BIT_LO              => C_WAY_BIT_POS'low
    )
    port map (
      -- ---------------------------------------------------
      -- Common signals.
      ACLK                      => ACLK,
      ARESET                    => ARESET,
      
      
      -- ---------------------------------------------------
      -- Access signals.
      
      access_valid              => access_valid,
      access_info               => access_info,
      
      access_data_info          => access_data_info,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read request).
      
      lookup_read_data_new      => lookup_read_data_new,
      
      
      -- ---------------------------------------------------
      -- Internal Interface Signals (Read Data).
      
      read_info_status          => read_info_status,
      read_data_status          => read_data_status,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Access).
      
      lookup_piperun            => lookup_piperun,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Frontend).
      
      
      lookup_read_data_info     => lookup_read_data_info,
      
      lookup_write_data_ready   => lookup_write_data_ready,
      
      
      -- ---------------------------------------------------
      -- Lookup signals (to Arbiter).
      
      lookup_read_done          => lookup_read_done,
      
      
      -- ---------------------------------------------------
      -- Update signals (to Frontend).
      
      -- Read miss
      update_read_data_info     => update_read_data_info,
      update_read_data_ready    => update_read_data_ready,
      
      -- Write Miss
      update_write_data_ready   => update_write_data_ready,
      
      -- Write miss response
      update_ext_bresp_info     => update_ext_bresp_info,
      update_ext_bresp_ready    => update_ext_bresp_ready,
      
      
      -- ---------------------------------------------------
      -- Automatic Clean Information.
      
      update_auto_clean_push    => update_auto_clean_push,
      update_auto_clean_addr    => update_auto_clean_addr,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_lookup_done          => ctrl_lookup_done,
      ctrl_update_done          => ctrl_update_done,
      
      
      -- ---------------------------------------------------
      -- Update signals (to Backend).
      
      read_req_info             => read_req_info,
      read_req_ready            => read_req_ready,
      
      write_req_info            => write_req_info,
      write_req_ready           => write_req_ready,
      
      write_data_info           => write_data_info,
      write_data_ready          => write_data_ready,
      write_data_almost_full    => write_data_almost_full,
      write_data_full           => write_data_full,
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   => be_writeunique_inflight,
      be_writeback_inflight     => be_writeback_inflight,
      
      
      -- ---------------------------------------------------
      -- Backend signals.
      
      backend_wr_resp_info      => backend_wr_resp_info,
      backend_wr_resp_ready     => backend_wr_resp_ready,
      backend_wr_resp_conf      => backend_wr_resp_conf,
      
      backend_rd_data_info      => backend_rd_data_info,
      backend_rd_data_ready     => backend_rd_data_ready,
      
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   => mst_snoop_fetch_piperun,
      mst_snoop_fetch_info      => mst_snoop_fetch_info,
      mst_snoop_mem_piperun     => mst_snoop_mem_piperun,
      mst_snoop_mem_info        => mst_snoop_mem_info,
      mst_snoop_check_piperun   => mst_snoop_check_piperun,
      mst_snoop_check_info      => mst_snoop_check_info,
      
      mst_snoop_fetch_ack_info  => mst_snoop_fetch_ack_info,
      mst_snoop_mem_ack_info    => mst_snoop_mem_ack_info,
      mst_snoop_check_ack_info  => mst_snoop_check_ack_info,
      mst_snoop_update_ack_info => mst_snoop_update_ack_info,
      
      mst_core_fetch_hazard     => mst_core_fetch_hazard,
      mst_core_mem_hazard       => mst_core_mem_hazard,
      mst_core_check_hazard     => mst_core_check_hazard,
      mst_core_update_hazard    => mst_core_update_hazard,
      
      mst_snoop_mem_rm_alloc    => mst_snoop_mem_rm_alloc,
      mst_snoop_check_rm_alloc  => mst_snoop_check_rm_alloc,
      
      mst_snoop_tag_valid       => mst_snoop_tag_valid,
      mst_snoop_tag_way         => mst_snoop_tag_way,
      mst_snoop_tag_info        => mst_snoop_tag_info,
      mst_snoop_tag_stall       => mst_snoop_tag_stall,
      
      mst_snoop_sdr_push        => mst_snoop_sdr_push,
      mst_snoop_sdr_info        => mst_snoop_sdr_info,
      mst_snoop_sdr_empty       => mst_snoop_sdr_empty,
      mst_snoop_sdr_full        => mst_snoop_sdr_full,
      
      mst_core_update_data_info => mst_core_update_data_info,
      mst_core_update_data_ready=> mst_core_update_data_ready,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      => stat_reset,
      stat_enable                     => stat_enable,
      
      -- Lookup
      stat_lu_opt_write_hit           => stat_lu_opt_write_hit,
      stat_lu_opt_write_miss          => stat_lu_opt_write_miss,
      stat_lu_opt_write_miss_dirty    => stat_lu_opt_write_miss_dirty,
      stat_lu_opt_read_hit            => stat_lu_opt_read_hit,
      stat_lu_opt_read_miss           => stat_lu_opt_read_miss,
      stat_lu_opt_read_miss_dirty     => stat_lu_opt_read_miss_dirty,
      stat_lu_opt_locked_write_hit    => stat_lu_opt_locked_write_hit,
      stat_lu_opt_locked_read_hit     => stat_lu_opt_locked_read_hit,
      stat_lu_opt_first_write_hit     => stat_lu_opt_first_write_hit,
      
      stat_lu_gen_write_hit           => stat_lu_gen_write_hit,
      stat_lu_gen_write_miss          => stat_lu_gen_write_miss,
      stat_lu_gen_write_miss_dirty    => stat_lu_gen_write_miss_dirty,
      stat_lu_gen_read_hit            => stat_lu_gen_read_hit,
      stat_lu_gen_read_miss           => stat_lu_gen_read_miss,
      stat_lu_gen_read_miss_dirty     => stat_lu_gen_read_miss_dirty,
      stat_lu_gen_locked_write_hit    => stat_lu_gen_locked_write_hit,
      stat_lu_gen_locked_read_hit     => stat_lu_gen_locked_read_hit,
      stat_lu_gen_first_write_hit     => stat_lu_gen_first_write_hit,
      
      stat_lu_stall                   => stat_lu_stall,
      stat_lu_fetch_stall             => stat_lu_fetch_stall,
      stat_lu_mem_stall               => stat_lu_mem_stall,
      stat_lu_data_stall              => stat_lu_data_stall,
      stat_lu_data_hit_stall          => stat_lu_data_hit_stall,
      stat_lu_data_miss_stall         => stat_lu_data_miss_stall,
      
      -- Update
      stat_ud_stall                   => stat_ud_stall,
      stat_ud_tag_free                => stat_ud_tag_free,
      stat_ud_data_free               => stat_ud_data_free,
      stat_ud_ri                      => stat_ud_ri,
      stat_ud_r                       => stat_ud_r,
      stat_ud_e                       => stat_ud_e,
      stat_ud_bs                      => stat_ud_bs,
      stat_ud_wm                      => stat_ud_wm,
      stat_ud_wma                     => stat_ud_wma,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => cachecore_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      
      MEMORY_DEBUG1             => MEMORY_DEBUG1_I,
      MEMORY_DEBUG2             => MEMORY_DEBUG2_I,
      LOOKUP_DEBUG              => LOOKUP_DEBUG1_I,
      UPDATE_DEBUG1             => UPDATE_DEBUG1_I,
      UPDATE_DEBUG2             => UPDATE_DEBUG2_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Backend
  -----------------------------------------------------------------------------
  
  BE: sc_back_end
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG_BOOL,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_MEM_LAT_RD_DEPTH   => C_STAT_MEM_LAT_RD_DEPTH,
      C_STAT_MEM_LAT_WR_DEPTH   => C_STAT_MEM_LAT_WR_DEPTH,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      
      -- IP Specific.
      C_BASEADDR                => C_BASEADDR,
      C_HIGHADDR                => C_HIGHADDR,
      C_NUM_PORTS               => C_NUM_PORTS,
      C_NUM_MASTER_PORTS        => C_NUM_MASTER_PORTS,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
      C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
      C_EXTERNAL_DATA_WIDTH     => C_EXTERNAL_DATA_WIDTH,
      C_EXTERNAL_DATA_ADDR_WIDTH=> C_EXTERNAL_DATA_ADDR_WIDTH,
      C_OPTIMIZE_ORDER          => C_OPTIMIZE_ORDER,
      C_ORDER_PER_PORT          => C_ORDER_PER_PORT,
      C_NUM_ORDER_BINS          => C_NUM_ORDER_BINS,
      C_ORDER_BINS_ADDR_MASK    => C_ORDER_BINS_ADDR_MASK,
      C_ENABLE_SLV_WR_THROTTLE  => C_ENABLE_SLV_WR_THROTTLE,
      C_ENABLE_WB_EXTRACT       => C_ENABLE_WB_EXTRACT,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_SNOOP_KEEP_READ_SHARED  => C_SNOOP_KEEP_READ_SHARED,
      C_SNOOP_KEEP_READ_CLEAN   => C_SNOOP_KEEP_READ_CLEAN,
      C_SNOOP_KEEP_READ_NSD     => C_SNOOP_KEEP_READ_NSD,
      C_SNOOP_KEEP_CLEAN_SHARED => C_SNOOP_KEEP_CLEAN_SHARED,

      -- Data type and settings specific.
      C_ADDR_VALID_HI           => C_ADDR_VALID_POS'high,
      C_ADDR_VALID_LO           => C_ADDR_VALID_POS'low,
      C_ADDR_INTERNAL_HI        => C_ADDR_INTERNAL_POS'high,
      C_ADDR_INTERNAL_LO        => C_ADDR_INTERNAL_POS'low,
      C_ADDR_DIRECT_HI          => C_ADDR_DIRECT_POS'high,
      C_ADDR_DIRECT_LO          => C_ADDR_DIRECT_POS'low,
      C_ADDR_REQ_HI             => C_ADDR_REQ_POS'high,
      C_ADDR_REQ_LO             => C_ADDR_REQ_POS'low,
      C_ADDR_TAG_CONTENTS_HI    => C_ADDR_TAG_CONTENTS_POS'high,
      C_ADDR_TAG_CONTENTS_LO    => C_ADDR_TAG_CONTENTS_POS'low,
      C_ADDR_LINE_HI            => C_ADDR_LINE_POS'high,
      C_ADDR_LINE_LO            => C_ADDR_LINE_POS'low,
      C_ADDR_EXT_WORD_HI        => C_ADDR_EXT_WORD_POS'high,
      C_ADDR_EXT_WORD_LO        => C_ADDR_EXT_WORD_POS'low,
      C_ADDR_OFFSET_HI          => C_ADDR_OFFSET_POS'high,
      C_ADDR_OFFSET_LO          => C_ADDR_OFFSET_POS'low,
      
      -- AXI4/ACE Master Interface #0 specific.
      C_M0_AXI_THREAD_ID_WIDTH  => C_M0_AXI_THREAD_ID_WIDTH,
      C_M0_AXI_DATA_WIDTH       => C_M0_AXI_DATA_WIDTH,
      C_M0_AXI_ADDR_WIDTH       => C_M0_AXI_ADDR_WIDTH,
      C_M0_AXI_RRESP_WIDTH      => C_M0_AXI_RRESP_WIDTH,
      
      -- AXI4 Master Interface #1 specific.
      C_M1_AXI_THREAD_ID_WIDTH  => C_M1_AXI_THREAD_ID_WIDTH,
      C_M1_AXI_DATA_WIDTH       => C_M1_AXI_DATA_WIDTH,
      C_M1_AXI_ADDR_WIDTH       => C_M1_AXI_ADDR_WIDTH,
      C_M1_AXI_RRESP_WIDTH      => C_M1_AXI_RRESP_WIDTH,
      
      -- AXI4 Master Interface #2 specific.
      C_M2_AXI_THREAD_ID_WIDTH  => C_M2_AXI_THREAD_ID_WIDTH,
      C_M2_AXI_DATA_WIDTH       => C_M2_AXI_DATA_WIDTH,
      C_M2_AXI_ADDR_WIDTH       => C_M2_AXI_ADDR_WIDTH,
      C_M2_AXI_RRESP_WIDTH      => C_M2_AXI_RRESP_WIDTH,
      
      -- AXI4 Master Interface #3 specific.
      C_M3_AXI_THREAD_ID_WIDTH  => C_M3_AXI_THREAD_ID_WIDTH,
      C_M3_AXI_DATA_WIDTH       => C_M3_AXI_DATA_WIDTH,
      C_M3_AXI_ADDR_WIDTH       => C_M3_AXI_ADDR_WIDTH,
      C_M3_AXI_RRESP_WIDTH      => C_M3_AXI_RRESP_WIDTH
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals.
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
      
      
      -- ---------------------------------------------------
      -- Update signals.
      
      read_req_info             => read_req_info,
      read_req_ready            => read_req_ready,
      
      write_req_info            => write_req_info,
      write_req_ready           => write_req_ready,
      
      write_data_info           => write_data_info,
      write_data_ready          => write_data_ready,
      write_data_almost_full    => write_data_almost_full,
      write_data_full           => write_data_full,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Sync Request.
      
      ctrl_dvm_req              => ctrl_dvm_req,
      ctrl_dvm_done             => ctrl_dvm_done,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_backend_done         => ctrl_backend_done,
      ctrl_bar_req              => ctrl_bar_req,
      ctrl_bar_done             => ctrl_bar_done,
      ctrl_insert_running       => ctrl_insert_running,
      
      
      -- ---------------------------------------------------
      -- Status signals (to Lookup).
      
      be_writeunique_inflight   => be_writeunique_inflight,
      be_writeback_inflight     => be_writeback_inflight,
      
      
      -- ---------------------------------------------------
      -- Backend signals (to Update).
      
      backend_wr_resp_info      => backend_wr_resp_info,
      backend_wr_resp_ready     => backend_wr_resp_ready,
      backend_wr_resp_conf      => backend_wr_resp_conf,
      
      backend_rd_data_info      => backend_rd_data_info,
      backend_rd_data_ready     => backend_rd_data_ready,
  
      
      -- ---------------------------------------------------
      -- Master Snoop Interface Signals.
      
      mst_snoop_fetch_piperun   => mst_snoop_fetch_piperun,
      mst_snoop_fetch_info      => mst_snoop_fetch_info,
      mst_snoop_mem_piperun     => mst_snoop_mem_piperun,
      mst_snoop_mem_info        => mst_snoop_mem_info,
      mst_snoop_check_piperun   => mst_snoop_check_piperun,
      mst_snoop_check_info      => mst_snoop_check_info,
      
      mst_snoop_fetch_ack_info  => mst_snoop_fetch_ack_info,
      mst_snoop_mem_ack_info    => mst_snoop_mem_ack_info,
      mst_snoop_check_ack_info  => mst_snoop_check_ack_info,
      mst_snoop_update_ack_info => mst_snoop_update_ack_info,
      
      mst_core_fetch_hazard     => mst_core_fetch_hazard,
      mst_core_mem_hazard       => mst_core_mem_hazard,
      mst_core_check_hazard     => mst_core_check_hazard,
      mst_core_update_hazard    => mst_core_update_hazard,
      
      mst_snoop_mem_rm_alloc    => mst_snoop_mem_rm_alloc,
      mst_snoop_check_rm_alloc  => mst_snoop_check_rm_alloc,
      
      mst_snoop_tag_valid       => mst_snoop_tag_valid,
      mst_snoop_tag_way         => mst_snoop_tag_way,
      mst_snoop_tag_info        => mst_snoop_tag_info,
      mst_snoop_tag_stall       => mst_snoop_tag_stall,
      
      mst_snoop_sdr_push        => mst_snoop_sdr_push,
      mst_snoop_sdr_info        => mst_snoop_sdr_info,
      mst_snoop_sdr_empty       => mst_snoop_sdr_empty,
      mst_snoop_sdr_full        => mst_snoop_sdr_full,
      
      mst_core_update_data_info => mst_core_update_data_info,
      mst_core_update_data_ready=> mst_core_update_data_ready,
      
      
      -- ---------------------------------------------------
      -- AXI4/ACE Master Interface #0 Signals.
      
      M0_AXI_AWID               => M0_AXI_AWID,
      M0_AXI_AWADDR             => M0_AXI_AWADDR,
      M0_AXI_AWLEN              => M0_AXI_AWLEN,
      M0_AXI_AWSIZE             => M0_AXI_AWSIZE,
      M0_AXI_AWBURST            => M0_AXI_AWBURST,
      M0_AXI_AWLOCK             => M0_AXI_AWLOCK,
      M0_AXI_AWCACHE            => M0_AXI_AWCACHE,
      M0_AXI_AWPROT             => M0_AXI_AWPROT,
      M0_AXI_AWQOS              => M0_AXI_AWQOS,
      M0_AXI_AWVALID            => M0_AXI_AWVALID,
      M0_AXI_AWREADY            => M0_AXI_AWREADY,
      M0_AXI_AWDOMAIN           => M0_AXI_AWDOMAIN,
      M0_AXI_AWSNOOP            => M0_AXI_AWSNOOP,
      M0_AXI_AWBAR              => M0_AXI_AWBAR,
      
      M0_AXI_WDATA              => M0_AXI_WDATA,
      M0_AXI_WSTRB              => M0_AXI_WSTRB,
      M0_AXI_WLAST              => M0_AXI_WLAST,
      M0_AXI_WVALID             => M0_AXI_WVALID,
      M0_AXI_WREADY             => M0_AXI_WREADY,
      
      M0_AXI_BRESP              => M0_AXI_BRESP,
      M0_AXI_BID                => M0_AXI_BID,
      M0_AXI_BVALID             => M0_AXI_BVALID,
      M0_AXI_BREADY             => M0_AXI_BREADY,
      M0_AXI_WACK               => M0_AXI_WACK,
      
      M0_AXI_ARID               => M0_AXI_ARID,
      M0_AXI_ARADDR             => M0_AXI_ARADDR,
      M0_AXI_ARLEN              => M0_AXI_ARLEN,
      M0_AXI_ARSIZE             => M0_AXI_ARSIZE,
      M0_AXI_ARBURST            => M0_AXI_ARBURST,
      M0_AXI_ARLOCK             => M0_AXI_ARLOCK,
      M0_AXI_ARCACHE            => M0_AXI_ARCACHE,
      M0_AXI_ARPROT             => M0_AXI_ARPROT,
      M0_AXI_ARQOS              => M0_AXI_ARQOS,
      M0_AXI_ARVALID            => M0_AXI_ARVALID,
      M0_AXI_ARREADY            => M0_AXI_ARREADY,
      M0_AXI_ARDOMAIN           => M0_AXI_ARDOMAIN,
      M0_AXI_ARSNOOP            => M0_AXI_ARSNOOP,
      M0_AXI_ARBAR              => M0_AXI_ARBAR,
      
      M0_AXI_RID                => M0_AXI_RID,
      M0_AXI_RDATA              => M0_AXI_RDATA,
      M0_AXI_RRESP              => M0_AXI_RRESP,
      M0_AXI_RLAST              => M0_AXI_RLAST,
      M0_AXI_RVALID             => M0_AXI_RVALID,
      M0_AXI_RREADY             => M0_AXI_RREADY,
      M0_AXI_RACK               => M0_AXI_RACK,
      
      M0_AXI_ACVALID            => M0_AXI_ACVALID,
      M0_AXI_ACADDR             => M0_AXI_ACADDR,
      M0_AXI_ACSNOOP            => M0_AXI_ACSNOOP,
      M0_AXI_ACPROT             => M0_AXI_ACPROT,
      M0_AXI_ACREADY            => M0_AXI_ACREADY,
      
      M0_AXI_CRVALID            => M0_AXI_CRVALID,
      M0_AXI_CRRESP             => M0_AXI_CRRESP,
      M0_AXI_CRREADY            => M0_AXI_CRREADY,
      
      M0_AXI_CDVALID            => M0_AXI_CDVALID,
      M0_AXI_CDDATA             => M0_AXI_CDDATA,
      M0_AXI_CDLAST             => M0_AXI_CDLAST,
      M0_AXI_CDREADY            => M0_AXI_CDREADY,
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #1 Signals.
      
      M1_AXI_AWID               => M1_AXI_AWID,
      M1_AXI_AWADDR             => M1_AXI_AWADDR,
      M1_AXI_AWLEN              => M1_AXI_AWLEN,
      M1_AXI_AWSIZE             => M1_AXI_AWSIZE,
      M1_AXI_AWBURST            => M1_AXI_AWBURST,
      M1_AXI_AWLOCK             => M1_AXI_AWLOCK,
      M1_AXI_AWCACHE            => M1_AXI_AWCACHE,
      M1_AXI_AWPROT             => M1_AXI_AWPROT,
      M1_AXI_AWQOS              => M1_AXI_AWQOS,
      M1_AXI_AWVALID            => M1_AXI_AWVALID,
      M1_AXI_AWREADY            => M1_AXI_AWREADY,
      
      M1_AXI_WDATA              => M1_AXI_WDATA,
      M1_AXI_WSTRB              => M1_AXI_WSTRB,
      M1_AXI_WLAST              => M1_AXI_WLAST,
      M1_AXI_WVALID             => M1_AXI_WVALID,
      M1_AXI_WREADY             => M1_AXI_WREADY,
      
      M1_AXI_BRESP              => M1_AXI_BRESP,
      M1_AXI_BID                => M1_AXI_BID,
      M1_AXI_BVALID             => M1_AXI_BVALID,
      M1_AXI_BREADY             => M1_AXI_BREADY,
      
      M1_AXI_ARID               => M1_AXI_ARID,
      M1_AXI_ARADDR             => M1_AXI_ARADDR,
      M1_AXI_ARLEN              => M1_AXI_ARLEN,
      M1_AXI_ARSIZE             => M1_AXI_ARSIZE,
      M1_AXI_ARBURST            => M1_AXI_ARBURST,
      M1_AXI_ARLOCK             => M1_AXI_ARLOCK,
      M1_AXI_ARCACHE            => M1_AXI_ARCACHE,
      M1_AXI_ARPROT             => M1_AXI_ARPROT,
      M1_AXI_ARQOS              => M1_AXI_ARQOS,
      M1_AXI_ARVALID            => M1_AXI_ARVALID,
      M1_AXI_ARREADY            => M1_AXI_ARREADY,
      
      M1_AXI_RID                => M1_AXI_RID,
      M1_AXI_RDATA              => M1_AXI_RDATA,
      M1_AXI_RRESP              => M1_AXI_RRESP,
      M1_AXI_RLAST              => M1_AXI_RLAST,
      M1_AXI_RVALID             => M1_AXI_RVALID,
      M1_AXI_RREADY             => M1_AXI_RREADY,
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #2 Signals.
      
      M2_AXI_AWID               => M2_AXI_AWID,
      M2_AXI_AWADDR             => M2_AXI_AWADDR,
      M2_AXI_AWLEN              => M2_AXI_AWLEN,
      M2_AXI_AWSIZE             => M2_AXI_AWSIZE,
      M2_AXI_AWBURST            => M2_AXI_AWBURST,
      M2_AXI_AWLOCK             => M2_AXI_AWLOCK,
      M2_AXI_AWCACHE            => M2_AXI_AWCACHE,
      M2_AXI_AWPROT             => M2_AXI_AWPROT,
      M2_AXI_AWQOS              => M2_AXI_AWQOS,
      M2_AXI_AWVALID            => M2_AXI_AWVALID,
      M2_AXI_AWREADY            => M2_AXI_AWREADY,
      
      M2_AXI_WDATA              => M2_AXI_WDATA,
      M2_AXI_WSTRB              => M2_AXI_WSTRB,
      M2_AXI_WLAST              => M2_AXI_WLAST,
      M2_AXI_WVALID             => M2_AXI_WVALID,
      M2_AXI_WREADY             => M2_AXI_WREADY,
      
      M2_AXI_BRESP              => M2_AXI_BRESP,
      M2_AXI_BID                => M2_AXI_BID,
      M2_AXI_BVALID             => M2_AXI_BVALID,
      M2_AXI_BREADY             => M2_AXI_BREADY,
      
      M2_AXI_ARID               => M2_AXI_ARID,
      M2_AXI_ARADDR             => M2_AXI_ARADDR,
      M2_AXI_ARLEN              => M2_AXI_ARLEN,
      M2_AXI_ARSIZE             => M2_AXI_ARSIZE,
      M2_AXI_ARBURST            => M2_AXI_ARBURST,
      M2_AXI_ARLOCK             => M2_AXI_ARLOCK,
      M2_AXI_ARCACHE            => M2_AXI_ARCACHE,
      M2_AXI_ARPROT             => M2_AXI_ARPROT,
      M2_AXI_ARQOS              => M2_AXI_ARQOS,
      M2_AXI_ARVALID            => M2_AXI_ARVALID,
      M2_AXI_ARREADY            => M2_AXI_ARREADY,
      
      M2_AXI_RID                => M2_AXI_RID,
      M2_AXI_RDATA              => M2_AXI_RDATA,
      M2_AXI_RRESP              => M2_AXI_RRESP,
      M2_AXI_RLAST              => M2_AXI_RLAST,
      M2_AXI_RVALID             => M2_AXI_RVALID,
      M2_AXI_RREADY             => M2_AXI_RREADY,
      
      
      -- ---------------------------------------------------
      -- AXI4 Master Interface #3 Signals.
      
      M3_AXI_AWID               => M3_AXI_AWID,
      M3_AXI_AWADDR             => M3_AXI_AWADDR,
      M3_AXI_AWLEN              => M3_AXI_AWLEN,
      M3_AXI_AWSIZE             => M3_AXI_AWSIZE,
      M3_AXI_AWBURST            => M3_AXI_AWBURST,
      M3_AXI_AWLOCK             => M3_AXI_AWLOCK,
      M3_AXI_AWCACHE            => M3_AXI_AWCACHE,
      M3_AXI_AWPROT             => M3_AXI_AWPROT,
      M3_AXI_AWQOS              => M3_AXI_AWQOS,
      M3_AXI_AWVALID            => M3_AXI_AWVALID,
      M3_AXI_AWREADY            => M3_AXI_AWREADY,
      
      M3_AXI_WDATA              => M3_AXI_WDATA,
      M3_AXI_WSTRB              => M3_AXI_WSTRB,
      M3_AXI_WLAST              => M3_AXI_WLAST,
      M3_AXI_WVALID             => M3_AXI_WVALID,
      M3_AXI_WREADY             => M3_AXI_WREADY,
      
      M3_AXI_BRESP              => M3_AXI_BRESP,
      M3_AXI_BID                => M3_AXI_BID,
      M3_AXI_BVALID             => M3_AXI_BVALID,
      M3_AXI_BREADY             => M3_AXI_BREADY,
      
      M3_AXI_ARID               => M3_AXI_ARID,
      M3_AXI_ARADDR             => M3_AXI_ARADDR,
      M3_AXI_ARLEN              => M3_AXI_ARLEN,
      M3_AXI_ARSIZE             => M3_AXI_ARSIZE,
      M3_AXI_ARBURST            => M3_AXI_ARBURST,
      M3_AXI_ARLOCK             => M3_AXI_ARLOCK,
      M3_AXI_ARCACHE            => M3_AXI_ARCACHE,
      M3_AXI_ARPROT             => M3_AXI_ARPROT,
      M3_AXI_ARQOS              => M3_AXI_ARQOS,
      M3_AXI_ARVALID            => M3_AXI_ARVALID,
      M3_AXI_ARREADY            => M3_AXI_ARREADY,
      
      M3_AXI_RID                => M3_AXI_RID,
      M3_AXI_RDATA              => M3_AXI_RDATA,
      M3_AXI_RRESP              => M3_AXI_RRESP,
      M3_AXI_RLAST              => M3_AXI_RLAST,
      M3_AXI_RVALID             => M3_AXI_RVALID,
      M3_AXI_RREADY             => M3_AXI_RREADY,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                => stat_reset,
      stat_enable               => stat_enable,
      
      -- Backend
      stat_be_aw                => stat_be_aw,
      stat_be_w                 => stat_be_w,
      stat_be_ar                => stat_be_ar,
      stat_be_ar_search_depth   => stat_be_ar_search_depth,
      stat_be_ar_stall          => stat_be_ar_stall,
      stat_be_ar_protect_stall  => stat_be_ar_protect_stall,
      stat_be_rd_latency        => stat_be_rd_latency,
      stat_be_wr_latency        => stat_be_wr_latency,
      stat_be_rd_latency_conf   => stat_be_rd_latency_conf,
      stat_be_wr_latency_conf   => stat_be_wr_latency_conf,
      
      
      -- ---------------------------------------------------
      -- Assert Signals
      
      assert_error              => backend_assert,
      
      
      -- ---------------------------------------------------
      -- Debug Signals.
      BACKEND_DEBUG             => BACKEND_DEBUG_I,
      M_IF_DEBUG                => M_IF_DEBUG_I
    );
  
  
  -----------------------------------------------------------------------------
  -- Control port 
  -----------------------------------------------------------------------------
  
  AXI_Ctrl: sc_s_axi_ctrl_interface
    generic map(
      -- General.
      C_TARGET                  => C_TARGET,
      C_USE_DEBUG               => C_USE_DEBUG_BOOL,
      C_USE_ASSERTIONS          => C_USE_ASSERTIONS,
      C_USE_STATISTICS          => C_USE_STATISTICS,
      C_STAT_BITS               => C_STAT_BITS,
      C_STAT_BIG_BITS           => C_STAT_BIG_BITS,
      C_STAT_COUNTER_BITS       => C_STAT_COUNTER_BITS,
      C_STAT_MAX_CYCLE_WIDTH    => C_STAT_MAX_CYCLE_WIDTH,
      C_STAT_USE_STDDEV         => C_STAT_USE_STDDEV,
      C_ENABLE_CTRL             => C_ENABLE_CTRL,
      C_ENABLE_AUTOMATIC_CLEAN  => C_ENABLE_AUTOMATIC_CLEAN,
      C_AUTOMATIC_CLEAN_MODE    => C_AUTOMATIC_CLEAN_MODE,
      
      -- Data type and settings specific.
      C_ADDR_ALL_WAYS_HI        => C_ADDR_ALL_WAYS_POS'high,
      C_ADDR_ALL_WAYS_LO        => C_ADDR_ALL_WAYS_POS'low,
      
      -- IP Specific.
      C_ENABLE_STATISTICS       => C_ENABLE_STATISTICS,
      C_ENABLE_VERSION_REGISTER => C_ENABLE_VERSION_REGISTER,
      C_NUM_OPTIMIZED_PORTS     => C_NUM_OPTIMIZED_PORTS,
      C_NUM_GENERIC_PORTS       => C_NUM_GENERIC_PORTS,
      C_NUM_MASTER_PORTS        => C_NUM_MASTER_PORTS,
      C_ENABLE_COHERENCY        => C_ENABLE_COHERENCY,
      C_ENABLE_NON_SECURE       => C_ENABLE_NON_SECURE,
      C_ENABLE_EXCLUSIVE        => C_ENABLE_EXCLUSIVE,
      C_ENABLE_ERROR_HANDLING   => C_ENABLE_ERROR_HANDLING,
      C_NUM_WAYS                => C_NUM_WAYS,
      C_CACHE_DATA_WIDTH        => C_CACHE_DATA_WIDTH,
      C_CACHE_BLOCKS            => C_CACHE_BLOCKS,
      C_CACHE_LINE_LENGTH       => C_CACHE_LINE_LENGTH,
      C_CACHE_SIZE              => C_CACHE_SIZE,
      C_Lx_CACHE_LINE_LENGTH    => C_Lx_CACHE_LINE_LENGTH,
      C_Lx_CACHE_SIZE           => C_Lx_CACHE_SIZE,
      C_S_AXI_ADDR_WIDTH        => C_S_AXI_ADDR_WIDTH,
      C_M_AXI_ADDR_WIDTH        => C_M_AXI_ADDR_WIDTH,
      C_M_AXI_DATA_WIDTH        => C_EXTERNAL_DATA_WIDTH,
      
      -- AXI4 Interface Specific.
      C_S_AXI_CTRL_BASEADDR     => C_BASEADDR,
      C_S_AXI_CTRL_HIGHADDR     => C_HIGHADDR,
      C_S_AXI_CTRL_DATA_WIDTH   => C_S_AXI_CTRL_DATA_WIDTH,
      C_S_AXI_CTRL_ADDR_WIDTH   => C_S_AXI_CTRL_ADDR_WIDTH
    )
    port map(
      -- ---------------------------------------------------
      -- Common signals
      
      ACLK                      => ACLK,
      ARESET                    => ARESET,
      
      
      -- ---------------------------------------------------
      -- AXI4-Lite Slave Interface Signals
      
      -- AW-Channel
      S_AXI_CTRL_AWADDR         => S_AXI_CTRL_AWADDR,
      S_AXI_CTRL_AWPROT         => S_AXI_CTRL_AWPROT,
      S_AXI_CTRL_AWVALID        => S_AXI_CTRL_AWVALID,
      S_AXI_CTRL_AWREADY        => S_AXI_CTRL_AWREADY,
  
      -- W-Channel
      S_AXI_CTRL_WDATA          => S_AXI_CTRL_WDATA,
      S_AXI_CTRL_WVALID         => S_AXI_CTRL_WVALID,
      S_AXI_CTRL_WREADY         => S_AXI_CTRL_WREADY,
  
      -- B-Channel
      S_AXI_CTRL_BRESP          => S_AXI_CTRL_BRESP,
      S_AXI_CTRL_BVALID         => S_AXI_CTRL_BVALID,
      S_AXI_CTRL_BREADY         => S_AXI_CTRL_BREADY,
  
      -- AR-Channel
      S_AXI_CTRL_ARADDR         => S_AXI_CTRL_ARADDR,
      S_AXI_CTRL_ARPROT         => S_AXI_CTRL_ARPROT,
      S_AXI_CTRL_ARVALID        => S_AXI_CTRL_ARVALID,
      S_AXI_CTRL_ARREADY        => S_AXI_CTRL_ARREADY,
  
      -- R-Channel
      S_AXI_CTRL_RDATA          => S_AXI_CTRL_RDATA,
      S_AXI_CTRL_RRESP          => S_AXI_CTRL_RRESP,
      S_AXI_CTRL_RVALID         => S_AXI_CTRL_RVALID,
      S_AXI_CTRL_RREADY         => S_AXI_CTRL_RREADY,
  
      
      -- ---------------------------------------------------
      -- Control If Transactions.
      
      ctrl_arbiter_allow        => ctrl_arbiter_allow,
      ctrl_access               => ctrl_access,
      ctrl_ready                => ctrl_ready,
      
      
      -- ---------------------------------------------------
      -- Automatic Clean Information.
      
      update_auto_clean_push    => update_auto_clean_push,
      update_auto_clean_addr    => update_auto_clean_addr,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Barrier Request.
      
      ctrl_access_done                => ctrl_access_done,
      ctrl_lookup_done                => ctrl_lookup_done,
      ctrl_update_done                => ctrl_update_done,
      ctrl_backend_done               => ctrl_backend_done,
      ctrl_bar_req                    => ctrl_bar_req,
      ctrl_bar_done                   => ctrl_bar_done,
      ctrl_insert_running             => ctrl_insert_running,
      
      
      -- ---------------------------------------------------
      -- ACE Downstream Sync Request.
      
      ctrl_dvm_req                    => ctrl_dvm_req,
      ctrl_dvm_done                   => ctrl_dvm_done,
      
      
      -- ---------------------------------------------------
      -- Statistics Signals
      
      stat_reset                      => stat_reset,
      stat_enable                     => stat_enable,
      
      -- Optimized ports.
      stat_s_axi_rd_segments          => stat_s_axi_rd_segments,
      stat_s_axi_wr_segments          => stat_s_axi_wr_segments,
      stat_s_axi_rip                  => stat_s_axi_rip,
      stat_s_axi_r                    => stat_s_axi_r,
      stat_s_axi_bip                  => stat_s_axi_bip,
      stat_s_axi_bp                   => stat_s_axi_bp,
      stat_s_axi_wip                  => stat_s_axi_wip,
      stat_s_axi_w                    => stat_s_axi_w,
      stat_s_axi_rd_latency           => stat_s_axi_rd_latency,
      stat_s_axi_wr_latency           => stat_s_axi_wr_latency,
      stat_s_axi_rd_latency_conf      => stat_s_axi_rd_latency_conf,
      stat_s_axi_wr_latency_conf      => stat_s_axi_wr_latency_conf,
  
      -- Generic ports.
      stat_s_axi_gen_rd_segments      => stat_s_axi_gen_rd_segments,
      stat_s_axi_gen_wr_segments      => stat_s_axi_gen_wr_segments,
      stat_s_axi_gen_rip              => stat_s_axi_gen_rip,
      stat_s_axi_gen_r                => stat_s_axi_gen_r,
      stat_s_axi_gen_bip              => stat_s_axi_gen_bip,
      stat_s_axi_gen_bp               => stat_s_axi_gen_bp,
      stat_s_axi_gen_wip              => stat_s_axi_gen_wip,
      stat_s_axi_gen_w                => stat_s_axi_gen_w,
      stat_s_axi_gen_rd_latency       => stat_s_axi_gen_rd_latency,
      stat_s_axi_gen_wr_latency       => stat_s_axi_gen_wr_latency,
      stat_s_axi_gen_rd_latency_conf  => stat_s_axi_gen_rd_latency_conf,
      stat_s_axi_gen_wr_latency_conf  => stat_s_axi_gen_wr_latency_conf,
      
      -- Arbiter
      stat_arb_valid                  => stat_arb_valid,
      stat_arb_concurrent_accesses    => stat_arb_concurrent_accesses,
      stat_arb_opt_read_blocked       => stat_arb_opt_read_blocked,
      stat_arb_gen_read_blocked       => stat_arb_gen_read_blocked,
      
      -- Access
      stat_access_valid               => stat_access_valid,
      stat_access_stall               => stat_access_stall,
      stat_access_fetch_stall         => stat_access_fetch_stall,
      stat_access_req_stall           => stat_access_req_stall,
      stat_access_act_stall           => stat_access_act_stall,
      
      -- Lookup
      stat_lu_opt_write_hit           => stat_lu_opt_write_hit,
      stat_lu_opt_write_miss          => stat_lu_opt_write_miss,
      stat_lu_opt_write_miss_dirty    => stat_lu_opt_write_miss_dirty,
      stat_lu_opt_read_hit            => stat_lu_opt_read_hit,
      stat_lu_opt_read_miss           => stat_lu_opt_read_miss,
      stat_lu_opt_read_miss_dirty     => stat_lu_opt_read_miss_dirty,
      stat_lu_opt_locked_write_hit    => stat_lu_opt_locked_write_hit,
      stat_lu_opt_locked_read_hit     => stat_lu_opt_locked_read_hit,
      stat_lu_opt_first_write_hit     => stat_lu_opt_first_write_hit,
      
      stat_lu_gen_write_hit           => stat_lu_gen_write_hit,
      stat_lu_gen_write_miss          => stat_lu_gen_write_miss,
      stat_lu_gen_write_miss_dirty    => stat_lu_gen_write_miss_dirty,
      stat_lu_gen_read_hit            => stat_lu_gen_read_hit,
      stat_lu_gen_read_miss           => stat_lu_gen_read_miss,
      stat_lu_gen_read_miss_dirty     => stat_lu_gen_read_miss_dirty,
      stat_lu_gen_locked_write_hit    => stat_lu_gen_locked_write_hit,
      stat_lu_gen_locked_read_hit     => stat_lu_gen_locked_read_hit,
      stat_lu_gen_first_write_hit     => stat_lu_gen_first_write_hit,
      
      stat_lu_stall                   => stat_lu_stall,
      stat_lu_fetch_stall             => stat_lu_fetch_stall,
      stat_lu_mem_stall               => stat_lu_mem_stall,
      stat_lu_data_stall              => stat_lu_data_stall,
      stat_lu_data_hit_stall          => stat_lu_data_hit_stall,
      stat_lu_data_miss_stall         => stat_lu_data_miss_stall,
      
      -- Update
      stat_ud_stall                   => stat_ud_stall,
      stat_ud_tag_free                => stat_ud_tag_free,
      stat_ud_data_free               => stat_ud_data_free,
      stat_ud_ri                      => stat_ud_ri,
      stat_ud_r                       => stat_ud_r,
      stat_ud_e                       => stat_ud_e,
      stat_ud_bs                      => stat_ud_bs,
      stat_ud_wm                      => stat_ud_wm,
      stat_ud_wma                     => stat_ud_wma,
      
      -- Backend
      stat_be_aw                      => stat_be_aw,
      stat_be_w                       => stat_be_w,
      stat_be_ar                      => stat_be_ar,
      stat_be_ar_search_depth         => stat_be_ar_search_depth,
      stat_be_ar_stall                => stat_be_ar_stall,
      stat_be_ar_protect_stall        => stat_be_ar_protect_stall,
      stat_be_rd_latency              => stat_be_rd_latency,
      stat_be_wr_latency              => stat_be_wr_latency,
      stat_be_rd_latency_conf         => stat_be_rd_latency_conf,
      stat_be_wr_latency_conf         => stat_be_wr_latency_conf,
      
      
      -- ---------------------------------------------------
      -- Debug Signals
      
      IF_DEBUG                  => CTRL_IF_DEBUG
    );
  
  
  -----------------------------------------------------------------------------
  -- Disabled signals
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Performance monitor
  -----------------------------------------------------------------------------
  
  
  -----------------------------------------------------------------------------
  -- Debug
  -----------------------------------------------------------------------------
  
  Use_Block_0: if ( C_CACHE_BLOCKS > 0 ) generate
  begin
    ARBITER0_DEBUG  <= fit_vec(ARBITER_DEBUG_I(0), C_ARBITER_DEBUG_WIDTH);
    ACCESS0_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(0), C_ACCESS1_DEBUG_WIDTH);
    MEMORY0_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(0), C_MEMORY1_DEBUG_WIDTH);
    MEMORY0_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(0), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP0_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(0), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE0_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(0), C_UPDATE1_DEBUG_WIDTH);
    UPDATE0_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(0), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_0;
  No_Block_0: if ( C_CACHE_BLOCKS < 1 ) generate
  begin
    ARBITER0_DEBUG  <= (others=>'0');
    ACCESS0_DEBUG   <= (others=>'0');
    MEMORY0_DEBUG1  <= (others=>'0');
    MEMORY0_DEBUG2  <= (others=>'0');
    LOOKUP0_DEBUG   <= (others=>'0');
    UPDATE0_DEBUG1  <= (others=>'0');
    UPDATE0_DEBUG2  <= (others=>'0');
    
  end generate No_Block_0;
  
  Use_Block_1: if ( C_CACHE_BLOCKS > 1 ) generate
  begin
    ARBITER1_DEBUG  <= fit_vec(ARBITER_DEBUG_I(1), C_ARBITER_DEBUG_WIDTH);
    ACCESS1_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(1), C_ACCESS1_DEBUG_WIDTH);
    MEMORY1_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(1), C_MEMORY1_DEBUG_WIDTH);
    MEMORY1_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(1), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP1_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(1), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE1_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(1), C_UPDATE1_DEBUG_WIDTH);
    UPDATE1_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(1), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_1;
  No_Block_1: if ( C_CACHE_BLOCKS < 2 ) generate
  begin
    ARBITER1_DEBUG  <= (others=>'0');
    ACCESS1_DEBUG   <= (others=>'0');
    MEMORY1_DEBUG1  <= (others=>'0');
    MEMORY1_DEBUG2  <= (others=>'0');
    LOOKUP1_DEBUG   <= (others=>'0');
    UPDATE1_DEBUG1  <= (others=>'0');
    UPDATE1_DEBUG2  <= (others=>'0');
    
  end generate No_Block_1;
  
  Use_Block_2: if ( C_CACHE_BLOCKS > 2 ) generate
  begin
    ARBITER2_DEBUG  <= fit_vec(ARBITER_DEBUG_I(2), C_ARBITER_DEBUG_WIDTH);
    ACCESS2_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(2), C_ACCESS1_DEBUG_WIDTH);
    MEMORY2_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(2), C_MEMORY1_DEBUG_WIDTH);
    MEMORY2_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(2), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP2_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(2), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE2_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(2), C_UPDATE1_DEBUG_WIDTH);
    UPDATE2_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(2), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_2;
  No_Block_2: if ( C_CACHE_BLOCKS < 3 ) generate
  begin
    ARBITER2_DEBUG  <= (others=>'0');
    ACCESS2_DEBUG   <= (others=>'0');
    MEMORY2_DEBUG1  <= (others=>'0');
    MEMORY2_DEBUG2  <= (others=>'0');
    LOOKUP2_DEBUG   <= (others=>'0');
    UPDATE2_DEBUG1  <= (others=>'0');
    UPDATE2_DEBUG2  <= (others=>'0');
    
  end generate No_Block_2;
  
  Use_Block_3: if ( C_CACHE_BLOCKS > 3 ) generate
  begin
    ARBITER3_DEBUG  <= fit_vec(ARBITER_DEBUG_I(3), C_ARBITER_DEBUG_WIDTH);
    ACCESS3_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(3), C_ACCESS1_DEBUG_WIDTH);
    MEMORY3_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(3), C_MEMORY1_DEBUG_WIDTH);
    MEMORY3_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(3), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP3_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(3), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE3_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(3), C_UPDATE1_DEBUG_WIDTH);
    UPDATE3_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(3), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_3;
  No_Block_3: if ( C_CACHE_BLOCKS < 4 ) generate
  begin
    ARBITER3_DEBUG  <= (others=>'0');
    ACCESS3_DEBUG   <= (others=>'0');
    MEMORY3_DEBUG1  <= (others=>'0');
    MEMORY3_DEBUG2  <= (others=>'0');
    LOOKUP3_DEBUG   <= (others=>'0');
    UPDATE3_DEBUG1  <= (others=>'0');
    UPDATE3_DEBUG2  <= (others=>'0');
    
  end generate No_Block_3;
  
  Use_Block_4: if ( C_CACHE_BLOCKS > 4 ) generate
  begin
    ARBITER4_DEBUG  <= fit_vec(ARBITER_DEBUG_I(4), C_ARBITER_DEBUG_WIDTH);
    ACCESS4_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(4), C_ACCESS1_DEBUG_WIDTH);
    MEMORY4_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(4), C_MEMORY1_DEBUG_WIDTH);
    MEMORY4_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(4), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP4_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(4), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE4_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(4), C_UPDATE1_DEBUG_WIDTH);
    UPDATE4_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(4), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_4;
  No_Block_4: if ( C_CACHE_BLOCKS < 5 ) generate
  begin
    ARBITER4_DEBUG  <= (others=>'0');
    ACCESS4_DEBUG   <= (others=>'0');
    MEMORY4_DEBUG1  <= (others=>'0');
    MEMORY4_DEBUG2  <= (others=>'0');
    LOOKUP4_DEBUG   <= (others=>'0');
    UPDATE4_DEBUG1  <= (others=>'0');
    UPDATE4_DEBUG2  <= (others=>'0');
    
  end generate No_Block_4;
  
  Use_Block_5: if ( C_CACHE_BLOCKS > 5 ) generate
  begin
    ARBITER5_DEBUG  <= fit_vec(ARBITER_DEBUG_I(5), C_ARBITER_DEBUG_WIDTH);
    ACCESS5_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(5), C_ACCESS1_DEBUG_WIDTH);
    MEMORY5_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(5), C_MEMORY1_DEBUG_WIDTH);
    MEMORY5_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(5), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP5_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(5), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE5_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(5), C_UPDATE1_DEBUG_WIDTH);
    UPDATE5_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(5), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_5;
  No_Block_5: if ( C_CACHE_BLOCKS < 6 ) generate
  begin
    ARBITER5_DEBUG  <= (others=>'0');
    ACCESS5_DEBUG   <= (others=>'0');
    MEMORY5_DEBUG1  <= (others=>'0');
    MEMORY5_DEBUG2  <= (others=>'0');
    LOOKUP5_DEBUG   <= (others=>'0');
    UPDATE5_DEBUG1  <= (others=>'0');
    UPDATE5_DEBUG2  <= (others=>'0');
    
  end generate No_Block_5;
  
  Use_Block_6: if ( C_CACHE_BLOCKS > 6 ) generate
  begin
    ARBITER6_DEBUG  <= fit_vec(ARBITER_DEBUG_I(6), C_ARBITER_DEBUG_WIDTH);
    ACCESS6_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(6), C_ACCESS1_DEBUG_WIDTH);
    MEMORY6_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(6), C_MEMORY1_DEBUG_WIDTH);
    MEMORY6_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(6), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP6_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(6), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE6_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(6), C_UPDATE1_DEBUG_WIDTH);
    UPDATE6_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(6), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_6;
  No_Block_6: if ( C_CACHE_BLOCKS < 7 ) generate
  begin
    ARBITER6_DEBUG  <= (others=>'0');
    ACCESS6_DEBUG   <= (others=>'0');
    MEMORY6_DEBUG1  <= (others=>'0');
    MEMORY6_DEBUG2  <= (others=>'0');
    LOOKUP6_DEBUG   <= (others=>'0');
    UPDATE6_DEBUG1  <= (others=>'0');
    UPDATE6_DEBUG2  <= (others=>'0');
    
  end generate No_Block_6;
  
  Use_Block_7: if ( C_CACHE_BLOCKS > 7 ) generate
  begin
    ARBITER7_DEBUG  <= fit_vec(ARBITER_DEBUG_I(7), C_ARBITER_DEBUG_WIDTH);
    ACCESS7_DEBUG   <= fit_vec(ACCESS_DEBUG1_I(7), C_ACCESS1_DEBUG_WIDTH);
    MEMORY7_DEBUG1  <= fit_vec(MEMORY_DEBUG1_I(7), C_MEMORY1_DEBUG_WIDTH);
    MEMORY7_DEBUG2  <= fit_vec(MEMORY_DEBUG2_I(7), C_MEMORY2_DEBUG_WIDTH);
    LOOKUP7_DEBUG   <= fit_vec(LOOKUP_DEBUG1_I(7), C_LOOKUP1_DEBUG_WIDTH);
    UPDATE7_DEBUG1  <= fit_vec(UPDATE_DEBUG1_I(7), C_UPDATE1_DEBUG_WIDTH);
    UPDATE7_DEBUG2  <= fit_vec(UPDATE_DEBUG2_I(7), C_UPDATE2_DEBUG_WIDTH);
    
  end generate Use_Block_7;
  No_Block_7: if ( C_CACHE_BLOCKS < 8 ) generate
  begin
    ARBITER7_DEBUG  <= (others=>'0');
    ACCESS7_DEBUG   <= (others=>'0');
    MEMORY7_DEBUG1  <= (others=>'0');
    MEMORY7_DEBUG2  <= (others=>'0');
    LOOKUP7_DEBUG   <= (others=>'0');
    UPDATE7_DEBUG1  <= (others=>'0');
    UPDATE7_DEBUG2  <= (others=>'0');
    
  end generate No_Block_7;
  
  Use_Port_0: if ( C_NUM_MASTER_PORTS > 0 ) generate
  begin
    BACKEND0_DEBUG  <= fit_vec(BACKEND_DEBUG_I(0), C_BACKEND_DEBUG_WIDTH);
    M0_IF_DEBUG     <= fit_vec(   M_IF_DEBUG_I(0), C_M_IF_DEBUG_WIDTH);
    
  end generate Use_Port_0;
  No_Port_0: if ( C_NUM_MASTER_PORTS < 1 ) generate
  begin
    BACKEND0_DEBUG  <= (others=>'0');
    M0_IF_DEBUG     <= (others=>'0');
    
  end generate No_Port_0;
  
  Use_Port_1: if ( C_NUM_MASTER_PORTS > 1 ) generate
  begin
    BACKEND1_DEBUG  <= fit_vec(BACKEND_DEBUG_I(1), C_BACKEND_DEBUG_WIDTH);
    M1_IF_DEBUG     <= fit_vec(   M_IF_DEBUG_I(1), C_M_IF_DEBUG_WIDTH);
    
  end generate Use_Port_1;
  No_Port_1: if ( C_NUM_MASTER_PORTS < 2 ) generate
  begin
    BACKEND1_DEBUG  <= (others=>'0');
    M1_IF_DEBUG     <= (others=>'0');
    
  end generate No_Port_1;
  
  Use_Port_2: if ( C_NUM_MASTER_PORTS > 2 ) generate
  begin
    BACKEND2_DEBUG  <= fit_vec(BACKEND_DEBUG_I(2), C_BACKEND_DEBUG_WIDTH);
    M2_IF_DEBUG     <= fit_vec(   M_IF_DEBUG_I(2), C_M_IF_DEBUG_WIDTH);
    
  end generate Use_Port_2;
  No_Port_2: if ( C_NUM_MASTER_PORTS < 3 ) generate
  begin
    BACKEND2_DEBUG  <= (others=>'0');
    M2_IF_DEBUG     <= (others=>'0');
    
  end generate No_Port_2;
  
  Use_Port_3: if ( C_NUM_MASTER_PORTS > 3 ) generate
  begin
    BACKEND3_DEBUG  <= fit_vec(BACKEND_DEBUG_I(3), C_BACKEND_DEBUG_WIDTH);
    M3_IF_DEBUG     <= fit_vec(   M_IF_DEBUG_I(3), C_M_IF_DEBUG_WIDTH);
    
  end generate Use_Port_3;
  No_Port_3: if ( C_NUM_MASTER_PORTS < 4 ) generate
  begin
    BACKEND3_DEBUG  <= (others=>'0');
    M3_IF_DEBUG     <= (others=>'0');
    
  end generate No_Port_3;
  
  
  -----------------------------------------------------------------------------
  -- Assertions
  -----------------------------------------------------------------------------
  
  -- ----------------------------------------
  -- Detect incorrect behaviour
  
  Assertions: block
  begin
    -- Detect condition
    assert_err(C_ASSERT_FRONTEND_ERROR)   <= frontend_assert  when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_CACHECORE_ERROR)  <= cachecore_assert when C_USE_ASSERTIONS else '0';
    
    -- Detect condition
    assert_err(C_ASSERT_BACKEND_ERROR)    <= backend_assert   when C_USE_ASSERTIONS else '0';
    
    -- pragma translate_off
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_FRONTEND_ERROR) /= '1' 
      report "System Cache: Frontend module error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_CACHECORE_ERROR) /= '1' 
      report "System Cache: Cache Core module error."
        severity error;
    
    -- Report issues.
    assert assert_err_1(C_ASSERT_BACKEND_ERROR) /= '1' 
      report "System Cache: Backend module error."
        severity error;
    
    -- pragma translate_on
  end block Assertions;
  
  
  -- Clocked to remove glites in simulation
  Delay_Assertions : process (ACLK) is
  begin  
    if ACLK'event and ACLK = '1' then     -- rising clock edge
      assert_err_1  <= (others=>'0');
      for N in assert_err'range loop
        if( assert_err(N) = '1' )  then
          assert_err_1(N) <= '1';
        end if;
      end loop;
    end if;
  end process Delay_Assertions;
  
  
end architecture IMP;


